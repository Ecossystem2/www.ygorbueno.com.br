(self.webpackChunkpanda_player = self.webpackChunkpanda_player || []).push([
    [216], {
        2799: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    W: () => r
                }), 179 == i.j) var s = i(3842);

            function r(t, e) {
                e.silentMultipleInit || s.jf.error(`${t} is already initialized.`)
            }
        },
        8678: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    r: () => a,
                    y: () => o
                }), 179 == i.j) var s = i(812);
            if (179 == i.j) var r = i(4933);
            if (179 == i.j) var n = i(3842);

            function a(t) {
                const e = {
                    version: "6.18.1",
                    onReady(t) {
                        t()
                    },
                    ...t
                };
                return Object.defineProperty(e, "_setDebug", {
                    get: () => r.yD,
                    enumerable: !1
                }), e
            }

            function o(t, e, i) {
                const r = t[e];
                r && !r.q && r.version && n.jf.warn("SDK is loaded more than once. This is unsupported and might have unexpected behavior."), t[e] = i, r && r.q && r.q.forEach((t => (0, s.Z)(t, "onReady callback threw an error:")()))
            }
        },
        3206: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    O: () => n,
                    y: () => a
                }), 179 == i.j) var s = i(4933);
            if (179 == i.j) var r = i(9693);

            function n(t, e, i, s, r) {
                return a(t, e, [i], s, r)
            }

            function a(t, e, i, n, {
                once: a,
                capture: o,
                passive: l
            } = {}) {
                const c = (0, s.zk)((e => {
                        (e.isTrusted || e.__ddIsTrusted || t.allowUntrustedEvents) && (a && f(), n(e))
                    })),
                    u = l ? {
                        capture: o,
                        passive: l
                    } : o,
                    d = window.EventTarget && e instanceof EventTarget ? window.EventTarget.prototype : e,
                    h = (0, r.I)(d, "addEventListener");

                function f() {
                    const t = (0, r.I)(d, "removeEventListener");
                    i.forEach((i => t.call(e, i, c, u)))
                }
                return i.forEach((t => h.call(e, t, c, u))), {
                    stop: f
                }
            }
        },
        9647: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    OC: () => u,
                    WQ: () => f,
                    d8: () => a,
                    ej: () => o,
                    oX: () => h
                }), 179 == i.j) var s = i(3842);
            if (179 == i.j) var r = i(5026);
            if (179 == i.j) var n = i(8129);

            function a(t, e, i = 0, s) {
                const r = new Date;
                r.setTime(r.getTime() + i);
                const n = `expires=${r.toUTCString()}`,
                    a = s && s.crossSite ? "none" : "strict",
                    o = s && s.domain ? `;domain=${s.domain}` : "",
                    l = s && s.secure ? ";secure" : "",
                    c = s && s.partitioned ? ";partitioned" : "";
                document.cookie = `${t}=${e};${n};path=/;samesite=${a}${o}${l}${c}`
            }

            function o(t) {
                return (0, n.MY)(document.cookie, t)
            }
            let l, c;

            function u(t) {
                return l || (l = (0, n.kq)(document.cookie)), l.get(t)
            }

            function d(t, e) {
                a(t, "", 0, e)
            }

            function h(t) {
                if (void 0 === document.cookie || null === document.cookie) return !1;
                try {
                    const e = `dd_cookie_test_${(0,n.DO)()}`,
                        i = "test";
                    a(e, i, r.yR, t);
                    const s = o(e) === i;
                    return d(e, t), s
                } catch (t) {
                    return s.jf.error(t), !1
                }
            }

            function f() {
                if (void 0 === c) {
                    const t = `dd_site_test_${(0,n.DO)()}`,
                        e = "test",
                        i = window.location.hostname.split(".");
                    let s = i.pop();
                    for (; i.length && !o(t);) s = `${i.pop()}.${s}`, a(t, e, r.WT, {
                        domain: s
                    });
                    d(t, {
                        domain: s
                    }), c = s
                }
                return c
            }
        },
        8679: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    y: () => c
                }), 179 == i.j) var s = i(5801);
            if (179 == i.j) var r = i(4933);
            if (179 == i.j) var n = i(3473);
            if (179 == i.j) var a = i(5026);
            if (179 == i.j) var o = i(170);
            let l;

            function c() {
                return l || (l = new n.y$((t => {
                    if (!window.fetch) return;
                    const {
                        stop: e
                    } = (0, s.S)(window, "fetch", (e => function({
                        parameters: t,
                        onPostCall: e,
                        handlingStack: i
                    }, s) {
                        const [n, l] = t;
                        let c = l && l.method;
                        void 0 === c && n instanceof Request && (c = n.method);
                        const u = void 0 !== c ? String(c).toUpperCase() : "GET",
                            d = n instanceof Request ? n.url : (0, o.D5)(String(n)),
                            h = {
                                state: "start",
                                init: l,
                                input: n,
                                method: u,
                                startClocks: (0, a.$I)(),
                                url: d,
                                handlingStack: i
                            };
                        s.notify(h), t[0] = h.input, t[1] = h.init, e((t => function(t, e, i) {
                            const s = i;

                            function n(e) {
                                s.state = "resolve", Object.assign(s, e), t.notify(s)
                            }
                            e.then((0, r.zk)((t => {
                                n({
                                    response: t,
                                    responseType: t.type,
                                    status: t.status,
                                    isAborted: !1
                                })
                            })), (0, r.zk)((t => {
                                var e, i;
                                n({
                                    status: 0,
                                    isAborted: (null === (i = null === (e = s.init) || void 0 === e ? void 0 : e.signal) || void 0 === i ? void 0 : i.aborted) || t instanceof DOMException && t.code === DOMException.ABORT_ERR,
                                    error: t
                                })
                            })))
                        }(s, t, h)))
                    }(e, t)), {
                        computeHandlingStack: !0
                    });
                    return e
                }))), l
            }
        },
        7581: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    FP: () => o,
                    PT: () => l,
                    k$: () => a
                }), 179 == i.j) var s = i(3473);
            if (179 == i.j) var r = i(4776);
            if (179 == i.j) var n = i(3206);
            const a = {
                HIDDEN: "visibility_hidden",
                UNLOADING: "before_unload",
                PAGEHIDE: "page_hide",
                FROZEN: "page_frozen"
            };

            function o(t) {
                return new s.y$((e => {
                    const {
                        stop: i
                    } = (0, n.y)(t, window, ["visibilitychange", "freeze"], (t => {
                        "visibilitychange" === t.type && "hidden" === document.visibilityState ? e.notify({
                            reason: a.HIDDEN
                        }) : "freeze" === t.type && e.notify({
                            reason: a.FROZEN
                        })
                    }), {
                        capture: !0
                    }), s = (0, n.O)(t, window, "beforeunload", (() => {
                        e.notify({
                            reason: a.UNLOADING
                        })
                    })).stop;
                    return () => {
                        i(), s()
                    }
                }))
            }

            function l(t) {
                return (0, r.TT)(a).includes(t)
            }
        },
        193: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    T: () => n,
                    _: () => a
                }), 179 == i.j) var s = i(251);
            if (179 == i.j) var r = i(3206);

            function n(t, e, i) {
                if (document.readyState === e || "complete" === document.readyState) return i(), {
                    stop: s.Z
                };
                const n = "complete" === e ? "load" : "DOMContentLoaded";
                return (0, r.O)(t, window, n, i, {
                    once: !0
                })
            }

            function a(t, e) {
                return new Promise((i => {
                    n(t, e, i)
                }))
            }
        },
        5343: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    S: () => d
                }), 179 == i.j) var s = i(5801);
            if (179 == i.j) var r = i(3473);
            if (179 == i.j) var n = i(5026);
            if (179 == i.j) var a = i(170);
            if (179 == i.j) var o = i(4162);
            if (179 == i.j) var l = i(3206);
            let c;
            const u = new WeakMap;

            function d(t) {
                return c || (c = function(t) {
                    return new r.y$((e => {
                        const {
                            stop: i
                        } = (0, s.S)(XMLHttpRequest.prototype, "open", h), {
                            stop: r
                        } = (0, s.S)(XMLHttpRequest.prototype, "send", (i => {
                            ! function({
                                target: t,
                                handlingStack: e
                            }, i, r) {
                                const a = u.get(t);
                                if (!a) return;
                                const c = a;
                                c.state = "start", c.startClocks = (0, n.$I)(), c.isAborted = !1, c.xhr = t, c.handlingStack = e;
                                let d = !1;
                                const {
                                    stop: h
                                } = (0, s.S)(t, "onreadystatechange", (() => {
                                    t.readyState === XMLHttpRequest.DONE && f()
                                })), f = () => {
                                    if (p(), h(), d) return;
                                    d = !0;
                                    const e = a;
                                    e.state = "complete", e.duration = (0, n._J)(c.startClocks.timeStamp, (0, n.n$)()), e.status = t.status, r.notify((0, o.mv)(e))
                                }, {
                                    stop: p
                                } = (0, l.O)(i, t, "loadend", f);
                                r.notify(c)
                            }(i, t, e)
                        }), {
                            computeHandlingStack: !0
                        }), {
                            stop: a
                        } = (0, s.S)(XMLHttpRequest.prototype, "abort", f);
                        return () => {
                            i(), r(), a()
                        }
                    }))
                }(t)), c
            }

            function h({
                target: t,
                parameters: [e, i]
            }) {
                u.set(t, {
                    state: "open",
                    method: String(e).toUpperCase(),
                    url: (0, a.D5)(String(i))
                })
            }

            function f({
                target: t
            }) {
                const e = u.get(t);
                e && (e.isAborted = !0)
            }
        },
        4138: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    l3: () => c
                }), 179 == i.j) var s = i(3842);
            if (179 == i.j) var r = i(5562);
            if (179 == i.j) var n = i(6676);
            if (179 == i.j) var a = i(7198);
            const o = "Running the Browser SDK in a Web extension content script is discouraged and will be forbidden in a future major release unless the `allowedTrackingOrigins` option is provided.",
                l = "SDK initialized on a non-allowed domain.";

            function c(t, e = ("undefined" != typeof location ? location.origin : ""), i = (new Error).stack) {
                const c = t.allowedTrackingOrigins;
                if (!c) {
                    if ((0, n.UI)(e, i)) {
                        s.jf.warn(o);
                        const t = (0, n.L0)(i);
                        (0, a.eJ)(o, {
                            extensionUrl: t || "unknown"
                        })
                    }
                    return !0
                }
                const u = (0, r.v)(c, e);
                return u || s.jf.error(l), u
            }
        },
        5673: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    Q: () => a
                }), 179 == i.j) var s = i(3473);
            if (179 == i.j) var r = i(1315);
            const n = 500;

            function a(t = r.Lp) {
                const e = new s.fk(n),
                    i = t().subscribe((t => {
                        e.notify({
                            type: 0,
                            error: t
                        })
                    }));
                return {
                    observable: e,
                    stop: () => {
                        i.unsubscribe()
                    }
                }
            }
        },
        7063: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    JZ: () => v,
                    Jj: () => f,
                    RJ: () => m,
                    fP: () => y,
                    tg: () => p
                }), 179 == i.j) var s = i(812);
            if (179 == i.j) var r = i(3842);
            if (179 == i.j) var n = i(5026);
            if (179 == i.j) var a = i(3603);
            if (179 == i.j) var o = i(1962);
            if (179 == i.j) var l = i(4162);
            if (179 == i.j) var c = i(7479);
            if (179 == i.j) var u = i(2988);
            if (179 == i.j) var d = i(4138);
            if (179 == i.j) var h = i(5039);
            const f = {
                    ALLOW: "allow",
                    MASK: "mask",
                    MASK_USER_INPUT: "mask-user-input"
                },
                p = {
                    ALL: "all",
                    SAMPLED: "sampled"
                };

            function g(t, e) {
                return null == t || "string" == typeof t || (r.jf.error(`${e} must be defined as a string`), !1)
            }

            function m(t, e) {
                return !(void 0 !== t && !(0, a.zz)(t) && (r.jf.error(`${e} Sample Rate should be a number between 0 and 100`), 1))
            }

            function y(t) {
                var e, i, a, f, p, y, v, b, T, E;
                if (t && t.clientToken)
                    if (void 0 === t.allowedTrackingOrigins || Array.isArray(t.allowedTrackingOrigins)) {
                        if ((!(S = t.site) || "string" != typeof S || /(datadog|ddog|datad0g|dd0g)/.test(S) || (r.jf.error(`Site should be a valid Datadog site. ${r.IA} ${r.aA}/getting_started/site/.`), 0)) && m(t.sessionSampleRate, "Session") && m(t.telemetrySampleRate, "Telemetry") && m(t.telemetryConfigurationSampleRate, "Telemetry Configuration") && m(t.telemetryUsageSampleRate, "Telemetry Usage") && g(t.version, "Version") && g(t.env, "Env") && g(t.service, "Service") && (0, d.l3)(t)) {
                            var S;
                            if (void 0 === t.trackingConsent || (0, l.E5)(u.h, t.trackingConsent)) return {
                                beforeSend: t.beforeSend && (0, s.Z)(t.beforeSend, "beforeSend threw an error:"),
                                sessionStoreStrategyType: (0, c.hB)(t),
                                sessionSampleRate: null !== (e = t.sessionSampleRate) && void 0 !== e ? e : 100,
                                telemetrySampleRate: null !== (i = t.telemetrySampleRate) && void 0 !== i ? i : 20,
                                telemetryConfigurationSampleRate: null !== (a = t.telemetryConfigurationSampleRate) && void 0 !== a ? a : 5,
                                telemetryUsageSampleRate: null !== (f = t.telemetryUsageSampleRate) && void 0 !== f ? f : 5,
                                service: null !== (p = t.service) && void 0 !== p ? p : void 0,
                                env: null !== (y = t.env) && void 0 !== y ? y : void 0,
                                version: null !== (v = t.version) && void 0 !== v ? v : void 0,
                                datacenter: null !== (b = t.datacenter) && void 0 !== b ? b : void 0,
                                silentMultipleInit: !!t.silentMultipleInit,
                                allowUntrustedEvents: !!t.allowUntrustedEvents,
                                trackingConsent: null !== (T = t.trackingConsent) && void 0 !== T ? T : u.h.GRANTED,
                                trackAnonymousUser: null === (E = t.trackAnonymousUser) || void 0 === E || E,
                                storeContextsAcrossPages: !!t.storeContextsAcrossPages,
                                batchBytesLimit: 16 * o.Hi,
                                eventRateLimiterThreshold: 3e3,
                                maxTelemetryEventsPerPage: 15,
                                flushTimeout: 30 * n.WT,
                                batchMessagesLimit: 50,
                                messageBytesLimit: 256 * o.Hi,
                                ...(0, h.h)(t)
                            };
                            r.jf.error('Tracking Consent should be either "granted" or "not-granted"')
                        }
                    } else r.jf.error("Allowed Tracking Origins must be an array");
                else r.jf.error("Client Token is not configured, we will not send any data.")
            }

            function v(t) {
                return {
                    session_sample_rate: t.sessionSampleRate,
                    telemetry_sample_rate: t.telemetrySampleRate,
                    telemetry_configuration_sample_rate: t.telemetryConfigurationSampleRate,
                    telemetry_usage_sample_rate: t.telemetryUsageSampleRate,
                    use_before_send: !!t.beforeSend,
                    use_partitioned_cross_site_session_cookie: t.usePartitionedCrossSiteSessionCookie,
                    use_secure_session_cookie: t.useSecureSessionCookie,
                    use_proxy: !!t.proxy,
                    silent_multiple_init: t.silentMultipleInit,
                    track_session_across_subdomains: t.trackSessionAcrossSubdomains,
                    track_anonymous_user: t.trackAnonymousUser,
                    session_persistence: t.sessionPersistence,
                    allow_fallback_to_local_storage: !!t.allowFallbackToLocalStorage,
                    store_contexts_across_pages: !!t.storeContextsAcrossPages,
                    allow_untrusted_events: !!t.allowUntrustedEvents,
                    tracking_consent: t.trackingConsent,
                    use_allowed_tracking_origins: Array.isArray(t.allowedTrackingOrigins)
                }
            }
        },
        9176: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    E: () => o,
                    _: () => l
                }), 179 == i.j) var s = i(5026);
            if (179 == i.j) var r = i(170);
            if (179 == i.j) var n = i(8129);
            if (179 == i.j) var a = i(3909);

            function o(t, e, i) {
                const a = function(t, e) {
                    const i = `/api/v2/${e}`,
                        s = t.proxy;
                    if ("string" == typeof s) {
                        const t = (0, r.D5)(s);
                        return e => `${t}?ddforward=${encodeURIComponent(`${i}?${e}`)}`
                    }
                    if ("function" == typeof s) return t => s({
                        path: i,
                        parameters: t
                    });
                    const n = l(e, t);
                    return t => `https://${n}${i}?${t}`
                }(t, e);
                return {
                    build(r, o) {
                        const l = function({
                            clientToken: t,
                            internalAnalyticsSubdomain: e
                        }, i, r, {
                            retry: a,
                            encoding: o
                        }, l = []) {
                            const c = ["ddsource=browser", `dd-api-key=${t}`, `dd-evp-origin-version=${encodeURIComponent("6.18.1")}`, "dd-evp-origin=browser", `dd-request-id=${(0,n.DO)()}`].concat(l);
                            return o && c.push(`dd-evp-encoding=${o}`), "rum" === i && (c.push(`batch_time=${(0,s.n$)()}`, `_dd.api=${r}`), a && c.push(`_dd.retry_count=${a.count}`, `_dd.retry_after=${a.lastFailureStatus}`)), e && c.reverse(), c.join("&")
                        }(t, e, r, o, i);
                        return a(l)
                    },
                    trackType: e
                }
            }

            function l(t, e) {
                const {
                    site: i = a.D_,
                    internalAnalyticsSubdomain: s
                } = e;
                if ("logs" === t && e.usePciIntake && i === a.D_) return a.iL;
                if (s && i === a.D_) return `${s}.${a.D_}`;
                if (i === a.by) return `http-intake.logs.${i}`;
                const r = i.split("."),
                    n = r.pop();
                return `browser-intake-${r.join("-")}.${n}`
            }
        },
        5528: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    MS: () => n
                }), 179 == i.j) var s = i(3842);
            const r = 200;

            function n(t) {
                const {
                    env: e,
                    service: i,
                    version: s,
                    datacenter: r
                } = t, n = [a("sdk_version", "6.18.1")];
                return e && n.push(a("env", e)), i && n.push(a("service", i)), s && n.push(a("version", s)), r && n.push(a("datacenter", r)), n
            }

            function a(t, e) {
                const i = e ? `${t}:${e}` : t;
                return (i.length > r || function(t) {
                        return !! function() {
                            try {
                                return new RegExp("[\\p{Ll}]", "u"), !0
                            } catch (t) {
                                return !1
                            }
                        }() && new RegExp("[^\\p{Ll}\\p{Lo}0-9_:./-]", "u").test(t)
                    }(i)) && s.jf.warn(`Tag ${i} doesn't meet tag requirements and will be sanitized. ${s.IA} ${s.aA}/getting_started/tagging/#defining-tags`),
                    function(t) {
                        return t.replace(/,/g, "_")
                    }(i)
            }
        },
        5039: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    h: () => n,
                    i: () => a
                }), 179 == i.j) var s = i(3909);
            if (179 == i.j) var r = i(9176);

            function n(t) {
                const e = t.site || s.D_,
                    i = function(t) {
                        return {
                            logsEndpointBuilder: (0, r.E)(t, "logs"),
                            rumEndpointBuilder: (0, r.E)(t, "rum"),
                            profilingEndpointBuilder: (0, r.E)(t, "profile"),
                            sessionReplayEndpointBuilder: (0, r.E)(t, "replay"),
                            exposuresEndpointBuilder: (0, r.E)(t, "exposures")
                        }
                    }(t),
                    n = function(t) {
                        if (!t.replica) return;
                        const e = { ...t,
                            site: s.D_,
                            clientToken: t.replica.clientToken
                        };
                        return {
                            logsEndpointBuilder: (0, r.E)(e, "logs"),
                            rumEndpointBuilder: (0, r.E)(e, "rum", [`application.id=${t.replica.applicationId}`])
                        }
                    }(t);
                return {
                    replica: n,
                    site: e,
                    ...i
                }
            }

            function a(t) {
                return s.Rg.every((e => t.includes(e)))
            }
        },
        8826: (t, e, i) => {
            "use strict";

            function s() {
                var t;
                const e = window.navigator;
                return {
                    status: e.onLine ? "connected" : "not_connected",
                    interfaces: e.connection && e.connection.type ? [e.connection.type] : void 0,
                    effective_type: null === (t = e.connection) || void 0 === t ? void 0 : t.effectiveType
                }
            }
            i.d(e, {
                T: () => s
            })
        },
        6296: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    a: () => p
                }), 179 == i.j) var s = i(5242);
            if (179 == i.j) var r = i(3473);
            if (179 == i.j) var n = i(3842);
            if (179 == i.j) var a = i(4933);
            if (179 == i.j) var o = i(8566);
            if (179 == i.j) var l = i(9012);
            if (179 == i.j) var c = i(2419);
            if (179 == i.j) var u = i(2685);
            if (179 == i.j) var d = i(4507);
            if (179 == i.j) var h = i(5026);
            let f = {};

            function p(t) {
                const e = t.map((t => (f[t] || (f[t] = function(t) {
                    return new r.y$((e => {
                        const i = n.jG[t];
                        return n.jG[t] = (...r) => {
                            i.apply(console, r);
                            const f = (0, d.Xp)("console error");
                            (0, a.L6)((() => {
                                e.notify(function(t, e, i) {
                                    const r = t.map((t => function(t) {
                                        return "string" == typeof t ? (0, o.N)(t) : (0, s.VZ)(t) ? (0, d.jN)((0, u._)(t)) : (0, l.l)((0, o.N)(t), void 0, 2)
                                    }(t))).join(" ");
                                    if (e === n.vA.error) {
                                        const n = t.find(s.VZ),
                                            a = (0, s.AP)({
                                                originalError: n,
                                                handlingStack: i,
                                                startClocks: (0, h.$I)(),
                                                source: c.z.CONSOLE,
                                                handling: "handled",
                                                nonErrorPrefix: "Provided",
                                                useFallbackStack: !1
                                            });
                                        return a.message = r, {
                                            api: e,
                                            message: r,
                                            handlingStack: i,
                                            error: a
                                        }
                                    }
                                    return {
                                        api: e,
                                        message: r,
                                        error: void 0,
                                        handlingStack: i
                                    }
                                }(r, t, f))
                            }))
                        }, () => {
                            n.jG[t] = i
                        }
                    }))
                }(t)), f[t])));
                return (0, r.$Z)(...e)
            }
        },
        254: (t, e, i) => {
            "use strict";
            i.d(e, {
                O: () => r,
                g: () => s
            });
            const s = {
                    userContext: "userContext",
                    globalContext: "globalContext",
                    accountContext: "accountContext"
                },
                r = {
                    getContext: "getContext",
                    setContext: "setContext",
                    setContextProperty: "setContextProperty",
                    removeContextProperty: "removeContextProperty",
                    clearContext: "clearContext"
                }
        },
        6129: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    W: () => u
                }), 179 == i.j) var s = i(2904);
            if (179 == i.j) var r = i(8566);
            if (179 == i.j) var n = i(3473);
            if (179 == i.j) var a = i(3842);
            if (179 == i.j) var o = i(9196);

            function l(t, e, i) {
                const s = { ...t
                };
                for (const [t, {
                        required: r,
                        type: n
                    }] of Object.entries(e)) "string" !== n || c(s[t]) || (s[t] = String(s[t])), r && c(s[t]) && a.jf.warn(`The property ${t} of ${i} is required; context will not be sent to the intake.`);
                return s
            }

            function c(t) {
                return null == t || "" === t
            }

            function u(t = "", {
                propertiesConfig: e = {}
            } = {}) {
                let i = {};
                const a = new n.y$,
                    c = {
                        getContext: () => (0, s.I8)(i),
                        setContext: s => {
                            (0, o.J)(s) ? i = (0, r.N)(l(s, e, t)): c.clearContext(), a.notify()
                        },
                        setContextProperty: (s, n) => {
                            i = (0, r.N)(l({ ...i,
                                [s]: n
                            }, e, t)), a.notify()
                        },
                        removeContextProperty: s => {
                            delete i[s], l(i, e, t), a.notify()
                        },
                        clearContext: () => {
                            i = {}, a.notify()
                        },
                        changeObservable: a
                    };
                return c
            }
        },
        9196: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    J: () => n
                }), 179 == i.j) var s = i(3842);
            if (179 == i.j) var r = i(3234);

            function n(t) {
                const e = "object" === (0, r.o)(t);
                return e || s.jf.error("Unsupported context:", t), e
            }
        },
        1214: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    z: () => n
                }), 179 == i.j) var s = i(7198);
            if (179 == i.j) var r = i(4933);

            function n(t, e, i, n) {
                return (0, r.zk)(((...r) => (n && (0, s.eG)({
                    feature: n
                }), t()[e][i](...r))))
            }
        },
        3150: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    ue: () => l
                }), 179 == i.j) var s = i(3206);
            if (179 == i.j) var r = i(2904);
            if (179 == i.j) var n = i(4162);
            const a = "_dd_c",
                o = 179 == i.j ? [] : null;

            function l(t, e, i, l) {
                const c = function(t, e) {
                    return `${a}_${t}_${e}`
                }(i, l);
                o.push((0, s.O)(t, window, "storage", (({
                    key: t
                }) => {
                    c === t && e.setContext(d())
                }))), e.changeObservable.subscribe((function() {
                    localStorage.setItem(c, JSON.stringify(e.getContext()))
                }));
                const u = (0, r.$e)(d(), e.getContext());

                function d() {
                    const t = localStorage.getItem(c);
                    return t ? JSON.parse(t) : {}
                }(0, n.Qr)(u) || e.setContext(u)
            }
        },
        9598: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    d: () => l,
                    p: () => o
                }), 179 == i.j) var s = i(3150);
            if (179 == i.j) var r = i(9643);
            if (179 == i.j) var n = i(4162);
            if (179 == i.j) var a = i(6129);

            function o(t, e, i) {
                const a = l();
                return e.storeContextsAcrossPages && (0, s.ue)(e, a, i, 4), t.register(0, (() => {
                    const t = a.getContext();
                    return (0, n.Qr)(t) || !t.id ? r.kb : {
                        account: t
                    }
                })), a
            }

            function l() {
                return (0, a.W)("account", {
                    propertiesConfig: {
                        id: {
                            type: "string",
                            required: !0
                        },
                        name: {
                            type: "string"
                        }
                    }
                })
            }
        },
        3127: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    $: () => n,
                    N: () => a
                }), 179 == i.j) var s = i(3150);
            if (179 == i.j) var r = i(6129);

            function n(t, e, i, r) {
                const n = a();
                return e.storeContextsAcrossPages && (0, s.ue)(e, n, i, 2), t.register(0, (() => {
                    const t = n.getContext();
                    return r ? {
                        context: t
                    } : t
                })), n
            }

            function a() {
                return (0, r.W)("global context")
            }
        },
        2027: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    c: () => o,
                    f: () => l
                }), 179 == i.j) var s = i(3150);
            if (179 == i.j) var r = i(9643);
            if (179 == i.j) var n = i(6129);
            if (179 == i.j) var a = i(4162);

            function o(t, e, i, n) {
                const o = l();
                return e.storeContextsAcrossPages && (0, s.ue)(e, o, n, 1), t.register(0, (({
                    eventType: t,
                    startTime: s
                }) => {
                    const n = o.getContext(),
                        l = i.findTrackedSession(s);
                    return l && l.anonymousId && !n.anonymous_id && e.trackAnonymousUser && (n.anonymous_id = l.anonymousId), (0, a.Qr)(n) ? r.kb : {
                        type: t,
                        usr: n
                    }
                })), t.register(1, (({
                    startTime: t
                }) => {
                    var e;
                    return {
                        anonymous_id: null === (e = i.findTrackedSession(t)) || void 0 === e ? void 0 : e.anonymousId
                    }
                })), o
            }

            function l() {
                return (0, n.W)("user", {
                    propertiesConfig: {
                        id: {
                            type: "string"
                        },
                        name: {
                            type: "string"
                        },
                        email: {
                            type: "string"
                        }
                    }
                })
            }
        },
        5242: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    AP: () => l,
                    K$: () => o,
                    VZ: () => h
                }), 179 == i.j) var s = i(8566);
            if (179 == i.j) var r = i(9012);
            if (179 == i.j) var n = i(2685);
            if (179 == i.j) var a = i(4507);
            const o = "No stack, consider using an instance of Error";

            function l({
                stackTrace: t,
                originalError: e,
                handlingStack: i,
                componentStack: s,
                startClocks: r,
                nonErrorPrefix: l,
                useFallbackStack: p = !0,
                source: g,
                handling: m
            }) {
                const y = h(e);
                return !t && y && (t = (0, n._)(e)), {
                    startClocks: r,
                    source: g,
                    handling: m,
                    handlingStack: i,
                    componentStack: s,
                    originalError: e,
                    type: t ? t.name : void 0,
                    message: c(t, y, l, e),
                    stack: t ? (0, a.P3)(t) : p ? o : void 0,
                    causes: y ? f(e, g) : void 0,
                    fingerprint: u(e),
                    context: d(e)
                }
            }

            function c(t, e, i, n) {
                return (null == t ? void 0 : t.message) && (null == t ? void 0 : t.name) ? t.message : e ? "Empty message" : `${i} ${(0,r.l)((0,s.N)(n))}`
            }

            function u(t) {
                return h(t) && "dd_fingerprint" in t ? String(t.dd_fingerprint) : void 0
            }

            function d(t) {
                if (null !== t && "object" == typeof t && "dd_context" in t) return t.dd_context
            }

            function h(t) {
                return t instanceof Error || "[object Error]" === Object.prototype.toString.call(t)
            }

            function f(t, e) {
                let i = t;
                const s = [];
                for (; h(null == i ? void 0 : i.cause) && s.length < 10;) {
                    const t = (0, n._)(i.cause);
                    s.push({
                        message: i.cause.message,
                        source: e,
                        type: null == t ? void 0 : t.name,
                        stack: t && (0, a.P3)(t)
                    }), i = i.cause
                }
                return s.length ? s : void 0
            }
        },
        2419: (t, e, i) => {
            "use strict";
            i.d(e, {
                z: () => s
            });
            const s = {
                AGENT: "agent",
                CONSOLE: "console",
                CUSTOM: "custom",
                LOGGER: "logger",
                NETWORK: "network",
                SOURCE: "source",
                REPORT: "report"
            }
        },
        1315: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    Lp: () => u
                }), 179 == i.j) var s = i(5801);
            if (179 == i.j) var r = i(3473);
            if (179 == i.j) var n = i(5026);
            if (179 == i.j) var a = i(2685);
            if (179 == i.j) var o = i(9271);
            if (179 == i.j) var l = i(5242);
            if (179 == i.j) var c = i(2419);

            function u() {
                return new r.y$((t => {
                    const e = (e, i) => {
                            const s = (0, l.AP)({
                                stackTrace: i,
                                originalError: e,
                                startClocks: (0, n.$I)(),
                                nonErrorPrefix: "Uncaught",
                                source: c.z.SOURCE,
                                handling: "unhandled"
                            });
                            t.notify(s)
                        },
                        {
                            stop: i
                        } = (r = e, (0, s.S)((0, o.R)(), "onerror", (({
                            parameters: [t, e, i, s, n]
                        }) => {
                            let o;
                            (0, l.VZ)(n) || (o = (0, a.f)(t, e, i, s)), r(null != n ? n : t, o)
                        })));
                    var r;
                    const {
                        stop: u
                    } = function(t) {
                        return (0, s.S)((0, o.R)(), "onunhandledrejection", (({
                            parameters: [e]
                        }) => {
                            t(e.reason || "Empty reason")
                        }))
                    }(e);
                    return () => {
                        i(), u()
                    }
                }))
            }
        },
        5123: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    K: () => a
                }), 179 == i.j) var s = i(5483);
            if (179 == i.j) var r = i(5026);
            if (179 == i.j) var n = i(2419);

            function a(t, e, i) {
                let a = 0,
                    o = !1;
                return {
                    isLimitReached() {
                        if (0 === a && (0, s.iK)((() => {
                                a = 0
                            }), r.yR), a += 1, a <= e || o) return o = !1, !1;
                        if (a === e + 1) {
                            o = !0;
                            try {
                                i({
                                    message: `Reached max number of ${t}s by minute: ${e}`,
                                    source: n.z.AGENT,
                                    startClocks: (0, r.$I)()
                                })
                            } finally {
                                o = !1
                            }
                        }
                        return !0
                    }
                }
            }
        },
        6676: (t, e, i) => {
            "use strict";
            i.d(e, {
                L0: () => a,
                UI: () => n
            });
            const s = 179 == i.j ? ["chrome-extension://", "moz-extension://"] : null;

            function r(t) {
                return s.some((e => t.includes(e)))
            }

            function n(t, e = "") {
                return !r(t) && r(e)
            }

            function a(t = "") {
                for (const e of s) {
                    const i = t.match(new RegExp(`${e}[^/]+`));
                    if (i) return i[0]
                }
            }
        },
        3909: (t, e, i) => {
            "use strict";
            i.d(e, {
                DZ: () => s,
                D_: () => n,
                Ds: () => a,
                Rg: () => c,
                by: () => r,
                iL: () => l,
                y7: () => o
            });
            const s = "datad0g.com",
                r = "dd0g-gov.com",
                n = "datadoghq.com",
                a = "datadoghq.eu",
                o = "ddog-gov.com",
                l = "pci.browser-intake-datadoghq.com",
                c = 179 == i.j ? ["ddsource", "dd-api-key", "dd-request-id"] : null
        },
        3670: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    _: () => u,
                    v: () => d
                }), 179 == i.j) var s = i(4507);
            if (179 == i.j) var r = i(4933);
            if (179 == i.j) var n = i(3473);
            if (179 == i.j) var a = i(3206);
            if (179 == i.j) var o = i(8129);
            if (179 == i.j) var l = i(2419);
            if (179 == i.j) var c = i(5026);
            const u = {
                intervention: "intervention",
                deprecation: "deprecation",
                cspViolation: "csp_violation"
            };

            function d(t, e) {
                const i = [];
                e.includes(u.cspViolation) && i.push(function(t) {
                    return new n.y$((e => {
                        const {
                            stop: i
                        } = (0, a.O)(t, document, "securitypolicyviolation", (t => {
                            e.notify(function(t) {
                                const e = `'${t.blockedURI}' blocked by '${t.effectiveDirective}' directive`;
                                return h({
                                    type: t.effectiveDirective,
                                    message: `${u.cspViolation}: ${e}`,
                                    originalError: t,
                                    csp: {
                                        disposition: t.disposition
                                    },
                                    stack: f(t.effectiveDirective, t.originalPolicy ? `${e} of the policy "${(0,o._z)(t.originalPolicy,100,"...")}"` : "no policy", t.sourceFile, t.lineNumber, t.columnNumber)
                                })
                            }(t))
                        }));
                        return i
                    }))
                }(t));
                const s = e.filter((t => t !== u.cspViolation));
                return s.length && i.push(function(t) {
                    return new n.y$((e => {
                        if (!window.ReportingObserver) return;
                        const i = (0, r.zk)(((t, i) => t.forEach((t => e.notify(function(t) {
                                const {
                                    type: e,
                                    body: i
                                } = t;
                                return h({
                                    type: i.id,
                                    message: `${e}: ${i.message}`,
                                    originalError: t,
                                    stack: f(i.id, i.message, i.sourceFile, i.lineNumber, i.columnNumber)
                                })
                            }(t)))))),
                            s = new window.ReportingObserver(i, {
                                types: t,
                                buffered: !0
                            });
                        return s.observe(), () => {
                            s.disconnect()
                        }
                    }))
                }(s)), (0, n.$Z)(...i)
            }

            function h(t) {
                return {
                    startClocks: (0, c.$I)(),
                    source: l.z.REPORT,
                    handling: "unhandled",
                    ...t
                }
            }

            function f(t, e, i, r, n) {
                return i ? (0, s.P3)({
                    name: t,
                    message: e,
                    stack: [{
                        func: "?",
                        url: i,
                        line: null != r ? r : void 0,
                        column: null != n ? n : void 0
                    }]
                }) : void 0
            }
        },
        8300: (t, e, i) => {
            "use strict";
            i.d(e, {
                _: () => s,
                x: () => r
            });
            const s = {
                    DOCUMENT: "document",
                    XHR: "xhr",
                    BEACON: "beacon",
                    FETCH: "fetch",
                    CSS: "css",
                    JS: "js",
                    IMAGE: "image",
                    FONT: "font",
                    MEDIA: "media",
                    OTHER: "other"
                },
                r = {
                    FETCH: s.FETCH,
                    XHR: s.XHR
                }
        },
        9739: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    TK: () => d
                }), 179 == i.j) var s = i(9647);
            if (179 == i.j) var r = i(4942);
            if (179 == i.j) var n = i(8336);
            const a = "_dd",
                o = "_dd_r",
                l = "_dd_l",
                c = "rum",
                u = "logs";

            function d(t) {
                if (!(0, s.OC)(r.H)) {
                    const e = (0, s.OC)(a),
                        i = (0, s.OC)(o),
                        r = (0, s.OC)(l),
                        d = {};
                    e && (d.id = e), r && /^[01]$/.test(r) && (d[u] = r), i && /^[012]$/.test(i) && (d[c] = i), (0, n.Qw)(d) && ((0, n.Il)(d), t.persistSession(d))
                }
            }
        },
        8981: (t, e, i) => {
            "use strict";
            i.d(e, {
                TN: () => r,
                _q: () => l,
                m8: () => o,
                sr: () => n,
                uY: () => a
            });
            var s = i(5026);
            const r = 4 * s.dV,
                n = 15 * s.yR,
                a = 179 == i.j ? s.P5 : null,
                o = "0",
                l = {
                    COOKIE: "cookie",
                    LOCAL_STORAGE: "local-storage"
                }
        },
        5135: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    HX: () => y
                }), 179 == i.j) var s = i(3473);
            if (179 == i.j) var r = i(9029);
            if (179 == i.j) var n = i(5026);
            if (179 == i.j) var a = i(3206);
            if (179 == i.j) var o = i(5483);
            if (179 == i.j) var l = i(7198);
            if (179 == i.j) var c = i(9262);
            if (179 == i.j) var u = i(9647);
            if (179 == i.j) var d = i(8981);
            if (179 == i.j) var h = i(7479);
            if (179 == i.j) var f = i(1010);
            const p = 179 == i.j ? n.yR : null,
                g = 179 == i.j ? d.TN : null;
            let m = 179 == i.j ? [] : null;

            function y(t, e, i, y) {
                const v = new s.y$,
                    b = new s.y$,
                    T = (0, h.vH)(t.sessionStoreStrategyType, t, e, i);
                m.push((() => T.stop()));
                const E = (0, r.p)({
                    expireDelay: g
                });

                function S() {
                    const t = T.getSession();
                    return t ? {
                        id: t.id,
                        trackingType: t[e],
                        isReplayForced: !!t.forcedReplay,
                        anonymousId: t.anonymousId
                    } : (async function() {
                        const t = (0, f.JP)();
                        let e = [];
                        e = "cookieStore" in window ? await window.cookieStore.getAll("_dd_s") : document.cookie.split(/\s*;\s*/).filter((t => t.startsWith("_dd_s"))), (0, l.eJ)("Unexpected session state", {
                            session: t,
                            isSyntheticsTest: (0, c.m)(),
                            createdTimestamp: null == t ? void 0 : t.created,
                            expireTimestamp: null == t ? void 0 : t.expire,
                            cookie: {
                                count: e.length,
                                domain: (0, u.WQ)(),
                                ...e
                            },
                            currentDomain: `${window.location.protocol}//${window.location.hostname}`
                        })
                    }().catch((() => {})), {
                        id: "invalid",
                        trackingType: d.m8,
                        isReplayForced: !1,
                        anonymousId: void 0
                    })
                }
                return m.push((() => E.stop())), T.renewObservable.subscribe((() => {
                        E.add(S(), (0, n._q)()), v.notify()
                    })), T.expireObservable.subscribe((() => {
                        b.notify(), E.closeActive((0, n._q)())
                    })), T.expandOrRenewSession(), E.add(S(), (0, n.cQ)().relative), y.observable.subscribe((() => {
                        y.isGranted() ? T.expandOrRenewSession() : T.expire()
                    })),
                    function(t, e) {
                        const {
                            stop: i
                        } = (0, a.y)(t, window, ["click", "touchstart", "keydown", "scroll"], (() => {
                            y.isGranted() && T.expandOrRenewSession()
                        }), {
                            capture: !0,
                            passive: !0
                        });
                        m.push(i)
                    }(t),
                    function(t, e) {
                        const i = () => {
                                "visible" === document.visibilityState && T.expandSession()
                            },
                            {
                                stop: s
                            } = (0, a.O)(t, document, "visibilitychange", i);
                        m.push(s);
                        const r = (0, o.Zi)(i, p);
                        m.push((() => {
                            (0, o.cv)(r)
                        }))
                    }(t),
                    function(t, e) {
                        const {
                            stop: i
                        } = (0, a.O)(t, window, "resume", (() => T.restartSession()), {
                            capture: !0
                        });
                        m.push(i)
                    }(t), {
                        findSession: (t, e) => E.find(t, e),
                        renewObservable: v,
                        expireObservable: b,
                        sessionStateUpdateObservable: T.sessionStateUpdateObservable,
                        expire: T.expire,
                        updateSessionState: T.updateSessionState
                    }
            }
        },
        8336: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    Ey: () => f,
                    Il: () => p,
                    NK: () => u,
                    Qw: () => h,
                    Tm: () => d,
                    q1: () => m,
                    u_: () => g
                }), 179 == i.j) var s = i(4162);
            if (179 == i.j) var r = i(4776);
            if (179 == i.j) var n = i(5026);
            if (179 == i.j) var a = i(8129);
            if (179 == i.j) var o = i(8981);
            if (179 == i.j) var l = i(6254);
            const c = "1";

            function u(t, e) {
                const i = {
                    isExpired: c
                };
                return e.trackAnonymousUser && ((null == t ? void 0 : t.anonymousId) ? i.anonymousId = null == t ? void 0 : t.anonymousId : i.anonymousId = (0, a.DO)()), i
            }

            function d(t) {
                return (0, s.Qr)(t)
            }

            function h(t) {
                return !d(t)
            }

            function f(t) {
                return void 0 !== t.isExpired || !((void 0 === (e = t).created || (0, n.m6)() - Number(e.created) < o.TN) && (void 0 === e.expire || (0, n.m6)() < Number(e.expire)));
                var e
            }

            function p(t) {
                t.expire = String((0, n.m6)() + o.sr)
            }

            function g(t) {
                return (0, r.qP)(t).map((([t, e]) => "anonymousId" === t ? `aid=${e}` : `${t}=${e}`)).join(l.SL)
            }

            function m(t) {
                const e = {};
                return (0, l.$B)(t) && t.split(l.SL).forEach((t => {
                    const i = l.tY.exec(t);
                    if (null !== i) {
                        const [, t, s] = i;
                        "aid" === t ? e.anonymousId = s : e[t] = s
                    }
                })), e
            }
        },
        6254: (t, e, i) => {
            "use strict";
            i.d(e, {
                $B: () => n,
                SL: () => r,
                tY: () => s
            });
            const s = /^([a-zA-Z]+)=([a-z0-9-]+)$/,
                r = "&";

            function n(t) {
                return !!t && (-1 !== t.indexOf(r) || s.test(t))
            }
        },
        7479: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    hB: () => g,
                    vH: () => m
                }), 179 == i.j) var s = i(5483);
            if (179 == i.j) var r = i(3473);
            if (179 == i.j) var n = i(5026);
            if (179 == i.j) var a = i(251);
            if (179 == i.j) var o = i(8129);
            if (179 == i.j) var l = i(3842);
            if (179 == i.j) var c = i(1010);
            if (179 == i.j) var u = i(8336);
            if (179 == i.j) var d = i(5485);
            if (179 == i.j) var h = i(3739);
            if (179 == i.j) var f = i(8981);
            const p = 179 == i.j ? n.WT : null;

            function g(t) {
                switch (t.sessionPersistence) {
                    case f._q.COOKIE:
                        return (0, c.XR)(t);
                    case f._q.LOCAL_STORAGE:
                        return (0, d.u)();
                    case void 0:
                        {
                            let e = (0, c.XR)(t);
                            return !e && t.allowFallbackToLocalStorage && (e = (0, d.u)()),
                            e
                        }
                    default:
                        l.jf.error(`Invalid session persistence '${String(t.sessionPersistence)}'`)
                }
            }

            function m(t, e, i, l, g = function(t, e) {
                return t.type === f._q.COOKIE ? (0, c.h$)(e, t.cookieOptions) : (0, d.m)(e)
            }(t, e)) {
                const m = new r.y$,
                    y = new r.y$,
                    v = new r.y$,
                    b = (0, s.Zi)((function() {
                        const t = g.retrieveSession();
                        (0, u.Ey)(t) ? (0, h.ax)({
                            process: t => (0, u.Ey)(t) ? (0, u.NK)(t, e) : void 0,
                            after: w
                        }, g) : w(t)
                    }), p);
                let T;
                k();
                const {
                    throttled: E,
                    cancel: S
                } = (0, a.P)((() => {
                    (0, h.ax)({
                        process: t => {
                            if ((0, u.Tm)(t)) return;
                            const e = w(t);
                            return function(t) {
                                if ((0, u.Tm)(t)) return !1;
                                const e = l(t[i]);
                                t[i] = e, delete t.isExpired, e === f.m8 || t.id || (t.id = (0, o.DO)(), t.created = String((0, n.m6)()))
                            }(e), e
                        },
                        after: t => {
                            (0, u.Qw)(t) && !A() && function(t) {
                                T = t, m.notify()
                            }(t), T = t
                        }
                    }, g)
                }), p);

                function w(t) {
                    return (0, u.Ey)(t) && (t = (0, u.NK)(t, e)), A() && (function(t) {
                        return T.id !== t.id || T[i] !== t[i]
                    }(t) ? (T = (0, u.NK)(T, e), y.notify()) : (v.notify({
                        previousState: T,
                        newState: t
                    }), T = t)), t
                }

                function k() {
                    (0, h.ax)({
                        process: t => {
                            if ((0, u.Tm)(t)) return (0, u.NK)(t, e)
                        },
                        after: t => {
                            T = t
                        }
                    }, g)
                }

                function A() {
                    return void 0 !== (null == T ? void 0 : T[i])
                }
                return {
                    expandOrRenewSession: E,
                    expandSession: function() {
                        (0, h.ax)({
                            process: t => A() ? w(t) : void 0
                        }, g)
                    },
                    getSession: () => T,
                    renewObservable: m,
                    expireObservable: y,
                    sessionStateUpdateObservable: v,
                    restartSession: k,
                    expire: () => {
                        S(), g.expireSession(T), w((0, u.NK)(T, e))
                    },
                    stop: () => {
                        (0, s.cv)(b)
                    },
                    updateSessionState: function(t) {
                        (0, h.ax)({
                            process: e => ({ ...e,
                                ...t
                            }),
                            after: w
                        }, g)
                    }
                }
            }
        },
        3739: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    ax: () => p
                }), 179 == i.j) var s = i(5483);
            if (179 == i.j) var r = i(8129);
            if (179 == i.j) var n = i(5026);
            if (179 == i.j) var a = i(7198);
            if (179 == i.j) var o = i(8336);
            const l = 10,
                c = 100,
                u = 179 == i.j ? n.WT : null,
                d = "--",
                h = 179 == i.j ? [] : null;
            let f;

            function p(t, e, i = 0) {
                var s;
                const {
                    isLockEnabled: l,
                    persistSession: u,
                    expireSession: p
                } = e, v = t => u({ ...t,
                    lock: T
                }), b = () => {
                    const {
                        lock: t,
                        ...i
                    } = e.retrieveSession();
                    return {
                        session: i,
                        lock: t && !y(t) ? t : void 0
                    }
                };
                if (f || (f = t), t !== f) return void h.push(t);
                if (l && i >= c) return (0, a.eJ)("Aborted session operation after max lock retries", {
                    currentStore: b()
                }), void m(e);
                let T, E = b();
                if (l) {
                    if (E.lock) return void g(t, e, i);
                    if (T = (0, r.DO)() + d + (0, n.n$)(), v(E.session), E = b(), E.lock !== T) return void g(t, e, i)
                }
                let S = t.process(E.session);
                if (l && (E = b(), E.lock !== T)) g(t, e, i);
                else {
                    if (S && ((0, o.Ey)(S) ? p(S) : ((0, o.Il)(S), l ? v(S) : u(S))), l && (!S || !(0, o.Ey)(S))) {
                        if (E = b(), E.lock !== T) return void g(t, e, i);
                        u(E.session), S = E.session
                    }
                    null === (s = t.after) || void 0 === s || s.call(t, S || E.session), m(e)
                }
            }

            function g(t, e, i) {
                (0, s.iK)((() => {
                    p(t, e, i + 1)
                }), l)
            }

            function m(t) {
                f = void 0;
                const e = h.shift();
                e && p(e, t)
            }

            function y(t) {
                const [, e] = t.split(d);
                return !e || (0, n._J)(Number(e), (0, n.n$)()) > u
            }
        },
        1010: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    JP: () => h,
                    XR: () => c,
                    h$: () => u
                }), 179 == i.j) var s = i(2172);
            if (179 == i.j) var r = i(9647);
            if (179 == i.j) var n = i(9739);
            if (179 == i.j) var a = i(8981);
            if (179 == i.j) var o = i(8336);
            if (179 == i.j) var l = i(4942);

            function c(t) {
                const e = function(t) {
                    const e = {};
                    return e.secure = !!t.useSecureSessionCookie || !!t.usePartitionedCrossSiteSessionCookie, e.crossSite = !!t.usePartitionedCrossSiteSessionCookie, e.partitioned = !!t.usePartitionedCrossSiteSessionCookie, t.trackSessionAcrossSubdomains && (e.domain = (0, r.WQ)()), e
                }(t);
                return (0, r.oX)(e) ? {
                    type: a._q.COOKIE,
                    cookieOptions: e
                } : void 0
            }

            function u(t, e) {
                const i = {
                    isLockEnabled: (0, s.mJ)(),
                    persistSession: i => d(e, t, i, a.sr),
                    retrieveSession: h,
                    expireSession: i => d(e, t, (0, o.NK)(i, t), a.TN)
                };
                return (0, n.TK)(i), i
            }

            function d(t, e, i, s) {
                (0, r.d8)(l.H, (0, o.u_)(i), e.trackAnonymousUser ? a.uY : s, t)
            }

            function h() {
                const t = (0, r.ej)(l.H);
                return (0, o.q1)(t)
            }
        },
        5485: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    m: () => c,
                    u: () => l
                }), 179 == i.j) var s = i(8129);
            if (179 == i.j) var r = i(8981);
            if (179 == i.j) var n = i(8336);
            if (179 == i.j) var a = i(4942);
            const o = "_dd_test_";

            function l() {
                try {
                    const t = (0, s.DO)(),
                        e = `${o}${t}`;
                    localStorage.setItem(e, t);
                    const i = localStorage.getItem(e);
                    return localStorage.removeItem(e), t === i ? {
                        type: r._q.LOCAL_STORAGE
                    } : void 0
                } catch (t) {
                    return
                }
            }

            function c(t) {
                return {
                    isLockEnabled: !1,
                    persistSession: u,
                    retrieveSession: d,
                    expireSession: e => function(t, e) {
                        u((0, n.NK)(t, e))
                    }(e, t)
                }
            }

            function u(t) {
                localStorage.setItem(a.H, (0, n.u_)(t))
            }

            function d() {
                const t = localStorage.getItem(a.H);
                return (0, n.q1)(t)
            }
        },
        4942: (t, e, i) => {
            "use strict";
            i.d(e, {
                H: () => s
            });
            const s = "_dd_s"
        },
        9262: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    L7: () => l,
                    QB: () => c,
                    Y9: () => o,
                    m: () => u
                }), 179 == i.j) var s = i(9647);
            const r = "datadog-synthetics-public-id",
                n = "datadog-synthetics-result-id",
                a = "datadog-synthetics-injects-rum";

            function o() {
                return Boolean(window._DATADOG_SYNTHETICS_INJECTS_RUM || (0, s.OC)(a))
            }

            function l() {
                const t = window._DATADOG_SYNTHETICS_PUBLIC_ID || (0, s.OC)(r);
                return "string" == typeof t ? t : void 0
            }

            function c() {
                const t = window._DATADOG_SYNTHETICS_RESULT_ID || (0, s.OC)(n);
                return "string" == typeof t ? t : void 0
            }

            function u() {
                return Boolean(l() && c())
            }
        },
        9711: (t, e, i) => {
            "use strict";
            i.d(e, {
                c: () => s
            });
            const s = {
                LOG: "log",
                CONFIGURATION: "configuration",
                USAGE: "usage"
            }
        },
        7198: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    Sz: () => I,
                    Uo: () => C,
                    VL: () => L,
                    eG: () => x,
                    eJ: () => R,
                    qZ: () => D
                }), 179 == i.j) var s = i(3842);
            if (179 == i.j) var r = i(5242);
            if (179 == i.j) var n = i(4507);
            if (179 == i.j) var a = i(7549);
            var o = i(3909);
            if (179 == i.j) var l = i(3473);
            if (179 == i.j) var c = i(5026);
            if (179 == i.j) var u = i(4933);
            if (179 == i.j) var d = i(8971);
            if (179 == i.j) var h = i(3603);
            if (179 == i.j) var f = i(9012);
            if (179 == i.j) var p = i(2904);
            if (179 == i.j) var g = i(2685);
            if (179 == i.j) var m = i(8826);
            if (179 == i.j) var y = i(6876);
            if (179 == i.j) var v = i(3789);
            if (179 == i.j) var b = i(2097);
            if (179 == i.j) var T = i(5419);
            if (179 == i.j) var E = i(9643);
            if (179 == i.j) var S = i(9711);
            const w = 179 == i.j ? ["https://www.datadoghq-browser-agent.com", "https://www.datad0g-browser-agent.com", "https://d3uc069fcn7uxw.cloudfront.net", "https://d20xtzwzcl0ceb.cloudfront.net", "http://localhost", "<anonymous>"] : null,
                k = [o.y7];
            let A;

            function _() {
                return A || (A = new l.fk(100)), A
            }

            function L(t, e, i, s, r, n) {
                const g = new l.y$,
                    {
                        stop: w
                    } = function(t, e, i, s, r) {
                        const n = [];
                        if ((0, y.xT)()) {
                            const t = (0, y.Ad)(),
                                e = r.subscribe((e => t.send("internal_telemetry", e)));
                            n.push(e.unsubscribe)
                        } else {
                            const a = [t.rumEndpointBuilder];
                            t.replica && function(t) {
                                return t.site === o.DZ
                            }(t) && a.push(t.replica.rumEndpointBuilder);
                            const c = (0, v.n)({
                                encoder: s(4),
                                request: (0, b.UF)(a, t.batchBytesLimit, e),
                                flushController: (0, T.r)({
                                    messagesLimit: t.batchMessagesLimit,
                                    bytesLimit: t.batchBytesLimit,
                                    durationLimit: t.flushTimeout,
                                    pageMayExitObservable: i,
                                    sessionExpireObservable: new l.y$
                                }),
                                messageBytesLimit: t.messageBytesLimit
                            });
                            n.push(c.stop);
                            const u = r.subscribe(c.add);
                            n.push(u.unsubscribe)
                        }
                        return {
                            stop: () => n.forEach((t => t()))
                        }
                    }(e, s, r, n, g),
                    {
                        enabled: A
                    } = function(t, e, i, s) {
                        const r = {},
                            n = !k.includes(e.site) && (0, h.y7)(e.telemetrySampleRate),
                            o = {
                                [S.c.LOG]: n,
                                [S.c.CONFIGURATION]: n && (0, h.y7)(e.telemetryConfigurationSampleRate),
                                [S.c.USAGE]: n && (0, h.y7)(e.telemetryUsageSampleRate)
                            },
                            l = {
                                is_local_file: "file:" === window.location.protocol,
                                is_worker: "WorkerGlobalScope" in self
                            },
                            g = _();
                        return g.subscribe((({
                            rawEvent: n,
                            kind: u
                        }) => {
                            if (!o[n.type]) return;
                            let h = r[u];
                            if (h || (h = r[u] = new Set), h.size >= e.maxTelemetryEventsPerPage) return;
                            const g = (0, f.l)(n);
                            if (h.has(g)) return;
                            const y = i.triggerHook(1, {
                                startTime: (0, c.$I)().relative
                            });
                            if (y === E.C_) return;
                            const v = function(t, e, i, s) {
                                const r = {
                                    type: "telemetry",
                                    date: (0, c.$I)().timeStamp,
                                    service: e,
                                    version: "6.18.1",
                                    source: "browser",
                                    _dd: {
                                        format_version: 2
                                    },
                                    telemetry: (0, p.$e)(i, {
                                        runtime_env: s,
                                        connectivity: (0, m.T)(),
                                        sdk_setup: "npm"
                                    }),
                                    experimental_features: Array.from((0, a.u0)())
                                };
                                return (0, p.$e)(r, t)
                            }(y, t, n, l);
                            s.notify(v), (0, d.j)("telemetry", v), h.add(g)
                        })), g.unbuffer(), (0, u.P_)(I), {
                            enabled: n
                        }
                    }(t, e, i, g);
                return {
                    stop: w,
                    enabled: A
                }
            }

            function R(t, e) {
                (0, u.DV)(s.vA.debug, t, e), _().notify({
                    rawEvent: {
                        type: S.c.LOG,
                        message: t,
                        status: "debug",
                        ...e
                    },
                    kind: "debug"
                })
            }

            function I(t, e) {
                _().notify({
                    rawEvent: {
                        type: S.c.LOG,
                        status: "error",
                        ...P(t),
                        ...e
                    },
                    kind: "error"
                })
            }

            function C(t) {
                _().notify({
                    rawEvent: {
                        type: S.c.CONFIGURATION,
                        configuration: t
                    },
                    kind: S.c.CONFIGURATION
                })
            }

            function D(t, e) {
                _().notify({
                    rawEvent: {
                        type: S.c.LOG,
                        message: t,
                        status: "debug",
                        ...e
                    },
                    kind: t
                })
            }

            function x(t) {
                _().notify({
                    rawEvent: {
                        type: S.c.USAGE,
                        usage: t
                    },
                    kind: S.c.USAGE
                })
            }

            function P(t) {
                if ((0, r.VZ)(t)) {
                    const e = (0, g._)(t);
                    return {
                        error: {
                            kind: e.name,
                            stack: (0, n.P3)(O(e))
                        },
                        message: e.message
                    }
                }
                return {
                    error: {
                        stack: r.K$
                    },
                    message: `Uncaught ${(0,f.l)(t)}`
                }
            }

            function O(t) {
                return t.stack = t.stack.filter((t => !t.url || w.some((e => t.url.startsWith(e))))), t
            }
        },
        2988: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    H: () => n,
                    h: () => r
                }), 179 == i.j) var s = i(3473);
            const r = {
                GRANTED: "granted",
                NOT_GRANTED: "not-granted"
            };

            function n(t) {
                const e = new s.y$;
                return {
                    tryToInit(e) {
                        t || (t = e)
                    },
                    update(i) {
                        t = i, e.notify()
                    },
                    isGranted: () => t === r.GRANTED,
                    observable: e
                }
            }
        },
        9643: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    C_: () => r,
                    kb: () => n,
                    uR: () => a
                }), 179 == i.j) var s = i(2904);
            const r = "DISCARDED",
                n = "SKIPPED";

            function a() {
                const t = {};
                return {
                    register: (e, i) => (t[e] || (t[e] = []), t[e].push(i), {
                        unregister: () => {
                            t[e] = t[e].filter((t => t !== i))
                        }
                    }),
                    triggerHook(e, i) {
                        const a = t[e] || [],
                            o = [];
                        for (const t of a) {
                            const e = t(i);
                            if (e === r) return r;
                            e !== n && o.push(e)
                        }
                        return (0, s.$e)(...o)
                    }
                }
            }
        },
        9307: (t, e, i) => {
            "use strict";
            i.d(e, {
                l: () => s
            });
            class s {
                constructor() {
                    this.callbacks = {}
                }
                notify(t, e) {
                    const i = this.callbacks[t];
                    i && i.forEach((t => t(e)))
                }
                subscribe(t, e) {
                    return this.callbacks[t] || (this.callbacks[t] = []), this.callbacks[t].push(e), {
                        unsubscribe: () => {
                            this.callbacks[t] = this.callbacks[t].filter((t => e !== t))
                        }
                    }
                }
            }
        },
        8783: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    D: () => n
                }), 179 == i.j) var s = i(3214);
            const r = 500;

            function n() {
                const t = [];
                return {
                    add: e => {
                        t.push(e) > r && t.splice(0, 1)
                    },
                    remove: e => {
                        (0, s.c)(t, e)
                    },
                    drain: e => {
                        t.forEach((t => t(e))), t.length = 0
                    }
                }
            }
        },
        812: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    Z: () => r
                }), 179 == i.j) var s = i(3842);

            function r(t, e) {
                return (...i) => {
                    try {
                        return t(...i)
                    } catch (t) {
                        s.jf.error(e, t)
                    }
                }
            }
        },
        3842: (t, e, i) => {
            "use strict";
            i.d(e, {
                IA: () => u,
                Qo: () => c,
                aA: () => l,
                jG: () => r,
                jf: () => o,
                vA: () => s
            });
            const s = {
                    log: "log",
                    debug: "debug",
                    info: "info",
                    warn: "warn",
                    error: "error"
                },
                r = console,
                n = {};
            Object.keys(s).forEach((t => {
                n[t] = r[t]
            }));
            const a = "Datadog Browser SDK:",
                o = {
                    debug: n.debug.bind(r, a),
                    log: n.log.bind(r, a),
                    info: n.info.bind(r, a),
                    warn: n.warn.bind(r, a),
                    error: n.error.bind(r, a)
                },
                l = "https://docs.datadoghq.com",
                c = `${l}/real_user_monitoring/browser/troubleshooting`,
                u = "More details:"
        },
        3895: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    G: () => r
                }), 179 == i.j) var s = i(1962);

            function r() {
                let t = "",
                    e = 0;
                return {
                    isAsync: !1,
                    get isEmpty() {
                        return !t
                    },
                    write(i, r) {
                        const n = (0, s.qt)(i);
                        e += n, t += i, r && r(n)
                    },
                    finish(t) {
                        t(this.finishSync())
                    },
                    finishSync() {
                        const i = {
                            output: t,
                            outputBytesCount: e,
                            rawBytesCount: e,
                            pendingData: ""
                        };
                        return t = "", e = 0, i
                    },
                    estimateEncodedBytesCount: t => t.length
                }
            }
        },
        7549: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    W_: () => o,
                    fG: () => a,
                    u0: () => l,
                    uh: () => r
                }), 179 == i.j) var s = i(4162);
            var r;
            ! function(t) {
                t.TRACK_INTAKE_REQUESTS = "track_intake_requests", t.WRITABLE_RESOURCE_GRAPHQL = "writable_resource_graphql", t.EARLY_REQUEST_COLLECTION = "early_request_collection", t.WATCH_COOKIE_WITHOUT_LOCK = "watch_cookie_without_lock", t.USE_TREE_WALKER_FOR_ACTION_NAME = "use_tree_walker_for_action_name"
            }(r || (r = {}));
            const n = new Set;

            function a(t) {
                Array.isArray(t) && t.filter((t => (0, s.E5)(r, t))).forEach((t => {
                    n.add(t)
                }))
            }

            function o(t) {
                return n.has(t)
            }

            function l() {
                return n
            }
        },
        9271: (t, e, i) => {
            "use strict";

            function s() {
                if ("object" == typeof globalThis) return globalThis;
                Object.defineProperty(Object.prototype, "_dd_temp_", {
                    get() {
                        return this
                    },
                    configurable: !0
                });
                let t = _dd_temp_;
                return delete Object.prototype._dd_temp_, "object" != typeof t && (t = "object" == typeof self ? self : "object" == typeof window ? window : {}), t
            }
            i.d(e, {
                R: () => s
            })
        },
        9693: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    I: () => r
                }), 179 == i.j) var s = i(9271);

            function r(t, e) {
                const i = (0, s.R)();
                let r;
                return i.Zone && "function" == typeof i.Zone.__symbol__ && (r = t[i.Zone.__symbol__(e)]), r || (r = t[e]), r
            }
        },
        5801: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    S: () => o,
                    X: () => l
                }), 179 == i.j) var s = i(5483);
            if (179 == i.j) var r = i(4933);
            if (179 == i.j) var n = i(251);
            if (179 == i.j) var a = i(4507);

            function o(t, e, i, {
                computeHandlingStack: s
            } = {}) {
                let o = t[e];
                if ("function" != typeof o) {
                    if (!(e in t) || !e.startsWith("on")) return {
                        stop: n.Z
                    };
                    o = n.Z
                }
                let l = !1;
                const c = function() {
                    if (l) return o.apply(this, arguments);
                    const t = Array.from(arguments);
                    let e;
                    (0, r.L6)(i, null, [{
                        target: this,
                        parameters: t,
                        onPostCall: t => {
                            e = t
                        },
                        handlingStack: s ? (0, a.Xp)("instrumented method") : void 0
                    }]);
                    const n = o.apply(this, t);
                    return e && (0, r.L6)(e, null, [n]), n
                };
                return t[e] = c, {
                    stop: () => {
                        l = !0, t[e] === c && (t[e] = o)
                    }
                }
            }

            function l(t, e, i) {
                const r = Object.getOwnPropertyDescriptor(t, e);
                if (!r || !r.set || !r.configurable) return {
                    stop: n.Z
                };
                const a = n.Z;
                let o = (t, e) => {
                    (0, s.iK)((() => {
                        o !== a && i(t, e)
                    }), 0)
                };
                const l = function(t) {
                    r.set.call(this, t), o(this, t)
                };
                return Object.defineProperty(t, e, {
                    set: l
                }), {
                    stop: () => {
                        var i;
                        (null === (i = Object.getOwnPropertyDescriptor(t, e)) || void 0 === i ? void 0 : i.set) === l && Object.defineProperty(t, e, r), o = a
                    }
                }
            }
        },
        5562: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    o: () => n,
                    v: () => a
                }), 179 == i.j) var s = i(3842);
            if (179 == i.j) var r = i(3234);

            function n(t) {
                const e = (0, r.o)(t);
                return "string" === e || "function" === e || t instanceof RegExp
            }

            function a(t, e, i = !1) {
                return t.some((t => {
                    try {
                        if ("function" == typeof t) return t(e);
                        if (t instanceof RegExp) return t.test(e);
                        if ("string" == typeof t) return i ? e.startsWith(t) : t === e
                    } catch (t) {
                        s.jf.error(t)
                    }
                    return !1
                }))
            }
        },
        2904: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    $e: () => a,
                    I8: () => n
                }), 179 == i.j) var s = i(3234);

            function r(t, e, i = function() {
                if ("undefined" != typeof WeakSet) {
                    const t = new WeakSet;
                    return {
                        hasAlreadyBeenSeen(e) {
                            const i = t.has(e);
                            return i || t.add(e), i
                        }
                    }
                }
                const t = [];
                return {
                    hasAlreadyBeenSeen(e) {
                        const i = t.indexOf(e) >= 0;
                        return i || t.push(e), i
                    }
                }
            }()) {
                if (void 0 === e) return t;
                if ("object" != typeof e || null === e) return e;
                if (e instanceof Date) return new Date(e.getTime());
                if (e instanceof RegExp) {
                    const t = e.flags || [e.global ? "g" : "", e.ignoreCase ? "i" : "", e.multiline ? "m" : "", e.sticky ? "y" : "", e.unicode ? "u" : ""].join("");
                    return new RegExp(e.source, t)
                }
                if (i.hasAlreadyBeenSeen(e)) return;
                if (Array.isArray(e)) {
                    const s = Array.isArray(t) ? t : [];
                    for (let t = 0; t < e.length; ++t) s[t] = r(s[t], e[t], i);
                    return s
                }
                const n = "object" === (0, s.o)(t) ? t : {};
                for (const t in e) Object.prototype.hasOwnProperty.call(e, t) && (n[t] = r(n[t], e[t], i));
                return n
            }

            function n(t) {
                return r(void 0, t)
            }

            function a(...t) {
                let e;
                for (const i of t) null != i && (e = r(e, i));
                return e
            }
        },
        4933: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    $y: () => u,
                    DV: () => d,
                    L6: () => c,
                    P_: () => a,
                    yD: () => o,
                    zk: () => l
                }), 179 == i.j) var s = i(3842);
            let r, n = !1;

            function a(t) {
                r = t
            }

            function o(t) {
                n = t
            }

            function l(t) {
                return function() {
                    return c(t, this, arguments)
                }
            }

            function c(t, e, i) {
                try {
                    return t.apply(e, i)
                } catch (t) {
                    u(t)
                }
            }

            function u(t) {
                if (d(t), r) try {
                    r(t)
                } catch (t) {
                    d(t)
                }
            }

            function d(...t) {
                n && s.jf.error("[MONITOR]", ...t)
            }
        },
        3473: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    $Z: () => n,
                    fk: () => a,
                    y$: () => r
                }), 179 == i.j) var s = i(3455);
            class r {
                constructor(t) {
                    this.onFirstSubscribe = t, this.observers = []
                }
                subscribe(t) {
                    return this.addObserver(t), {
                        unsubscribe: () => this.removeObserver(t)
                    }
                }
                notify(t) {
                    this.observers.forEach((e => e(t)))
                }
                addObserver(t) {
                    this.observers.push(t), 1 === this.observers.length && this.onFirstSubscribe && (this.onLastUnsubscribe = this.onFirstSubscribe(this) || void 0)
                }
                removeObserver(t) {
                    this.observers = this.observers.filter((e => t !== e)), !this.observers.length && this.onLastUnsubscribe && this.onLastUnsubscribe()
                }
            }

            function n(...t) {
                return new r((e => {
                    const i = t.map((t => t.subscribe((t => e.notify(t)))));
                    return () => i.forEach((t => t.unsubscribe()))
                }))
            }
            class a extends(179 == i.j ? r : null) {
                constructor(t) {
                    super(), this.maxBufferSize = t, this.buffer = []
                }
                notify(t) {
                    this.buffer.push(t), this.buffer.length > this.maxBufferSize && this.buffer.shift(), super.notify(t)
                }
                subscribe(t) {
                    let e = !1;
                    const i = {
                        unsubscribe: () => {
                            e = !0, this.removeObserver(t)
                        }
                    };
                    return (0, s.Y)((() => {
                        for (const i of this.buffer) {
                            if (e) return;
                            t(i)
                        }
                        e || this.addObserver(t)
                    })), i
                }
                unbuffer() {
                    (0, s.Y)((() => {
                        this.maxBufferSize = this.buffer.length = 0
                    }))
                }
            }
        },
        3455: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    Y: () => r
                }), 179 == i.j) var s = i(4933);

            function r(t) {
                const e = window.queueMicrotask;
                "function" == typeof e ? e((0, s.zk)(t)) : Promise.resolve().then((0, s.zk)(t))
            }
        },
        8057: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    n: () => n
                }), 179 == i.j) var s = i(4933);
            if (179 == i.j) var r = i(251);

            function n(t, e, i) {
                const n = t.getReader(),
                    a = [];
                let o = 0;

                function l() {
                    let t, s;
                    if (n.cancel().catch(r.Z), i.collectStreamBody) {
                        let e;
                        if (1 === a.length) e = a[0];
                        else {
                            e = new Uint8Array(o);
                            let t = 0;
                            a.forEach((i => {
                                e.set(i, t), t += i.length
                            }))
                        }
                        t = e.slice(0, i.bytesLimit), s = e.length > i.bytesLimit
                    }
                    e(void 0, t, s)
                }! function t() {
                    n.read().then((0, s.zk)((e => {
                        e.done ? l() : (i.collectStreamBody && a.push(e.value), o += e.value.length, o > i.bytesLimit ? l() : t())
                    })), (0, s.zk)((t => e(t))))
                }()
            }
        },
        1337: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    Kk: () => a
                }), 179 == i.j) var s = i(5483);
            if (179 == i.j) var r = i(4933);
            if (179 == i.j) var n = i(5026);

            function a(t, e) {
                if (window.requestIdleCallback && window.cancelIdleCallback) {
                    const i = window.requestIdleCallback((0, r.zk)(t), e);
                    return () => window.cancelIdleCallback(i)
                }
                return function(t) {
                    const e = (0, n.m6)(),
                        i = (0, s.iK)((() => {
                            t({
                                didTimeout: !1,
                                timeRemaining: () => Math.max(0, o - ((0, n.m6)() - e))
                            })
                        }), 0);
                    return () => (0, s.gr)(i)
                }(t)
            }
            const o = 50
        },
        8971: (t, e, i) => {
            "use strict";

            function s(t, e) {
                const i = window.__ddBrowserSdkExtensionCallback;
                i && i({
                    type: t,
                    payload: e
                })
            }
            i.d(e, {
                j: () => s
            })
        },
        9012: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    l: () => r,
                    y: () => n
                }), 179 == i.j) var s = i(251);

            function r(t, e, i) {
                if ("object" != typeof t || null === t) return JSON.stringify(t);
                const s = n(Object.prototype),
                    r = n(Array.prototype),
                    a = n(Object.getPrototypeOf(t)),
                    o = n(t);
                try {
                    return JSON.stringify(t, e, i)
                } catch (t) {
                    return "<error: unable to serialize object>"
                } finally {
                    s(), r(), a(), o()
                }
            }

            function n(t) {
                const e = t,
                    i = e.toJSON;
                return i ? (delete e.toJSON, () => {
                    e.toJSON = i
                }) : s.Z
            }
        },
        8566: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    N: () => c
                }), 179 == i.j) var s = i(3842);
            var r = i(1962);
            if (179 == i.j) var n = i(9012);
            const a = 220 * r.Hi,
                o = "$",
                l = 3;

            function c(t, e = a) {
                const i = (0, n.y)(Object.prototype),
                    s = (0, n.y)(Array.prototype),
                    r = [],
                    c = new WeakMap,
                    d = u(t, o, void 0, r, c),
                    f = JSON.stringify(d);
                let p = f ? f.length : 0;
                if (!(p > e)) {
                    for (; r.length > 0 && p < e;) {
                        const i = r.shift();
                        let s = 0;
                        if (Array.isArray(i.source))
                            for (let n = 0; n < i.source.length; n++) {
                                const a = u(i.source[n], i.path, n, r, c);
                                if (p += void 0 !== a ? JSON.stringify(a).length : 4, p += s, s = 1, p > e) {
                                    h(e, "truncated", t);
                                    break
                                }
                                i.target[n] = a
                            } else
                                for (const n in i.source)
                                    if (Object.prototype.hasOwnProperty.call(i.source, n)) {
                                        const a = u(i.source[n], i.path, n, r, c);
                                        if (void 0 !== a && (p += JSON.stringify(a).length + s + n.length + l, s = 1), p > e) {
                                            h(e, "truncated", t);
                                            break
                                        }
                                        i.target[n] = a
                                    }
                    }
                    return i(), s(), d
                }
                h(e, "discarded", t)
            }

            function u(t, e, i, s, r) {
                const n = function(t) {
                    const e = t;
                    if (e && "function" == typeof e.toJSON) try {
                        return e.toJSON()
                    } catch (t) {}
                    return t
                }(t);
                if (!n || "object" != typeof n) return "bigint" == typeof(a = n) ? `[BigInt] ${a.toString()}` : "function" == typeof a ? `[Function] ${a.name||"unknown"}` : "symbol" == typeof a ? `[Symbol] ${a.description||a.toString()}` : a;
                var a;
                const o = d(n);
                if ("[Object]" !== o && "[Array]" !== o && "[Error]" !== o) return o;
                const l = t;
                if (r.has(l)) return `[Reference seen at ${r.get(l)}]`;
                const c = void 0 !== i ? `${e}.${i}` : e,
                    u = Array.isArray(n) ? [] : {};
                return r.set(l, c), s.push({
                    source: n,
                    target: u,
                    path: c
                }), u
            }

            function d(t) {
                try {
                    if (t instanceof Event) return {
                        type: (e = t).type,
                        isTrusted: e.isTrusted,
                        currentTarget: e.currentTarget ? d(e.currentTarget) : null,
                        target: e.target ? d(e.target) : null
                    };
                    if (t instanceof RegExp) return `[RegExp] ${t.toString()}`;
                    const i = Object.prototype.toString.call(t).match(/\[object (.*)\]/);
                    if (i && i[1]) return `[${i[1]}]`
                } catch (t) {}
                var e;
                return "[Unserializable]"
            }

            function h(t, e, i) {
                s.jf.warn(`The data provided has been ${e} as it is over the limit of ${t} characters:`, i)
            }
        },
        2685: (t, e, i) => {
            "use strict";
            i.d(e, {
                _: () => r,
                f: () => p
            });
            const s = "?";

            function r(t) {
                var e, i;
                const r = [];
                let n = f(t, "stack");
                const a = String(t);
                if (n && n.startsWith(a) && (n = n.slice(a.length)), n && n.split("\n").forEach((t => {
                        const e = function(t) {
                            const e = o.exec(t);
                            if (!e) return;
                            const i = e[2] && 0 === e[2].indexOf("native"),
                                r = e[2] && 0 === e[2].indexOf("eval"),
                                n = l.exec(e[2]);
                            return r && n && (e[2] = n[1], e[3] = n[2], e[4] = n[3]), {
                                args: i ? [e[2]] : [],
                                column: e[4] ? +e[4] : void 0,
                                func: e[1] || s,
                                line: e[3] ? +e[3] : void 0,
                                url: i ? void 0 : e[2]
                            }
                        }(t) || function(t) {
                            const e = c.exec(t);
                            if (e) return {
                                args: [],
                                column: e[3] ? +e[3] : void 0,
                                func: s,
                                line: e[2] ? +e[2] : void 0,
                                url: e[1]
                            }
                        }(t) || function(t) {
                            const e = u.exec(t);
                            if (e) return {
                                args: [],
                                column: e[4] ? +e[4] : void 0,
                                func: e[1] || s,
                                line: +e[3],
                                url: e[2]
                            }
                        }(t) || function(t) {
                            const e = d.exec(t);
                            if (!e) return;
                            const i = e[3] && e[3].indexOf(" > eval") > -1,
                                r = h.exec(e[3]);
                            return i && r && (e[3] = r[1], e[4] = r[2], e[5] = void 0), {
                                args: e[2] ? e[2].split(",") : [],
                                column: e[5] ? +e[5] : void 0,
                                func: e[1] || s,
                                line: e[4] ? +e[4] : void 0,
                                url: e[3]
                            }
                        }(t);
                        e && (!e.func && e.line && (e.func = s), r.push(e))
                    })), r.length > 0 && function() {
                        if (void 0 !== y) return y;
                        class t extends Error {
                            constructor() {
                                super(), this.name = "Error"
                            }
                        }
                        const [e, i] = [t, Error].map((t => new t));
                        return y = m(Object.getPrototypeOf(e)) && i.stack !== e.stack, y
                    }() && t instanceof Error) {
                    const n = [];
                    let a = t;
                    for (;
                        (a = Object.getPrototypeOf(a)) && m(a);) {
                        const t = (null === (e = a.constructor) || void 0 === e ? void 0 : e.name) || s;
                        n.push(t)
                    }
                    for (let t = n.length - 1; t >= 0 && (null === (i = r[0]) || void 0 === i ? void 0 : i.func) === n[t]; t--) r.shift()
                }
                return {
                    message: f(t, "message"),
                    name: f(t, "name"),
                    stack: r
                }
            }
            const n = "((?:file|https?|blob|chrome-extension|electron|native|eval|webpack|snippet|<anonymous>|\\w+\\.|\\/).*?)",
                a = "(?::(\\d+))",
                o = new RegExp(`^\\s*at (.*?) ?\\(${n}${a}?${a}?\\)?\\s*$`, "i"),
                l = new RegExp(`\\((\\S*)${a}${a}\\)`),
                c = new RegExp(`^\\s*at ?${n}${a}?${a}??\\s*$`, "i"),
                u = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
                d = /^\s*(.*?)(?:\((.*?)\))?(?:(?:(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\[native).*?|[^@]*bundle|\[wasm code\])(?::(\d+))?(?::(\d+))?)|@)\s*$/i,
                h = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;

            function f(t, e) {
                if ("object" != typeof t || !t || !(e in t)) return;
                const i = t[e];
                return "string" == typeof i ? i : void 0
            }

            function p(t, e, i, s) {
                if (void 0 === e) return;
                const {
                    name: r,
                    message: n
                } = function(t) {
                    let e, i;
                    return "[object String]" === {}.toString.call(t) && ([, e, i] = g.exec(t)), {
                        name: e,
                        message: i
                    }
                }(t);
                return {
                    name: r,
                    message: n,
                    stack: [{
                        url: e,
                        column: s,
                        line: i
                    }]
                }
            }
            const g = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?([\s\S]*)$/;

            function m(t) {
                return String(t.constructor).startsWith("class ")
            }
            let y
        },
        4507: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    P3: () => a,
                    Xp: () => n,
                    jN: () => o
                }), 179 == i.j) var s = i(4933);
            if (179 == i.j) var r = i(2685);

            function n(t) {
                const e = new Error(t);
                let i;
                return e.name = "HandlingStack", (0, s.L6)((() => {
                    const t = (0, r._)(e);
                    t.stack = t.stack.slice(2), i = a(t)
                })), i
            }

            function a(t) {
                let e = o(t);
                return t.stack.forEach((t => {
                    const i = "?" === t.func ? "<anonymous>" : t.func,
                        s = t.args && t.args.length > 0 ? `(${t.args.join(", ")})` : "",
                        r = t.line ? `:${t.line}` : "",
                        n = t.line && t.column ? `:${t.column}` : "";
                    e += `\n  at ${i}${s} @ ${t.url}${r}${n}`
                })), e
            }

            function o(t) {
                return `${t.name||"Error"}: ${t.message}`
            }
        },
        49: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    y: () => o
                }), 179 == i.j) var s = i(5026);
            if (179 == i.j) var r = i(1337);
            const n = 179 == i.j ? s.WT : null,
                a = 30;

            function o() {
                const t = [];

                function e(e) {
                    let s;
                    if (e.didTimeout) {
                        const t = performance.now();
                        s = () => a - (performance.now() - t)
                    } else s = e.timeRemaining.bind(e);
                    for (; s() > 0 && t.length;) t.shift()();
                    t.length && i()
                }

                function i() {
                    (0, r.Kk)(e, {
                        timeout: n
                    })
                }
                return {
                    push(e) {
                        1 === t.push(e) && i()
                    }
                }
            }
        },
        5483: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    Zi: () => l,
                    cv: () => c,
                    gr: () => o,
                    iK: () => a
                }), 179 == i.j) var s = i(9693);
            if (179 == i.j) var r = i(4933);
            if (179 == i.j) var n = i(9271);

            function a(t, e) {
                return (0, s.I)((0, n.R)(), "setTimeout")((0, r.zk)(t), e)
            }

            function o(t) {
                (0, s.I)((0, n.R)(), "clearTimeout")(t)
            }

            function l(t, e) {
                return (0, s.I)((0, n.R)(), "setInterval")((0, r.zk)(t), e)
            }

            function c(t) {
                (0, s.I)((0, n.R)(), "clearInterval")(t)
            }
        },
        3214: (t, e, i) => {
            "use strict";

            function s(t, e) {
                const i = t.indexOf(e);
                i >= 0 && t.splice(i, 1)
            }
            i.d(e, {
                c: () => s
            })
        },
        2172: (t, e, i) => {
            "use strict";

            function s() {
                return 0 === a()
            }

            function r() {
                return 1 === a()
            }
            let n;

            function a() {
                return null != n ? n : n = function(t = window) {
                    var e;
                    const i = t.navigator.userAgent;
                    return t.chrome || /HeadlessChrome/.test(i) ? 0 : 0 === (null === (e = t.navigator.vendor) || void 0 === e ? void 0 : e.indexOf("Apple")) || /safari/i.test(i) && !/chrome|android/i.test(i) ? 1 : 2
                }()
            }
            i.d(e, {
                G6: () => r,
                mJ: () => s
            })
        },
        1962: (t, e, i) => {
            "use strict";
            i.d(e, {
                Hi: () => s,
                Kb: () => o,
                X9: () => r,
                qt: () => a
            });
            const s = 1024,
                r = 1024 * s,
                n = /[^\u0000-\u007F]/;

            function a(t) {
                return n.test(t) ? void 0 !== window.TextEncoder ? (new TextEncoder).encode(t).length : new Blob([t]).size : t.length
            }

            function o(t) {
                const e = t.reduce(((t, e) => t + e.length), 0),
                    i = new Uint8Array(e);
                let s = 0;
                for (const e of t) i.set(e, s), s += e.length;
                return i
            }
        },
        251: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    P: () => r,
                    Z: () => n
                }), 179 == i.j) var s = i(5483);

            function r(t, e, i) {
                const r = !i || void 0 === i.leading || i.leading,
                    n = !i || void 0 === i.trailing || i.trailing;
                let a, o, l = !1;
                return {
                    throttled: (...i) => {
                        l ? a = i : (r ? t(...i) : a = i, l = !0, o = (0, s.iK)((() => {
                            n && a && t(...a), l = !1, a = void 0
                        }), e))
                    },
                    cancel: () => {
                        (0, s.gr)(o), l = !1, a = void 0
                    }
                }
            }

            function n() {}
        },
        3603: (t, e, i) => {
            "use strict";

            function s(t) {
                return 0 !== t && 100 * Math.random() <= t
            }

            function r(t, e) {
                return +t.toFixed(e)
            }

            function n(t) {
                return a(t) && t >= 0 && t <= 100
            }

            function a(t) {
                return "number" == typeof t
            }
            i.d(e, {
                NM: () => r,
                hj: () => a,
                y7: () => s,
                zz: () => n
            })
        },
        4162: (t, e, i) => {
            "use strict";

            function s(t) {
                return { ...t
                }
            }

            function r(t, e) {
                return Object.keys(t).some((i => t[i] === e))
            }

            function n(t) {
                return 0 === Object.keys(t).length
            }

            function a(t, e) {
                const i = {};
                for (const s of Object.keys(t)) i[s] = e(t[s]);
                return i
            }
            i.d(e, {
                E5: () => r,
                Q8: () => a,
                Qr: () => n,
                mv: () => s
            })
        },
        4776: (t, e, i) => {
            "use strict";

            function s(t, e) {
                for (let i = t.length - 1; i >= 0; i -= 1) {
                    const s = t[i];
                    if (e(s, i, t)) return s
                }
            }

            function r(t) {
                return Object.values(t)
            }

            function n(t) {
                return Object.entries(t)
            }
            i.d(e, {
                TT: () => r,
                dF: () => s,
                qP: () => n
            })
        },
        9100: (t, e, i) => {
            "use strict";

            function s(t) {
                return t >= 500
            }

            function r(t) {
                try {
                    return t.clone()
                } catch (t) {
                    return
                }
            }
            i.d(e, {
                o: () => s,
                u: () => r
            })
        },
        8129: (t, e, i) => {
            "use strict";

            function s(t) {
                return t ? (parseInt(t, 10) ^ 16 * Math.random() >> parseInt(t, 10) / 4).toString(16) : "10000000-1000-4000-8000-100000000000".replace(/[018]/g, s)
            }
            i.d(e, {
                DO: () => s,
                MY: () => n,
                _z: () => o,
                kq: () => a
            });
            const r = /([\w-]+)\s*=\s*([^;]+)/g;

            function n(t, e) {
                for (r.lastIndex = 0;;) {
                    const i = r.exec(t);
                    if (!i) break;
                    if (i[1] === e) return i[2]
                }
            }

            function a(t) {
                const e = new Map;
                for (r.lastIndex = 0;;) {
                    const i = r.exec(t);
                    if (!i) break;
                    e.set(i[1], i[2])
                }
                return e
            }

            function o(t, e, i = "") {
                const s = t.charCodeAt(e - 1),
                    r = s >= 55296 && s <= 56319 ? e + 1 : e;
                return t.length <= r ? t : `${t.slice(0,r)}${i}`
            }
        },
        5026: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    $I: () => m,
                    Cn: () => E,
                    DY: () => l,
                    P5: () => o,
                    QA: () => d,
                    WK: () => b,
                    WT: () => r,
                    _J: () => v,
                    _q: () => g,
                    c0: () => h,
                    cQ: () => y,
                    dV: () => a,
                    lO: () => c,
                    m6: () => f,
                    n$: () => p,
                    ni: () => T,
                    yR: () => n
                }), 179 == i.j) var s = i(3603);
            const r = 1e3,
                n = 60 * r,
                a = 60 * n,
                o = 24 * a * 365;

            function l(t) {
                return {
                    relative: t,
                    timeStamp: u(t)
                }
            }

            function c(t) {
                return {
                    relative: T(t),
                    timeStamp: t
                }
            }

            function u(t) {
                const e = f() - performance.now();
                return e > w() ? Math.round(b(e, t)) : function(t) {
                    return Math.round(b(w(), t))
                }(t)
            }

            function d() {
                return Math.round(f() - b(w(), performance.now()))
            }

            function h(t) {
                return (0, s.hj)(t) ? (0, s.NM)(1e6 * t, 0) : t
            }

            function f() {
                return (new Date).getTime()
            }

            function p() {
                return f()
            }

            function g() {
                return performance.now()
            }

            function m() {
                return {
                    relative: g(),
                    timeStamp: p()
                }
            }

            function y() {
                return {
                    relative: 0,
                    timeStamp: w()
                }
            }

            function v(t, e) {
                return e - t
            }

            function b(t, e) {
                return t + e
            }

            function T(t) {
                return t - w()
            }

            function E(t) {
                return t < o
            }
            let S;

            function w() {
                return void 0 === S && (S = performance.timing.navigationStart), S
            }
        },
        6826: (t, e, i) => {
            "use strict";

            function s() {
                try {
                    return (new Intl.DateTimeFormat).resolvedOptions().timeZone
                } catch (t) {
                    return
                }
            }
            i.d(e, {
                Z: () => s
            })
        },
        3234: (t, e, i) => {
            "use strict";

            function s(t) {
                return null === t ? "null" : Array.isArray(t) ? "array" : typeof t
            }
            i.d(e, {
                o: () => s
            })
        },
        170: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    D5: () => r,
                    Q2: () => o,
                    jv: () => n,
                    ye: () => a
                }), 179 == i.j) var s = i(9012);

            function r(t) {
                return o(t, location.href).href
            }

            function n(t) {
                try {
                    return !!o(t)
                } catch (t) {
                    return !1
                }
            }

            function a(t) {
                const e = o(t).pathname;
                return "/" === e[0] ? e : `/${e}`
            }

            function o(t, e) {
                const {
                    URL: i
                } = function() {
                    if (!l) {
                        let t, e;
                        try {
                            t = document.createElement("iframe"), t.style.display = "none", document.body.appendChild(t), e = t.contentWindow
                        } catch (t) {
                            e = window
                        }
                        l = {
                            URL: e.URL
                        }, null == t || t.remove()
                    }
                    return l
                }();
                try {
                    return void 0 !== e ? new i(t, e) : new i(t)
                } catch (i) {
                    throw new Error(`Failed to construct URL: ${String(i)} ${(0,s.l)({url:t,base:e})}`)
                }
            }
            let l
        },
        9029: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    p: () => u
                }), 179 == i.j) var s = i(5483);
            if (179 == i.j) var r = i(3214);
            if (179 == i.j) var n = i(5026);
            const a = 1 / 0,
                o = 179 == i.j ? n.yR : null;
            let l = null;
            const c = new Set;

            function u({
                expireDelay: t,
                maxEntries: e
            }) {
                let i = [];
                l || (l = (0, s.Zi)((() => {
                    c.forEach((t => t()))
                }), o));
                const u = () => {
                    const e = (0, n._q)() - t;
                    for (; i.length > 0 && i[i.length - 1].endTime < e;) i.pop()
                };
                return c.add(u), {
                    add: function(t, s) {
                        const n = {
                            value: t,
                            startTime: s,
                            endTime: a,
                            remove: () => {
                                (0, r.c)(i, n)
                            },
                            close: t => {
                                n.endTime = t
                            }
                        };
                        return e && i.length >= e && i.pop(), i.unshift(n), n
                    },
                    find: function(t = a, e = {
                        returnInactive: !1
                    }) {
                        for (const s of i)
                            if (s.startTime <= t) {
                                if (e.returnInactive || t <= s.endTime) return s.value;
                                break
                            }
                    },
                    closeActive: function(t) {
                        const e = i[0];
                        e && e.endTime === a && e.close(t)
                    },
                    findAll: function(t = a, e = 0) {
                        const s = (0, n.WK)(t, e);
                        return i.filter((e => e.startTime <= s && t <= e.endTime)).map((t => t.value))
                    },
                    reset: function() {
                        i = []
                    },
                    stop: function() {
                        c.delete(u), 0 === c.size && l && ((0, s.cv)(l), l = null)
                    }
                }
            }
        },
        3789: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    n: () => l
                }), 179 == i.j) var s = i(3842);
            if (179 == i.j) var r = i(4776);
            if (179 == i.j) var n = i(7581);
            if (179 == i.j) var a = i(9012);
            if (179 == i.j) var o = i(1962);

            function l({
                encoder: t,
                request: e,
                flushController: i,
                messageBytesLimit: l
            }) {
                let u = {};
                const d = i.flushObservable.subscribe((i => function(i) {
                    const s = (0, r.TT)(u).join("\n");
                    u = {};
                    const a = (0, n.PT)(i.reason),
                        l = a ? e.sendOnExit : e.send;
                    if (a && t.isAsync) {
                        const e = t.finishSync();
                        e.outputBytesCount && l(c(e));
                        const i = [e.pendingData, s].filter(Boolean).join("\n");
                        i && l({
                            data: i,
                            bytesCount: (0, o.qt)(i)
                        })
                    } else s && t.write(t.isEmpty ? s : `\n${s}`), t.finish((t => {
                        l(c(t))
                    }))
                }(i)));

                function h(e, r) {
                    const n = (0, a.l)(e),
                        o = t.estimateEncodedBytesCount(n);
                    o >= l ? s.jf.warn(`Discarded a message whose size was bigger than the maximum allowed size ${l}KB. ${s.IA} ${s.Qo}/#technical-limitations`) : (function(t) {
                        return void 0 !== t && void 0 !== u[t]
                    }(r) && function(e) {
                        const s = u[e];
                        delete u[e];
                        const r = t.estimateEncodedBytesCount(s);
                        i.notifyAfterRemoveMessage(r)
                    }(r), function(e, s, r) {
                        i.notifyBeforeAddMessage(s), void 0 !== r ? (u[r] = e, i.notifyAfterAddMessage()) : t.write(t.isEmpty ? e : `\n${e}`, (t => {
                            i.notifyAfterAddMessage(t - s)
                        }))
                    }(n, o, r))
                }
                return {
                    flushController: i,
                    add: h,
                    upsert: h,
                    stop: d.unsubscribe
                }
            }

            function c(t) {
                let e;
                return e = "string" == typeof t.output ? t.output : new Blob([t.output], {
                    type: "text/plain"
                }), {
                    data: e,
                    bytesCount: t.outputBytesCount,
                    encoding: t.encoding
                }
            }
        },
        6876: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    Ad: () => r,
                    ke: () => n,
                    xT: () => a
                }), 179 == i.j) var s = i(9271);

            function r() {
                const t = (0, s.R)().DatadogEventBridge;
                if (t) return {
                    getCapabilities() {
                        var e;
                        return JSON.parse((null === (e = t.getCapabilities) || void 0 === e ? void 0 : e.call(t)) || "[]")
                    },
                    getPrivacyLevel() {
                        var e;
                        return null === (e = t.getPrivacyLevel) || void 0 === e ? void 0 : e.call(t)
                    },
                    getAllowedWebViewHosts: () => JSON.parse(t.getAllowedWebViewHosts()),
                    send(e, i, s) {
                        const r = s ? {
                            id: s
                        } : void 0;
                        t.send(JSON.stringify({
                            eventType: e,
                            event: i,
                            view: r
                        }))
                    }
                }
            }

            function n(t) {
                const e = r();
                return !!e && e.getCapabilities().includes(t)
            }

            function a(t) {
                var e;
                void 0 === t && (t = null === (e = (0, s.R)().location) || void 0 === e ? void 0 : e.hostname);
                const i = r();
                return !!i && i.getAllowedWebViewHosts().some((e => t === e || t.endsWith(`.${e}`)))
            }
        },
        5419: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    r: () => n
                }), 179 == i.j) var s = i(3473);
            if (179 == i.j) var r = i(5483);

            function n({
                messagesLimit: t,
                bytesLimit: e,
                durationLimit: i,
                pageMayExitObservable: n,
                sessionExpireObservable: a
            }) {
                const o = n.subscribe((t => f(t.reason))),
                    l = a.subscribe((() => f("session_expire"))),
                    c = new s.y$((() => () => {
                        o.unsubscribe(), l.unsubscribe()
                    }));
                let u, d = 0,
                    h = 0;

                function f(t) {
                    if (0 === h) return;
                    const e = h,
                        i = d;
                    h = 0, d = 0, p(), c.notify({
                        reason: t,
                        messagesCount: e,
                        bytesCount: i
                    })
                }

                function p() {
                    (0, r.gr)(u), u = void 0
                }
                return {
                    flushObservable: c,
                    get messagesCount() {
                        return h
                    },
                    notifyBeforeAddMessage(t) {
                        d + t >= e && f("bytes_limit"), h += 1, d += t, void 0 === u && (u = (0, r.iK)((() => {
                            f("duration_limit")
                        }), i))
                    },
                    notifyAfterAddMessage(i = 0) {
                        d += i, h >= t ? f("messages_limit") : d >= e && f("bytes_limit")
                    },
                    notifyAfterRemoveMessage(t) {
                        d -= t, h -= 1, 0 === h && p()
                    }
                }
            }
        },
        2097: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    UF: () => a
                }), 179 == i.j) var s = i(4933);
            if (179 == i.j) var r = i(3473);
            if (179 == i.j) var n = i(7825);

            function a(t, e, i) {
                const s = new r.y$,
                    a = (0, n.Fj)();
                return {
                    observable: s,
                    send: r => {
                        for (const o of t)(0, n.BT)(r, a, ((t, i) => c(o, e, t, i)), o.trackType, i, s)
                    },
                    sendOnExit: i => {
                        for (const s of t) o(s, e, i)
                    }
                }
            }

            function o(t, e, i) {
                if (navigator.sendBeacon && i.bytesCount < e) try {
                    const e = t.build("beacon", i);
                    if (navigator.sendBeacon(e, i.data)) return
                } catch (t) {
                    ! function(t) {
                        l || (l = !0, (0, s.$y)(t))
                    }(t)
                }
                u(t, i)
            }
            let l = !1;

            function c(t, e, i, r) {
                if (function() {
                        try {
                            return window.Request && "keepalive" in new Request("http://a")
                        } catch (t) {
                            return !1
                        }
                    }() && i.bytesCount < e) {
                    const e = t.build("fetch-keepalive", i);
                    fetch(e, {
                        method: "POST",
                        body: i.data,
                        keepalive: !0,
                        mode: "cors"
                    }).then((0, s.zk)((t => null == r ? void 0 : r({
                        status: t.status,
                        type: t.type
                    })))).catch((0, s.zk)((() => u(t, i, r))))
                } else u(t, i, r)
            }

            function u(t, e, i) {
                const r = t.build("fetch", e);
                fetch(r, {
                    method: "POST",
                    body: e.data,
                    mode: "cors"
                }).then((0, s.zk)((t => null == i ? void 0 : i({
                    status: t.status,
                    type: t.type
                })))).catch((0, s.zk)((() => null == i ? void 0 : i({
                    status: 0
                }))))
            }
        },
        7825: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    BT: () => f,
                    Fj: () => y
                }), 179 == i.j) var s = i(5483);
            if (179 == i.j) var r = i(5026);
            var n = i(1962);
            if (179 == i.j) var a = i(9100);
            if (179 == i.j) var o = i(2419);
            const l = 80 * n.Hi,
                c = 32,
                u = 3 * n.X9,
                d = 179 == i.j ? r.yR : null,
                h = 179 == i.j ? r.WT : null;

            function f(t, e, i, s, r, n) {
                0 === e.transportStatus && 0 === e.queuedPayloads.size() && e.bandwidthMonitor.canHandle(t) ? g(t, e, i, n, {
                    onSuccess: () => m(0, e, i, s, r, n),
                    onFailure: () => {
                        e.queuedPayloads.enqueue(t) || n.notify({
                            type: "queue-full",
                            bandwidth: e.bandwidthMonitor.stats(),
                            payload: t
                        }), p(e, i, s, r, n)
                    }
                }) : e.queuedPayloads.enqueue(t) || n.notify({
                    type: "queue-full",
                    bandwidth: e.bandwidthMonitor.stats(),
                    payload: t
                })
            }

            function p(t, e, i, r, n) {
                2 === t.transportStatus && (0, s.iK)((() => {
                    g(t.queuedPayloads.first(), t, e, n, {
                        onSuccess: () => {
                            t.queuedPayloads.dequeue(), t.currentBackoffTime = h, m(1, t, e, i, r, n)
                        },
                        onFailure: () => {
                            t.currentBackoffTime = Math.min(d, 2 * t.currentBackoffTime), p(t, e, i, r, n)
                        }
                    })
                }), t.currentBackoffTime)
            }

            function g(t, e, i, s, {
                onSuccess: r,
                onFailure: n
            }) {
                e.bandwidthMonitor.add(t), i(t, (i => {
                    e.bandwidthMonitor.remove(t),
                        function(t) {
                            return "opaque" !== t.type && (0 === t.status && !navigator.onLine || 408 === t.status || 429 === t.status || (0, a.o)(t.status))
                        }(i) ? (e.transportStatus = e.bandwidthMonitor.ongoingRequestCount > 0 ? 1 : 2, t.retry = {
                            count: t.retry ? t.retry.count + 1 : 1,
                            lastFailureStatus: i.status
                        }, s.notify({
                            type: "failure",
                            bandwidth: e.bandwidthMonitor.stats(),
                            payload: t
                        }), n()) : (e.transportStatus = 0, s.notify({
                            type: "success",
                            bandwidth: e.bandwidthMonitor.stats(),
                            payload: t
                        }), r())
                }))
            }

            function m(t, e, i, s, a, l) {
                0 === t && e.queuedPayloads.isFull() && !e.queueFullReported && (a({
                    message: `Reached max ${s} events size queued for upload: ${u/n.X9}MiB`,
                    source: o.z.AGENT,
                    startClocks: (0, r.$I)()
                }), e.queueFullReported = !0);
                const c = e.queuedPayloads;
                for (e.queuedPayloads = v(); c.size() > 0;) f(c.dequeue(), e, i, s, a, l)
            }

            function y() {
                return {
                    transportStatus: 0,
                    currentBackoffTime: h,
                    bandwidthMonitor: {
                        ongoingRequestCount: 0,
                        ongoingByteCount: 0,
                        canHandle(t) {
                            return 0 === this.ongoingRequestCount || this.ongoingByteCount + t.bytesCount <= l && this.ongoingRequestCount < c
                        },
                        add(t) {
                            this.ongoingRequestCount += 1, this.ongoingByteCount += t.bytesCount
                        },
                        remove(t) {
                            this.ongoingRequestCount -= 1, this.ongoingByteCount -= t.bytesCount
                        },
                        stats() {
                            return {
                                ongoingByteCount: this.ongoingByteCount,
                                ongoingRequestCount: this.ongoingRequestCount
                            }
                        }
                    },
                    queuedPayloads: v(),
                    queueFullReported: !1
                }
            }

            function v() {
                const t = [];
                return {
                    bytesCount: 0,
                    enqueue(e) {
                        return !this.isFull() && (t.push(e), this.bytesCount += e.bytesCount, !0)
                    },
                    first: () => t[0],
                    dequeue() {
                        const e = t.shift();
                        return e && (this.bytesCount -= e.bytesCount), e
                    },
                    size: () => t.length,
                    isFull() {
                        return this.bytesCount >= u
                    }
                }
            }
        },
        9744: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    k: () => l
                }), 179 == i.j) var s = i(3473);
            if (179 == i.j) var r = i(3206);
            if (179 == i.j) var n = i(5026);
            if (179 == i.j) var a = i(8129);
            if (179 == i.j) var o = i(5483);

            function l(t, e) {
                const i = window.cookieStore ? function(t) {
                    return (e, i) => (0, r.O)(t, window.cookieStore, "change", (t => {
                        const s = t.changed.find((t => t.name === e)) || t.deleted.find((t => t.name === e));
                        s && i(s.value)
                    })).stop
                }(t) : u;
                return new s.y$((t => i(e, (e => t.notify(e)))))
            }
            const c = 179 == i.j ? n.WT : null;

            function u(t, e) {
                const i = (0, a.MY)(document.cookie, t),
                    s = (0, o.Zi)((() => {
                        const s = (0, a.MY)(document.cookie, t);
                        s !== i && e(s)
                    }), c);
                return () => {
                    (0, o.cv)(s)
                }
            }
        },
        4250: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    q: () => l,
                    y: () => o
                }), 179 == i.j) var s = i(3473);
            if (179 == i.j) var r = i(4933);
            if (179 == i.j) var n = i(9693);
            if (179 == i.j) var a = i(251);

            function o() {
                const t = l();
                return new s.y$((e => {
                    if (!t) return;
                    const i = new t((0, r.zk)((t => e.notify(t))));
                    return i.observe(document, {
                        attributes: !0,
                        characterData: !0,
                        childList: !0,
                        subtree: !0
                    }), () => i.disconnect()
                }))
            }

            function l() {
                let t;
                const e = window;
                if (e.Zone && (t = (0, n.I)(e, "MutationObserver"), e.MutationObserver && t === e.MutationObserver)) {
                    const i = new e.MutationObserver(a.Z),
                        s = (0, n.I)(i, "originalInstance");
                    t = s && s.constructor
                }
                return t || (t = e.MutationObserver), t
            }
        },
        7569: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    X: () => n
                }), 179 == i.j) var s = i(5026);
            if (179 == i.j) var r = i(3206);

            function n(t, e) {
                const i = (0, s.m6)();
                let n = !1;
                const {
                    stop: a
                } = (0, r.y)(t, window, ["click", "mousedown", "keydown", "touchstart", "pointerdown"], (e => {
                    if (!e.cancelable) return;
                    const i = {
                        entryType: "first-input",
                        processingStart: (0, s._q)(),
                        processingEnd: (0, s._q)(),
                        startTime: e.timeStamp,
                        duration: 0,
                        name: "",
                        cancelable: !1,
                        target: null,
                        toJSON: () => ({})
                    };
                    "pointerdown" === e.type ? function(t, e) {
                        (0, r.y)(t, window, ["pointerup", "pointercancel"], (t => {
                            "pointerup" === t.type && o(e)
                        }), {
                            once: !0
                        })
                    }(t, i) : o(i)
                }), {
                    passive: !0,
                    capture: !0
                });
                return {
                    stop: a
                };

                function o(t) {
                    if (!n) {
                        n = !0, a();
                        const r = t.processingStart - t.startTime;
                        r >= 0 && r < (0, s.m6)() - i && e(t)
                    }
                }
            }
        },
        3644: (t, e, i) => {
            "use strict";

            function s(t) {
                return t.nodeType === Node.TEXT_NODE
            }

            function r(t) {
                return t.nodeType === Node.COMMENT_NODE
            }

            function n(t) {
                return t.nodeType === Node.ELEMENT_NODE
            }

            function a(t) {
                return n(t) && Boolean(t.shadowRoot)
            }

            function o(t) {
                const e = t;
                return !!e.host && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n(e.host)
            }

            function l(t) {
                return t.childNodes.length > 0 || a(t)
            }

            function c(t, e) {
                let i = t.firstChild;
                for (; i;) e(i), i = i.nextSibling;
                a(t) && e(t.shadowRoot)
            }

            function u(t) {
                return o(t) ? t.host : t.parentNode
            }
            i.d(e, {
                BM: () => s,
                Ow: () => u,
                Sn: () => l,
                Tv: () => n,
                Uo: () => c,
                VO: () => o,
                aT: () => a,
                dI: () => r
            })
        },
        3766: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    t: () => o
                }), 179 == i.j) var s = i(4162);
            if (179 == i.j) var r = i(3473);
            if (179 == i.j) var n = i(5801);
            if (179 == i.j) var a = i(3206);

            function o(t, e) {
                let i = (0, s.mv)(e);
                return new r.y$((r => {
                    const {
                        stop: o
                    } = function(t, e) {
                        const {
                            stop: i
                        } = (0, n.S)(l("pushState"), "pushState", (({
                            onPostCall: t
                        }) => {
                            t(e)
                        })), {
                            stop: s
                        } = (0, n.S)(l("replaceState"), "replaceState", (({
                            onPostCall: t
                        }) => {
                            t(e)
                        })), {
                            stop: r
                        } = (0, a.O)(t, window, "popstate", e);
                        return {
                            stop: () => {
                                i(), s(), r()
                            }
                        }
                    }(t, u), {
                        stop: c
                    } = function(t, e) {
                        return (0, a.O)(t, window, "hashchange", e)
                    }(t, u);

                    function u() {
                        if (i.href === e.href) return;
                        const t = (0, s.mv)(e);
                        r.notify({
                            newLocation: t,
                            oldLocation: i
                        }), i = t
                    }
                    return () => {
                        o(), c()
                    }
                }))
            }

            function l(t) {
                return Object.prototype.hasOwnProperty.call(history, t) ? history : History.prototype
            }
        },
        247: (t, e, i) => {
            "use strict";

            function s() {
                let t;
                const e = window.visualViewport;
                return t = e ? e.pageLeft - e.offsetLeft : void 0 !== window.scrollX ? window.scrollX : window.pageXOffset || 0, Math.round(t)
            }

            function r() {
                let t;
                const e = window.visualViewport;
                return t = e ? e.pageTop - e.offsetTop : void 0 !== window.scrollY ? window.scrollY : window.pageYOffset || 0, Math.round(t)
            }
            i.d(e, {
                $: () => s,
                X: () => r
            })
        },
        5788: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    AX: () => o,
                    PA: () => l
                }), 179 == i.j) var s = i(3473);
            if (179 == i.j) var r = i(251);
            if (179 == i.j) var n = i(3206);
            let a;

            function o(t) {
                return a || (a = function(t) {
                    return new s.y$((e => {
                        const {
                            throttled: i
                        } = (0, r.P)((() => {
                            e.notify(l())
                        }), 200);
                        return (0, n.O)(t, window, "resize", i, {
                            capture: !0,
                            passive: !0
                        }).stop
                    }))
                }(t)), a
            }

            function l() {
                const t = window.visualViewport;
                return t ? {
                    width: Number(t.width * t.scale),
                    height: Number(t.height * t.scale)
                } : {
                    width: Number(window.innerWidth || 0),
                    height: Number(window.innerHeight || 0)
                }
            }
        },
        4967: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    M: () => n
                }), 179 == i.j) var s = i(3473);
            if (179 == i.j) var r = i(5801);

            function n() {
                const t = new s.y$,
                    {
                        stop: e
                    } = (0, r.S)(window, "open", (() => t.notify()));
                return {
                    observable: t,
                    stop: e
                }
            }
        },
        6508: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    bl: () => o
                }), 179 == i.j) var s = i(5026);
            if (179 == i.j) var r = i(5483);
            const n = 179 == i.j ? s.WT : null,
                a = 100;

            function o(t, e) {
                const i = [];
                let s, o = 0;

                function l(t) {
                    t.stopObservable.subscribe(c), i.push(t), (0, r.gr)(s), s = (0, r.iK)(u, n)
                }

                function c() {
                    1 === o && i.every((t => t.isStopped())) && (o = 2, e(i))
                }

                function u() {
                    (0, r.gr)(s), 0 === o && (o = 1, c())
                }
                return l(t), {
                    tryAppend: t => {
                        return 0 === o && (i.length > 0 && (e = i[i.length - 1].event, s = t.event, !(e.target === s.target && (r = e, c = s, Math.sqrt(Math.pow(r.clientX - c.clientX, 2) + Math.pow(r.clientY - c.clientY, 2)) <= a) && e.timeStamp - s.timeStamp <= n)) ? (u(), !1) : (l(t), !0));
                        var e, s, r, c
                    },
                    stop: () => {
                        u()
                    }
                }
            }
        },
        8124: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    u: () => r
                }), 179 == i.j) var s = i(3206);

            function r(t, {
                onPointerDown: e,
                onPointerUp: i
            }) {
                let r, o, l = {
                    selection: !1,
                    input: !1,
                    scroll: !1
                };
                const c = [(0, s.O)(t, window, "pointerdown", (t => {
                    a(t) && (r = n(), l = {
                        selection: !1,
                        input: !1,
                        scroll: !1
                    }, o = e(t))
                }), {
                    capture: !0
                }), (0, s.O)(t, window, "selectionchange", (() => {
                    r && n() || (l.selection = !0)
                }), {
                    capture: !0
                }), (0, s.O)(t, window, "scroll", (() => {
                    l.scroll = !0
                }), {
                    capture: !0,
                    passive: !0
                }), (0, s.O)(t, window, "pointerup", (t => {
                    if (a(t) && o) {
                        const e = l;
                        i(o, t, (() => e)), o = void 0
                    }
                }), {
                    capture: !0
                }), (0, s.O)(t, window, "input", (() => {
                    l.input = !0
                }), {
                    capture: !0
                })];
                return {
                    stop: () => {
                        c.forEach((t => t.stop()))
                    }
                }
            }

            function n() {
                const t = window.getSelection();
                return !t || t.isCollapsed
            }

            function a(t) {
                return t.target instanceof Element && !1 !== t.isPrimary
            }
        },
        1093: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    ir: () => l
                }), 179 == i.j) var s = i(3842);
            if (179 == i.j) var r = i(4162);
            if (179 == i.j) var n = i(9176);
            const a = "v1",
                o = 179 == i.j ? ["applicationId", "service", "env", "version", "sessionSampleRate", "sessionReplaySampleRate", "defaultPrivacyLevel", "enablePrivacyForActionName", "traceSampleRate", "trackSessionAcrossSubdomains", "allowedTracingUrls", "allowedTrackingOrigins"] : null;
            async function l(t) {
                const e = await async function(t) {
                    let e;
                    try {
                        e = await fetch(function(t) {
                            return t.remoteConfigurationProxy ? t.remoteConfigurationProxy : `https://sdk-configuration.${(0,n._)("rum",t)}/${a}/${encodeURIComponent(t.remoteConfigurationId)}.json`
                        }(t))
                    } catch (t) {
                        e = void 0
                    }
                    if (!e || !e.ok) return {
                        ok: !1,
                        error: new Error("Error fetching the remote configuration.")
                    };
                    const i = await e.json();
                    return i.rum ? {
                        ok: !0,
                        value: i.rum
                    } : {
                        ok: !1,
                        error: new Error("No remote configuration for RUM.")
                    }
                }(t);
                if (e.ok) return function(t, e) {
                    const i = { ...t
                    };
                    return o.forEach((t => {
                        t in e && (i[t] = c(e[t]))
                    })), i
                }(t, e.value);
                s.jf.error(e.error)
            }

            function c(t) {
                if (Array.isArray(t)) return t.map(c);
                if (function(t) {
                        return "object" == typeof t && null !== t
                    }(t)) {
                    if ("rcSerializedType" in t) {
                        const e = t.rcSerializedType;
                        switch (e) {
                            case "string":
                                return t.value;
                            case "regex":
                                return function(t) {
                                    try {
                                        return new RegExp(t)
                                    } catch (e) {
                                        s.jf.error(`Invalid regex in the remote configuration: '${t}'`)
                                    }
                                }(t.value);
                            default:
                                return void s.jf.error(`Unsupported remote configuration: "rcSerializedType": "${e}"`)
                        }
                    }
                    return (0, r.Q8)(t, c)
                }
                return t
            }
        },
        5747: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    z: () => o
                }), 179 == i.j) var s = i(9647);
            if (179 == i.j) var r = i(9643);
            if (179 == i.j) var n = i(9744);
            const a = "datadog-ci-visibility-test-execution-id";

            function o(t, e, i = (0, n.k)(t, a)) {
                var o;
                let l = (0, s.OC)(a) || (null === (o = window.Cypress) || void 0 === o ? void 0 : o.env("traceId"));
                const c = i.subscribe((t => {
                    l = t
                }));
                return e.register(0, (({
                    eventType: t
                }) => "string" != typeof l ? r.kb : {
                    type: t,
                    session: {
                        type: "ci_test"
                    },
                    ci_test: {
                        test_execution_id: l
                    }
                })), {
                    stop: () => {
                        c.unsubscribe()
                    }
                }
            }
        },
        3583: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    d: () => r
                }), 179 == i.j) var s = i(8826);

            function r(t) {
                t.register(0, (({
                    eventType: t
                }) => ({
                    type: t,
                    connectivity: (0, s.T)()
                })))
            }
        },
        1545: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    Y: () => a
                }), 179 == i.j) var s = i(5026);
            if (179 == i.j) var r = i(3603);
            if (179 == i.j) var n = i(6876);

            function a(t, e, i) {
                t.register(0, (({
                    eventType: t
                }) => ({
                    type: t,
                    _dd: {
                        format_version: 2,
                        drift: (0, s.QA)(),
                        configuration: {
                            session_sample_rate: (0, r.NM)(e.sessionSampleRate, 3),
                            session_replay_sample_rate: (0, r.NM)(e.sessionReplaySampleRate, 3),
                            profiling_sample_rate: (0, r.NM)(e.profilingSampleRate, 3)
                        },
                        browser_sdk_version: (0, n.xT)() ? "6.18.1" : void 0,
                        sdk_name: i
                    },
                    application: {
                        id: e.applicationId
                    },
                    date: (0, s.n$)(),
                    source: "browser"
                }))), t.register(1, (() => ({
                    application: {
                        id: e.applicationId
                    }
                })))
            }
        },
        354: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    Z: () => n
                }), 179 == i.j) var s = i(4933);
            if (179 == i.j) var r = i(5788);

            function n(t, e) {
                let i;
                const n = requestAnimationFrame((0, s.zk)((() => {
                        i = (0, r.PA)()
                    }))),
                    a = (0, r.AX)(e).subscribe((t => {
                        i = t
                    })).unsubscribe;
                return t.register(0, (({
                    eventType: t
                }) => ({
                    type: t,
                    display: i ? {
                        viewport: i
                    } : void 0
                }))), {
                    stop: () => {
                        a(), n && cancelAnimationFrame(n)
                    }
                }
            }
        },
        1762: (t, e, i) => {
            "use strict";

            function s(t, e, i, s, r) {
                return {
                    get: n => {
                        const a = i.findView(n),
                            o = r.findUrl(n),
                            l = e.findTrackedSession(n);
                        if (l && a && o) {
                            const e = s.findActionId(n);
                            return {
                                application_id: t,
                                session_id: l.id,
                                user_action: e ? {
                                    id: e
                                } : void 0,
                                view: {
                                    id: a.id,
                                    name: a.name,
                                    referrer: o.referrer,
                                    url: o.url
                                }
                            }
                        }
                    }
                }
            }
            i.d(e, {
                A: () => s
            })
        },
        4208: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    E: () => n
                }), 179 == i.j) var s = i(9262);
            if (179 == i.j) var r = i(9643);

            function n(t) {
                t.register(0, (({
                    eventType: t
                }) => (0, s.m)() ? {
                    type: t,
                    session: {
                        type: "synthetics"
                    },
                    synthetics: {
                        test_id: (0, s.L7)(),
                        result_id: (0, s.QB)(),
                        injected: (0, s.Y9)()
                    }
                } : r.kb))
            }
        },
        2582: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    I: () => r
                }), 179 == i.j) var s = i(9643);

            function r(t, e) {
                t.register(1, (() => e.isGranted() ? s.kb : s.C_))
            }
        },
        6593: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    Y: () => l
                }), 179 == i.j) var s = i(8981);
            if (179 == i.j) var r = i(9029);
            if (179 == i.j) var n = i(5026);
            if (179 == i.j) var a = i(9643);
            const o = 179 == i.j ? s.TN : null;

            function l(t, e, i, s) {
                const l = (0, r.p)({
                    expireDelay: o
                });
                let c;
                t.subscribe(1, (({
                    startClocks: t
                }) => {
                    const e = s.href;
                    l.add(d({
                        url: e,
                        referrer: c || document.referrer
                    }), t.relative), c = e
                })), t.subscribe(6, (({
                    endClocks: t
                }) => {
                    l.closeActive(t.relative)
                }));
                const u = i.subscribe((({
                    newLocation: t
                }) => {
                    const e = l.find();
                    if (e) {
                        const i = (0, n._q)();
                        l.closeActive(i), l.add(d({
                            url: t.href,
                            referrer: e.referrer
                        }), i)
                    }
                }));

                function d({
                    url: t,
                    referrer: e
                }) {
                    return {
                        url: t,
                        referrer: e
                    }
                }
                return e.register(0, (({
                    startTime: t,
                    eventType: e
                }) => {
                    const i = l.find(t);
                    return i ? {
                        type: e,
                        view: {
                            url: i.url,
                            referrer: i.referrer
                        }
                    } : a.C_
                })), {
                    findUrl: t => l.find(t),
                    stop: () => {
                        u.unsubscribe(), l.stop()
                    }
                }
            }
        },
        1503: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    O: () => a
                }), 179 == i.j) var s = i(8981);
            if (179 == i.j) var r = i(9029);
            const n = 179 == i.j ? s.TN : null;

            function a(t) {
                const e = (0, r.p)({
                    expireDelay: n
                });
                return t.subscribe(1, (t => {
                    e.add(function(t) {
                        return {
                            service: t.service,
                            version: t.version,
                            context: t.context,
                            id: t.id,
                            name: t.name,
                            startClocks: t.startClocks
                        }
                    }(t), t.startClocks.relative)
                })), t.subscribe(6, (({
                    endClocks: t
                }) => {
                    e.closeActive(t.relative)
                })), t.subscribe(3, (t => {
                    const i = e.find(t.startClocks.relative);
                    i && (t.name && (i.name = t.name), t.context && (i.context = t.context), i.sessionIsActive = t.sessionIsActive)
                })), t.subscribe(10, (() => {
                    e.reset()
                })), {
                    findView: t => e.find(t),
                    stop: () => {
                        e.stop()
                    }
                }
            }
        },
        8748: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    J: () => r
                }), 179 == i.j) var s = i(3603);

            function r(t) {
                return (0, s.hj)(t) && t < 0 ? void 0 : t
            }
        },
        8455: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    U: () => n
                }), 179 == i.j) var s = i(6296);
            if (179 == i.j) var r = i(3842);

            function n(t) {
                const e = (0, s.a)([r.vA.error]).subscribe((e => t.notify(e.error)));
                return {
                    stop: () => {
                        e.unsubscribe()
                    }
                }
            }
        },
        1939: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    x: () => r
                }), 179 == i.j) var s = i(3670);

            function r(t, e) {
                const i = (0, s.v)(t, [s._.cspViolation, s._.intervention]).subscribe((t => e.notify(t)));
                return {
                    stop: () => {
                        i.unsubscribe()
                    }
                }
            }
        },
        2475: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    G: () => r
                }), 179 == i.j) var s = i(3909);

            function r(t, {
                session: e,
                viewContext: i,
                errorType: r
            }) {
                const n = e ? e.id : "no-session-id",
                    a = [];
                void 0 !== r && a.push(`error-type=${r}`), i && (a.push(`seed=${i.id}`), a.push(`from=${i.startClocks.timeStamp}`));
                const o = function(t) {
                    const e = t.site,
                        i = t.subdomain || function(t) {
                            switch (t.site) {
                                case s.D_:
                                case s.Ds:
                                    return "app";
                                case s.DZ:
                                    return "dd";
                                default:
                                    return
                            }
                        }(t);
                    return `https://${i?`${i}.`:""}${e}`
                }(t);
                return `${o}/rum/replay/sessions/${n}?${a.join("&")}`
            }
        },
        769: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    H: () => r
                }), 179 == i.j) var s = i(9643);
            const r = 179 == i.j ? s.uR : null
        },
        5689: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    j: () => r
                }), 179 == i.j) var s = i(9307);
            const r = 179 == i.j ? s.l : null
        },
        1802: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    O: () => o
                }), 179 == i.j) var s = i(2904);
            if (179 == i.j) var r = i(4776);
            if (179 == i.j) var n = i(3234);
            if (179 == i.j) var a = i(8566);

            function o(t, e, i) {
                const n = (0, s.I8)(t),
                    a = i(n);
                return (0, r.qP)(e).forEach((([e, i]) => l(t, n, e.split(/\.|(?=\[\])/), i))), a
            }

            function l(t, e, i, s) {
                const [r, ...o] = i;
                if ("[]" !== r) {
                    if (c(t) && c(e)) return o.length > 0 ? l(t[r], e[r], o, s) : void
                    function(t, e, i, s) {
                        const r = (0, n.o)(i);
                        r === s ? t[e] = (0, a.N)(i) : "object" !== s || "undefined" !== r && "null" !== r || (t[e] = {})
                    }(t, r, e[r], s)
                } else Array.isArray(t) && Array.isArray(e) && t.forEach(((t, i) => l(t, e[i], o, s)))
            }

            function c(t) {
                return "object" === (0, n.o)(t)
            }
        },
        604: (t, e, i) => {
            "use strict";

            function s(t, e, i) {
                if (t)
                    for (const s of t) {
                        const t = s[e];
                        t && t(i)
                    }
            }
            i.d(e, {
                n: () => s
            })
        },
        7655: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    t: () => n
                }), 179 == i.j) var s = i(7198);
            const r = 1e3;

            function n(t) {
                const e = new Set,
                    i = t.subscribe(8, (t => {
                        e.add(t), e.size > r && ((0, s.eJ)("Too many requests"), e.delete(e.values().next().value))
                    }));
                return {
                    getMatchingRequest(t) {
                        let i, s = 1 / 0;
                        for (const r of e) {
                            const e = t.startTime - r.startClocks.relative;
                            0 <= e && e < s && r.url === t.name && (s = Math.abs(e), i = r)
                        }
                        return i && e.delete(i), i
                    },
                    stop() {
                        i.unsubscribe()
                    }
                }
            }
        },
        4717: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    j5: () => u,
                    oi: () => c
                }), 179 == i.j) var s = i(5135);
            if (179 == i.j) var r = i(6876);
            if (179 == i.j) var n = i(251);
            if (179 == i.j) var a = i(3473);
            if (179 == i.j) var o = i(3603);
            const l = "rum";

            function c(t, e, i) {
                const r = (0, s.HX)(t, l, (e => function(t, e) {
                    return "0" === (i = e) || "1" === i || "2" === i ? e : (0, o.y7)(t.sessionSampleRate) ? (0, o.y7)(t.sessionReplaySampleRate) ? "1" : "2" : "0";
                    var i
                }(t, e)), i);
                return r.expireObservable.subscribe((() => {
                    e.notify(9)
                })), r.renewObservable.subscribe((() => {
                    e.notify(10)
                })), r.sessionStateUpdateObservable.subscribe((({
                    previousState: t,
                    newState: e
                }) => {
                    if (!t.forcedReplay && e.forcedReplay) {
                        const t = r.findSession();
                        t && (t.isReplayForced = !0)
                    }
                })), {
                    findTrackedSession: t => {
                        const e = r.findSession(t);
                        if (e && "0" !== e.trackingType) return {
                            id: e.id,
                            sessionReplay: "1" === e.trackingType ? 1 : e.isReplayForced ? 2 : 0,
                            anonymousId: e.anonymousId
                        }
                    },
                    expire: r.expire,
                    expireObservable: r.expireObservable,
                    setForcedReplay: () => r.updateSessionState({
                        forcedReplay: "1"
                    })
                }
            }

            function u() {
                const t = {
                    id: "00000000-aaaa-0000-aaaa-000000000000",
                    sessionReplay: (0, r.ke)("records") ? 1 : 0
                };
                return {
                    findTrackedSession: () => t,
                    expire: n.Z,
                    expireObservable: new a.y$,
                    setForcedReplay: n.Z
                }
            }
        },
        1601: (t, e, i) => {
            "use strict";

            function s() {
                return n(64)
            }

            function r() {
                return n(63)
            }

            function n(t) {
                const e = crypto.getRandomValues(new Uint32Array(2));
                return 63 === t && (e[e.length - 1] >>>= 1), {
                    toString(t = 10) {
                        let i = e[1],
                            s = e[0],
                            r = "";
                        do {
                            const e = i % t * 4294967296 + s;
                            i = Math.floor(i / t), s = Math.floor(e / t), r = (e % t).toString(t) + r
                        } while (i || s);
                        return r
                    }
                }
            }

            function a(t) {
                return t.toString(16).padStart(16, "0")
            }
            i.d(e, {
                LV: () => s,
                Nu: () => r,
                vz: () => a
            })
        },
        9725: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    T: () => r
                }), 179 == i.j) var s = i(3206);

            function r(t, e) {
                const {
                    stop: i
                } = (0, s.O)(t, window, "pageshow", (t => {
                    t.persisted && e(t)
                }), {
                    capture: !0
                });
                return i
            }
        },
        5533: (t, e, i) => {
            "use strict";
            i.d(e, {
                S: () => r
            });
            const s = (t, e) => t * e,
                r = t => s(t.previousRect.width, t.previousRect.height) + s(t.currentRect.width, t.currentRect.height) - ((t, e) => {
                    const i = Math.max(t.left, e.left),
                        r = Math.max(t.top, e.top),
                        n = Math.min(t.right, e.right),
                        a = Math.min(t.bottom, e.bottom);
                    return i >= n || r >= a ? 0 : s(n - i, a - r)
                })(t.previousRect, t.currentRect)
        },
        4408: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    j: () => o
                }), 179 == i.j) var s = i(3603);
            if (179 == i.j) var r = i(251);
            if (179 == i.j) var n = i(7198);
            const a = "Initial view metrics";

            function o(t, e, i) {
                if (!i.enabled || !(0, s.y7)(t.initialViewMetricsTelemetrySampleRate)) return {
                    stop: r.Z
                };
                const {
                    unsubscribe: o
                } = e.subscribe(4, (({
                    initialViewMetrics: t
                }) => {
                    var e, i;
                    t.largestContentfulPaint && t.navigationTimings && ((0, n.qZ)(a, {
                        metrics: (e = t.largestContentfulPaint, i = t.navigationTimings, {
                            lcp: {
                                value: e.value
                            },
                            navigation: {
                                domComplete: i.domComplete,
                                domContentLoaded: i.domContentLoaded,
                                domInteractive: i.domInteractive,
                                firstByte: i.firstByte,
                                loadEvent: i.loadEvent
                            }
                        })
                    }), o())
                }));
                return {
                    stop: o
                }
            }
        },
        1358: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    _X: () => d
                }), 179 == i.j) var s = i(5026);
            if (179 == i.j) var r = i(3473);
            if (179 == i.j) var n = i(251);
            if (179 == i.j) var a = i(4933);
            if (179 == i.j) var o = i(3206);
            if (179 == i.j) var l = i(247);
            if (179 == i.j) var c = i(5788);
            const u = 179 == i.j ? s.WT : null;

            function d(t, e, i, d = function(t, e = u) {
                return new r.y$((i => {
                    if (window.ResizeObserver) {
                        const s = (0, n.P)((function() {
                                i.notify(function() {
                                    const t = (0, l.X)(),
                                        {
                                            height: e
                                        } = (0, c.PA)();
                                    return {
                                        scrollHeight: Math.round((document.scrollingElement || document.documentElement).scrollHeight),
                                        scrollDepth: Math.round(e + t),
                                        scrollTop: t
                                    }
                                }())
                            }), e, {
                                leading: !1,
                                trailing: !0
                            }),
                            r = document.scrollingElement || document.documentElement,
                            u = new ResizeObserver((0, a.zk)(s.throttled));
                        r && u.observe(r);
                        const d = (0, o.O)(t, window, "scroll", s.throttled, {
                            passive: !0
                        });
                        return () => {
                            s.cancel(), u.disconnect(), d.stop()
                        }
                    }
                }))
            }(t)) {
                let h = 0,
                    f = 0,
                    p = 0;
                const g = d.subscribe((({
                    scrollDepth: t,
                    scrollTop: r,
                    scrollHeight: n
                }) => {
                    let a = !1;
                    if (t > h && (h = t, a = !0), n > f) {
                        f = n;
                        const t = (0, s._q)();
                        p = (0, s._J)(e.relative, t), a = !0
                    }
                    a && i({
                        maxDepth: Math.min(h, f),
                        maxDepthScrollTop: r,
                        maxScrollHeight: f,
                        maxScrollHeightTime: p
                    })
                }));
                return {
                    stop: () => g.unsubscribe()
                }
            }
        },
        782: (t, e, i) => {
            "use strict";
            i.d(e, {
                Us: () => b,
                Xn: () => te,
                k6: () => Zt,
                zx: () => Yt,
                $n: () => Xt,
                nw: () => Qt,
                D$: () => m,
                uo: () => Mt,
                YO: () => Se,
                Uo: () => Gt.Uo,
                q5: () => et.q,
                IE: () => ie,
                SZ: () => re,
                Ow: () => Gt.Ow,
                $1: () => Ss.$,
                X_: () => Ss.X,
                Gm: () => ws.G,
                FB: () => le,
                PA: () => Es.PA,
                Sn: () => Gt.Sn,
                AX: () => Es.AX,
                aT: () => Gt.aT,
                VO: () => Gt.VO,
                HR: () => V,
                _r: () => J,
                Ch: () => se,
                Pu: () => Lt,
                gR: () => ne,
                iB: () => Ts,
                wM: () => jt
            });
            var s = i(2988),
                r = i(5673),
                n = i(3895),
                a = i(4933),
                o = i(7198),
                l = i(8678),
                c = i(2904),
                u = i(4507),
                d = i(8566),
                h = i(5026),
                f = i(1214),
                p = i(254),
                g = i(2799);
            const m = {
                    ACTION: "action",
                    ERROR: "error",
                    LONG_TASK: "long_task",
                    VIEW: "view",
                    RESOURCE: "resource",
                    VITAL: "vital"
                },
                y = {
                    LONG_TASK: "long-task",
                    LONG_ANIMATION_FRAME: "long-animation-frame"
                },
                v = {
                    INITIAL_LOAD: "initial_load",
                    ROUTE_CHANGE: "route_change",
                    BF_CACHE: "bf_cache"
                },
                b = {
                    CLICK: "click",
                    CUSTOM: "custom"
                },
                T = {
                    RAGE_CLICK: "rage_click",
                    ERROR_CLICK: "error_click",
                    DEAD_CLICK: "dead_click"
                },
                E = {
                    DURATION: "duration"
                };
            var S = i(8129);

            function w({
                vitalsByName: t,
                vitalsByReference: e
            }, i, s = {}) {
                const r = {
                        name: i,
                        startClocks: (0, h.$I)(),
                        context: s.context,
                        description: s.description
                    },
                    n = {
                        __dd_vital_reference: !0
                    };
                return t.set(i, r), e.set(n, r), n
            }

            function k(t, {
                vitalsByName: e,
                vitalsByReference: i
            }, s, r = {}) {
                const n = "string" == typeof s ? e.get(s) : i.get(s);
                n && (t(function(t, e, i, s) {
                    var r;
                    return {
                        name: t.name,
                        type: E.DURATION,
                        startClocks: e,
                        duration: (0, h._J)(e.timeStamp, s.timeStamp),
                        context: (0, c.$e)(t.context, i.context),
                        description: null !== (r = i.description) && void 0 !== r ? r : t.description
                    }
                }(n, n.startClocks, r, (0, h.$I)())), "string" == typeof s ? e.delete(s) : i.delete(s))
            }
            var A = i(604),
                _ = i(8783),
                L = i(3127),
                R = i(2027),
                I = i(9598),
                C = i(6876),
                D = i(3842),
                x = i(251),
                P = i(8679),
                O = i(7549),
                M = i(9262),
                N = i(7063),
                F = i(3603),
                $ = i(4162),
                U = i(5562),
                B = i(3234),
                j = i(4776);
            const G = new Map;

            function V(t, e) {
                if (100 === e) return !0;
                if (0 === e) return !1;
                const i = G.get(e);
                if (i && t === i.sessionId) return i.decision;
                let s;
                return s = window.BigInt ? function(t, e) {
                    const i = BigInt("1111111111111111111"),
                        s = BigInt("0x10000000000000000");
                    return Number(t * i % s) <= e / 100 * Number(s)
                }(BigInt(`0x${t.split("-")[4]}`), e) : (0, F.y7)(e), G.set(e, {
                    sessionId: t,
                    decision: s
                }), s
            }
            var H = i(1601);

            function K(t) {
                0 !== t.status || t.isAborted || (t.traceId = void 0, t.spanId = void 0, t.traceSampled = void 0)
            }

            function z(t, e, i, s, r, n) {
                const a = i.findTrackedSession();
                if (!a) return;
                const o = t.allowedTracingUrls.find((t => (0, U.v)([t.match], e.url, !0)));
                if (!o) return;
                const l = V(a.id, t.traceSampleRate);
                (l || t.traceContextInjection === N.tg.ALL) && (e.traceSampled = l, e.traceId = (0, H.LV)(), e.spanId = (0, H.Nu)(), n(function(t, e, i, s, r, n, a, o) {
                    const l = {};
                    if (r.forEach((s => {
                            switch (s) {
                                case "datadog":
                                    Object.assign(l, {
                                        "x-datadog-origin": "rum",
                                        "x-datadog-parent-id": e.toString(),
                                        "x-datadog-sampling-priority": i ? "1" : "0",
                                        "x-datadog-trace-id": t.toString()
                                    });
                                    break;
                                case "tracecontext":
                                    Object.assign(l, {
                                        traceparent: `00-0000000000000000${(0,H.vz)(t)}-${(0,H.vz)(e)}-0${i?"1":"0"}`,
                                        tracestate: `dd=s:${i?"1":"0"};o:rum`
                                    });
                                    break;
                                case "b3":
                                    Object.assign(l, {
                                        b3: `${(0,H.vz)(t)}-${(0,H.vz)(e)}-${i?"1":"0"}`
                                    });
                                    break;
                                case "b3multi":
                                    Object.assign(l, {
                                        "X-B3-TraceId": (0, H.vz)(t),
                                        "X-B3-SpanId": (0, H.vz)(e),
                                        "X-B3-Sampled": i ? "1" : "0"
                                    })
                            }
                        })), o.propagateTraceBaggage) {
                        const t = {
                                "session.id": s
                            },
                            e = n.getContext().id;
                        "string" == typeof e && (t["user.id"] = e);
                        const i = a.getContext().id;
                        "string" == typeof i && (t["account.id"] = i);
                        const r = Object.entries(t).map((([t, e]) => `${t}=${encodeURIComponent(e)}`)).join(",");
                        r && (l.baggage = r)
                    }
                    return l
                }(e.traceId, e.spanId, e.traceSampled, a.id, o.propagatorTypes, s, r, t)))
            }
            const q = ["tracecontext", "datadog"];

            function W(t) {
                const e = new Set;
                return Array.isArray(t.allowedTracingUrls) && t.allowedTracingUrls.length > 0 && t.allowedTracingUrls.forEach((t => {
                    (0, U.o)(t) ? q.forEach((t => e.add(t))): "object" === (0, B.o)(t) && Array.isArray(t.propagatorTypes) && t.propagatorTypes.forEach((t => e.add(t)))
                })), Array.from(e)
            }
            var Y = i(1093);

            function X({
                ignoreInitIfSyntheticsWillInjectRum: t = !0,
                startDeflateWorker: e
            }, i, s, r) {
                const n = (0, _.D)(),
                    l = (0, L.N)();
                Q(l, p.g.globalContext, n);
                const c = (0, R.f)();
                Q(c, p.g.userContext, n);
                const u = (0, I.d)();
                let d, f, m, y;
                Q(u, p.g.accountContext, n);
                const v = i.observable.subscribe(T),
                    b = {};

                function T() {
                    if (!m || !y || !i.isGranted()) return;
                    let t;
                    if (v.unsubscribe(), y.trackViewsManually) {
                        if (!d) return;
                        n.remove(d.callback), t = d.options
                    }
                    const e = r(y, f, t);
                    n.drain(e)
                }

                function E(t) {
                    const s = (0, C.xT)();
                    if (s && (t = function(t) {
                            var e, i;
                            return { ...t,
                                applicationId: "00000000-aaaa-0000-aaaa-000000000000",
                                clientToken: "empty",
                                sessionSampleRate: 100,
                                defaultPrivacyLevel: null !== (e = t.defaultPrivacyLevel) && void 0 !== e ? e : null === (i = (0, C.Ad)()) || void 0 === i ? void 0 : i.getPrivacyLevel()
                            }
                        }(t)), m = t, (0, o.Uo)(function(t) {
                            var e;
                            const i = (0, N.JZ)(t);
                            return {
                                session_replay_sample_rate: t.sessionReplaySampleRate,
                                start_session_replay_recording_manually: t.startSessionReplayRecordingManually,
                                trace_sample_rate: t.traceSampleRate,
                                trace_context_injection: t.traceContextInjection,
                                action_name_attribute: t.actionNameAttribute,
                                use_allowed_tracing_urls: Array.isArray(t.allowedTracingUrls) && t.allowedTracingUrls.length > 0,
                                selected_tracing_propagators: W(t),
                                default_privacy_level: t.defaultPrivacyLevel,
                                enable_privacy_for_action_name: t.enablePrivacyForActionName,
                                use_excluded_activity_urls: Array.isArray(t.excludedActivityUrls) && t.excludedActivityUrls.length > 0,
                                use_worker_url: !!t.workerUrl,
                                compress_intake_requests: t.compressIntakeRequests,
                                track_views_manually: t.trackViewsManually,
                                track_user_interactions: t.trackUserInteractions,
                                track_resources: t.trackResources,
                                track_long_task: t.trackLongTasks,
                                track_bfcache_views: t.trackBfcacheViews,
                                plugins: null === (e = t.plugins) || void 0 === e ? void 0 : e.map((t => {
                                    var e;
                                    return {
                                        name: t.name,
                                        ...null === (e = t.getConfigurationTelemetry) || void 0 === e ? void 0 : e.call(t)
                                    }
                                })),
                                track_feature_flags_for_events: t.trackFeatureFlagsForEvents,
                                ...i
                            }
                        }(t)), y) return void(0, g.W)("DD_RUM", t);
                    const r = function(t) {
                        var e, i, s, r, n, a, o;
                        if (void 0 === t.trackFeatureFlagsForEvents || Array.isArray(t.trackFeatureFlagsForEvents) || D.jf.warn("trackFeatureFlagsForEvents should be an array"), !t.applicationId) return void D.jf.error("Application ID is not configured, no RUM data will be collected.");
                        if (!(0, N.RJ)(t.sessionReplaySampleRate, "Session Replay") || !(0, N.RJ)(t.traceSampleRate, "Trace")) return;
                        if (void 0 !== t.excludedActivityUrls && !Array.isArray(t.excludedActivityUrls)) return void D.jf.error("Excluded Activity Urls should be an array");
                        const l = function(t) {
                            if (void 0 === t.allowedTracingUrls) return [];
                            if (!Array.isArray(t.allowedTracingUrls)) return void D.jf.error("Allowed Tracing URLs should be an array");
                            if (0 !== t.allowedTracingUrls.length && void 0 === t.service) return void D.jf.error("Service needs to be configured when tracing is enabled");
                            const e = [];
                            return t.allowedTracingUrls.forEach((t => {
                                (0, U.o)(t) ? e.push({
                                    match: t,
                                    propagatorTypes: q
                                }): function(t) {
                                    const e = t;
                                    return "object" === (0, B.o)(e) && (0, U.o)(e.match) && Array.isArray(e.propagatorTypes)
                                }(t) ? e.push(t) : D.jf.warn("Allowed Tracing Urls parameters should be a string, RegExp, function, or an object. Ignoring parameter", t)
                            })), e
                        }(t);
                        if (!l) return;
                        const c = (0, N.fP)(t);
                        if (!c) return;
                        const u = null !== (e = t.sessionReplaySampleRate) && void 0 !== e ? e : 0;
                        return {
                            applicationId: t.applicationId,
                            actionNameAttribute: t.actionNameAttribute,
                            sessionReplaySampleRate: u,
                            startSessionReplayRecordingManually: void 0 !== t.startSessionReplayRecordingManually ? !!t.startSessionReplayRecordingManually : 0 === u,
                            traceSampleRate: null !== (i = t.traceSampleRate) && void 0 !== i ? i : 100,
                            rulePsr: (0, F.hj)(t.traceSampleRate) ? t.traceSampleRate / 100 : void 0,
                            allowedTracingUrls: l,
                            excludedActivityUrls: null !== (s = t.excludedActivityUrls) && void 0 !== s ? s : [],
                            workerUrl: t.workerUrl,
                            compressIntakeRequests: !!t.compressIntakeRequests,
                            trackUserInteractions: !(null !== (r = t.trackUserInteractions) && void 0 !== r && !r),
                            trackViewsManually: !!t.trackViewsManually,
                            trackResources: !(null !== (n = t.trackResources) && void 0 !== n && !n),
                            trackLongTasks: !(null !== (a = t.trackLongTasks) && void 0 !== a && !a),
                            trackBfcacheViews: !!t.trackBfcacheViews,
                            subdomain: t.subdomain,
                            defaultPrivacyLevel: (0, $.E5)(N.Jj, t.defaultPrivacyLevel) ? t.defaultPrivacyLevel : N.Jj.MASK,
                            enablePrivacyForActionName: !!t.enablePrivacyForActionName,
                            customerDataTelemetrySampleRate: 1,
                            initialViewMetricsTelemetrySampleRate: 1,
                            replayTelemetrySampleRate: 1,
                            traceContextInjection: (0, $.E5)(N.tg, t.traceContextInjection) ? t.traceContextInjection : N.tg.SAMPLED,
                            plugins: t.plugins || [],
                            trackFeatureFlagsForEvents: t.trackFeatureFlagsForEvents || [],
                            profilingSampleRate: null !== (o = t.profilingSampleRate) && void 0 !== o ? o : 0,
                            propagateTraceBaggage: !!t.propagateTraceBaggage,
                            ...c
                        }
                    }(t);
                    r && (s || r.sessionStoreStrategyType ? r.compressIntakeRequests && !s && e && (f = e(r, "Datadog RUM", x.Z), !f) || (y = r, (0, P.y)().subscribe(x.Z), i.tryToInit(r.trackingConsent), T()) : D.jf.warn("No storage available for session. We will not send any data."))
                }
                const S = t => {
                    n.add((e => e.addDurationVital(t)))
                };
                return {
                    init(e, i) {
                        e ? ((0, O.fG)(e.enableExperimentalFeatures), m = e, t && (0, M.Y9)() || ((0, A.n)(e.plugins, "onInit", {
                            initConfiguration: e,
                            publicApi: i
                        }), e.remoteConfigurationId ? (0, Y.ir)(e).then((t => {
                            t && E(t)
                        })).catch(a.$y) : E(e))) : D.jf.error("Missing configuration")
                    },
                    get initConfiguration() {
                        return m
                    },
                    getInternalContext: x.Z,
                    stopSession: x.Z,
                    addTiming(t, e = (0, h.n$)()) {
                        n.add((i => i.addTiming(t, e)))
                    },
                    startView(t, e = (0, h.$I)()) {
                        const i = i => {
                            i.startView(t, e)
                        };
                        n.add(i), d || (d = {
                            options: t,
                            callback: i
                        }, T())
                    },
                    setViewName(t) {
                        n.add((e => e.setViewName(t)))
                    },
                    setViewContext(t) {
                        n.add((e => e.setViewContext(t)))
                    },
                    setViewContextProperty(t, e) {
                        n.add((i => i.setViewContextProperty(t, e)))
                    },
                    getViewContext: () => b,
                    globalContext: l,
                    userContext: c,
                    accountContext: u,
                    addAction(t) {
                        n.add((e => e.addAction(t)))
                    },
                    addError(t) {
                        n.add((e => e.addError(t)))
                    },
                    addFeatureFlagEvaluation(t, e) {
                        n.add((i => i.addFeatureFlagEvaluation(t, e)))
                    },
                    startDurationVital: (t, e) => w(s, t, e),
                    stopDurationVital(t, e) {
                        k(S, s, t, e)
                    },
                    addDurationVital: S
                }
            }

            function Q(t, e, i) {
                t.changeObservable.subscribe((() => {
                    const s = t.getContext();
                    i.add((t => t[e].setContext(s)))
                }))
            }

            function J(t, e, i, m = {}) {
                const y = (0, s.H)(),
                    v = {
                        vitalsByName: new Map,
                        vitalsByReference: new WeakMap
                    },
                    T = (0, r.Q)().observable;
                let S = X(m, y, v, ((s, r, a) => {
                    const o = t(s, e, i, a, r && m.createDeflateEncoder ? t => m.createDeflateEncoder(s, r, t) : n.G, y, v, T, m.sdkName);
                    return e.onRumStart(o.lifeCycle, s, o.session, o.viewHistory, r, o.telemetry), i.onRumStart(o.lifeCycle, o.hooks, s, o.session, o.viewHistory), S = function(t, e) {
                        return {
                            init: t => {
                                (0, g.W)("DD_RUM", t)
                            },
                            initConfiguration: t.initConfiguration,
                            ...e
                        }
                    }(S, o), (0, A.n)(s.plugins, "onRumStart", {
                        strategy: S,
                        addEvent: o.addEvent
                    }), o
                }));
                const w = () => S,
                    k = (0, a.zk)((t => {
                        const e = "object" == typeof t ? t : {
                            name: t
                        };
                        S.startView(e), (0, o.eG)({
                            feature: "start-view"
                        })
                    })),
                    _ = (0, l.r)({
                        init: (0, a.zk)((t => {
                            S.init(t, _)
                        })),
                        setTrackingConsent: (0, a.zk)((t => {
                            y.update(t), (0, o.eG)({
                                feature: "set-tracking-consent",
                                tracking_consent: t
                            })
                        })),
                        setViewName: (0, a.zk)((t => {
                            S.setViewName(t), (0, o.eG)({
                                feature: "set-view-name"
                            })
                        })),
                        setViewContext: (0, a.zk)((t => {
                            S.setViewContext(t), (0, o.eG)({
                                feature: "set-view-context"
                            })
                        })),
                        setViewContextProperty: (0, a.zk)(((t, e) => {
                            S.setViewContextProperty(t, e), (0, o.eG)({
                                feature: "set-view-context-property"
                            })
                        })),
                        getViewContext: (0, a.zk)((() => ((0, o.eG)({
                            feature: "set-view-context-property"
                        }), S.getViewContext()))),
                        getInternalContext: (0, a.zk)((t => S.getInternalContext(t))),
                        getInitConfiguration: (0, a.zk)((() => (0, c.I8)(S.initConfiguration))),
                        addAction: (t, e) => {
                            const i = (0, u.Xp)("action");
                            (0, a.L6)((() => {
                                S.addAction({
                                    name: (0, d.N)(t),
                                    context: (0, d.N)(e),
                                    startClocks: (0, h.$I)(),
                                    type: b.CUSTOM,
                                    handlingStack: i
                                }), (0, o.eG)({
                                    feature: "add-action"
                                })
                            }))
                        },
                        addError: (t, e) => {
                            const i = (0, u.Xp)("error");
                            (0, a.L6)((() => {
                                S.addError({
                                    error: t,
                                    handlingStack: i,
                                    context: (0, d.N)(e),
                                    startClocks: (0, h.$I)()
                                }), (0, o.eG)({
                                    feature: "add-error"
                                })
                            }))
                        },
                        addTiming: (0, a.zk)(((t, e) => {
                            S.addTiming((0, d.N)(t), e)
                        })),
                        setGlobalContext: (0, f.z)(w, p.g.globalContext, p.O.setContext, "set-global-context"),
                        getGlobalContext: (0, f.z)(w, p.g.globalContext, p.O.getContext, "get-global-context"),
                        setGlobalContextProperty: (0, f.z)(w, p.g.globalContext, p.O.setContextProperty, "set-global-context-property"),
                        removeGlobalContextProperty: (0, f.z)(w, p.g.globalContext, p.O.removeContextProperty, "remove-global-context-property"),
                        clearGlobalContext: (0, f.z)(w, p.g.globalContext, p.O.clearContext, "clear-global-context"),
                        setUser: (0, f.z)(w, p.g.userContext, p.O.setContext, "set-user"),
                        getUser: (0, f.z)(w, p.g.userContext, p.O.getContext, "get-user"),
                        setUserProperty: (0, f.z)(w, p.g.userContext, p.O.setContextProperty, "set-user-property"),
                        removeUserProperty: (0, f.z)(w, p.g.userContext, p.O.removeContextProperty, "remove-user-property"),
                        clearUser: (0, f.z)(w, p.g.userContext, p.O.clearContext, "clear-user"),
                        setAccount: (0, f.z)(w, p.g.accountContext, p.O.setContext, "set-account"),
                        getAccount: (0, f.z)(w, p.g.accountContext, p.O.getContext, "get-account"),
                        setAccountProperty: (0, f.z)(w, p.g.accountContext, p.O.setContextProperty, "set-account-property"),
                        removeAccountProperty: (0, f.z)(w, p.g.accountContext, p.O.removeContextProperty, "remove-account-property"),
                        clearAccount: (0, f.z)(w, p.g.accountContext, p.O.clearContext, "clear-account"),
                        startView: k,
                        stopSession: (0, a.zk)((() => {
                            S.stopSession(), (0, o.eG)({
                                feature: "stop-session"
                            })
                        })),
                        addFeatureFlagEvaluation: (0, a.zk)(((t, e) => {
                            S.addFeatureFlagEvaluation((0, d.N)(t), (0, d.N)(e)), (0, o.eG)({
                                feature: "add-feature-flag-evaluation"
                            })
                        })),
                        getSessionReplayLink: (0, a.zk)((() => e.getSessionReplayLink())),
                        startSessionReplayRecording: (0, a.zk)((t => {
                            e.start(t), (0, o.eG)({
                                feature: "start-session-replay-recording",
                                force: t && t.force
                            })
                        })),
                        stopSessionReplayRecording: (0, a.zk)((() => e.stop())),
                        addDurationVital: (0, a.zk)(((t, e) => {
                            (0, o.eG)({
                                feature: "add-duration-vital"
                            }), S.addDurationVital({
                                name: (0, d.N)(t),
                                type: E.DURATION,
                                startClocks: (0, h.lO)(e.startTime),
                                duration: e.duration,
                                context: (0, d.N)(e && e.context),
                                description: (0, d.N)(e && e.description)
                            })
                        })),
                        startDurationVital: (0, a.zk)(((t, e) => ((0, o.eG)({
                            feature: "start-duration-vital"
                        }), S.startDurationVital((0, d.N)(t), {
                            context: (0, d.N)(e && e.context),
                            description: (0, d.N)(e && e.description)
                        })))),
                        stopDurationVital: (0, a.zk)(((t, e) => {
                            (0, o.eG)({
                                feature: "stop-duration-vital"
                            }), S.stopDurationVital("string" == typeof t ? (0, d.N)(t) : t, {
                                context: (0, d.N)(e && e.context),
                                description: (0, d.N)(e && e.description)
                            })
                        }))
                    });
                return _
            }
            var Z = i(8971),
                tt = i(7581),
                et = i(4250),
                it = i(4967),
                st = i(1762),
                rt = i(5689),
                nt = i(1503),
                at = i(5343),
                ot = i(8300),
                lt = i(9100),
                ct = i(8057),
                ut = i(170),
                dt = i(5039);
            const ht = "initial_document",
                ft = [
                    [ot._.DOCUMENT, t => ht === t],
                    [ot._.XHR, t => "xmlhttprequest" === t],
                    [ot._.FETCH, t => "fetch" === t],
                    [ot._.BEACON, t => "beacon" === t],
                    [ot._.CSS, (t, e) => /\.css$/i.test(e)],
                    [ot._.JS, (t, e) => /\.js$/i.test(e)],
                    [ot._.IMAGE, (t, e) => ["image", "img", "icon"].includes(t) || null !== /\.(gif|jpg|jpeg|tiff|png|svg|ico)$/i.exec(e)],
                    [ot._.FONT, (t, e) => null !== /\.(woff|eot|woff2|ttf)$/i.exec(e)],
                    [ot._.MEDIA, (t, e) => ["audio", "video"].includes(t) || null !== /\.(mp3|mp4)$/i.exec(e)]
                ];

            function pt(t) {
                const e = t.name;
                if (!(0, ut.jv)(e)) return (0, o.eJ)(`Failed to construct URL for "${t.name}"`), ot._.OTHER;
                const i = (0, ut.ye)(e);
                for (const [e, s] of ft)
                    if (s(t.initiatorType, i)) return e;
                return ot._.OTHER
            }

            function gt(...t) {
                for (let e = 1; e < t.length; e += 1)
                    if (t[e - 1] > t[e]) return !1;
                return !0
            }

            function mt(t) {
                return "xmlhttprequest" === t.initiatorType || "fetch" === t.initiatorType
            }

            function yt(t) {
                if (!bt(t)) return;
                const {
                    startTime: e,
                    fetchStart: i,
                    workerStart: s,
                    redirectStart: r,
                    redirectEnd: n,
                    domainLookupStart: a,
                    domainLookupEnd: o,
                    connectStart: l,
                    secureConnectionStart: c,
                    connectEnd: u,
                    requestStart: d,
                    responseStart: h,
                    responseEnd: f
                } = t, p = {
                    download: Tt(e, h, f),
                    first_byte: Tt(e, d, h)
                };
                return 0 < s && s < i && (p.worker = Tt(e, s, i)), i < u && (p.connect = Tt(e, l, u), l <= c && c <= u && (p.ssl = Tt(e, c, u))), i < o && (p.dns = Tt(e, a, o)), e < n && (p.redirect = Tt(e, r, n)), p
            }

            function vt(t) {
                return t.duration >= 0
            }

            function bt(t) {
                const e = gt(t.startTime, t.fetchStart, t.domainLookupStart, t.domainLookupEnd, t.connectStart, t.connectEnd, t.requestStart, t.responseStart, t.responseEnd),
                    i = ! function(t) {
                        return t.redirectEnd > t.startTime
                    }(t) || gt(t.startTime, t.redirectStart, t.redirectEnd, t.fetchStart);
                return e && i
            }

            function Tt(t, e, i) {
                if (t <= e && e <= i) return {
                    duration: (0, h.c0)((0, h._J)(e, i)),
                    start: (0, h.c0)((0, h._J)(t, e))
                }
            }

            function Et(t) {
                return "" === t.nextHopProtocol ? void 0 : t.nextHopProtocol
            }

            function St(t) {
                return "" === t.deliveryType ? "other" : t.deliveryType
            }

            function wt(t) {
                if (t.startTime < t.responseStart) {
                    const {
                        encodedBodySize: e,
                        decodedBodySize: i,
                        transferSize: s
                    } = t;
                    return {
                        size: i,
                        encoded_body_size: e,
                        decoded_body_size: i,
                        transfer_size: s
                    }
                }
                return {
                    size: void 0,
                    encoded_body_size: void 0,
                    decoded_body_size: void 0,
                    transfer_size: void 0
                }
            }

            function kt(t) {
                return t && (!(0, dt.i)(t) || (0, O.W_)(O.uh.TRACK_INTAKE_REQUESTS))
            }
            const At = /data:(.+)?(;base64)?,/g,
                _t = 24e3;

            function Lt(t, e = _t) {
                if (t.length <= e || !t.startsWith("data:")) return t;
                const i = t.substring(0, 100).match(At);
                return i ? `${i[0]}[...]` : t
            }
            let Rt = 1;

            function It() {
                const t = Rt;
                return Rt += 1, t
            }
            var Ct = i(9643),
                Dt = i(8748),
                xt = i(9029),
                Pt = i(3473);

            function Ot({
                lifeCycle: t,
                isChildEvent: e,
                onChange: i = x.Z
            }) {
                const s = {
                        errorCount: 0,
                        longTaskCount: 0,
                        resourceCount: 0,
                        actionCount: 0,
                        frustrationCount: 0
                    },
                    r = t.subscribe(13, (t => {
                        var r;
                        if ("view" !== t.type && "vital" !== t.type && e(t)) switch (t.type) {
                            case m.ERROR:
                                s.errorCount += 1, i();
                                break;
                            case m.ACTION:
                                s.actionCount += 1, t.action.frustration && (s.frustrationCount += t.action.frustration.type.length), i();
                                break;
                            case m.LONG_TASK:
                                s.longTaskCount += 1, i();
                                break;
                            case m.RESOURCE:
                                (null === (r = t._dd) || void 0 === r ? void 0 : r.discarded) || (s.resourceCount += 1, i())
                        }
                    }));
                return {
                    stop: () => {
                        r.unsubscribe()
                    },
                    eventCounts: s
                }
            }
            var Mt, Nt = i(5483),
                Ft = i(3206),
                $t = i(7569);

            function Ut(t, e) {
                return new Pt.y$((i => {
                    if (!window.PerformanceObserver) return;
                    const s = t => {
                        const e = function(t) {
                            return t.filter((t => ! function(t) {
                                return !(t.entryType !== Mt.RESOURCE || kt(t.name) && vt(t))
                            }(t)))
                        }(t);
                        e.length > 0 && i.notify(e)
                    };
                    let r, n = !0;
                    const o = new PerformanceObserver((0, a.zk)((t => {
                        n ? r = (0, Nt.iK)((() => s(t.getEntries()))) : s(t.getEntries())
                    })));
                    try {
                        o.observe(e)
                    } catch (t) {
                        if ([Mt.RESOURCE, Mt.NAVIGATION, Mt.LONG_TASK, Mt.PAINT].includes(e.type)) {
                            e.buffered && (r = (0, Nt.iK)((() => s(performance.getEntriesByType(e.type)))));
                            try {
                                o.observe({
                                    entryTypes: [e.type]
                                })
                            } catch (t) {
                                return
                            }
                        }
                    }
                    let l;
                    return n = !1,
                        function(t) {
                            !Bt && void 0 !== window.performance && "getEntries" in performance && "addEventListener" in performance && (Bt = (0, Ft.O)(t, performance, "resourcetimingbufferfull", (() => {
                                performance.clearResourceTimings()
                            })))
                        }(t), jt(Mt.FIRST_INPUT) || e.type !== Mt.FIRST_INPUT || ({
                            stop: l
                        } = (0, $t.X)(t, (t => {
                            s([t])
                        }))), () => {
                            o.disconnect(), l && l(), (0, Nt.gr)(r)
                        }
                }))
            }
            let Bt;

            function jt(t) {
                return window.PerformanceObserver && void 0 !== PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes(t)
            }! function(t) {
                t.EVENT = "event", t.FIRST_INPUT = "first-input", t.LARGEST_CONTENTFUL_PAINT = "largest-contentful-paint", t.LAYOUT_SHIFT = "layout-shift", t.LONG_TASK = "longtask", t.LONG_ANIMATION_FRAME = "long-animation-frame", t.NAVIGATION = "navigation", t.PAINT = "paint", t.RESOURCE = "resource", t.VISIBILITY_STATE = "visibility-state"
            }(Mt || (Mt = {}));
            var Gt = i(3644);
            const Vt = 100,
                Ht = 100,
                Kt = "data-dd-excluded-activity-mutations";

            function zt(t, e, i, s, r, n) {
                const o = function(t, e, i, s) {
                    return new Pt.y$((r => {
                        const n = [];
                        let a, o = 0;
                        return n.push(e.subscribe((t => {
                            t.every(Wt) || l()
                        })), i.subscribe(l), Ut(s, {
                            type: Mt.RESOURCE
                        }).subscribe((t => {
                            t.some((t => !qt(s, t.name))) && l()
                        })), t.subscribe(7, (t => {
                            qt(s, t.url) || (void 0 === a && (a = t.requestIndex), o += 1, l())
                        })), t.subscribe(8, (t => {
                            qt(s, t.url) || void 0 === a || t.requestIndex < a || (o -= 1, l())
                        }))), () => {
                            n.forEach((t => t.unsubscribe()))
                        };

                        function l() {
                            r.notify({
                                isBusy: o > 0
                            })
                        }
                    }))
                }(t, e, i, s);
                return function(t, e, i) {
                    let s, r = !1;
                    const n = (0, Nt.iK)((0, a.zk)((() => u({
                            hadActivity: !1
                        }))), Vt),
                        o = void 0 !== i ? (0, Nt.iK)((0, a.zk)((() => u({
                            hadActivity: !0,
                            end: (0, h.n$)()
                        }))), i) : void 0,
                        l = t.subscribe((({
                            isBusy: t
                        }) => {
                            (0, Nt.gr)(n), (0, Nt.gr)(s);
                            const e = (0, h.n$)();
                            t || (s = (0, Nt.iK)((0, a.zk)((() => u({
                                hadActivity: !0,
                                end: e
                            }))), Ht))
                        })),
                        c = () => {
                            r = !0, (0, Nt.gr)(n), (0, Nt.gr)(s), (0, Nt.gr)(o), l.unsubscribe()
                        };

                    function u(t) {
                        r || (c(), e(t))
                    }
                    return {
                        stop: c
                    }
                }(o, r, n)
            }

            function qt(t, e) {
                return (0, U.v)(t.excludedActivityUrls, e)
            }

            function Wt(t) {
                const e = "characterData" === t.type ? t.target.parentElement : t.target;
                return Boolean(e && (0, Gt.Tv)(e) && e.matches(`[${Kt}], [${Kt}] *`))
            }
            const Yt = {
                    IGNORE: "ignore",
                    HIDDEN: "hidden",
                    ALLOW: N.Jj.ALLOW,
                    MASK: N.Jj.MASK,
                    MASK_USER_INPUT: N.Jj.MASK_USER_INPUT
                },
                Xt = "data-dd-privacy",
                Qt = "hidden",
                Jt = "dd-privacy-",
                Zt = "***",
                te = "data:image/gif;base64,R0lGODlhAQABAIAAAMLCwgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==",
                ee = {
                    INPUT: !0,
                    OUTPUT: !0,
                    TEXTAREA: !0,
                    SELECT: !0,
                    OPTION: !0,
                    DATALIST: !0,
                    OPTGROUP: !0
                };

            function ie(t, e, i) {
                if (i && i.has(t)) return i.get(t);
                const s = (0, Gt.Ow)(t),
                    r = s ? ie(s, e, i) : e,
                    n = se(re(t), r);
                return i && i.set(t, n), n
            }

            function se(t, e) {
                switch (e) {
                    case Yt.HIDDEN:
                    case Yt.IGNORE:
                        return e
                }
                switch (t) {
                    case Yt.ALLOW:
                    case Yt.MASK:
                    case Yt.MASK_USER_INPUT:
                    case Yt.HIDDEN:
                    case Yt.IGNORE:
                        return t;
                    default:
                        return e
                }
            }

            function re(t) {
                if ((0, Gt.Tv)(t)) {
                    if ("BASE" === t.tagName) return Yt.ALLOW;
                    if ("INPUT" === t.tagName) {
                        const e = t;
                        if ("password" === e.type || "email" === e.type || "tel" === e.type) return Yt.MASK;
                        if ("hidden" === e.type) return Yt.MASK;
                        const i = e.getAttribute("autocomplete");
                        if (i && (i.startsWith("cc-") || i.endsWith("-password"))) return Yt.MASK
                    }
                    return t.matches(ce(Yt.HIDDEN)) ? Yt.HIDDEN : t.matches(ce(Yt.MASK)) ? Yt.MASK : t.matches(ce(Yt.MASK_USER_INPUT)) ? Yt.MASK_USER_INPUT : t.matches(ce(Yt.ALLOW)) ? Yt.ALLOW : function(t) {
                        if ("SCRIPT" === t.nodeName) return !0;
                        if ("LINK" === t.nodeName) {
                            const t = e("rel");
                            return /preload|prefetch/i.test(t) && "script" === e("as") || "shortcut icon" === t || "icon" === t
                        }
                        if ("META" === t.nodeName) {
                            const i = e("name"),
                                s = e("rel"),
                                r = e("property");
                            return /^msapplication-tile(image|color)$/.test(i) || "application-name" === i || "icon" === s || "apple-touch-icon" === s || "shortcut icon" === s || "keywords" === i || "description" === i || /^(og|twitter|fb):/.test(r) || /^(og|twitter):/.test(i) || "pinterest" === i || "robots" === i || "googlebot" === i || "bingbot" === i || t.hasAttribute("http-equiv") || "author" === i || "generator" === i || "framework" === i || "publisher" === i || "progid" === i || /^article:/.test(r) || /^product:/.test(r) || "google-site-verification" === i || "yandex-verification" === i || "csrf-token" === i || "p:domain_verify" === i || "verify-v1" === i || "verification" === i || "shopify-checkout-api-token" === i
                        }

                        function e(e) {
                            return (t.getAttribute(e) || "").toLowerCase()
                        }
                        return !1
                    }(t) ? Yt.IGNORE : void 0
                }
            }

            function ne(t, e) {
                switch (e) {
                    case Yt.MASK:
                    case Yt.HIDDEN:
                    case Yt.IGNORE:
                        return !0;
                    case Yt.MASK_USER_INPUT:
                        return (0, Gt.BM)(t) ? ae(t.parentNode) : ae(t);
                    default:
                        return !1
                }
            }

            function ae(t) {
                if (!t || t.nodeType !== t.ELEMENT_NODE) return !1;
                const e = t;
                if ("INPUT" === e.tagName) switch (e.type) {
                    case "button":
                    case "color":
                    case "reset":
                    case "submit":
                        return !1
                }
                return !!ee[e.tagName]
            }
            const oe = t => t.replace(/\S/g, "x");

            function le(t, e, i) {
                var s;
                const r = null === (s = t.parentElement) || void 0 === s ? void 0 : s.tagName;
                let n = t.textContent || "";
                if (e && !n.trim()) return;
                const a = i;
                if ("SCRIPT" === r) n = Zt;
                else if (a === Yt.HIDDEN) n = Zt;
                else if (ne(t, a))
                    if ("DATALIST" === r || "SELECT" === r || "OPTGROUP" === r) {
                        if (!n.trim()) return
                    } else n = "OPTION" === r ? Zt : oe(n);
                return n
            }

            function ce(t) {
                return `[${Xt}="${t}"], .${Jt}${t}`
            }
            const ue = "data-dd-action-name",
                de = "Masked Element";

            function he(t, e) {
                const i = t.closest(`[${e}]`);
                if (i) return ve(ye(i.getAttribute(e).trim()))
            }
            const fe = [(t, e, i) => {
                    if ("labels" in t && t.labels && t.labels.length > 0) return Te(t.labels[0], e, i)
                }, t => {
                    if ("INPUT" === t.nodeName) {
                        const e = t,
                            i = e.getAttribute("type");
                        if ("button" === i || "submit" === i || "reset" === i) return {
                            name: e.value,
                            nameSource: "text_content"
                        }
                    }
                }, (t, e, i) => {
                    if ("BUTTON" === t.nodeName || "LABEL" === t.nodeName || "button" === t.getAttribute("role")) return Te(t, e, i)
                }, t => be(t, "aria-label"), (t, e, i) => {
                    const s = t.getAttribute("aria-labelledby");
                    if (s) return {
                        name: s.split(/\s+/).map((e => function(t, e) {
                            return t.ownerDocument ? t.ownerDocument.getElementById(e) : null
                        }(t, e))).filter((t => Boolean(t))).map((t => Ee(t, e, i))).join(" "),
                        nameSource: "text_content"
                    }
                }, t => be(t, "alt"), t => be(t, "name"), t => be(t, "title"), t => be(t, "placeholder"), (t, e, i) => {
                    if ("options" in t && t.options.length > 0) return Te(t.options[0], e, i)
                }],
                pe = [(t, e, i) => Te(t, e, i)],
                ge = 10;

            function me(t, e, i, s) {
                let r = t,
                    n = 0;
                for (; n <= ge && r && "BODY" !== r.nodeName && "HTML" !== r.nodeName && "HEAD" !== r.nodeName;) {
                    for (const t of i) {
                        const i = t(r, e, s);
                        if (i) {
                            const {
                                name: t,
                                nameSource: e
                            } = i, s = t && t.trim();
                            if (s) return {
                                name: ve(ye(s)),
                                nameSource: e
                            }
                        }
                    }
                    if ("FORM" === r.nodeName) break;
                    r = r.parentElement, n += 1
                }
            }

            function ye(t) {
                return t.replace(/\s+/g, " ")
            }

            function ve(t) {
                return t.length > 100 ? `${(0,S._z)(t,100)} [...]` : t
            }

            function be(t, e) {
                return {
                    name: t.getAttribute(e) || "",
                    nameSource: "standard_attribute"
                }
            }

            function Te(t, e, i) {
                return {
                    name: Ee(t, e, i) || "",
                    nameSource: "text_content"
                }
            }

            function Ee(t, e, i) {
                if (!t.isContentEditable) {
                    if ((0, O.W_)(O.uh.USE_TREE_WALKER_FOR_ACTION_NAME)) return function(t, e, i) {
                        const s = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, (function(t) {
                            if ((0, Gt.Tv)(t)) {
                                const s = re(t);
                                if (t.hasAttribute(ue) || e && t.hasAttribute(e) || i && s && ne(t, s)) return NodeFilter.FILTER_REJECT;
                                const r = getComputedStyle(t);
                                if ("visible" !== r.visibility || "none" === r.display || r.contentVisibility && "visible" !== r.contentVisibility) return NodeFilter.FILTER_REJECT
                            }
                            return NodeFilter.FILTER_ACCEPT
                        }));
                        let r = "";
                        for (; s.nextNode();) {
                            const t = s.currentNode;
                            (0, Gt.Tv)(t) ? ("BR" === t.nodeName || "P" === t.nodeName || ["block", "flex", "grid", "list-item", "table", "table-caption"].includes(getComputedStyle(t).display)) && (r += " ") : r += t.textContent || ""
                        }
                        return r.replace(/\s+/g, " ").trim()
                    }(t, e, i);
                    if ("innerText" in t) {
                        let s = t.innerText;
                        const r = e => {
                            const i = t.querySelectorAll(e);
                            for (let t = 0; t < i.length; t += 1) {
                                const e = i[t];
                                if ("innerText" in e) {
                                    const t = e.innerText;
                                    t && t.trim().length > 0 && (s = s.replace(t, ""))
                                }
                            }
                        };
                        return r(`[${ue}]`), e && r(`[${e}]`), i && r(`${ce(Yt.HIDDEN)}, ${ce(Yt.MASK)}`), s
                    }
                    return t.textContent
                }
            }
            const Se = [ue, "data-testid", "data-test", "data-qa", "data-cy", "data-test-id", "data-qa-id", "data-testing", "data-component", "data-element", "data-source-file"],
                we = [Le, function(t) {
                    if (t.id && !_e(t.id)) return `#${CSS.escape(t.id)}`
                }],
                ke = [Le, function(t) {
                    if ("BODY" === t.tagName) return;
                    const e = t.classList;
                    for (let i = 0; i < e.length; i += 1) {
                        const s = e[i];
                        if (!_e(s)) return `${CSS.escape(t.tagName)}.${CSS.escape(s)}`
                    }
                }, function(t) {
                    return CSS.escape(t.tagName)
                }];

            function Ae(t, e) {
                if (!t.isConnected) return;
                let i, s = t;
                for (; s && "HTML" !== s.nodeName;) {
                    const t = Ie(s, we, Ce, e, i);
                    if (t) return t;
                    i = Ie(s, ke, De, e, i) || xe(Re(s), i), s = s.parentElement
                }
                return i
            }

            function _e(t) {
                return /[0-9]/.test(t)
            }

            function Le(t, e) {
                if (e) {
                    const t = i(e);
                    if (t) return t
                }
                for (const t of Se) {
                    const e = i(t);
                    if (e) return e
                }

                function i(e) {
                    if (t.hasAttribute(e)) return `${CSS.escape(t.tagName)}[${e}="${CSS.escape(t.getAttribute(e))}"]`
                }
            }

            function Re(t) {
                let e = t.parentElement.firstElementChild,
                    i = 1;
                for (; e && e !== t;) e.tagName === t.tagName && (i += 1), e = e.nextElementSibling;
                return `${CSS.escape(t.tagName)}:nth-of-type(${i})`
            }

            function Ie(t, e, i, s, r) {
                for (const n of e) {
                    const e = n(t, s);
                    if (e && i(t, e, r)) return xe(e, r)
                }
            }

            function Ce(t, e, i) {
                return 1 === t.ownerDocument.querySelectorAll(xe(e, i)).length
            }

            function De(t, e, i) {
                let s;
                if (void 0 === i) s = t => t.matches(e);
                else {
                    const t = xe(`${e}:scope`, i);
                    s = e => null !== e.querySelector(t)
                }
                let r = t.parentElement.firstElementChild;
                for (; r;) {
                    if (r !== t && s(r)) return !1;
                    r = r.nextElementSibling
                }
                return !0
            }

            function xe(t, e) {
                return e ? `${t}>${e}` : t
            }
            var Pe = i(6508),
                Oe = i(8124);
            const Me = 3;
            const Ne = 'input:not([type="checkbox"]):not([type="radio"]):not([type="button"]):not([type="submit"]):not([type="reset"]):not([type="range"]),textarea,select,[contenteditable],[contenteditable] *,canvas,a[href],a[href] *';

            function Fe(t) {
                if (t.hasPageActivity || t.getUserActivity().input || t.getUserActivity().scroll) return !1;
                let e = t.event.target;
                return "LABEL" === e.tagName && e.hasAttribute("for") && (e = document.getElementById(e.getAttribute("for"))), !e || !e.matches(Ne)
            }
            const $e = 10 * h.WT,
                Ue = new Map;

            function Be(t, e) {
                Ue.set(t, e), Ue.forEach(((t, e) => {
                    (0, h._J)(e, (0, h._q)()) > $e && Ue.delete(e)
                }))
            }
            const je = 5 * h.yR;

            function Ge(t, e, i, s) {
                const r = (0, xt.p)({
                        expireDelay: je
                    }),
                    n = new Pt.y$;
                let a;
                t.subscribe(10, (() => {
                    r.reset()
                })), t.subscribe(5, c), t.subscribe(11, (t => {
                    t.reason === tt.k$.UNLOADING && c()
                }));
                const {
                    stop: o
                } = (0, Oe.u)(s, {
                    onPointerDown: r => function(t, e, i, s, r) {
                        const n = t.enablePrivacyForActionName ? ie(s.target, t.defaultPrivacyLevel) : Yt.ALLOW;
                        if (n === Yt.HIDDEN) return;
                        const a = function(t, e, i) {
                            const s = t.target.getBoundingClientRect(),
                                r = Ae(t.target, i.actionNameAttribute);
                            r && Be(t.timeStamp, r);
                            const n = function(t, {
                                enablePrivacyForActionName: e,
                                actionNameAttribute: i
                            }, s = Yt.ALLOW) {
                                const r = he(t, ue) || i && he(t, i);
                                return r ? {
                                    name: r,
                                    nameSource: "custom_attribute"
                                } : s === Yt.MASK ? {
                                    name: de,
                                    nameSource: "mask_placeholder"
                                } : me(t, i, fe, e) || me(t, i, pe, e) || {
                                    name: "",
                                    nameSource: "blank"
                                }
                            }(t.target, i, e);
                            return {
                                type: b.CLICK,
                                target: {
                                    width: Math.round(s.width),
                                    height: Math.round(s.height),
                                    selector: r
                                },
                                position: {
                                    x: Math.round(t.clientX - s.left),
                                    y: Math.round(t.clientY - s.top)
                                },
                                name: n.name,
                                nameSource: n.nameSource
                            }
                        }(s, n, t);
                        let o = !1;
                        return zt(e, i, r, t, (t => {
                            o = t.hadActivity
                        }), Vt), {
                            clickActionBase: a,
                            hadActivityOnPointerDown: () => o
                        }
                    }(s, t, e, r, i),
                    onPointerUp: ({
                        clickActionBase: a,
                        hadActivityOnPointerDown: o
                    }, c, u) => {
                        ! function(t, e, i, s, r, n, a, o, l, c, u) {
                            var d;
                            const h = Ve(e, r, c, o, l);
                            a(h);
                            const f = null === (d = null == o ? void 0 : o.target) || void 0 === d ? void 0 : d.selector;
                            f && Be(l.timeStamp, f);
                            const {
                                stop: p
                            } = zt(e, i, s, t, (t => {
                                t.hadActivity && t.end < h.startClocks.timeStamp ? h.discard() : t.hadActivity ? h.stop(t.end) : u() ? h.stop(h.startClocks.timeStamp) : h.stop()
                            }), $e), g = e.subscribe(5, (({
                                endClocks: t
                            }) => {
                                h.stop(t.timeStamp)
                            })), m = n.subscribe((() => {
                                h.stop()
                            }));
                            h.stopObservable.subscribe((() => {
                                g.unsubscribe(), p(), m.unsubscribe()
                            }))
                        }(s, t, e, i, r, n, l, a, c, u, o)
                    }
                });
                return {
                    stop: () => {
                        c(), n.notify(), o()
                    },
                    actionContexts: {
                        findActionId: t => r.findAll(t)
                    }
                };

                function l(t) {
                    if (!a || !a.tryAppend(t)) {
                        const e = t.clone();
                        a = (0, Pe.bl)(t, (t => {
                            ! function(t, e) {
                                const {
                                    isRage: i
                                } = function(t, e) {
                                    if (function(t) {
                                            if (t.some((t => t.getUserActivity().selection || t.getUserActivity().scroll))) return !1;
                                            for (let e = 0; e < t.length - (Me - 1); e += 1)
                                                if (t[e + Me - 1].event.timeStamp - t[e].event.timeStamp <= h.WT) return !0;
                                            return !1
                                        }(t)) return e.addFrustration(T.RAGE_CLICK), t.some(Fe) && e.addFrustration(T.DEAD_CLICK), e.hasError && e.addFrustration(T.ERROR_CLICK), {
                                        isRage: !0
                                    };
                                    const i = t.some((t => t.getUserActivity().selection));
                                    return t.forEach((t => {
                                        t.hasError && t.addFrustration(T.ERROR_CLICK), Fe(t) && !i && t.addFrustration(T.DEAD_CLICK)
                                    })), {
                                        isRage: !1
                                    }
                                }(t, e);
                                i ? (t.forEach((t => t.discard())), e.stop((0, h.n$)()), e.validate(t.map((t => t.event)))) : (e.discard(), t.forEach((t => t.validate())))
                            }(t, e)
                        }))
                    }
                }

                function c() {
                    a && a.stop()
                }
            }

            function Ve(t, e, i, s, r) {
                const n = (0, S.DO)(),
                    a = (0, h.$I)(),
                    o = e.add(n, a.relative),
                    l = Ot({
                        lifeCycle: t,
                        isChildEvent: t => void 0 !== t.action && (Array.isArray(t.action.id) ? t.action.id.includes(n) : t.action.id === n)
                    });
                let c, u = 0;
                const d = [],
                    f = new Pt.y$;

                function p(t) {
                    0 === u && (c = t, u = 1, c ? o.close((0, h.ni)(c)) : o.remove(), l.stop(), f.notify())
                }
                return {
                    event: r,
                    stop: p,
                    stopObservable: f,
                    get hasError() {
                        return l.eventCounts.errorCount > 0
                    },
                    get hasPageActivity() {
                        return void 0 !== c
                    },
                    getUserActivity: i,
                    addFrustration: t => {
                        d.push(t)
                    },
                    startClocks: a,
                    isStopped: () => 1 === u || 2 === u,
                    clone: () => Ve(t, e, i, s, r),
                    validate: e => {
                        if (p(), 1 !== u) return;
                        const {
                            resourceCount: i,
                            errorCount: o,
                            longTaskCount: f
                        } = l.eventCounts, g = {
                            duration: c && (0, h._J)(a.timeStamp, c),
                            startClocks: a,
                            id: n,
                            frustrationTypes: d,
                            counts: {
                                resourceCount: i,
                                errorCount: o,
                                longTaskCount: f
                            },
                            events: null != e ? e : [r],
                            event: r,
                            ...s
                        };
                        t.notify(0, g), u = 2
                    },
                    discard: () => {
                        p(), u = 2
                    }
                }
            }

            function He(t) {
                const e = Ke(t) ? {
                        action: {
                            id: t.id,
                            loading_time: (0, Dt.J)((0, h.c0)(t.duration)),
                            frustration: {
                                type: t.frustrationTypes
                            },
                            error: {
                                count: t.counts.errorCount
                            },
                            long_task: {
                                count: t.counts.longTaskCount
                            },
                            resource: {
                                count: t.counts.resourceCount
                            }
                        },
                        _dd: {
                            action: {
                                target: t.target,
                                position: t.position,
                                name_source: t.nameSource
                            }
                        }
                    } : {
                        context: t.context
                    },
                    i = (0, c.$e)({
                        action: {
                            id: (0, S.DO)(),
                            target: {
                                name: t.name
                            },
                            type: t.type
                        },
                        date: t.startClocks.timeStamp,
                        type: m.ACTION
                    }, e),
                    s = Ke(t) ? t.duration : void 0,
                    r = Ke(t) ? {
                        events: t.events
                    } : {
                        handlingStack: t.handlingStack
                    };
                return {
                    rawRumEvent: i,
                    duration: s,
                    startTime: t.startClocks.relative,
                    domainContext: r
                }
            }

            function Ke(t) {
                return t.type !== b.CUSTOM
            }
            var ze = i(5242),
                qe = i(2419),
                We = i(8455),
                Ye = i(1939);
            var Xe = i(49);
            const Qe = new WeakSet;

            function Je(t) {
                return (0, h.WK)(t.startTime, t.duration)
            }
            var Ze = i(193);
            const ti = 2 * h.yR;

            function ei(t) {
                const e = function(t) {
                    const e = t.querySelector("meta[name=dd-trace-id]"),
                        i = t.querySelector("meta[name=dd-trace-time]");
                    return ii(e && e.content, i && i.content)
                }(t) || function(t) {
                    const e = function(t) {
                        for (let e = 0; e < t.childNodes.length; e += 1) {
                            const i = si(t.childNodes[e]);
                            if (i) return i
                        }
                        if (t.body)
                            for (let e = t.body.childNodes.length - 1; e >= 0; e -= 1) {
                                const i = t.body.childNodes[e],
                                    s = si(i);
                                if (s) return s;
                                if (!(0, Gt.BM)(i)) break
                            }
                    }(t);
                    if (e) return ii((0, S.MY)(e, "trace-id"), (0, S.MY)(e, "trace-time"))
                }(t);
                if (e && !(e.traceTime <= (0, h.m6)() - ti)) return e.traceId
            }

            function ii(t, e) {
                const i = e && Number(e);
                if (t && i) return {
                    traceId: t,
                    traceTime: i
                }
            }

            function si(t) {
                if (t && (0, Gt.dI)(t)) {
                    const e = /^\s*DATADOG;(.*?)\s*$/.exec(t.data);
                    if (e) return e[1]
                }
            }

            function ri() {
                if (jt(Mt.NAVIGATION)) {
                    const t = performance.getEntriesByType(Mt.NAVIGATION)[0];
                    if (t) return t
                }
                const t = function() {
                        const t = {},
                            e = performance.timing;
                        for (const i in e)
                            if ((0, F.hj)(e[i])) {
                                const s = i,
                                    r = e[s];
                                t[s] = 0 === r ? 0 : (0, h.ni)(r)
                            }
                        return t
                    }(),
                    e = {
                        entryType: Mt.NAVIGATION,
                        initiatorType: "navigation",
                        name: window.location.href,
                        startTime: 0,
                        duration: t.loadEventEnd,
                        decodedBodySize: 0,
                        encodedBodySize: 0,
                        transferSize: 0,
                        workerStart: 0,
                        toJSON: () => ({ ...e,
                            toJSON: void 0
                        }),
                        ...t
                    };
                return e
            }

            function ni(t, e, i = ri) {
                (0, Ze.T)(t, "interactive", (() => {
                    const t = i(),
                        s = Object.assign(t.toJSON(), {
                            entryType: Mt.RESOURCE,
                            initiatorType: ht,
                            duration: t.responseEnd,
                            traceId: ei(document),
                            toJSON: () => ({ ...s,
                                toJSON: void 0
                            })
                        });
                    e(s)
                }))
            }
            var ai = i(7655);

            function oi(t, e, i, s = (0, Xe.y)(), r = ni) {
                let n;
                const a = (0, O.W_)(O.uh.EARLY_REQUEST_COLLECTION);
                a ? n = (0, ai.t)(t) : t.subscribe(8, (t => {
                    l((() => function(t, e, i) {
                        const s = function(t) {
                            if (!performance || !("getEntriesByName" in performance)) return;
                            const e = performance.getEntriesByName(t.url, "resource");
                            if (!e.length || !("toJSON" in e[0])) return;
                            const i = e.filter((t => !Qe.has(t))).filter((t => vt(t) && bt(t))).filter((e => {
                                return i = e, s = t.startClocks.relative, r = Je({
                                    startTime: t.startClocks.relative,
                                    duration: t.duration
                                }), i.startTime >= s - 1 && Je(i) <= (0, h.WK)(r, 1);
                                var i, s, r
                            }));
                            return 1 === i.length ? (Qe.add(i[0]), i[0].toJSON()) : void 0
                        }(t);
                        return ci(s, t, i, e)
                    }(t, e, i)))
                }));
                const o = Ut(e, {
                    type: Mt.RESOURCE,
                    buffered: !0
                }).subscribe((t => {
                    for (const s of t) !a && mt(s) || l((() => li(s, e, i, n)))
                }));

                function l(e) {
                    s.push((() => {
                        const i = e();
                        i && t.notify(12, i)
                    }))
                }
                return r(e, (t => {
                    l((() => li(t, e, i, n)))
                })), {
                    stop: () => {
                        o.unsubscribe()
                    }
                }
            }

            function li(t, e, i, s) {
                return ci(t, mt(t) && s ? s.getMatchingRequest(t) : void 0, i, e)
            }

            function ci(t, e, i, s) {
                if (!t && !e) return;
                const r = e ? function(t, e) {
                    if (t.traceSampled && t.traceId && t.spanId) return {
                        _dd: {
                            span_id: t.spanId.toString(),
                            trace_id: t.traceId.toString(),
                            rule_psr: e.rulePsr
                        }
                    }
                }(e, s) : function(t, e) {
                    if (t.traceId) return {
                        _dd: {
                            trace_id: t.traceId,
                            span_id: (0, H.Nu)().toString(),
                            rule_psr: e.rulePsr
                        }
                    }
                }(t, s);
                if (!s.trackResources && !r) return;
                const n = t ? (0, h.DY)(t.startTime) : e.startClocks,
                    a = t ? function(t) {
                        const {
                            duration: e,
                            startTime: i,
                            responseEnd: s
                        } = t;
                        return 0 === e && i < s ? (0, h._J)(i, s) : e
                    }(t) : function(t, e, i) {
                        return t.wasInPageStateDuringPeriod("frozen", e.relative, i) ? void 0 : i
                    }(i, n, e.duration),
                    o = (0, c.$e)({
                        date: n.timeStamp,
                        resource: {
                            id: (0, S.DO)(),
                            duration: (0, h.c0)(a),
                            type: e ? e.type === ot.x.XHR ? ot._.XHR : ot._.FETCH : pt(t),
                            method: e ? e.method : void 0,
                            status_code: e ? e.status : (l = t.responseStatus, 0 === l ? void 0 : l),
                            url: e ? Lt(e.url) : t.name,
                            protocol: t && Et(t),
                            delivery_type: t && St(t)
                        },
                        type: m.RESOURCE,
                        _dd: {
                            discarded: !s.trackResources
                        }
                    }, r, t && function(t) {
                        const {
                            renderBlockingStatus: e
                        } = t;
                        return {
                            resource: {
                                render_blocking_status: e,
                                ...wt(t),
                                ...yt(t)
                            }
                        }
                    }(t));
                var l;
                return {
                    startTime: n.relative,
                    duration: a,
                    rawRumEvent: o,
                    domainContext: ui(t, e)
                }
            }

            function ui(t, e) {
                if (e) {
                    const i = {
                        performanceEntry: t,
                        isAborted: e.isAborted,
                        handlingStack: e.handlingStack
                    };
                    return e.type === ot.x.XHR ? {
                        xhr: e.xhr,
                        ...i
                    } : {
                        requestInput: e.input,
                        requestInit: e.init,
                        response: e.response,
                        error: e.error,
                        ...i
                    }
                }
                return {
                    performanceEntry: t
                }
            }
            var di = i(6826),
                hi = i(6129);
            const fi = 10 * h.yR;
            const pi = 10 * h.yR;

            function gi(t, e, i = window) {
                if ("hidden" === document.visibilityState) return {
                    timeStamp: 0,
                    stop: x.Z
                };
                if (jt(Mt.VISIBILITY_STATE)) {
                    const t = performance.getEntriesByType(Mt.VISIBILITY_STATE).filter((t => "hidden" === t.name)).find((t => t.startTime >= e.relative));
                    if (t) return {
                        timeStamp: t.startTime,
                        stop: x.Z
                    }
                }
                let s = 1 / 0;
                const {
                    stop: r
                } = (0, Ft.y)(t, i, ["pagehide", "visibilitychange"], (t => {
                    "pagehide" !== t.type && "hidden" !== document.visibilityState || (s = t.timeStamp, r())
                }), {
                    capture: !0
                });
                return {
                    get timeStamp() {
                        return s
                    },
                    stop: r
                }
            }

            function mi(t, e, i, s) {
                const r = {},
                    {
                        stop: n
                    } = function(t, e, i = ri) {
                        return function(t, e) {
                            let i;
                            const {
                                stop: s
                            } = (0, Ze.T)(t, "complete", (() => {
                                i = (0, Nt.iK)((() => e()))
                            }));
                            return {
                                stop: () => {
                                    s(), (0, Nt.gr)(i)
                                }
                            }
                        }(t, (() => {
                            const t = i();
                            (function(t) {
                                return t.loadEventEnd <= 0
                            })(t) || e(function(t) {
                                return {
                                    domComplete: t.domComplete,
                                    domContentLoaded: t.domContentLoadedEventEnd,
                                    domInteractive: t.domInteractive,
                                    loadEvent: t.loadEventEnd,
                                    firstByte: t.responseStart >= 0 && t.responseStart <= (0, h._q)() ? t.responseStart : void 0
                                }
                            }(t))
                        }))
                    }(t, (t => {
                        i(t.loadEvent), r.navigationTimings = t, s()
                    })),
                    a = gi(t, e),
                    {
                        stop: o
                    } = function(t, e, i) {
                        return {
                            stop: Ut(t, {
                                type: Mt.PAINT,
                                buffered: !0
                            }).subscribe((t => {
                                const i = t.find((t => "first-contentful-paint" === t.name && t.startTime < e.timeStamp && t.startTime < fi));
                                var n;
                                i && (n = i.startTime, r.firstContentfulPaint = n, s())
                            })).unsubscribe
                        }
                    }(t, a),
                    {
                        stop: l
                    } = function(t, e, i, n) {
                        let a = 1 / 0;
                        const {
                            stop: o
                        } = (0, Ft.y)(t, i, ["pointerdown", "keydown"], (t => {
                            a = t.timeStamp
                        }), {
                            capture: !0,
                            once: !0
                        });
                        let l = 0;
                        const c = Ut(t, {
                            type: Mt.LARGEST_CONTENTFUL_PAINT,
                            buffered: !0
                        }).subscribe((i => {
                            const n = (0, j.dF)(i, (t => t.entryType === Mt.LARGEST_CONTENTFUL_PAINT && t.startTime < a && t.startTime < e.timeStamp && t.startTime < pi && t.size > l));
                            if (n) {
                                let e;
                                n.element && (e = Ae(n.element, t.actionNameAttribute)), o = {
                                    value: n.startTime,
                                    targetSelector: e,
                                    resourceUrl: (c = n, "" === c.url ? void 0 : c.url)
                                }, r.largestContentfulPaint = o, s(), l = n.size
                            }
                            var o, c
                        }));
                        return {
                            stop: () => {
                                o(), c.unsubscribe()
                            }
                        }
                    }(t, a, window),
                    {
                        stop: c
                    } = function(t, e, i) {
                        const n = Ut(t, {
                            type: Mt.FIRST_INPUT,
                            buffered: !0
                        }).subscribe((i => {
                            const n = i.find((t => t.startTime < e.timeStamp));
                            if (n) {
                                const e = (0, h._J)(n.startTime, n.processingStart);
                                let i;
                                n.target && (0, Gt.Tv)(n.target) && (i = Ae(n.target, t.actionNameAttribute)), a = {
                                    delay: e >= 0 ? e : 0,
                                    time: n.startTime,
                                    targetSelector: i
                                }, r.firstInput = a, s()
                            }
                            var a
                        }));
                        return {
                            stop: () => {
                                n.unsubscribe()
                            }
                        }
                    }(t, a);
                return {
                    stop: function() {
                        n(), o(), l(), c(), a.stop()
                    },
                    initialViewMetrics: r
                }
            }
            var yi = i(5533);

            function vi(t) {
                let e;
                for (const i of t)
                    if (i.node && (0, Gt.Tv)(i.node)) {
                        const t = (0, yi.S)(i);
                        (!e || (0, yi.S)(e) < t) && (e = i)
                    }
                return e
            }

            function bi({
                x: t,
                y: e,
                width: i,
                height: s
            }) {
                return {
                    x: t,
                    y: e,
                    width: i,
                    height: s
                }
            }
            const Ti = 5 * h.WT,
                Ei = h.WT;
            let Si, wi = 0,
                ki = 1 / 0,
                Ai = 0;
            const _i = () => Si ? wi : window.performance.interactionCount || 0,
                Li = 10,
                Ri = 1 * h.yR;
            var Ii = i(1358);

            function Ci(t, e, i, s, r, n, o) {
                const l = {},
                    {
                        stop: c,
                        setLoadEvent: u
                    } = function(t, e, i, s, n, a, o) {
                        let c = n === v.INITIAL_LOAD,
                            u = !0;
                        const d = [],
                            f = gi(s, a);

                        function p() {
                            if (!u && !c && d.length > 0) {
                                const e = Math.max(...d);
                                e < f.timeStamp - a.relative && (t = e, l.loadingTime = t, r())
                            }
                            var t
                        }
                        const {
                            stop: g
                        } = zt(t, e, i, s, (t => {
                            u && (u = !1, t.hadActivity && d.push((0, h._J)(a.timeStamp, t.end)), p())
                        }));
                        return {
                            stop: () => {
                                g(), f.stop()
                            },
                            setLoadEvent: t => {
                                c && (c = !1, d.push(t), p())
                            }
                        }
                    }(t, e, i, s, n, o),
                    {
                        stop: d
                    } = (0, Ii._X)(s, o, (t => {
                        l.scroll = t
                    })),
                    {
                        stop: f
                    } = function(t, e, i) {
                        if (!jt(Mt.LAYOUT_SHIFT) || !("WeakRef" in window)) return {
                            stop: x.Z
                        };
                        let s, r = 0;
                        i({
                            value: 0
                        });
                        const n = function() {
                                let t, e, i = 0,
                                    s = 0;
                                return {
                                    update: r => {
                                        let n;
                                        return void 0 === t || r.startTime - e >= Ei || r.startTime - t >= Ti ? (t = e = r.startTime, s = i = r.value, n = !0) : (i += r.value, e = r.startTime, n = r.value > s, n && (s = r.value)), {
                                            cumulatedValue: i,
                                            isMaxValue: n
                                        }
                                    }
                                }
                            }(),
                            a = Ut(t, {
                                type: Mt.LAYOUT_SHIFT,
                                buffered: !0
                            }).subscribe((a => {
                                var o;
                                for (const l of a) {
                                    if (l.hadRecentInput || l.startTime < e) continue;
                                    const {
                                        cumulatedValue: a,
                                        isMaxValue: c
                                    } = n.update(l);
                                    if (c) {
                                        const t = vi(l.sources);
                                        s = {
                                            target: (null == t ? void 0 : t.node) ? new WeakRef(t.node) : void 0,
                                            time: (0, h._J)(e, l.startTime),
                                            previousRect: null == t ? void 0 : t.previousRect,
                                            currentRect: null == t ? void 0 : t.currentRect,
                                            devicePixelRatio: window.devicePixelRatio
                                        }
                                    }
                                    if (a > r) {
                                        r = a;
                                        const e = null === (o = null == s ? void 0 : s.target) || void 0 === o ? void 0 : o.deref();
                                        i({
                                            value: (0, F.NM)(r, 4),
                                            targetSelector: e && Ae(e, t.actionNameAttribute),
                                            time: null == s ? void 0 : s.time,
                                            previousRect: (null == s ? void 0 : s.previousRect) ? bi(s.previousRect) : void 0,
                                            currentRect: (null == s ? void 0 : s.currentRect) ? bi(s.currentRect) : void 0,
                                            devicePixelRatio: null == s ? void 0 : s.devicePixelRatio
                                        })
                                    }
                                }
                            }));
                        return {
                            stop: () => {
                                a.unsubscribe()
                            }
                        }
                    }(s, o.relative, (t => {
                        l.cumulativeLayoutShift = t, r()
                    })),
                    {
                        stop: p,
                        getInteractionToNextPaint: g,
                        setViewEnd: m
                    } = function(t, e, i) {
                        if (!(jt(Mt.EVENT) && window.PerformanceEventTiming && "interactionId" in PerformanceEventTiming.prototype)) return {
                            getInteractionToNextPaint: () => {},
                            setViewEnd: x.Z,
                            stop: x.Z
                        };
                        const {
                            getViewInteractionCount: s,
                            stopViewInteractionCount: r
                        } = function(t) {
                            "interactionCount" in performance || Si || (Si = new window.PerformanceObserver((0, a.zk)((t => {
                                t.getEntries().forEach((t => {
                                    const e = t;
                                    e.interactionId && (ki = Math.min(ki, e.interactionId), Ai = Math.max(Ai, e.interactionId), wi = (Ai - ki) / 7 + 1)
                                }))
                            }))), Si.observe({
                                type: "event",
                                buffered: !0,
                                durationThreshold: 0
                            }));
                            const e = t === v.INITIAL_LOAD ? 0 : _i();
                            let i = {
                                stopped: !1
                            };

                            function s() {
                                return _i() - e
                            }
                            return {
                                getViewInteractionCount: () => i.stopped ? i.interactionCount : s(),
                                stopViewInteractionCount: () => {
                                    i = {
                                        stopped: !0,
                                        interactionCount: s()
                                    }
                                }
                            }
                        }(i);
                        let n = 1 / 0;
                        const o = function(t) {
                            const e = [];

                            function i() {
                                e.sort(((t, e) => e.duration - t.duration)).splice(Li)
                            }
                            return {
                                process(t) {
                                    const s = e.findIndex((e => t.interactionId === e.interactionId)),
                                        r = e[e.length - 1]; - 1 !== s ? t.duration > e[s].duration && (e[s] = t, i()) : (e.length < Li || t.duration > r.duration) && (e.push(t), i())
                                },
                                estimateP98Interaction() {
                                    const i = Math.min(e.length - 1, Math.floor(t() / 50));
                                    return e[i]
                                }
                            }
                        }(s);
                        let l, c, u = -1;

                        function d(i) {
                            for (const t of i) t.interactionId && t.startTime >= e && t.startTime <= n && o.process(t);
                            const s = o.estimateP98Interaction();
                            s && s.duration !== u && (u = s.duration, c = (0, h._J)(e, s.startTime), l = function(t) {
                                const e = Ue.get(t);
                                return Ue.delete(t), e
                            }(s.startTime), !l && s.target && (0, Gt.Tv)(s.target) && (l = Ae(s.target, t.actionNameAttribute)))
                        }
                        const f = Ut(t, {
                                type: Mt.FIRST_INPUT,
                                buffered: !0
                            }).subscribe(d),
                            p = Ut(t, {
                                type: Mt.EVENT,
                                durationThreshold: 40,
                                buffered: !0
                            }).subscribe(d);
                        return {
                            getInteractionToNextPaint: () => u >= 0 ? {
                                value: Math.min(u, Ri),
                                targetSelector: l,
                                time: c
                            } : s() ? {
                                value: 0
                            } : void 0,
                            setViewEnd: t => {
                                n = t, r()
                            },
                            stop: () => {
                                p.unsubscribe(), f.unsubscribe()
                            }
                        }
                    }(s, o.relative, n);
                return {
                    stop: () => {
                        c(), f(), d()
                    },
                    stopINPTracking: p,
                    setLoadEvent: u,
                    setViewEnd: m,
                    getCommonViewMetrics: () => (l.interactionToNextPaint = g(), l)
                }
            }
            var Di = i(9725);
            const xi = 3e3,
                Pi = 5 * h.yR,
                Oi = 5 * h.yR;

            function Mi(t, e, i, s, r, n, a, o) {
                const l = new Set;
                let c, u, d = f(v.INITIAL_LOAD, (0, h.cQ)(), o);

                function f(n, a, o) {
                    const c = function(t, e, i, s, r, n, a = (0, h.$I)(), o) {
                        const l = (0, S.DO)(),
                            c = new Pt.y$,
                            u = {};
                        let d, f = 0;
                        const p = (0, $.mv)(r),
                            g = (0, hi.W)();
                        let m = !0,
                            y = null == o ? void 0 : o.name;
                        const b = (null == o ? void 0 : o.service) || s.service,
                            T = (null == o ? void 0 : o.version) || s.version,
                            E = null == o ? void 0 : o.context;
                        E && g.setContext(E);
                        const w = {
                            id: l,
                            name: y,
                            startClocks: a,
                            service: b,
                            version: T,
                            context: E
                        };
                        t.notify(1, w), t.notify(2, w);
                        const {
                            throttled: k,
                            cancel: A
                        } = (0, x.P)(G, xi, {
                            leading: !1
                        }), {
                            setLoadEvent: _,
                            setViewEnd: L,
                            stop: R,
                            stopINPTracking: I,
                            getCommonViewMetrics: C
                        } = Ci(t, e, i, s, j, n, a), {
                            stop: P,
                            initialViewMetrics: O
                        } = n === v.INITIAL_LOAD ? mi(s, a, _, j) : {
                            stop: x.Z,
                            initialViewMetrics: {}
                        };
                        n === v.BF_CACHE && function(t, e, i) {
                            var s, r;
                            s = t.relative, r = t => {
                                e.firstContentfulPaint = t, e.largestContentfulPaint = {
                                    value: t
                                }, i()
                            }, requestAnimationFrame((() => {
                                requestAnimationFrame((() => {
                                    r((0, h._J)(s, (0, h._q)()))
                                }))
                            }))
                        }(a, O, j);
                        const {
                            stop: M,
                            eventCounts: N
                        } = function(t, e, i) {
                            const {
                                stop: s,
                                eventCounts: r
                            } = Ot({
                                lifeCycle: t,
                                isChildEvent: t => t.view.id === e,
                                onChange: i
                            });
                            return {
                                stop: s,
                                eventCounts: r
                            }
                        }(t, l, j), F = (0, Nt.Zi)(G, Pi), U = t.subscribe(11, (t => {
                            t.reason === tt.k$.UNLOADING && G()
                        }));

                        function B() {
                            t.notify(3, {
                                id: l,
                                name: y,
                                context: g.getContext(),
                                startClocks: a,
                                sessionIsActive: m
                            })
                        }

                        function j() {
                            B(), k()
                        }

                        function G() {
                            A(), B(), f += 1;
                            const e = void 0 === d ? (0, h.n$)() : d.timeStamp;
                            t.notify(4, {
                                customTimings: u,
                                documentVersion: f,
                                id: l,
                                name: y,
                                service: b,
                                version: T,
                                context: g.getContext(),
                                loadingType: n,
                                location: p,
                                startClocks: a,
                                commonViewMetrics: C(),
                                initialViewMetrics: O,
                                duration: (0, h._J)(a.timeStamp, e),
                                isActive: void 0 === d,
                                sessionIsActive: m,
                                eventCounts: N
                            })
                        }
                        return G(), g.changeObservable.subscribe(j), {
                            get name() {
                                return y
                            },
                            service: b,
                            version: T,
                            contextManager: g,
                            stopObservable: c,
                            end(e = {}) {
                                var i, s;
                                d || (d = null !== (i = e.endClocks) && void 0 !== i ? i : (0, h.$I)(), m = null === (s = e.sessionIsActive) || void 0 === s || s, t.notify(5, {
                                    endClocks: d
                                }), t.notify(6, {
                                    endClocks: d
                                }), (0, Nt.cv)(F), L(d.relative), R(), U.unsubscribe(), G(), (0, Nt.iK)((() => {
                                    this.stop()
                                }), Oi))
                            },
                            stop() {
                                P(), M(), I(), c.notify()
                            },
                            addTiming(t, e) {
                                if (d) return;
                                const i = (0, h.Cn)(e) ? e : (0, h._J)(a.timeStamp, e);
                                u[function(t) {
                                    const e = t.replace(/[^a-zA-Z0-9-_.@$]/g, "_");
                                    return e !== t && D.jf.warn(`Invalid timing name: ${t}, sanitized to: ${e}`), e
                                }(t)] = i, j()
                            },
                            setViewName(t) {
                                y = t, G()
                            }
                        }
                    }(e, i, s, r, t, n, a, o);
                    return l.add(c), c.stopObservable.subscribe((() => {
                        l.delete(c)
                    })), c
                }
                return e.subscribe(10, (() => {
                    d = f(v.ROUTE_CHANGE, void 0, {
                        name: d.name,
                        service: d.service,
                        version: d.version,
                        context: d.contextManager.getContext()
                    })
                })), e.subscribe(9, (() => {
                    d.end({
                        sessionIsActive: !1
                    })
                })), a && (u = function(t) {
                    return t.subscribe((({
                        oldLocation: t,
                        newLocation: e
                    }) => {
                        var i, s;
                        s = e, ((i = t).pathname !== s.pathname || ! function(t) {
                            const e = t.substring(1);
                            return "" !== e && !!document.getElementById(e)
                        }(s.hash) && Ni(s.hash) !== Ni(i.hash)) && (d.end(), d = f(v.ROUTE_CHANGE))
                    }))
                }(n), r.trackBfcacheViews && (c = (0, Di.T)(r, (t => {
                    d.end();
                    const e = (0, h.DY)(t.timeStamp);
                    d = f(v.BF_CACHE, e, void 0)
                })))), {
                    addTiming: (t, e = (0, h.n$)()) => {
                        d.addTiming(t, e)
                    },
                    startView: (t, e) => {
                        d.end({
                            endClocks: e
                        }), d = f(v.ROUTE_CHANGE, e, t)
                    },
                    setViewContext: t => {
                        d.contextManager.setContext(t)
                    },
                    setViewContextProperty: (t, e) => {
                        d.contextManager.setContextProperty(t, e)
                    },
                    setViewName: t => {
                        d.setViewName(t)
                    },
                    getViewContext: () => d.contextManager.getContext(),
                    stop: () => {
                        u && u.unsubscribe(), c && c(), d.end(), l.forEach((t => t.stop()))
                    }
                }
            }

            function Ni(t) {
                const e = t.indexOf("?");
                return e < 0 ? t : t.slice(0, e)
            }

            function Fi({
                cumulativeLayoutShift: t,
                interactionToNextPaint: e
            }, {
                firstContentfulPaint: i,
                firstInput: s,
                largestContentfulPaint: r
            }) {
                return {
                    cls: t && {
                        score: t.value,
                        timestamp: (0, h.c0)(t.time),
                        target_selector: t.targetSelector,
                        previous_rect: t.previousRect,
                        current_rect: t.currentRect
                    },
                    fcp: i && {
                        timestamp: (0, h.c0)(i)
                    },
                    fid: s && {
                        duration: (0, h.c0)(s.delay),
                        timestamp: (0, h.c0)(s.time),
                        target_selector: s.targetSelector
                    },
                    inp: e && {
                        duration: (0, h.c0)(e.value),
                        timestamp: (0, h.c0)(e.time),
                        target_selector: e.targetSelector
                    },
                    lcp: r && {
                        timestamp: (0, h.c0)(r.value),
                        target_selector: r.targetSelector,
                        resource_url: r.resourceUrl
                    }
                }
            }
            var $i = i(4717),
                Ui = i(3789),
                Bi = i(2097),
                ji = i(5419),
                Gi = i(8387),
                Vi = i(6593),
                Hi = i(3766),
                Ki = i(8981);
            const zi = Ki.TN,
                qi = 10 * h.WT;
            let Wi, Yi;

            function Xi() {
                0 !== Wi.batchCount && ((0, o.qZ)("Customer data measures", Wi), Ji())
            }

            function Qi(t, e) {
                t.sum += e, t.min = Math.min(t.min, e), t.max = Math.max(t.max, e)
            }

            function Ji() {
                Wi = {
                    batchCount: 0,
                    batchBytesCount: {
                        min: 1 / 0,
                        max: 0,
                        sum: 0
                    },
                    batchMessagesCount: {
                        min: 1 / 0,
                        max: 0,
                        sum: 0
                    }
                }
            }
            const Zi = 4e3,
                ts = 500,
                es = Ki.TN;

            function is(t, e, i) {
                if (0 !== t.length) return t.slice(-i).reverse().map((({
                    state: t,
                    startTime: i
                }) => ({
                    state: t,
                    start: (0, h.c0)((0, h._J)(e, i))
                })))
            }

            function ss() {
                return "hidden" === document.visibilityState ? "hidden" : document.hasFocus() ? "active" : "passive"
            }
            var rs = i(354),
                ns = i(5747),
                as = i(4208),
                os = i(5123),
                ls = i(5528),
                cs = i(1802);
            const us = {
                    "view.name": "string",
                    "view.url": "string",
                    "view.referrer": "string"
                },
                ds = {
                    context: "object"
                },
                hs = {
                    service: "string",
                    version: "string"
                };
            let fs;
            var ps = i(3583),
                gs = i(1545),
                ms = i(2582),
                ys = i(769);
            const vs = [m.ACTION, m.ERROR, m.LONG_TASK, m.RESOURCE, m.VITAL];
            var bs = i(4408);

            function Ts(t, e, i, s, r, n, a, l, u) {
                const d = [],
                    f = new rt.j,
                    p = (0, ys.H)();
                f.subscribe(13, (t => (0, Z.j)("rum", t)));
                const g = t => {
                        f.notify(14, {
                            error: t
                        }), (0, o.eJ)("Error reported to customer", {
                            "error.message": t.message
                        })
                    },
                    v = (0, tt.FP)(t),
                    b = v.subscribe((t => {
                        f.notify(11, t)
                    }));
                d.push((() => b.unsubscribe()));
                const T = (0, o.VL)("browser-rum-sdk", t, p, g, v, r);
                d.push(T.stop);
                const E = (0, C.xT)() ? (0, $i.j5)() : (0, $i.oi)(t, f, n);
                if ((0, C.xT)())(0, Gi.i)(f);
                else {
                    const e = function(t, e, i, s, r, n) {
                        const a = [t.rumEndpointBuilder];
                        t.replica && a.push(t.replica.rumEndpointBuilder);
                        const o = (0, Ui.n)({
                            encoder: n(2),
                            request: (0, Bi.UF)(a, t.batchBytesLimit, i),
                            flushController: (0, ji.r)({
                                messagesLimit: t.batchMessagesLimit,
                                bytesLimit: t.batchBytesLimit,
                                durationLimit: t.flushTimeout,
                                pageMayExitObservable: s,
                                sessionExpireObservable: r
                            }),
                            messageBytesLimit: t.messageBytesLimit
                        });
                        return e.subscribe(13, (t => {
                            t.type === m.VIEW ? o.upsert(t, t.view.id) : o.add(t)
                        })), o
                    }(t, f, g, v, E.expireObservable, r);
                    d.push((() => e.stop())),
                        function(t, e, i, s) {
                            e.enabled && (0, F.y7)(t.customerDataTelemetrySampleRate) && (Ji(), Yi = !1, i.subscribe(13, (() => {
                                Yi = !0
                            })), s.subscribe((({
                                bytesCount: t,
                                messagesCount: e
                            }) => {
                                Yi && (Yi = !1, Wi.batchCount += 1, Qi(Wi.batchBytesCount, t), Qi(Wi.batchMessagesCount, e))
                            })), (0, Nt.Zi)(Xi, qi))
                        }(t, T, f, e.flushController.flushObservable)
                }
                const A = (0, et.y)(),
                    _ = (0, Hi.t)(t, location),
                    {
                        observable: M,
                        stop: N
                    } = (0, it.M)();
                d.push(N), (0, gs.Y)(p, t, u);
                const U = function(t, e, i = ts) {
                        const s = (0, xt.p)({
                            expireDelay: es,
                            maxEntries: Zi
                        });
                        let r;
                        jt(Mt.VISIBILITY_STATE) && performance.getEntriesByType(Mt.VISIBILITY_STATE).forEach((t => {
                            a("hidden" === t.name ? "hidden" : "active", t.startTime)
                        })), a(ss(), (0, h._q)());
                        const {
                            stop: n
                        } = (0, Ft.y)(e, window, ["pageshow", "focus", "blur", "visibilitychange", "resume", "freeze", "pagehide"], (t => {
                            a(function(t) {
                                return "freeze" === t.type ? "frozen" : "pagehide" === t.type ? t.persisted ? "frozen" : "terminated" : ss()
                            }(t), t.timeStamp)
                        }), {
                            capture: !0
                        });

                        function a(t, e = (0, h._q)()) {
                            t !== r && (r = t, s.closeActive(e), s.add({
                                state: r,
                                startTime: e
                            }, e))
                        }

                        function o(t, e, i) {
                            return s.findAll(e, i).some((e => e.state === t))
                        }
                        return t.register(0, (({
                            startTime: t,
                            duration: e = 0,
                            eventType: r
                        }) => r === m.VIEW ? {
                            type: r,
                            _dd: {
                                page_states: is(s.findAll(t, e), t, i)
                            }
                        } : r === m.ACTION || r === m.ERROR ? {
                            type: r,
                            view: {
                                in_foreground: o("active", t, 0)
                            }
                        } : Ct.kb)), {
                            wasInPageStateDuringPeriod: o,
                            addPageState: a,
                            stop: () => {
                                n(), s.stop()
                            }
                        }
                    }(p, t),
                    B = (0, nt.O)(f);
                d.push((() => B.stop()));
                const G = (0, Vi.Y)(f, p, _, location);
                d.push((() => G.stop()));
                const V = function(t, e, i) {
                    const s = (0, xt.p)({
                        expireDelay: zi
                    });
                    return t.subscribe(1, (({
                        startClocks: t
                    }) => {
                        s.add({}, t.relative)
                    })), t.subscribe(6, (({
                        endClocks: t
                    }) => {
                        s.closeActive(t.relative)
                    })), e.register(0, (({
                        startTime: t,
                        eventType: e
                    }) => {
                        if (!i.trackFeatureFlagsForEvents.concat([m.VIEW, m.ERROR]).includes(e)) return Ct.kb;
                        const r = s.find(t);
                        return !r || (0, $.Qr)(r) ? Ct.kb : {
                            type: e,
                            feature_flags: r
                        }
                    })), {
                        addFeatureFlagEvaluation: (t, e) => {
                            const i = s.find();
                            i && (i[t] = e)
                        }
                    }
                }(f, p, t);
                ! function(t, e, i, s) {
                    t.register(0, (({
                        eventType: t,
                        startTime: r
                    }) => {
                        const n = e.findTrackedSession(r),
                            a = s.findView(r);
                        if (!n || !a) return Ct.C_;
                        let o, l, c;
                        return t === m.VIEW ? (o = !!i.getReplayStats(a.id) || void 0, l = 1 === n.sessionReplay, c = !!a.sessionIsActive && void 0) : o = !!i.isRecording() || void 0, {
                            type: t,
                            session: {
                                id: n.id,
                                type: "user",
                                has_replay: o,
                                sampled_for_replay: l,
                                is_active: c
                            }
                        }
                    })), t.register(1, (({
                        startTime: t
                    }) => {
                        const i = e.findTrackedSession(t);
                        return i ? {
                            session: {
                                id: i.id
                            }
                        } : Ct.kb
                    }))
                }(p, E, e, B), (0, ps.d)(p), (0, ms.I)(p, n);
                const H = (0, L.$)(p, t, "rum", !0),
                    q = (0, R.c)(p, t, E, "rum"),
                    W = (0, I.p)(p, t, "rum"),
                    {
                        actionContexts: Y,
                        addAction: X,
                        addEvent: Q,
                        stop: J
                    } = function(t, e, i, s, r, n, a) {
                        const o = function(t, e, i, s, r) {
                                t.subscribe(0, (e => t.notify(12, He(e)))), e.register(0, (({
                                    startTime: t,
                                    eventType: e
                                }) => {
                                    if (e !== m.ERROR && e !== m.RESOURCE && e !== m.LONG_TASK) return Ct.kb;
                                    const i = n.findActionId(t);
                                    return i ? {
                                        type: e,
                                        action: {
                                            id: i
                                        }
                                    } : Ct.kb
                                })), e.register(1, (({
                                    startTime: t
                                }) => ({
                                    action: {
                                        id: n.findActionId(t)
                                    }
                                })));
                                let n = {
                                        findActionId: x.Z
                                    },
                                    a = x.Z;
                                return r.trackUserInteractions && ({
                                    actionContexts: n,
                                    stop: a
                                } = Ge(t, i, s, r)), {
                                    addAction: e => {
                                        t.notify(12, He(e))
                                    },
                                    actionContexts: n,
                                    stop: a
                                }
                            }(t, e, r, n, i),
                            l = function(t) {
                                return {
                                    addEvent: (e, i, s, r) => {
                                        vs.includes(i.type) && t.notify(12, {
                                            startTime: e,
                                            rawRumEvent: i,
                                            domainContext: s,
                                            duration: r
                                        })
                                    }
                                }
                            }(t),
                            u = (0, rs.Z)(e, i),
                            d = (0, ns.z)(i, e);
                        return (0, as.E)(e),
                            function(t, e, i, s) {
                                fs = {
                                    [m.VIEW]: {
                                        "view.performance.lcp.resource_url": "string",
                                        ...ds,
                                        ...us,
                                        ...hs
                                    },
                                    [m.ERROR]: {
                                        "error.message": "string",
                                        "error.stack": "string",
                                        "error.resource.url": "string",
                                        "error.fingerprint": "string",
                                        ...ds,
                                        ...us,
                                        ...hs
                                    },
                                    [m.RESOURCE]: {
                                        "resource.url": "string",
                                        ...(0, O.W_)(O.uh.WRITABLE_RESOURCE_GRAPHQL) ? {
                                            "resource.graphql": "object"
                                        } : {},
                                        ...ds,
                                        ...us,
                                        ...hs
                                    },
                                    [m.ACTION]: {
                                        "action.target.name": "string",
                                        ...ds,
                                        ...us,
                                        ...hs
                                    },
                                    [m.LONG_TASK]: {
                                        "long_task.scripts[].source_url": "string",
                                        "long_task.scripts[].invoker": "string",
                                        ...ds,
                                        ...us,
                                        ...hs
                                    },
                                    [m.VITAL]: { ...ds,
                                        ...us,
                                        ...hs
                                    }
                                };
                                const r = {
                                    [m.ERROR]: (0, os.K)(m.ERROR, t.eventRateLimiterThreshold, s),
                                    [m.ACTION]: (0, os.K)(m.ACTION, t.eventRateLimiterThreshold, s),
                                    [m.VITAL]: (0, os.K)(m.VITAL, t.eventRateLimiterThreshold, s)
                                };
                                e.subscribe(12, (({
                                    startTime: s,
                                    duration: n,
                                    rawRumEvent: a,
                                    domainContext: o
                                }) => {
                                    const l = i.triggerHook(0, {
                                        eventType: a.type,
                                        startTime: s,
                                        duration: n
                                    });
                                    if (l === Ct.C_) return;
                                    const u = (0, c.$e)(l, a, {
                                        ddtags: (0, ls.MS)(t).join(",")
                                    });
                                    (function(t, e, i, s) {
                                        var r;
                                        if (e) {
                                            const s = (0, cs.O)(t, fs[t.type], (t => e(t, i)));
                                            if (!1 === s && t.type !== m.VIEW) return !1;
                                            !1 === s && D.jf.warn("Can't dismiss view events using beforeSend!")
                                        }
                                        return !(null === (r = s[t.type]) || void 0 === r ? void 0 : r.isLimitReached())
                                    })(u, t.beforeSend, o, r) && ((0, $.Qr)(u.context) && delete u.context, e.notify(13, u))
                                }))
                            }(i, t, e, a), {
                                pageStateHistory: s,
                                addAction: o.addAction,
                                addEvent: l.addEvent,
                                actionContexts: o.actionContexts,
                                stop: () => {
                                    o.stop(), d.stop(), u.stop(), s.stop()
                                }
                            }
                    }(f, p, t, U, A, M, g);
                d.push(J);
                const {
                    addTiming: ut,
                    startView: dt,
                    setViewName: ht,
                    setViewContext: ft,
                    setViewContextProperty: pt,
                    getViewContext: gt,
                    stop: mt
                } = function(t, e, i, s, r, n, a, o, l, c) {
                    return t.subscribe(4, (e => t.notify(12, function(t, e, i) {
                        var s, r, n, a, o, l, c, u, d, f, p, g, y, v, b, T, E, S;
                        const w = i.getReplayStats(t.id),
                            k = null === (r = null === (s = t.commonViewMetrics) || void 0 === s ? void 0 : s.cumulativeLayoutShift) || void 0 === r ? void 0 : r.devicePixelRatio,
                            A = {
                                _dd: {
                                    document_version: t.documentVersion,
                                    replay_stats: w,
                                    cls: k ? {
                                        device_pixel_ratio: k
                                    } : void 0,
                                    configuration: {
                                        start_session_replay_recording_manually: e.startSessionReplayRecordingManually
                                    }
                                },
                                date: t.startClocks.timeStamp,
                                type: m.VIEW,
                                view: {
                                    action: {
                                        count: t.eventCounts.actionCount
                                    },
                                    frustration: {
                                        count: t.eventCounts.frustrationCount
                                    },
                                    cumulative_layout_shift: null === (n = t.commonViewMetrics.cumulativeLayoutShift) || void 0 === n ? void 0 : n.value,
                                    cumulative_layout_shift_time: (0, h.c0)(null === (a = t.commonViewMetrics.cumulativeLayoutShift) || void 0 === a ? void 0 : a.time),
                                    cumulative_layout_shift_target_selector: null === (o = t.commonViewMetrics.cumulativeLayoutShift) || void 0 === o ? void 0 : o.targetSelector,
                                    first_byte: (0, h.c0)(null === (l = t.initialViewMetrics.navigationTimings) || void 0 === l ? void 0 : l.firstByte),
                                    dom_complete: (0, h.c0)(null === (c = t.initialViewMetrics.navigationTimings) || void 0 === c ? void 0 : c.domComplete),
                                    dom_content_loaded: (0, h.c0)(null === (u = t.initialViewMetrics.navigationTimings) || void 0 === u ? void 0 : u.domContentLoaded),
                                    dom_interactive: (0, h.c0)(null === (d = t.initialViewMetrics.navigationTimings) || void 0 === d ? void 0 : d.domInteractive),
                                    error: {
                                        count: t.eventCounts.errorCount
                                    },
                                    first_contentful_paint: (0, h.c0)(t.initialViewMetrics.firstContentfulPaint),
                                    first_input_delay: (0, h.c0)(null === (f = t.initialViewMetrics.firstInput) || void 0 === f ? void 0 : f.delay),
                                    first_input_time: (0, h.c0)(null === (p = t.initialViewMetrics.firstInput) || void 0 === p ? void 0 : p.time),
                                    first_input_target_selector: null === (g = t.initialViewMetrics.firstInput) || void 0 === g ? void 0 : g.targetSelector,
                                    interaction_to_next_paint: (0, h.c0)(null === (y = t.commonViewMetrics.interactionToNextPaint) || void 0 === y ? void 0 : y.value),
                                    interaction_to_next_paint_time: (0, h.c0)(null === (v = t.commonViewMetrics.interactionToNextPaint) || void 0 === v ? void 0 : v.time),
                                    interaction_to_next_paint_target_selector: null === (b = t.commonViewMetrics.interactionToNextPaint) || void 0 === b ? void 0 : b.targetSelector,
                                    is_active: t.isActive,
                                    name: t.name,
                                    largest_contentful_paint: (0, h.c0)(null === (T = t.initialViewMetrics.largestContentfulPaint) || void 0 === T ? void 0 : T.value),
                                    largest_contentful_paint_target_selector: null === (E = t.initialViewMetrics.largestContentfulPaint) || void 0 === E ? void 0 : E.targetSelector,
                                    load_event: (0, h.c0)(null === (S = t.initialViewMetrics.navigationTimings) || void 0 === S ? void 0 : S.loadEvent),
                                    loading_time: (0, Dt.J)((0, h.c0)(t.commonViewMetrics.loadingTime)),
                                    loading_type: t.loadingType,
                                    long_task: {
                                        count: t.eventCounts.longTaskCount
                                    },
                                    performance: Fi(t.commonViewMetrics, t.initialViewMetrics),
                                    resource: {
                                        count: t.eventCounts.resourceCount
                                    },
                                    time_spent: (0, h.c0)(t.duration)
                                },
                                display: t.commonViewMetrics.scroll ? {
                                    scroll: {
                                        max_depth: t.commonViewMetrics.scroll.maxDepth,
                                        max_depth_scroll_top: t.commonViewMetrics.scroll.maxDepthScrollTop,
                                        max_scroll_height: t.commonViewMetrics.scroll.maxScrollHeight,
                                        max_scroll_height_time: (0, h.c0)(t.commonViewMetrics.scroll.maxScrollHeightTime)
                                    }
                                } : void 0,
                                privacy: {
                                    replay_level: e.defaultPrivacyLevel
                                },
                                device: {
                                    locale: navigator.language,
                                    locales: navigator.languages,
                                    time_zone: (0, di.Z)()
                                }
                            };
                        return (0, $.Qr)(t.customTimings) || (A.view.custom_timings = (0, $.Q8)(t.customTimings, h.c0)), {
                            rawRumEvent: A,
                            startTime: t.startClocks.relative,
                            duration: t.duration,
                            domainContext: {
                                location: t.location
                            }
                        }
                    }(e, i, o)))), e.register(0, (({
                        startTime: t,
                        eventType: e
                    }) => {
                        const i = l.findView(t);
                        return i ? {
                            type: e,
                            service: i.service,
                            version: i.version,
                            context: i.context,
                            view: {
                                id: i.id,
                                name: i.name
                            }
                        } : Ct.C_
                    })), e.register(1, (({
                        startTime: t
                    }) => {
                        var e;
                        return {
                            view: {
                                id: null === (e = l.findView(t)) || void 0 === e ? void 0 : e.id
                            }
                        }
                    })), Mi(s, t, r, n, i, a, !i.trackViewsManually, c)
                }(f, p, t, location, A, M, _, e, B, s);
                d.push(mt);
                const {
                    stop: yt
                } = (0, bs.j)(t, f, T);
                d.push(yt);
                const {
                    stop: vt
                } = oi(f, t, U);
                if (d.push(vt), t.trackLongTasks)
                    if (jt(Mt.LONG_ANIMATION_FRAME)) {
                        const {
                            stop: e
                        } = function(t, e) {
                            const i = Ut(e, {
                                type: Mt.LONG_ANIMATION_FRAME,
                                buffered: !0
                            }).subscribe((e => {
                                for (const i of e) {
                                    const e = (0, h.DY)(i.startTime),
                                        s = {
                                            date: e.timeStamp,
                                            long_task: {
                                                id: (0, S.DO)(),
                                                entry_type: y.LONG_ANIMATION_FRAME,
                                                duration: (0, h.c0)(i.duration),
                                                blocking_duration: (0, h.c0)(i.blockingDuration),
                                                first_ui_event_timestamp: (0, h.c0)(i.firstUIEventTimestamp),
                                                render_start: (0, h.c0)(i.renderStart),
                                                style_and_layout_start: (0, h.c0)(i.styleAndLayoutStart),
                                                start_time: (0, h.c0)(i.startTime),
                                                scripts: i.scripts.map((t => ({
                                                    duration: (0, h.c0)(t.duration),
                                                    pause_duration: (0, h.c0)(t.pauseDuration),
                                                    forced_style_and_layout_duration: (0, h.c0)(t.forcedStyleAndLayoutDuration),
                                                    start_time: (0, h.c0)(t.startTime),
                                                    execution_start: (0, h.c0)(t.executionStart),
                                                    source_url: t.sourceURL,
                                                    source_function_name: t.sourceFunctionName,
                                                    source_char_position: t.sourceCharPosition,
                                                    invoker: t.invoker,
                                                    invoker_type: t.invokerType,
                                                    window_attribution: t.windowAttribution
                                                })))
                                            },
                                            type: m.LONG_TASK,
                                            _dd: {
                                                discarded: !1
                                            }
                                        };
                                    t.notify(12, {
                                        rawRumEvent: s,
                                        startTime: e.relative,
                                        duration: i.duration,
                                        domainContext: {
                                            performanceEntry: i
                                        }
                                    })
                                }
                            }));
                            return {
                                stop: () => i.unsubscribe()
                            }
                        }(f, t);
                        d.push(e)
                    } else ! function(t, e) {
                        Ut(e, {
                            type: Mt.LONG_TASK,
                            buffered: !0
                        }).subscribe((i => {
                            for (const s of i) {
                                if (s.entryType !== Mt.LONG_TASK) break;
                                if (!e.trackLongTasks) break;
                                const i = (0, h.DY)(s.startTime),
                                    r = {
                                        date: i.timeStamp,
                                        long_task: {
                                            id: (0, S.DO)(),
                                            entry_type: y.LONG_TASK,
                                            duration: (0, h.c0)(s.duration)
                                        },
                                        type: m.LONG_TASK,
                                        _dd: {
                                            discarded: !1
                                        }
                                    };
                                t.notify(12, {
                                    rawRumEvent: r,
                                    startTime: i.relative,
                                    duration: s.duration,
                                    domainContext: {
                                        performanceEntry: s
                                    }
                                })
                            }
                        }))
                    }(f, t);
                const {
                    addError: bt
                } = function(t, e, i) {
                    const s = new Pt.y$;
                    return i.subscribe((t => {
                            0 === t.type && s.notify(t.error)
                        })), (0, We.U)(s), (0, Ye.x)(e, s), s.subscribe((e => t.notify(14, {
                            error: e
                        }))),
                        function(t) {
                            return t.subscribe(14, (({
                                error: e
                            }) => {
                                t.notify(12, function(t) {
                                    const e = {
                                            date: t.startClocks.timeStamp,
                                            error: {
                                                id: (0, S.DO)(),
                                                message: t.message,
                                                source: t.source,
                                                stack: t.stack,
                                                handling_stack: t.handlingStack,
                                                component_stack: t.componentStack,
                                                type: t.type,
                                                handling: t.handling,
                                                causes: t.causes,
                                                source_type: "browser",
                                                fingerprint: t.fingerprint,
                                                csp: t.csp
                                            },
                                            type: m.ERROR,
                                            context: t.context
                                        },
                                        i = {
                                            error: t.originalError,
                                            handlingStack: t.handlingStack
                                        };
                                    return {
                                        rawRumEvent: e,
                                        startTime: t.startClocks.relative,
                                        domainContext: i
                                    }
                                }(e))
                            })), {
                                addError: ({
                                    error: e,
                                    handlingStack: i,
                                    componentStack: s,
                                    startClocks: r,
                                    context: n
                                }) => {
                                    const a = (0, ze.AP)({
                                        originalError: e,
                                        handlingStack: i,
                                        componentStack: s,
                                        startClocks: r,
                                        nonErrorPrefix: "Provided",
                                        source: qe.z.CUSTOM,
                                        handling: "handled"
                                    });
                                    a.context = (0, c.$e)(a.context, n), t.notify(14, {
                                        error: a
                                    })
                                }
                            }
                        }(t)
                }(f, t, l);
                l.unbuffer(),
                    function(t, e, i, s, r) {
                        const n = function(t, e, i, s) {
                            return {
                                clearTracingIfNeeded: K,
                                traceFetch: r => z(t, r, e, i, s, (t => {
                                    var e;
                                    if (r.input instanceof Request && !(null === (e = r.init) || void 0 === e ? void 0 : e.headers)) r.input = new Request(r.input), Object.keys(t).forEach((e => {
                                        r.input.headers.append(e, t[e])
                                    }));
                                    else {
                                        r.init = (0, $.mv)(r.init);
                                        const e = [];
                                        r.init.headers instanceof Headers ? r.init.headers.forEach(((t, i) => {
                                            e.push([i, t])
                                        })) : Array.isArray(r.init.headers) ? r.init.headers.forEach((t => {
                                            e.push(t)
                                        })) : r.init.headers && Object.keys(r.init.headers).forEach((t => {
                                            e.push([t, r.init.headers[t]])
                                        })), r.init.headers = e.concat((0, j.qP)(t))
                                    }
                                })),
                                traceXhr: (r, n) => z(t, r, e, i, s, (t => {
                                    Object.keys(t).forEach((e => {
                                        n.setRequestHeader(e, t[e])
                                    }))
                                }))
                            }
                        }(e, i, s, r);
                        ! function(t, e, i) {
                            (0, at.S)(e).subscribe((e => {
                                const s = e;
                                if (kt(s.url)) switch (s.state) {
                                    case "start":
                                        i.traceXhr(s, s.xhr), s.requestIndex = It(), t.notify(7, {
                                            requestIndex: s.requestIndex,
                                            url: s.url
                                        });
                                        break;
                                    case "complete":
                                        i.clearTracingIfNeeded(s), t.notify(8, {
                                            duration: s.duration,
                                            method: s.method,
                                            requestIndex: s.requestIndex,
                                            spanId: s.spanId,
                                            startClocks: s.startClocks,
                                            status: s.status,
                                            traceId: s.traceId,
                                            traceSampled: s.traceSampled,
                                            type: ot.x.XHR,
                                            url: s.url,
                                            xhr: s.xhr,
                                            isAborted: s.isAborted,
                                            handlingStack: s.handlingStack
                                        })
                                }
                            }))
                        }(t, e, n),
                        function(t, e) {
                            (0, P.y)().subscribe((i => {
                                const s = i;
                                if (kt(s.url)) switch (s.state) {
                                    case "start":
                                        e.traceFetch(s), s.requestIndex = It(), t.notify(7, {
                                            requestIndex: s.requestIndex,
                                            url: s.url
                                        });
                                        break;
                                    case "resolve":
                                        ! function(t, e) {
                                            const i = t.response && (0, lt.u)(t.response);
                                            i && i.body ? (0, ct.n)(i.body, (() => {
                                                e((0, h._J)(t.startClocks.timeStamp, (0, h.n$)()))
                                            }), {
                                                bytesLimit: Number.POSITIVE_INFINITY,
                                                collectStreamBody: !1
                                            }) : e((0, h._J)(t.startClocks.timeStamp, (0, h.n$)()))
                                        }(s, (i => {
                                            e.clearTracingIfNeeded(s), t.notify(8, {
                                                duration: i,
                                                method: s.method,
                                                requestIndex: s.requestIndex,
                                                responseType: s.responseType,
                                                spanId: s.spanId,
                                                startClocks: s.startClocks,
                                                status: s.status,
                                                traceId: s.traceId,
                                                traceSampled: s.traceSampled,
                                                type: ot.x.FETCH,
                                                url: s.url,
                                                response: s.response,
                                                init: s.init,
                                                input: s.input,
                                                isAborted: s.isAborted,
                                                handlingStack: s.handlingStack
                                            })
                                        }))
                                }
                            }))
                        }(t, n)
                    }(f, t, E, q, W);
                const Tt = function(t, e, i) {
                        function s(i) {
                            (function(t) {
                                return !e.wasInPageStateDuringPeriod("frozen", t.startClocks.relative, t.duration)
                            })(i) && t.notify(12, function(t, e) {
                                return {
                                    rawRumEvent: {
                                        date: t.startClocks.timeStamp,
                                        vital: {
                                            id: (0, S.DO)(),
                                            type: t.type,
                                            name: t.name,
                                            duration: (0, h.c0)(t.duration),
                                            description: t.description
                                        },
                                        type: m.VITAL,
                                        context: t.context,
                                        _dd: {
                                            vital: {
                                                computed_value: !0
                                            }
                                        }
                                    },
                                    startTime: t.startClocks.relative,
                                    duration: t.duration,
                                    domainContext: {}
                                }
                            }(i))
                        }
                        return {
                            addDurationVital: s,
                            startDurationVital: (t, e = {}) => w(i, t, e),
                            stopDurationVital: (t, e = {}) => {
                                k(s, i, t, e)
                            }
                        }
                    }(f, U, a),
                    Et = (0, st.A)(t.applicationId, E, B, Y, G);
                return d.push((() => i.stop())), {
                    addAction: X,
                    addEvent: Q,
                    addError: bt,
                    addTiming: ut,
                    addFeatureFlagEvaluation: V.addFeatureFlagEvaluation,
                    startView: dt,
                    setViewContext: ft,
                    setViewContextProperty: pt,
                    getViewContext: gt,
                    setViewName: ht,
                    lifeCycle: f,
                    viewHistory: B,
                    session: E,
                    stopSession: () => E.expire(),
                    getInternalContext: Et.get,
                    startDurationVital: Tt.startDurationVital,
                    stopDurationVital: Tt.stopDurationVital,
                    addDurationVital: Tt.addDurationVital,
                    globalContext: H,
                    userContext: q,
                    accountContext: W,
                    telemetry: T,
                    stop: () => {
                        d.forEach((t => t()))
                    },
                    hooks: p
                }
            }
            var Es = i(5788),
                Ss = i(247),
                ws = i(2475)
        },
        8387: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    i: () => r
                }), 179 == i.j) var s = i(6876);

            function r(t) {
                const e = (0, s.Ad)();
                t.subscribe(13, (t => {
                    e.send("rum", t)
                }))
            }
        },
        8259: (t, e, i) => {
            "use strict";

            function s() {
                return "function" == typeof Array.from && "function" == typeof CSSSupportsRule && "function" == typeof URL.createObjectURL && "forEach" in NodeList.prototype
            }
            i.d(e, {
                T: () => s
            })
        },
        4903: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    n: () => r
                }), 179 == i.j) var s = i(9833);
            async function r(t = n) {
                try {
                    return await t()
                } catch (t) {
                    (0, s.j)({
                        error: t,
                        source: "Profiler",
                        scriptType: "module"
                    })
                }
            }
            async function n() {
                return (await i.e(216).then(i.bind(i, 8478))).createRumProfiler
            }
        },
        2910: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    w: () => r
                }), 179 == i.j) var s = i(251);

            function r() {
                let t = 0;
                return {
                    strategy: {
                        start() {
                            t = 1
                        },
                        stop() {
                            t = 2
                        },
                        isRecording: () => !1,
                        getSessionReplayLink: s.Z
                    },
                    shouldStartImmediately: e => 1 === t || 0 === t && !e.startSessionReplayRecordingManually
                }
            }
        },
        1061: (t, e, i) => {
            "use strict";
            i.r(e), i.d(e, {
                startRecording: () => kt
            });
            var s = i(7198),
                r = i(2097),
                n = i(6876),
                a = i(8971),
                o = i(8290),
                l = i(251),
                c = i(3206),
                u = i(170),
                d = i(782);
            const h = new WeakMap;

            function f(t) {
                return h.has(t)
            }

            function p(t) {
                return h.get(t)
            }

            function g(t, e) {
                const i = t.tagName,
                    s = t.value;
                if ((0, d.gR)(t, e)) {
                    const e = t.type;
                    if ("INPUT" === i && ("button" === e || "submit" === e || "reset" === e)) return s;
                    if (!s || "OPTION" === i) return;
                    return d.k6
                }
                return "OPTION" === i || "SELECT" === i ? t.value : "INPUT" === i || "TEXTAREA" === i ? s : void 0
            }
            const m = /url\((?:(')([^']*)'|(")([^"]*)"|([^)]*))\)/gm,
                y = /^[A-Za-z]+:|^\/\//,
                v = /^["']?data:.*,/i;
            const b = /[^a-z1-6-_]/;

            function T(t) {
                const e = t.toLowerCase().trim();
                return b.test(e) ? "div" : e
            }

            function E(t, e) {
                return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${t}' height='${e}' style='background-color:silver'%3E%3C/svg%3E`
            }
            var S = i(5026);
            const w = {
                    FullSnapshot: 2,
                    IncrementalSnapshot: 3,
                    Meta: 4,
                    Focus: 6,
                    ViewEnd: 7,
                    VisualViewport: 8,
                    FrustrationRecord: 9
                },
                k = {
                    Document: 0,
                    DocumentType: 1,
                    Element: 2,
                    Text: 3,
                    CDATA: 4,
                    DocumentFragment: 11
                },
                A = {
                    Mutation: 0,
                    MouseMove: 1,
                    MouseInteraction: 2,
                    Scroll: 3,
                    ViewportResize: 4,
                    Input: 5,
                    TouchMove: 6,
                    MediaInteraction: 7,
                    StyleSheetRule: 8
                },
                _ = {
                    MouseUp: 0,
                    MouseDown: 1,
                    Click: 2,
                    ContextMenu: 3,
                    DblClick: 4,
                    Focus: 5,
                    Blur: 6,
                    TouchStart: 7,
                    TouchEnd: 9
                },
                L = {
                    Play: 0,
                    Pause: 1
                };
            var R = i(6084),
                I = i(2172);
            const C = 1e6;

            function D(t, e, i, s) {
                if (e === d.zx.HIDDEN) return null;
                const r = t.getAttribute(i);
                if (e === d.zx.MASK && i !== d.$n && !d.YO.includes(i) && i !== s.actionNameAttribute) {
                    const e = t.tagName;
                    switch (i) {
                        case "title":
                        case "alt":
                        case "placeholder":
                            return d.k6
                    }
                    if ("IMG" === e && ("src" === i || "srcset" === i)) {
                        const e = t;
                        if (e.naturalWidth > 0) return E(e.naturalWidth, e.naturalHeight);
                        const {
                            width: i,
                            height: s
                        } = t.getBoundingClientRect();
                        return i > 0 || s > 0 ? E(i, s) : d.Xn
                    }
                    if ("SOURCE" === e && ("src" === i || "srcset" === i)) return d.Xn;
                    if ("A" === e && "href" === i) return d.k6;
                    if (r && i.startsWith("data-")) return d.k6;
                    if ("IFRAME" === e && "srcdoc" === i) return d.k6
                }
                return r && "string" == typeof r ? (0, d.Pu)(r, C) : r
            }
            var x = i(1612);

            function P(t) {
                if (!t) return null;
                let e;
                try {
                    e = t.rules || t.cssRules
                } catch (t) {}
                return e ? (i = Array.from(e, (0, I.G6)() ? O : M).join(""), s = t.href, i.replace(m, ((t, e, i, r, n, a) => {
                    const o = i || n || a;
                    if (!s || !o || y.test(o) || v.test(o)) return t;
                    const l = e || r || "";
                    return `url(${l}${function(t,e){try{return(0,u.Q2)(t,e).href}catch(e){return t}}(o,s)}${l})`
                }))) : null;
                var i, s
            }

            function O(t) {
                if (function(t) {
                        return "selectorText" in t
                    }(t) && t.selectorText.includes(":")) {
                    const e = /(\[[\w-]+[^\\])(:[^\]]+\])/g;
                    return t.cssText.replace(e, "$1\\$2")
                }
                return M(t)
            }

            function M(t) {
                return function(t) {
                    return "styleSheet" in t
                }(t) && P(t.styleSheet) || t.cssText
            }

            function N(t, e) {
                const i = function(t, e) {
                    switch (t.nodeType) {
                        case t.DOCUMENT_NODE:
                            return function(t, e) {
                                return {
                                    type: k.Document,
                                    childNodes: $(t, e),
                                    adoptedStyleSheets: (0, R.x)(t.adoptedStyleSheets)
                                }
                            }(t, e);
                        case t.DOCUMENT_FRAGMENT_NODE:
                            return function(t, e) {
                                const i = (0, d.VO)(t);
                                return i && e.serializationContext.shadowRootsController.addShadowRoot(t), {
                                    type: k.DocumentFragment,
                                    childNodes: $(t, e),
                                    isShadowRoot: i,
                                    adoptedStyleSheets: i ? (0, R.x)(t.adoptedStyleSheets) : void 0
                                }
                            }(t, e);
                        case t.DOCUMENT_TYPE_NODE:
                            return i = t, {
                                type: k.DocumentType,
                                name: i.name,
                                publicId: i.publicId,
                                systemId: i.systemId
                            };
                        case t.ELEMENT_NODE:
                            return function(t, e) {
                                const i = T(t.tagName),
                                    s = "svg" === (n = t).tagName || n instanceof SVGElement || void 0,
                                    r = (0, d.Ch)((0, d.SZ)(t), e.parentNodePrivacyLevel);
                                var n;
                                if (r === d.zx.HIDDEN) {
                                    const {
                                        width: e,
                                        height: r
                                    } = t.getBoundingClientRect();
                                    return {
                                        type: k.Element,
                                        tagName: i,
                                        attributes: {
                                            rr_width: `${e}px`,
                                            rr_height: `${r}px`,
                                            [d.$n]: d.nw
                                        },
                                        childNodes: [],
                                        isSVG: s
                                    }
                                }
                                if (r === d.zx.IGNORE) return;
                                const a = function(t, e, i) {
                                    if (e === d.zx.HIDDEN) return {};
                                    const s = {},
                                        r = T(t.tagName),
                                        n = t.ownerDocument;
                                    for (let r = 0; r < t.attributes.length; r += 1) {
                                        const n = t.attributes.item(r).name,
                                            a = D(t, e, n, i.configuration);
                                        null !== a && (s[n] = a)
                                    }
                                    if (t.value && ("textarea" === r || "select" === r || "option" === r || "input" === r)) {
                                        const i = g(t, e);
                                        void 0 !== i && (s.value = i)
                                    }
                                    if ("option" === r && e === d.zx.ALLOW) {
                                        const e = t;
                                        e.selected && (s.selected = e.selected)
                                    }
                                    if ("link" === r) {
                                        const e = Array.from(n.styleSheets).find((e => e.href === t.href)),
                                            r = P(e);
                                        r && e && ((0, x.ik)(i.serializationContext.serializationStats, "cssText", r.length), s._cssText = r)
                                    }
                                    if ("style" === r && t.sheet) {
                                        const e = P(t.sheet);
                                        e && ((0, x.ik)(i.serializationContext.serializationStats, "cssText", e.length), s._cssText = e)
                                    }
                                    const a = t;
                                    if ("input" !== r || "radio" !== a.type && "checkbox" !== a.type || (e === d.zx.ALLOW ? s.checked = !!a.checked : (0, d.gR)(a, e) && delete s.checked), "audio" === r || "video" === r) {
                                        const e = t;
                                        s.rr_mediaState = e.paused ? "paused" : "played"
                                    }
                                    let o, l;
                                    const c = i.serializationContext;
                                    switch (c.status) {
                                        case 0:
                                            o = Math.round(t.scrollTop), l = Math.round(t.scrollLeft), (o || l) && c.elementsScrollPositions.set(t, {
                                                scrollTop: o,
                                                scrollLeft: l
                                            });
                                            break;
                                        case 1:
                                            c.elementsScrollPositions.has(t) && ({
                                                scrollTop: o,
                                                scrollLeft: l
                                            } = c.elementsScrollPositions.get(t))
                                    }
                                    return l && (s.rr_scrollLeft = l), o && (s.rr_scrollTop = o), s
                                }(t, r, e);
                                let o = [];
                                if ((0, d.Sn)(t) && "style" !== i) {
                                    let s;
                                    s = e.parentNodePrivacyLevel === r && e.ignoreWhiteSpace === ("head" === i) ? e : { ...e,
                                        parentNodePrivacyLevel: r,
                                        ignoreWhiteSpace: "head" === i
                                    }, o = $(t, s)
                                }
                                return {
                                    type: k.Element,
                                    tagName: i,
                                    attributes: a,
                                    childNodes: o,
                                    isSVG: s
                                }
                            }(t, e);
                        case t.TEXT_NODE:
                            return function(t, e) {
                                const i = (0, d.FB)(t, e.ignoreWhiteSpace || !1, e.parentNodePrivacyLevel);
                                if (void 0 !== i) return {
                                    type: k.Text,
                                    textContent: i
                                }
                            }(t, e);
                        case t.CDATA_SECTION_NODE:
                            return {
                                type: k.CDATA,
                                textContent: ""
                            }
                    }
                    var i
                }(t, e);
                if (!i) return null;
                const s = p(t) || F++,
                    r = i;
                return r.id = s,
                    function(t, e) {
                        h.set(t, e)
                    }(t, s), e.serializedNodeIds && e.serializedNodeIds.add(s), r
            }
            let F = 1;

            function $(t, e) {
                const i = [];
                return (0, d.Uo)(t, (t => {
                    const s = N(t, e);
                    s && i.push(s)
                })), i
            }

            function U(t, e, i) {
                const s = (0, S.n$)(),
                    r = N(t, {
                        serializationContext: i,
                        parentNodePrivacyLevel: e.defaultPrivacyLevel,
                        configuration: e
                    });
                return (0, x.ik)(i.serializationStats, "serializationDuration", (0, S._J)(s, (0, S.n$)())), r
            }

            function B(t) {
                return Boolean(t.changedTouches)
            }

            function j(t) {
                return !0 === t.composed && (0, d.aT)(t.target) ? t.composedPath()[0] : t.target
            }
            var G = i(5523);

            function V(t, e) {
                return {
                    data: {
                        source: t,
                        ...e
                    },
                    type: w.IncrementalSnapshot,
                    timestamp: (0, S.n$)()
                }
            }
            const H = 50;

            function K(t, e) {
                const {
                    throttled: i,
                    cancel: s
                } = (0, l.P)((t => {
                    const i = j(t);
                    if (f(i)) {
                        const s = z(t);
                        if (!s) return;
                        const r = {
                            id: p(i),
                            timeOffset: 0,
                            x: s.x,
                            y: s.y
                        };
                        e(V(B(t) ? A.TouchMove : A.MouseMove, {
                            positions: [r]
                        }))
                    }
                }), H, {
                    trailing: !1
                }), {
                    stop: r
                } = (0, c.y)(t, document, ["mousemove", "touchmove"], i, {
                    capture: !0,
                    passive: !0
                });
                return {
                    stop: () => {
                        r(), s()
                    }
                }
            }

            function z(t) {
                let {
                    clientX: e,
                    clientY: i
                } = B(t) ? t.changedTouches[0] : t;
                if (window.visualViewport) {
                    const {
                        visualViewportX: t,
                        visualViewportY: s
                    } = (0, G.n)(e, i);
                    e = t, i = s
                }
                if (Number.isFinite(e) && Number.isFinite(i)) return {
                    x: e,
                    y: i
                };
                t.isTrusted && (0, s.eJ)("mouse/touch event without x/y")
            }
            const q = {
                pointerup: _.MouseUp,
                mousedown: _.MouseDown,
                click: _.Click,
                contextmenu: _.ContextMenu,
                dblclick: _.DblClick,
                focus: _.Focus,
                blur: _.Blur,
                touchstart: _.TouchStart,
                touchend: _.TouchEnd
            };

            function W(t, e, i) {
                return (0, c.y)(t, document, Object.keys(q), (s => {
                    const r = j(s);
                    if ((0, d.IE)(r, t.defaultPrivacyLevel) === d.zx.HIDDEN || !f(r)) return;
                    const n = p(r),
                        a = q[s.type];
                    let o;
                    if (a !== _.Blur && a !== _.Focus) {
                        const t = z(s);
                        if (!t) return;
                        o = {
                            id: n,
                            type: a,
                            x: t.x,
                            y: t.y
                        }
                    } else o = {
                        id: n,
                        type: a
                    };
                    const l = {
                        id: i.getIdForEvent(s),
                        ...V(A.MouseInteraction, o)
                    };
                    e(l)
                }), {
                    capture: !0,
                    passive: !0
                })
            }
            const Y = 100;

            function X(t, e, i, s = document) {
                const {
                    throttled: r,
                    cancel: n
                } = (0, l.P)((s => {
                    const r = j(s);
                    if (!r || (0, d.IE)(r, t.defaultPrivacyLevel) === d.zx.HIDDEN || !f(r)) return;
                    const n = p(r),
                        a = r === document ? {
                            scrollTop: (0, d.X_)(),
                            scrollLeft: (0, d.$1)()
                        } : {
                            scrollTop: Math.round(r.scrollTop),
                            scrollLeft: Math.round(r.scrollLeft)
                        };
                    i.set(r, a), e(V(A.Scroll, {
                        id: n,
                        x: a.scrollLeft,
                        y: a.scrollTop
                    }))
                }), Y), {
                    stop: a
                } = (0, c.O)(t, s, "scroll", r, {
                    capture: !0,
                    passive: !0
                });
                return {
                    stop: () => {
                        a(), n()
                    }
                }
            }
            const Q = 200;

            function J(t, e) {
                const i = (0, d.AX)(t).subscribe((t => {
                    e(V(A.ViewportResize, t))
                }));
                return {
                    stop: () => {
                        i.unsubscribe()
                    }
                }
            }

            function Z(t, e) {
                const i = window.visualViewport;
                if (!i) return {
                    stop: l.Z
                };
                const {
                    throttled: s,
                    cancel: r
                } = (0, l.P)((() => {
                    e({
                        data: (0, G.m)(i),
                        type: w.VisualViewport,
                        timestamp: (0, S.n$)()
                    })
                }), Q, {
                    trailing: !1
                }), {
                    stop: n
                } = (0, c.y)(t, i, ["resize", "scroll"], s, {
                    capture: !0,
                    passive: !0
                });
                return {
                    stop: () => {
                        n(), r()
                    }
                }
            }

            function tt(t, e) {
                return (0, c.y)(t, document, ["play", "pause"], (i => {
                    const s = j(i);
                    s && (0, d.IE)(s, t.defaultPrivacyLevel) !== d.zx.HIDDEN && f(s) && e(V(A.MediaInteraction, {
                        id: p(s),
                        type: "play" === i.type ? L.Play : L.Pause
                    }))
                }), {
                    capture: !0,
                    passive: !0
                })
            }
            var et = i(5801);

            function it(t) {
                function e(t, e) {
                    t && f(t.ownerNode) && e(p(t.ownerNode))
                }
                const i = [(0, et.S)(CSSStyleSheet.prototype, "insertRule", (({
                    target: i,
                    parameters: [s, r]
                }) => {
                    e(i, (e => t(V(A.StyleSheetRule, {
                        id: e,
                        adds: [{
                            rule: s,
                            index: r
                        }]
                    }))))
                })), (0, et.S)(CSSStyleSheet.prototype, "deleteRule", (({
                    target: i,
                    parameters: [s]
                }) => {
                    e(i, (e => t(V(A.StyleSheetRule, {
                        id: e,
                        removes: [{
                            index: s
                        }]
                    }))))
                }))];

                function s(s) {
                    i.push((0, et.S)(s.prototype, "insertRule", (({
                        target: i,
                        parameters: [s, r]
                    }) => {
                        e(i.parentStyleSheet, (e => {
                            const n = st(i);
                            n && (n.push(r || 0), t(V(A.StyleSheetRule, {
                                id: e,
                                adds: [{
                                    rule: s,
                                    index: n
                                }]
                            })))
                        }))
                    })), (0, et.S)(s.prototype, "deleteRule", (({
                        target: i,
                        parameters: [s]
                    }) => {
                        e(i.parentStyleSheet, (e => {
                            const r = st(i);
                            r && (r.push(s), t(V(A.StyleSheetRule, {
                                id: e,
                                removes: [{
                                    index: r
                                }]
                            })))
                        }))
                    })))
                }
                return "undefined" != typeof CSSGroupingRule ? s(CSSGroupingRule) : (s(CSSMediaRule), s(CSSSupportsRule)), {
                    stop: () => {
                        i.forEach((t => t.stop()))
                    }
                }
            }

            function st(t) {
                const e = [];
                let i = t;
                for (; i.parentRule;) {
                    const t = Array.from(i.parentRule.cssRules).indexOf(i);
                    e.unshift(t), i = i.parentRule
                }
                if (!i.parentStyleSheet) return;
                const s = Array.from(i.parentStyleSheet.cssRules).indexOf(i);
                return e.unshift(s), e
            }

            function rt(t, e) {
                return (0, c.y)(t, window, ["focus", "blur"], (() => {
                    e({
                        data: {
                            has_focus: document.hasFocus()
                        },
                        type: w.Focus,
                        timestamp: (0, S.n$)()
                    })
                }))
            }

            function nt(t, e, i) {
                const s = t.subscribe(12, (t => {
                    var s, r;
                    t.rawRumEvent.type === d.D$.ACTION && t.rawRumEvent.action.type === d.Us.CLICK && (null === (r = null === (s = t.rawRumEvent.action.frustration) || void 0 === s ? void 0 : s.type) || void 0 === r ? void 0 : r.length) && "events" in t.domainContext && t.domainContext.events && t.domainContext.events.length && e({
                        timestamp: t.rawRumEvent.date,
                        type: w.FrustrationRecord,
                        data: {
                            frustrationTypes: t.rawRumEvent.action.frustration.type,
                            recordIds: t.domainContext.events.map((t => i.getIdForEvent(t)))
                        }
                    })
                }));
                return {
                    stop: () => {
                        s.unsubscribe()
                    }
                }
            }

            function at(t, e) {
                const i = t.subscribe(5, (() => {
                    e({
                        timestamp: (0, S.n$)(),
                        type: w.ViewEnd
                    })
                }));
                return {
                    stop: () => {
                        i.unsubscribe()
                    }
                }
            }

            function ot(t, e, i = document) {
                const s = t.defaultPrivacyLevel,
                    r = new WeakMap,
                    n = i !== document,
                    {
                        stop: a
                    } = (0, c.y)(t, i, n ? ["change"] : ["input", "change"], (t => {
                        const e = j(t);
                        (e instanceof HTMLInputElement || e instanceof HTMLTextAreaElement || e instanceof HTMLSelectElement) && u(e)
                    }), {
                        capture: !0,
                        passive: !0
                    });
                let o;
                if (n) o = l.Z;
                else {
                    const t = [(0, et.X)(HTMLInputElement.prototype, "value", u), (0, et.X)(HTMLInputElement.prototype, "checked", u), (0, et.X)(HTMLSelectElement.prototype, "value", u), (0, et.X)(HTMLTextAreaElement.prototype, "value", u), (0, et.X)(HTMLSelectElement.prototype, "selectedIndex", u)];
                    o = () => {
                        t.forEach((t => t.stop()))
                    }
                }
                return {
                    stop: () => {
                        o(), a()
                    }
                };

                function u(t) {
                    const e = (0, d.IE)(t, s);
                    if (e === d.zx.HIDDEN) return;
                    const i = t.type;
                    let r;
                    if ("radio" === i || "checkbox" === i) {
                        if ((0, d.gR)(t, e)) return;
                        r = {
                            isChecked: t.checked
                        }
                    } else {
                        const i = g(t, e);
                        if (void 0 === i) return;
                        r = {
                            text: i
                        }
                    }
                    h(t, r);
                    const n = t.name;
                    "radio" === i && n && t.checked && document.querySelectorAll(`input[type="radio"][name="${CSS.escape(n)}"]`).forEach((e => {
                        e !== t && h(e, {
                            isChecked: !1
                        })
                    }))
                }

                function h(t, i) {
                    if (!f(t)) return;
                    const s = r.get(t);
                    s && s.text === i.text && s.isChecked === i.isChecked || (r.set(t, i), e(V(A.Input, {
                        id: p(t),
                        ...i
                    })))
                }
            }
            var lt = i(4933),
                ct = i(3156);

            function ut(t, e, i, s) {
                const r = (0, d.q5)();
                if (!r) return {
                    stop: l.Z,
                    flush: l.Z
                };
                const n = (0, ct.W)((s => {
                        ! function(t, e, i, s) {
                            const r = new Map;
                            t.filter((t => "childList" === t.type)).forEach((t => {
                                t.removedNodes.forEach((t => {
                                    dt(t, s.removeShadowRoot)
                                }))
                            }));
                            const n = t.filter((t => t.target.isConnected && function(t) {
                                    let e = t;
                                    for (; e;) {
                                        if (!f(e) && !(0, d.VO)(e)) return !1;
                                        e = (0, d.Ow)(e)
                                    }
                                    return !0
                                }(t.target) && (0, d.IE)(t.target, i.defaultPrivacyLevel, r) !== d.zx.HIDDEN)),
                                a = (0, x.mk)(),
                                {
                                    adds: o,
                                    removes: l,
                                    hasBeenSerialized: c
                                } = function(t, e, i, s, r) {
                                    const n = new Set,
                                        a = new Map;
                                    for (const e of t) e.addedNodes.forEach((t => {
                                        n.add(t)
                                    })), e.removedNodes.forEach((t => {
                                        n.has(t) || a.set(t, e.target), n.delete(t)
                                    }));
                                    const o = Array.from(n);
                                    o.sort(((t, e) => {
                                        const i = t.compareDocumentPosition(e);
                                        return i & Node.DOCUMENT_POSITION_CONTAINED_BY ? -1 : i & Node.DOCUMENT_POSITION_CONTAINS || i & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : i & Node.DOCUMENT_POSITION_PRECEDING ? -1 : 0
                                    }));
                                    const l = new Set,
                                        c = {
                                            status: 2,
                                            serializationStats: i,
                                            shadowRootsController: s
                                        },
                                        u = [];
                                    for (const t of o) {
                                        if (g(t)) continue;
                                        const s = (0, d.IE)(t.parentNode, e.defaultPrivacyLevel, r);
                                        if (s === d.zx.HIDDEN || s === d.zx.IGNORE) continue;
                                        const n = (0, S.n$)(),
                                            a = N(t, {
                                                serializedNodeIds: l,
                                                parentNodePrivacyLevel: s,
                                                serializationContext: c,
                                                configuration: e
                                            });
                                        if ((0, x.ik)(i, "serializationDuration", (0, S._J)(n, (0, S.n$)())), !a) continue;
                                        const o = (0, d.Ow)(t);
                                        u.push({
                                            nextId: m(t),
                                            parentId: p(o),
                                            node: a
                                        })
                                    }
                                    const h = [];
                                    return a.forEach(((t, e) => {
                                        f(e) && h.push({
                                            parentId: p(t),
                                            id: p(e)
                                        })
                                    })), {
                                        adds: u,
                                        removes: h,
                                        hasBeenSerialized: g
                                    };

                                    function g(t) {
                                        return f(t) && l.has(p(t))
                                    }

                                    function m(t) {
                                        let e = t.nextSibling;
                                        for (; e;) {
                                            if (f(e)) return p(e);
                                            e = e.nextSibling
                                        }
                                        return null
                                    }
                                }(n.filter((t => "childList" === t.type)), i, a, s, r),
                                u = function(t, e, i) {
                                    var s;
                                    const r = [],
                                        n = new Set,
                                        a = t.filter((t => !n.has(t.target) && (n.add(t.target), !0)));
                                    for (const t of a) {
                                        if (t.target.textContent === t.oldValue) continue;
                                        const n = (0, d.IE)((0, d.Ow)(t.target), e.defaultPrivacyLevel, i);
                                        n !== d.zx.HIDDEN && n !== d.zx.IGNORE && r.push({
                                            id: p(t.target),
                                            value: null !== (s = (0, d.FB)(t.target, !1, n)) && void 0 !== s ? s : null
                                        })
                                    }
                                    return r
                                }(n.filter((t => "characterData" === t.type && !c(t.target))), i, r),
                                h = function(t, e, i) {
                                    const s = [],
                                        r = new Map,
                                        n = t.filter((t => {
                                            const e = r.get(t.target);
                                            return !(e && e.has(t.attributeName) || (e ? e.add(t.attributeName) : r.set(t.target, new Set([t.attributeName])), 0))
                                        })),
                                        a = new Map;
                                    for (const t of n) {
                                        if (t.target.getAttribute(t.attributeName) === t.oldValue) continue;
                                        const r = (0, d.IE)(t.target, e.defaultPrivacyLevel, i),
                                            n = D(t.target, r, t.attributeName, e);
                                        let o;
                                        if ("value" === t.attributeName) {
                                            const e = g(t.target, r);
                                            if (void 0 === e) continue;
                                            o = e
                                        } else o = "string" == typeof n ? n : null;
                                        let l = a.get(t.target);
                                        l || (l = {
                                            id: p(t.target),
                                            attributes: {}
                                        }, s.push(l), a.set(t.target, l)), l.attributes[t.attributeName] = o
                                    }
                                    return s
                                }(n.filter((t => "attributes" === t.type && !c(t.target))), i, r);
                            (u.length || h.length || l.length || o.length) && e(V(A.Mutation, {
                                adds: o,
                                removes: l,
                                texts: u,
                                attributes: h
                            }), a)
                        }(s.concat(a.takeRecords()), t, e, i)
                    })),
                    a = new r((0, lt.zk)(n.addMutations));
                return a.observe(s, {
                    attributeOldValue: !0,
                    attributes: !0,
                    characterData: !0,
                    characterDataOldValue: !0,
                    childList: !0,
                    subtree: !0
                }), {
                    stop: () => {
                        a.disconnect(), n.stop()
                    },
                    flush: () => {
                        n.flush()
                    }
                }
            }

            function dt(t, e) {
                (0, d.aT)(t) && e(t.shadowRoot), (0, d.Uo)(t, (t => dt(t, e)))
            }
            var ht = i(5159);
            const ft = (t, e, i) => {
                const s = new Map,
                    r = {
                        addShadowRoot: n => {
                            if (s.has(n)) return;
                            const a = ut(e, t, r, n),
                                o = ot(t, e, n),
                                l = X(t, e, i, n);
                            s.set(n, {
                                flush: () => a.flush(),
                                stop: () => {
                                    a.stop(), o.stop(), l.stop()
                                }
                            })
                        },
                        removeShadowRoot: t => {
                            const e = s.get(t);
                            e && (e.stop(), s.delete(t))
                        },
                        stop: () => {
                            s.forEach((({
                                stop: t
                            }) => t()))
                        },
                        flush: () => {
                            s.forEach((({
                                flush: t
                            }) => t()))
                        }
                    };
                return r
            };
            var pt = i(9411);
            var gt = i(7581),
                mt = i(5483),
                yt = i(76);

            function vt({
                context: t,
                creationReason: e,
                encoder: i
            }) {
                let s = 0;
                const r = t.view.id,
                    n = {
                        start: 1 / 0,
                        end: -1 / 0,
                        creation_reason: e,
                        records_count: 0,
                        has_full_snapshot: !1,
                        index_in_view: o.FT(r),
                        source: "browser",
                        ...t
                    },
                    a = (0, x.mk)();
                return o.ui(r), {
                    addRecord: function(t, e, r) {
                        n.start = Math.min(n.start, t.timestamp), n.end = Math.max(n.end, t.timestamp), n.records_count += 1, n.has_full_snapshot || (n.has_full_snapshot = t.type === w.FullSnapshot), e && (0, x.mH)(a, e);
                        const o = i.isEmpty ? '{"records":[' : ",";
                        i.write(o + JSON.stringify(t), (t => {
                            s += t, r(s)
                        }))
                    },
                    flush: function(t) {
                        if (i.isEmpty) throw new Error("Empty segment flushed");
                        i.write(`],${JSON.stringify(n).slice(1)}\n`), i.finish((e => {
                            o.pk(n.view.id, e.rawBytesCount), t(n, a, e)
                        }))
                    }
                }
            }
            const bt = 5 * S.WT;
            let Tt = 6e4;

            function Et(t, e, i, s, r, n) {
                return function(t, r, n, a) {
                    let o = {
                        status: 0,
                        nextSegmentCreationReason: "init"
                    };
                    const {
                        unsubscribe: l
                    } = t.subscribe(2, (() => {
                        u("view_change")
                    })), {
                        unsubscribe: c
                    } = t.subscribe(11, (t => {
                        u(t.reason)
                    }));

                    function u(t) {
                        1 === o.status && (o.segment.flush(((e, i, s) => {
                            const r = (0, yt.H)(s.output, e, i, s.rawBytesCount);
                            (0, gt.PT)(t) ? n.sendOnExit(r): n.send(r)
                        })), (0, mt.gr)(o.expirationTimeoutId)), o = "stop" !== t ? {
                            status: 0,
                            nextSegmentCreationReason: t
                        } : {
                            status: 2
                        }
                    }
                    return {
                        addRecord: (t, r) => {
                            if (2 !== o.status) {
                                if (0 === o.status) {
                                    const t = function(t, e, i) {
                                        const s = e.findTrackedSession(),
                                            r = i.findView();
                                        if (s && r) return {
                                            application: {
                                                id: t
                                            },
                                            session: {
                                                id: s.id
                                            },
                                            view: {
                                                id: r.id
                                            }
                                        }
                                    }(e.applicationId, i, s);
                                    if (!t) return;
                                    o = {
                                        status: 1,
                                        segment: vt({
                                            encoder: a,
                                            context: t,
                                            creationReason: o.nextSegmentCreationReason
                                        }),
                                        expirationTimeoutId: (0, mt.iK)((() => {
                                            u("segment_duration_limit")
                                        }), bt)
                                    }
                                }
                                o.segment.addRecord(t, r, (t => {
                                    t > Tt && u("segment_bytes_limit")
                                }))
                            }
                        },
                        stop: () => {
                            u("stop"), l(), c()
                        }
                    }
                }(t, 0, r, n)
            }
            var St = i(1946),
                wt = i(9317);

            function kt(t, e, i, l, c, u, h) {
                const f = [],
                    p = h || (0, r.UF)([e.sessionReplayEndpointBuilder], Tt, (e => {
                        t.notify(14, {
                            error: e
                        }), (0, s.eJ)("Error reported to customer", {
                            "error.message": e.message
                        })
                    }));
                let g;
                if ((0, n.xT)())({
                    addRecord: g
                } = (0, wt.d)(l));
                else {
                    const s = Et(t, e, i, l, p, c);
                    g = s.addRecord, f.push(s.stop);
                    const r = (0, St.I)(e, u, p.observable);
                    f.push(r.stop)
                }
                const {
                    stop: m
                } = function(t) {
                    const {
                        emit: e,
                        configuration: i,
                        lifeCycle: s
                    } = t;
                    if (!e) throw new Error("emit function is required");
                    const r = (i, s) => {
                            e(i, s), (0, a.j)("record", {
                                record: i
                            });
                            const r = t.viewHistory.findView();
                            o.xK(r.id)
                        },
                        n = (0, ht.N)(),
                        l = ft(i, r, n),
                        {
                            stop: c
                        } = function(t, e, i, s, r, n) {
                            const a = (i, r) => {
                                const {
                                    width: a,
                                    height: o
                                } = (0, d.PA)();
                                n({
                                    data: {
                                        height: o,
                                        href: window.location.href,
                                        width: a
                                    },
                                    type: w.Meta,
                                    timestamp: i
                                }), n({
                                    data: {
                                        has_focus: document.hasFocus()
                                    },
                                    type: w.Focus,
                                    timestamp: i
                                });
                                const l = (0, x.mk)();
                                n({
                                    data: {
                                        node: U(document, s, {
                                            status: r,
                                            elementsScrollPositions: t,
                                            serializationStats: l,
                                            shadowRootsController: e
                                        }),
                                        initialOffset: {
                                            left: (0, d.$1)(),
                                            top: (0, d.X_)()
                                        }
                                    },
                                    type: w.FullSnapshot,
                                    timestamp: i
                                }, l), window.visualViewport && n({
                                    data: (0, G.m)(window.visualViewport),
                                    type: w.VisualViewport,
                                    timestamp: i
                                })
                            };
                            a((0, S.n$)(), 0);
                            const {
                                unsubscribe: o
                            } = i.subscribe(2, (t => {
                                r(), a(t.startClocks.timeStamp, 1)
                            }));
                            return {
                                stop: o
                            }
                        }(n, l, s, i, u, r);

                    function u() {
                        l.flush(), f.flush()
                    }
                    const h = (0, pt.b)(),
                        f = ut(r, i, l, document),
                        p = [f, K(i, r), W(i, r, h), X(i, r, n, document), J(i, r), ot(i, r), tt(i, r), it(r), rt(i, r), Z(i, r), nt(s, r, h), at(s, (t => {
                            u(), r(t)
                        }))];
                    return {
                        stop: () => {
                            l.stop(), p.forEach((t => t.stop())), c()
                        },
                        flushMutations: u,
                        shadowRootsController: l
                    }
                }({
                    emit: g,
                    configuration: e,
                    lifeCycle: t,
                    viewHistory: l
                });
                return f.push(m), {
                    stop: () => {
                        f.forEach((t => t()))
                    }
                }
            }
        },
        4376: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    x: () => a
                }), 179 == i.j) var s = i(3206);
            if (179 == i.j) var r = i(7198);
            if (179 == i.j) var n = i(1962);

            function a(t, e, i) {
                let a, o = 0,
                    l = [],
                    c = 0;
                const u = [],
                    {
                        stop: d
                    } = (0, s.O)(t, e, "message", (({
                        data: t
                    }) => {
                        if ("wrote" !== t.type || t.streamId !== i) return;
                        o += t.additionalBytesCount, l.push(t.result), a = t.trailer;
                        const e = u.shift();
                        e && e.id === t.id ? e.writeCallback ? e.writeCallback(t.result.byteLength) : e.finishCallback && e.finishCallback() : (d(), (0, r.eJ)("Worker responses received out of order."))
                    }));

                function h() {
                    const t = 0 === l.length ? new Uint8Array(0) : (0, n.Kb)(l.concat(a)),
                        e = {
                            rawBytesCount: o,
                            output: t,
                            outputBytesCount: t.byteLength,
                            encoding: "deflate"
                        };
                    return o = 0, l = [], e
                }

                function f() {
                    c > 0 && (e.postMessage({
                        action: "reset",
                        streamId: i
                    }), c = 0)
                }
                return {
                    isAsync: !0,
                    get isEmpty() {
                        return 0 === c
                    },
                    write(t, s) {
                        e.postMessage({
                            action: "write",
                            id: c,
                            data: t,
                            streamId: i
                        }), u.push({
                            id: c,
                            writeCallback: s,
                            data: t
                        }), c += 1
                    },
                    finish(t) {
                        f(), u.length ? (u.forEach((t => {
                            delete t.writeCallback
                        })), u[u.length - 1].finishCallback = () => t(h())) : t(h())
                    },
                    finishSync() {
                        f();
                        const t = u.map((t => (delete t.writeCallback, delete t.finishCallback, t.data))).join("");
                        return { ...h(),
                            pendingData: t
                        }
                    },
                    estimateEncodedBytesCount: t => t.length / 8,
                    stop() {
                        d()
                    }
                }
            }
        },
        8478: (t, e, i) => {
            "use strict";
            i.r(e), i.d(e, {
                DEFAULT_RUM_PROFILER_CONFIGURATION: () => y,
                createRumProfiler: () => v
            });
            var s = i(3206),
                r = i(5026),
                n = i(9271),
                a = i(4933),
                o = i(3842),
                l = i(5483),
                c = i(782),
                u = i(8873);
            const d = new Map;

            function h(t) {
                for (const e of d.keys()) e < t && d.delete(e)
            }
            var f = i(7198),
                p = i(5528);
            const g = {
                sendProfile: (t, e, i) => {
                    const {
                        profilingEndpointBuilder: s,
                        applicationId: n
                    } = e, a = function(t, e, i) {
                        const s = (0, p.MS)(e),
                            n = function(t, e, i) {
                                const s = {
                                    application: {
                                        id: e
                                    }
                                };
                                i && (s.session = {
                                    id: i
                                });
                                const r = Array.from(new Set(t.views.map((t => t.viewId))));
                                r.length && (s.view = {
                                    id: r
                                });
                                const n = t.longTasks.map((t => t.id)).filter((t => void 0 !== t));
                                return n.length && (s.long_task = {
                                    id: n
                                }), s
                            }(t, e.applicationId, i),
                            a = function(t) {
                                return t.concat(["language:javascript", "runtime:chrome", "family:chrome", "host:browser"])
                            }(s);
                        return { ...n,
                            attachments: ["wall-time.json"],
                            start: new Date(t.startClocks.timeStamp).toISOString(),
                            end: new Date(t.endClocks.timeStamp).toISOString(),
                            family: "chrome",
                            runtime: "chrome",
                            format: "json",
                            version: 4,
                            tags_profiler: a.join(","),
                            _dd: {
                                clock_drift: (0, r.QA)()
                            }
                        }
                    }(t, e, i), o = function(t, e) {
                        const i = new Blob([JSON.stringify(t)], {
                                type: "application/json"
                            }),
                            s = new FormData;
                        return s.append("event", new Blob([JSON.stringify(e)], {
                            type: "application/json"
                        }), "event.json"), s.append("wall-time.json", i, "wall-time.json"), {
                            data: s,
                            bytesCount: 0
                        }
                    }(t, a), l = s.build("fetch", o);
                    return (0, f.eJ)("Sending profile to public profiling intake", {
                        profilingIntakeURL: l,
                        applicationId: n,
                        sessionId: i
                    }), fetch(l, {
                        body: o.data,
                        method: "POST"
                    })
                }
            };
            var m = i(4996);
            const y = {
                sampleIntervalMs: 10,
                collectIntervalMs: 6e4,
                minProfileDurationMs: 5e3,
                minNumberOfSamples: 50
            };

            function v(t, e, i, f, p = y) {
                const v = (0, c.wM)(c.uo.LONG_ANIMATION_FRAME);
                let b;
                const T = [];
                let E = {
                    state: "stopped"
                };

                function S() {
                    const i = (0, n.R)().Profiler;
                    if (!i) throw f.set({
                        status: "error",
                        error_reason: "not-supported-by-browser"
                    }), new Error("RUM Profiler is not supported in this browser.");
                    w(E).catch(a.$y);
                    const {
                        cleanupTasks: s,
                        observer: u
                    } = function(i) {
                        if ("running" === i.state) return {
                            cleanupTasks: i.cleanupTasks,
                            observer: i.observer
                        };
                        const s = [];
                        let r;
                        if (t.trackLongTasks) {
                            r = new PerformanceObserver(L), r.observe({
                                entryTypes: [v ? "long-animation-frame" : "longtask"]
                            });
                            const t = e.subscribe(12, (t => {
                                ! function({
                                    rawRumEvent: t,
                                    startTime: e
                                }) {
                                    t.type === c.D$.LONG_TASK && function(t, e) {
                                        d.set(e, t)
                                    }(t.long_task.id, e)
                                }(t)
                            }));
                            s.push((() => null == r ? void 0 : r.disconnect())), s.push(t.unsubscribe)
                        }
                        const n = e.subscribe(2, (t => {
                            const e = {
                                viewId: t.id,
                                viewName: (0, m.M)(t.name, document.location.pathname),
                                startClocks: t.startClocks
                            };
                            A(e), b = e
                        }));
                        return s.push(n.unsubscribe), {
                            cleanupTasks: s,
                            observer: r
                        }
                    }(E);
                    let h;
                    try {
                        h = new i({
                            sampleInterval: p.sampleIntervalMs,
                            maxBufferSize: Math.round(1.5 * p.collectIntervalMs / p.sampleIntervalMs)
                        })
                    } catch (t) {
                        return void(t instanceof Error && t.message.includes("disabled by Document Policy") ? (o.jf.warn("[DD_RUM] Profiler startup failed. Ensure your server includes the `Document-Policy: js-profiling` response header when serving HTML pages.", t), f.set({
                            status: "error",
                            error_reason: "missing-document-policy-header"
                        })) : f.set({
                            status: "error",
                            error_reason: "unexpected-exception"
                        }))
                    }
                    f.set({
                        status: "running",
                        error_reason: void 0
                    }), E = {
                        state: "running",
                        startClocks: (0, r.$I)(),
                        profiler: h,
                        timeoutId: (0, l.iK)(S, p.collectIntervalMs),
                        longTasks: [],
                        views: [],
                        cleanupTasks: s,
                        observer: u
                    }, A(b), h.addEventListener("samplebufferfull", _)
                }
                async function w(e) {
                    var s, n;
                    if ("running" !== e.state) return;
                    R(null !== (n = null === (s = e.observer) || void 0 === s ? void 0 : s.takeRecords()) && void 0 !== n ? n : []), (0, l.gr)(e.timeoutId), e.profiler.removeEventListener("samplebufferfull", _);
                    const {
                        startClocks: o,
                        longTasks: c,
                        views: d
                    } = e, f = (0, r.$I)();
                    await e.profiler.stop().then((e => {
                        const s = (0, r.$I)(),
                            n = c.length > 0,
                            l = (0, r._J)(o.timeStamp, s.timeStamp) < p.minProfileDurationMs,
                            m = (0, u.G)(e.samples) < p.minNumberOfSamples;
                        (n || !l && !m) && (function(e) {
                            var s;
                            const r = null === (s = i.findTrackedSession()) || void 0 === s ? void 0 : s.id;
                            g.sendProfile(e, t, r).catch(a.$y)
                        }(Object.assign(e, {
                            startClocks: o,
                            endClocks: s,
                            clocksOrigin: (0, r.cQ)(),
                            longTasks: c,
                            views: d,
                            sampleInterval: p.sampleIntervalMs
                        })), h(f.relative))
                    })).catch(a.$y)
                }
                async function k(t) {
                    "running" === E.state && (E.cleanupTasks.forEach((t => t())), await w(E), E = {
                        state: t
                    })
                }

                function A(t) {
                    "running" === E.state && t && E.views.push(t)
                }

                function _() {
                    S()
                }

                function L(t) {
                    R(t.getEntries())
                }

                function R(t) {
                    var e;
                    if ("running" === E.state)
                        for (const i of t) {
                            if (i.duration < p.sampleIntervalMs) continue;
                            const t = (0, r.DY)(i.startTime),
                                s = (e = t.relative, d.get(e));
                            E.longTasks.push({
                                id: s,
                                duration: i.duration,
                                entryType: i.entryType,
                                startClocks: t
                            })
                        }
                }

                function I() {
                    "hidden" === document.visibilityState && "running" === E.state ? k("paused").catch(a.$y) : "visible" === document.visibilityState && "paused" === E.state && S()
                }

                function C() {
                    S()
                }
                return {
                    start: function(e) {
                        "running" !== E.state && (b = e ? {
                            startClocks: e.startClocks,
                            viewId: e.id,
                            viewName: (0, m.M)(e.name, document.location.pathname)
                        } : void 0, T.push((0, s.O)(t, window, "visibilitychange", I).stop, (0, s.O)(t, window, "beforeunload", C).stop), S())
                    },
                    stop: async function() {
                        await k("stopped"), T.forEach((t => t())), h((0, r.$I)().relative), f.set({
                            status: "stopped",
                            error_reason: void 0
                        })
                    },
                    isStopped: function() {
                        return "stopped" === E.state
                    },
                    isRunning: function() {
                        return "running" === E.state
                    },
                    isPaused: function() {
                        return "paused" === E.state
                    }
                }
            }
        },
        8491: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    Y: () => r
                }), 179 == i.j) var s = i(9271);

            function r() {
                return void 0 !== (0, s.R)().Profiler
            }
        },
        4996: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    M: () => r
                }), 179 == i.j) var s = i(7593);
            const r = (t, e) => t || (0, s.D)(e)
        },
        7593: (t, e, i) => {
            "use strict";
            i.d(e, {
                D: () => r
            });
            const s = /\/(?![vV]\d{1,2}\/)([^/\d?]*\d+[^/?]*)/g;

            function r(t) {
                return t ? t.replace(s, "/?") : "/"
            }
        },
        8873: (t, e, i) => {
            "use strict";

            function s(t) {
                let e = 0;
                for (const i of t) void 0 !== i.stackId && e++;
                return e
            }
            i.d(e, {
                G: () => s
            })
        },
        5159: (t, e, i) => {
            "use strict";

            function s() {
                const t = new WeakMap;
                return {
                    set(e, i) {
                        (e !== document || document.scrollingElement) && t.set(e === document ? document.scrollingElement : e, i)
                    },
                    get: e => t.get(e),
                    has: e => t.has(e)
                }
            }
            i.d(e, {
                N: () => s
            })
        },
        3156: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    W: () => o
                }), 179 == i.j) var s = i(251);
            if (179 == i.j) var r = i(1337);
            const n = 100,
                a = 16;

            function o(t) {
                let e = s.Z,
                    i = [];

                function o() {
                    e(), t(i), i = []
                }
                const {
                    throttled: l,
                    cancel: c
                } = (0, s.P)(o, a, {
                    leading: !1
                });
                return {
                    addMutations: t => {
                        0 === i.length && (e = (0, r.Kk)(l, {
                            timeout: n
                        })), i.push(...t)
                    },
                    flush: o,
                    stop: () => {
                        e(), c()
                    }
                }
            }
        },
        9411: (t, e, i) => {
            "use strict";

            function s() {
                const t = new WeakMap;
                let e = 1;
                return {
                    getIdForEvent: i => (t.has(i) || t.set(i, e++), t.get(i))
                }
            }
            i.d(e, {
                b: () => s
            })
        },
        1612: (t, e, i) => {
            "use strict";

            function s() {
                return {
                    cssText: {
                        count: 0,
                        max: 0,
                        sum: 0
                    },
                    serializationDuration: {
                        count: 0,
                        max: 0,
                        sum: 0
                    }
                }
            }

            function r(t, e, i) {
                t[e].count += 1, t[e].max = Math.max(t[e].max, i), t[e].sum += i
            }

            function n(t, e) {
                for (const i of ["cssText", "serializationDuration"]) t[i].count += e[i].count, t[i].max = Math.max(t[i].max, e[i].max), t[i].sum += e[i].sum
            }
            i.d(e, {
                ik: () => r,
                mH: () => n,
                mk: () => s
            })
        },
        6084: (t, e, i) => {
            "use strict";

            function s(t) {
                if (void 0 !== t && 0 !== t.length) return t.map((t => {
                    const e = t.cssRules || t.rules;
                    return {
                        cssRules: Array.from(e, (t => t.cssText)),
                        disabled: t.disabled || void 0,
                        media: t.media.length > 0 ? Array.from(t.media) : void 0
                    }
                }))
            }
            i.d(e, {
                x: () => s
            })
        },
        5523: (t, e, i) => {
            "use strict";
            i.d(e, {
                m: () => r,
                n: () => s
            });
            const s = (t, e) => {
                    const i = window.visualViewport,
                        s = {
                            layoutViewportX: t,
                            layoutViewportY: e,
                            visualViewportX: t,
                            visualViewportY: e
                        };
                    return i ? (function(t) {
                        return Math.abs(t.pageTop - t.offsetTop - window.scrollY) > 25 || Math.abs(t.pageLeft - t.offsetLeft - window.scrollX) > 25
                    }(i) ? (s.layoutViewportX = Math.round(t + i.offsetLeft), s.layoutViewportY = Math.round(e + i.offsetTop)) : (s.visualViewportX = Math.round(t - i.offsetLeft), s.visualViewportY = Math.round(e - i.offsetTop)), s) : s
                },
                r = t => ({
                    scale: t.scale,
                    offsetLeft: t.offsetLeft,
                    offsetTop: t.offsetTop,
                    pageLeft: t.pageLeft,
                    pageTop: t.pageTop,
                    height: t.height,
                    width: t.width
                })
        },
        8290: (t, e, i) => {
            "use strict";
            i.d(e, {
                FT: () => n,
                MA: () => c,
                pk: () => l,
                ui: () => a,
                xK: () => o
            });
            const s = 1e3;
            let r;

            function n(t) {
                return u(t).segments_count
            }

            function a(t) {
                u(t).segments_count += 1
            }

            function o(t) {
                u(t).records_count += 1
            }

            function l(t, e) {
                u(t).segments_total_raw_size += e
            }

            function c(t) {
                return null == r ? void 0 : r.get(t)
            }

            function u(t) {
                let e;
                return r || (r = new Map), r.has(t) ? e = r.get(t) : (e = {
                    records_count: 0,
                    segments_count: 0,
                    segments_total_raw_size: 0
                }, r.set(t, e), r.size > s && function() {
                    if (!r) return;
                    const t = r.keys().next().value;
                    t && r.delete(t)
                }()), e
            }
        },
        9833: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    j: () => n
                }), 179 == i.j) var s = i(3842);
            if (179 == i.j) var r = i(7198);

            function n({
                configuredUrl: t,
                error: e,
                source: i,
                scriptType: n
            }) {
                if (s.jf.error(`${i} failed to start: an error occurred while initializing the ${n}:`, e), e instanceof Event || e instanceof Error && ((a = e.message).includes("Content Security Policy") || a.includes("requires 'TrustedScriptURL'"))) {
                    let e;
                    e = t ? `Please make sure the ${n} URL ${t} is correct and CSP is correctly configured.` : "Please make sure CSP is correctly configured.", s.jf.error(`${e} See documentation at ${s.aA}/integrations/content_security_policy_logs/#use-csp-with-real-user-monitoring-and-session-replay`)
                } else "worker" === n && (0, r.Sz)(e);
                var a
            }
        },
        76: (t, e, i) => {
            "use strict";

            function s(t, e, i, s) {
                const r = new FormData;
                r.append("segment", new Blob([t], {
                    type: "application/octet-stream"
                }), `${e.session.id}-${e.start}`);
                const n = {
                        raw_segment_size: s,
                        compressed_segment_size: t.byteLength,
                        ...e
                    },
                    a = JSON.stringify(n);
                return r.append("event", new Blob([a], {
                    type: "application/json"
                })), {
                    data: r,
                    bytesCount: t.byteLength,
                    cssText: i.cssText,
                    isFullSnapshot: 0 === e.index_in_view,
                    rawSize: s,
                    recordCount: e.records_count,
                    serializationDuration: i.serializationDuration
                }
            }
            i.d(e, {
                H: () => s
            })
        },
        1946: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    I: () => o
                }), 179 == i.j) var s = i(3603);
            if (179 == i.j) var r = i(251);
            if (179 == i.j) var n = i(7198);
            const a = "Segment network request metrics";

            function o(t, e, i) {
                if (!e.enabled || !(0, s.y7)(t.replayTelemetrySampleRate)) return {
                    stop: r.Z
                };
                const {
                    unsubscribe: o
                } = i.subscribe((t => {
                    if ("failure" === t.type || "queue-full" === t.type || "success" === t.type && t.payload.isFullSnapshot) {
                        const r = (e = t.type, i = t.bandwidth, {
                            cssText: {
                                count: (s = t.payload).cssText.count,
                                max: s.cssText.max,
                                sum: s.cssText.sum
                            },
                            isFullSnapshot: s.isFullSnapshot,
                            ongoingRequests: {
                                count: i.ongoingRequestCount,
                                totalSize: i.ongoingByteCount
                            },
                            recordCount: s.recordCount,
                            result: e,
                            serializationDuration: {
                                count: s.serializationDuration.count,
                                max: s.serializationDuration.max,
                                sum: s.serializationDuration.sum
                            },
                            size: {
                                compressed: s.bytesCount,
                                raw: s.rawSize
                            }
                        });
                        (0, n.qZ)(a, {
                            metrics: r
                        })
                    }
                    var e, i, s
                }));
                return {
                    stop: o
                }
            }
        },
        9317: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    d: () => r
                }), 179 == i.j) var s = i(6876);

            function r(t) {
                const e = (0, s.Ad)();
                return {
                    addRecord: i => {
                        const s = t.findView();
                        e.send("record", i, s.id)
                    }
                }
            }
        },
        9031: (t, e, i) => {
            "use strict";
            if (i.d(e, {
                    M: () => l
                }), 179 == i.j) var s = i(3603);
            if (179 == i.j) var r = i(251);
            if (179 == i.j) var n = i(5026);
            if (179 == i.j) var a = i(7198);
            const o = "Recorder init metrics";

            function l(t, e, i) {
                if (!e.enabled || !(0, s.y7)(t.replayTelemetrySampleRate)) return {
                    stop: r.Z
                };
                let l, c, u;
                const {
                    unsubscribe: d
                } = i.subscribe((t => {
                    switch (t.type) {
                        case "start":
                            l = {
                                forced: t.forced,
                                timestamp: (0, n.n$)()
                            }, c = void 0, u = void 0;
                            break;
                        case "document-ready":
                            l && (c = (0, n._J)(l.timestamp, (0, n.n$)()));
                            break;
                        case "recorder-settled":
                            l && (u = (0, n._J)(l.timestamp, (0, n.n$)()));
                            break;
                        case "aborted":
                        case "deflate-encoder-load-failed":
                        case "recorder-load-failed":
                        case "succeeded":
                            d(), l && (0, a.qZ)(o, {
                                metrics: (e = l.forced, i = u, s = (0, n._J)(l.timestamp, (0, n.n$)()), r = t.type, h = c, {
                                    forced: e,
                                    loadRecorderModuleDuration: i,
                                    recorderInitDuration: s,
                                    result: r,
                                    waitForDocReadyDuration: h
                                })
                            })
                    }
                    var e, i, s, r, h
                }));
                return {
                    stop: d
                }
            }
        },
        5751: (t, e, i) => {
            "use strict";
            i.d(e, {
                v: () => N
            });
            var s = i(8678),
                r = i(9271),
                n = i(782),
                a = i(6876),
                o = i(251),
                l = i(8290),
                c = i(4376),
                u = i(5026),
                d = i(3206),
                h = i(5483),
                f = i(3842),
                p = i(7198),
                g = i(9833);
            const m = 30 * u.WT;

            function y(t) {
                return new Worker(t.workerUrl || URL.createObjectURL(new Blob(['(()=>{function t(t){const e=t.reduce((t,e)=>t+e.length,0),a=new Uint8Array(e);let n=0;for(const e of t)a.set(e,n),n+=e.length;return a}function e(t){for(var e=t.length;--e>=0;)t[e]=0}var a=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),n=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),r=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),i=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),s=Array(576);e(s);var h=Array(60);e(h);var l=Array(512);e(l);var _=Array(256);e(_);var o=Array(29);e(o);var d,u,f,c=Array(30);function p(t,e,a,n,r){this.static_tree=t,this.extra_bits=e,this.extra_base=a,this.elems=n,this.max_length=r,this.has_stree=t&&t.length}function g(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}e(c);var v=function(t){return t<256?l[t]:l[256+(t>>>7)]},w=function(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255},m=function(t,e,a){t.bi_valid>16-a?(t.bi_buf|=e<<t.bi_valid&65535,w(t,t.bi_buf),t.bi_buf=e>>16-t.bi_valid,t.bi_valid+=a-16):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=a)},b=function(t,e,a){m(t,a[2*e],a[2*e+1])},y=function(t,e){var a=0;do{a|=1&t,t>>>=1,a<<=1}while(--e>0);return a>>>1},z=function(t,e,a){var n,r,i=Array(16),s=0;for(n=1;n<=15;n++)i[n]=s=s+a[n-1]<<1;for(r=0;r<=e;r++){var h=t[2*r+1];0!==h&&(t[2*r]=y(i[h]++,h))}},k=function(t){var e;for(e=0;e<286;e++)t.dyn_ltree[2*e]=0;for(e=0;e<30;e++)t.dyn_dtree[2*e]=0;for(e=0;e<19;e++)t.bl_tree[2*e]=0;t.dyn_ltree[512]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0},x=function(t){t.bi_valid>8?w(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0},A=function(t,e,a,n){var r=2*e,i=2*a;return t[r]<t[i]||t[r]===t[i]&&n[e]<=n[a]},U=function(t,e,a){for(var n=t.heap[a],r=a<<1;r<=t.heap_len&&(r<t.heap_len&&A(e,t.heap[r+1],t.heap[r],t.depth)&&r++,!A(e,n,t.heap[r],t.depth));)t.heap[a]=t.heap[r],a=r,r<<=1;t.heap[a]=n},B=function(t,e,r){var i,s,h,l,d=0;if(0!==t.last_lit)do{i=t.pending_buf[t.d_buf+2*d]<<8|t.pending_buf[t.d_buf+2*d+1],s=t.pending_buf[t.l_buf+d],d++,0===i?b(t,s,e):(h=_[s],b(t,h+256+1,e),0!==(l=a[h])&&(s-=o[h],m(t,s,l)),i--,h=v(i),b(t,h,r),0!==(l=n[h])&&(i-=c[h],m(t,i,l)))}while(d<t.last_lit);b(t,256,e)},I=function(t,e){var a,n,r,i=e.dyn_tree,s=e.stat_desc.static_tree,h=e.stat_desc.has_stree,l=e.stat_desc.elems,_=-1;for(t.heap_len=0,t.heap_max=573,a=0;a<l;a++)0!==i[2*a]?(t.heap[++t.heap_len]=_=a,t.depth[a]=0):i[2*a+1]=0;for(;t.heap_len<2;)i[2*(r=t.heap[++t.heap_len]=_<2?++_:0)]=1,t.depth[r]=0,t.opt_len--,h&&(t.static_len-=s[2*r+1]);for(e.max_code=_,a=t.heap_len>>1;a>=1;a--)U(t,i,a);r=l;do{a=t.heap[1],t.heap[1]=t.heap[t.heap_len--],U(t,i,1),n=t.heap[1],t.heap[--t.heap_max]=a,t.heap[--t.heap_max]=n,i[2*r]=i[2*a]+i[2*n],t.depth[r]=(t.depth[a]>=t.depth[n]?t.depth[a]:t.depth[n])+1,i[2*a+1]=i[2*n+1]=r,t.heap[1]=r++,U(t,i,1)}while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],function(t,e){var a,n,r,i,s,h,l=e.dyn_tree,_=e.max_code,o=e.stat_desc.static_tree,d=e.stat_desc.has_stree,u=e.stat_desc.extra_bits,f=e.stat_desc.extra_base,c=e.stat_desc.max_length,p=0;for(i=0;i<=15;i++)t.bl_count[i]=0;for(l[2*t.heap[t.heap_max]+1]=0,a=t.heap_max+1;a<573;a++)(i=l[2*l[2*(n=t.heap[a])+1]+1]+1)>c&&(i=c,p++),l[2*n+1]=i,n>_||(t.bl_count[i]++,s=0,n>=f&&(s=u[n-f]),h=l[2*n],t.opt_len+=h*(i+s),d&&(t.static_len+=h*(o[2*n+1]+s)));if(0!==p){do{for(i=c-1;0===t.bl_count[i];)i--;t.bl_count[i]--,t.bl_count[i+1]+=2,t.bl_count[c]--,p-=2}while(p>0);for(i=c;0!==i;i--)for(n=t.bl_count[i];0!==n;)(r=t.heap[--a])>_||(l[2*r+1]!==i&&(t.opt_len+=(i-l[2*r+1])*l[2*r],l[2*r+1]=i),n--)}}(t,e),z(i,_,t.bl_count)},E=function(t,e,a){var n,r,i=-1,s=e[1],h=0,l=7,_=4;for(0===s&&(l=138,_=3),e[2*(a+1)+1]=65535,n=0;n<=a;n++)r=s,s=e[2*(n+1)+1],++h<l&&r===s||(h<_?t.bl_tree[2*r]+=h:0!==r?(r!==i&&t.bl_tree[2*r]++,t.bl_tree[32]++):h<=10?t.bl_tree[34]++:t.bl_tree[36]++,h=0,i=r,0===s?(l=138,_=3):r===s?(l=6,_=3):(l=7,_=4))},C=function(t,e,a){var n,r,i=-1,s=e[1],h=0,l=7,_=4;for(0===s&&(l=138,_=3),n=0;n<=a;n++)if(r=s,s=e[2*(n+1)+1],!(++h<l&&r===s)){if(h<_)do{b(t,r,t.bl_tree)}while(0!==--h);else 0!==r?(r!==i&&(b(t,r,t.bl_tree),h--),b(t,16,t.bl_tree),m(t,h-3,2)):h<=10?(b(t,17,t.bl_tree),m(t,h-3,3)):(b(t,18,t.bl_tree),m(t,h-11,7));h=0,i=r,0===s?(l=138,_=3):r===s?(l=6,_=3):(l=7,_=4)}},D=!1,M=function(t,e,a,n){m(t,0+(n?1:0),3),function(t,e,a){x(t),w(t,a),w(t,~a),t.pending_buf.set(t.window.subarray(e,e+a),t.pending),t.pending+=a}(t,e,a)},j=M,L=function(t,e,a,n){for(var r=65535&t,i=t>>>16&65535,s=0;0!==a;){a-=s=a>2e3?2e3:a;do{i=i+(r=r+e[n++]|0)|0}while(--s);r%=65521,i%=65521}return r|i<<16},S=new Uint32Array(function(){for(var t,e=[],a=0;a<256;a++){t=a;for(var n=0;n<8;n++)t=1&t?3988292384^t>>>1:t>>>1;e[a]=t}return e}()),T=function(t,e,a,n){var r=S,i=n+a;t^=-1;for(var s=n;s<i;s++)t=t>>>8^r[255&(t^e[s])];return-1^t},O={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},q=j,F=function(t,e,a){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&a,t.last_lit++,0===e?t.dyn_ltree[2*a]++:(t.matches++,e--,t.dyn_ltree[2*(_[a]+256+1)]++,t.dyn_dtree[2*v(e)]++),t.last_lit===t.lit_bufsize-1},G=-2,H=258,J=262,K=103,N=113,P=666,Q=function(t,e){return t.msg=O[e],e},R=function(t){return(t<<1)-(t>4?9:0)},V=function(t){for(var e=t.length;--e>=0;)t[e]=0},W=function(t,e,a){return(e<<t.hash_shift^a)&t.hash_mask},X=function(t){var e=t.state,a=e.pending;a>t.avail_out&&(a=t.avail_out),0!==a&&(t.output.set(e.pending_buf.subarray(e.pending_out,e.pending_out+a),t.next_out),t.next_out+=a,e.pending_out+=a,t.total_out+=a,t.avail_out-=a,e.pending-=a,0===e.pending&&(e.pending_out=0))},Y=function(t,e){(function(t,e,a,n){var r,l,_=0;t.level>0?(2===t.strm.data_type&&(t.strm.data_type=function(t){var e,a=4093624447;for(e=0;e<=31;e++,a>>>=1)if(1&a&&0!==t.dyn_ltree[2*e])return 0;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return 1;for(e=32;e<256;e++)if(0!==t.dyn_ltree[2*e])return 1;return 0}(t)),I(t,t.l_desc),I(t,t.d_desc),_=function(t){var e;for(E(t,t.dyn_ltree,t.l_desc.max_code),E(t,t.dyn_dtree,t.d_desc.max_code),I(t,t.bl_desc),e=18;e>=3&&0===t.bl_tree[2*i[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(t),r=t.opt_len+3+7>>>3,(l=t.static_len+3+7>>>3)<=r&&(r=l)):r=l=a+5,a+4<=r&&-1!==e?M(t,e,a,n):4===t.strategy||l===r?(m(t,2+(n?1:0),3),B(t,s,h)):(m(t,4+(n?1:0),3),function(t,e,a,n){var r;for(m(t,e-257,5),m(t,a-1,5),m(t,n-4,4),r=0;r<n;r++)m(t,t.bl_tree[2*i[r]+1],3);C(t,t.dyn_ltree,e-1),C(t,t.dyn_dtree,a-1)}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,_+1),B(t,t.dyn_ltree,t.dyn_dtree)),k(t),n&&x(t)})(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,X(t.strm)},Z=function(t,e){t.pending_buf[t.pending++]=e},$=function(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e},tt=function(t,e,a,n){var r=t.avail_in;return r>n&&(r=n),0===r?0:(t.avail_in-=r,e.set(t.input.subarray(t.next_in,t.next_in+r),a),1===t.state.wrap?t.adler=L(t.adler,e,r,a):2===t.state.wrap&&(t.adler=T(t.adler,e,r,a)),t.next_in+=r,t.total_in+=r,r)},et=function(t,e){var a,n,r=t.max_chain_length,i=t.strstart,s=t.prev_length,h=t.nice_match,l=t.strstart>t.w_size-J?t.strstart-(t.w_size-J):0,_=t.window,o=t.w_mask,d=t.prev,u=t.strstart+H,f=_[i+s-1],c=_[i+s];t.prev_length>=t.good_match&&(r>>=2),h>t.lookahead&&(h=t.lookahead);do{if(_[(a=e)+s]===c&&_[a+s-1]===f&&_[a]===_[i]&&_[++a]===_[i+1]){i+=2,a++;do{}while(_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&i<u);if(n=H-(u-i),i=u-H,n>s){if(t.match_start=e,s=n,n>=h)break;f=_[i+s-1],c=_[i+s]}}}while((e=d[e&o])>l&&0!==--r);return s<=t.lookahead?s:t.lookahead},at=function(t){var e,a,n,r,i,s=t.w_size;do{if(r=t.window_size-t.lookahead-t.strstart,t.strstart>=s+(s-J)){t.window.set(t.window.subarray(s,s+s),0),t.match_start-=s,t.strstart-=s,t.block_start-=s,e=a=t.hash_size;do{n=t.head[--e],t.head[e]=n>=s?n-s:0}while(--a);e=a=s;do{n=t.prev[--e],t.prev[e]=n>=s?n-s:0}while(--a);r+=s}if(0===t.strm.avail_in)break;if(a=tt(t.strm,t.window,t.strstart+t.lookahead,r),t.lookahead+=a,t.lookahead+t.insert>=3)for(i=t.strstart-t.insert,t.ins_h=t.window[i],t.ins_h=W(t,t.ins_h,t.window[i+1]);t.insert&&(t.ins_h=W(t,t.ins_h,t.window[i+3-1]),t.prev[i&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=i,i++,t.insert--,!(t.lookahead+t.insert<3)););}while(t.lookahead<J&&0!==t.strm.avail_in)},nt=function(t,e){for(var a,n;;){if(t.lookahead<J){if(at(t),t.lookahead<J&&0===e)return 1;if(0===t.lookahead)break}if(a=0,t.lookahead>=3&&(t.ins_h=W(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==a&&t.strstart-a<=t.w_size-J&&(t.match_length=et(t,a)),t.match_length>=3)if(n=F(t,t.strstart-t.match_start,t.match_length-3),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=3){t.match_length--;do{t.strstart++,t.ins_h=W(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart}while(0!==--t.match_length);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=W(t,t.ins_h,t.window[t.strstart+1]);else n=F(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(n&&(Y(t,!1),0===t.strm.avail_out))return 1}return t.insert=t.strstart<2?t.strstart:2,4===e?(Y(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(Y(t,!1),0===t.strm.avail_out)?1:2},rt=function(t,e){for(var a,n,r;;){if(t.lookahead<J){if(at(t),t.lookahead<J&&0===e)return 1;if(0===t.lookahead)break}if(a=0,t.lookahead>=3&&(t.ins_h=W(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=2,0!==a&&t.prev_length<t.max_lazy_match&&t.strstart-a<=t.w_size-J&&(t.match_length=et(t,a),t.match_length<=5&&(1===t.strategy||3===t.match_length&&t.strstart-t.match_start>4096)&&(t.match_length=2)),t.prev_length>=3&&t.match_length<=t.prev_length){r=t.strstart+t.lookahead-3,n=F(t,t.strstart-1-t.prev_match,t.prev_length-3),t.lookahead-=t.prev_length-1,t.prev_length-=2;do{++t.strstart<=r&&(t.ins_h=W(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart)}while(0!==--t.prev_length);if(t.match_available=0,t.match_length=2,t.strstart++,n&&(Y(t,!1),0===t.strm.avail_out))return 1}else if(t.match_available){if((n=F(t,0,t.window[t.strstart-1]))&&Y(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return 1}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(n=F(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<2?t.strstart:2,4===e?(Y(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(Y(t,!1),0===t.strm.avail_out)?1:2};function it(t,e,a,n,r){this.good_length=t,this.max_lazy=e,this.nice_length=a,this.max_chain=n,this.func=r}var st=[new it(0,0,0,0,function(t,e){var a=65535;for(a>t.pending_buf_size-5&&(a=t.pending_buf_size-5);;){if(t.lookahead<=1){if(at(t),0===t.lookahead&&0===e)return 1;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var n=t.block_start+a;if((0===t.strstart||t.strstart>=n)&&(t.lookahead=t.strstart-n,t.strstart=n,Y(t,!1),0===t.strm.avail_out))return 1;if(t.strstart-t.block_start>=t.w_size-J&&(Y(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,4===e?(Y(t,!0),0===t.strm.avail_out?3:4):(t.strstart>t.block_start&&(Y(t,!1),t.strm.avail_out),1)}),new it(4,4,8,4,nt),new it(4,5,16,8,nt),new it(4,6,32,32,nt),new it(4,4,16,16,rt),new it(8,16,32,32,rt),new it(8,16,128,128,rt),new it(8,32,128,256,rt),new it(32,128,258,1024,rt),new it(32,258,258,4096,rt)];function ht(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=8,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),V(this.dyn_ltree),V(this.dyn_dtree),V(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),V(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),V(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}for(var lt=function(t){var e,i=function(t){if(!t||!t.state)return Q(t,G);t.total_in=t.total_out=0,t.data_type=2;var e=t.state;return e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?42:N,t.adler=2===e.wrap?0:1,e.last_flush=0,function(t){D||(function(){var t,e,i,g,v,w=Array(16);for(i=0,g=0;g<28;g++)for(o[g]=i,t=0;t<1<<a[g];t++)_[i++]=g;for(_[i-1]=g,v=0,g=0;g<16;g++)for(c[g]=v,t=0;t<1<<n[g];t++)l[v++]=g;for(v>>=7;g<30;g++)for(c[g]=v<<7,t=0;t<1<<n[g]-7;t++)l[256+v++]=g;for(e=0;e<=15;e++)w[e]=0;for(t=0;t<=143;)s[2*t+1]=8,t++,w[8]++;for(;t<=255;)s[2*t+1]=9,t++,w[9]++;for(;t<=279;)s[2*t+1]=7,t++,w[7]++;for(;t<=287;)s[2*t+1]=8,t++,w[8]++;for(z(s,287,w),t=0;t<30;t++)h[2*t+1]=5,h[2*t]=y(t,5);d=new p(s,a,257,286,15),u=new p(h,n,0,30,15),f=new p([],r,0,19,7)}(),D=!0),t.l_desc=new g(t.dyn_ltree,d),t.d_desc=new g(t.dyn_dtree,u),t.bl_desc=new g(t.bl_tree,f),t.bi_buf=0,t.bi_valid=0,k(t)}(e),0}(t);return 0===i&&((e=t.state).window_size=2*e.w_size,V(e.head),e.max_lazy_match=st[e.level].max_lazy,e.good_match=st[e.level].good_length,e.nice_match=st[e.level].nice_length,e.max_chain_length=st[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=2,e.match_available=0,e.ins_h=0),i},_t=function(t,e){var a,n;if(!t||!t.state||e>5||e<0)return t?Q(t,G):G;var r=t.state;if(!t.output||!t.input&&0!==t.avail_in||r.status===P&&4!==e)return Q(t,0===t.avail_out?-5:G);r.strm=t;var i=r.last_flush;if(r.last_flush=e,42===r.status)if(2===r.wrap)t.adler=0,Z(r,31),Z(r,139),Z(r,8),r.gzhead?(Z(r,(r.gzhead.text?1:0)+(r.gzhead.hcrc?2:0)+(r.gzhead.extra?4:0)+(r.gzhead.name?8:0)+(r.gzhead.comment?16:0)),Z(r,255&r.gzhead.time),Z(r,r.gzhead.time>>8&255),Z(r,r.gzhead.time>>16&255),Z(r,r.gzhead.time>>24&255),Z(r,9===r.level?2:r.strategy>=2||r.level<2?4:0),Z(r,255&r.gzhead.os),r.gzhead.extra&&r.gzhead.extra.length&&(Z(r,255&r.gzhead.extra.length),Z(r,r.gzhead.extra.length>>8&255)),r.gzhead.hcrc&&(t.adler=T(t.adler,r.pending_buf,r.pending,0)),r.gzindex=0,r.status=69):(Z(r,0),Z(r,0),Z(r,0),Z(r,0),Z(r,0),Z(r,9===r.level?2:r.strategy>=2||r.level<2?4:0),Z(r,3),r.status=N);else{var h=8+(r.w_bits-8<<4)<<8;h|=(r.strategy>=2||r.level<2?0:r.level<6?1:6===r.level?2:3)<<6,0!==r.strstart&&(h|=32),h+=31-h%31,r.status=N,$(r,h),0!==r.strstart&&($(r,t.adler>>>16),$(r,65535&t.adler)),t.adler=1}if(69===r.status)if(r.gzhead.extra){for(a=r.pending;r.gzindex<(65535&r.gzhead.extra.length)&&(r.pending!==r.pending_buf_size||(r.gzhead.hcrc&&r.pending>a&&(t.adler=T(t.adler,r.pending_buf,r.pending-a,a)),X(t),a=r.pending,r.pending!==r.pending_buf_size));)Z(r,255&r.gzhead.extra[r.gzindex]),r.gzindex++;r.gzhead.hcrc&&r.pending>a&&(t.adler=T(t.adler,r.pending_buf,r.pending-a,a)),r.gzindex===r.gzhead.extra.length&&(r.gzindex=0,r.status=73)}else r.status=73;if(73===r.status)if(r.gzhead.name){a=r.pending;do{if(r.pending===r.pending_buf_size&&(r.gzhead.hcrc&&r.pending>a&&(t.adler=T(t.adler,r.pending_buf,r.pending-a,a)),X(t),a=r.pending,r.pending===r.pending_buf_size)){n=1;break}n=r.gzindex<r.gzhead.name.length?255&r.gzhead.name.charCodeAt(r.gzindex++):0,Z(r,n)}while(0!==n);r.gzhead.hcrc&&r.pending>a&&(t.adler=T(t.adler,r.pending_buf,r.pending-a,a)),0===n&&(r.gzindex=0,r.status=91)}else r.status=91;if(91===r.status)if(r.gzhead.comment){a=r.pending;do{if(r.pending===r.pending_buf_size&&(r.gzhead.hcrc&&r.pending>a&&(t.adler=T(t.adler,r.pending_buf,r.pending-a,a)),X(t),a=r.pending,r.pending===r.pending_buf_size)){n=1;break}n=r.gzindex<r.gzhead.comment.length?255&r.gzhead.comment.charCodeAt(r.gzindex++):0,Z(r,n)}while(0!==n);r.gzhead.hcrc&&r.pending>a&&(t.adler=T(t.adler,r.pending_buf,r.pending-a,a)),0===n&&(r.status=K)}else r.status=K;if(r.status===K&&(r.gzhead.hcrc?(r.pending+2>r.pending_buf_size&&X(t),r.pending+2<=r.pending_buf_size&&(Z(r,255&t.adler),Z(r,t.adler>>8&255),t.adler=0,r.status=N)):r.status=N),0!==r.pending){if(X(t),0===t.avail_out)return r.last_flush=-1,0}else if(0===t.avail_in&&R(e)<=R(i)&&4!==e)return Q(t,-5);if(r.status===P&&0!==t.avail_in)return Q(t,-5);if(0!==t.avail_in||0!==r.lookahead||0!==e&&r.status!==P){var l=2===r.strategy?function(t,e){for(var a;;){if(0===t.lookahead&&(at(t),0===t.lookahead)){if(0===e)return 1;break}if(t.match_length=0,a=F(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,a&&(Y(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,4===e?(Y(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(Y(t,!1),0===t.strm.avail_out)?1:2}(r,e):3===r.strategy?function(t,e){for(var a,n,r,i,s=t.window;;){if(t.lookahead<=H){if(at(t),t.lookahead<=H&&0===e)return 1;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=3&&t.strstart>0&&(n=s[r=t.strstart-1])===s[++r]&&n===s[++r]&&n===s[++r]){i=t.strstart+H;do{}while(n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&r<i);t.match_length=H-(i-r),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=3?(a=F(t,1,t.match_length-3),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(a=F(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),a&&(Y(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,4===e?(Y(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(Y(t,!1),0===t.strm.avail_out)?1:2}(r,e):st[r.level].func(r,e);if(3!==l&&4!==l||(r.status=P),1===l||3===l)return 0===t.avail_out&&(r.last_flush=-1),0;if(2===l&&(1===e?function(t){m(t,2,3),b(t,256,s),function(t){16===t.bi_valid?(w(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}(t)}(r):5!==e&&(q(r,0,0,!1),3===e&&(V(r.head),0===r.lookahead&&(r.strstart=0,r.block_start=0,r.insert=0))),X(t),0===t.avail_out))return r.last_flush=-1,0}return 4!==e?0:r.wrap<=0?1:(2===r.wrap?(Z(r,255&t.adler),Z(r,t.adler>>8&255),Z(r,t.adler>>16&255),Z(r,t.adler>>24&255),Z(r,255&t.total_in),Z(r,t.total_in>>8&255),Z(r,t.total_in>>16&255),Z(r,t.total_in>>24&255)):($(r,t.adler>>>16),$(r,65535&t.adler)),X(t),r.wrap>0&&(r.wrap=-r.wrap),0!==r.pending?0:1)},ot=function(t){if(!t||!t.state)return G;var e=t.state.status;return 42!==e&&69!==e&&73!==e&&91!==e&&e!==K&&e!==N&&e!==P?Q(t,G):(t.state=null,e===N?Q(t,-3):0)},dt=new Uint8Array(256),ut=0;ut<256;ut++)dt[ut]=ut>=252?6:ut>=248?5:ut>=240?4:ut>=224?3:ut>=192?2:1;dt[254]=dt[254]=1;var ft=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},ct=Object.prototype.toString;function pt(){this.options={level:-1,method:8,chunkSize:16384,windowBits:15,memLevel:8,strategy:0};var t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new ft,this.strm.avail_out=0;var e,a,n=function(t,e,a,n,r,i){if(!t)return G;var s=1;if(-1===e&&(e=6),n<0?(s=0,n=-n):n>15&&(s=2,n-=16),r<1||r>9||8!==a||n<8||n>15||e<0||e>9||i<0||i>4)return Q(t,G);8===n&&(n=9);var h=new ht;return t.state=h,h.strm=t,h.wrap=s,h.gzhead=null,h.w_bits=n,h.w_size=1<<h.w_bits,h.w_mask=h.w_size-1,h.hash_bits=r+7,h.hash_size=1<<h.hash_bits,h.hash_mask=h.hash_size-1,h.hash_shift=~~((h.hash_bits+3-1)/3),h.window=new Uint8Array(2*h.w_size),h.head=new Uint16Array(h.hash_size),h.prev=new Uint16Array(h.w_size),h.lit_bufsize=1<<r+6,h.pending_buf_size=4*h.lit_bufsize,h.pending_buf=new Uint8Array(h.pending_buf_size),h.d_buf=1*h.lit_bufsize,h.l_buf=3*h.lit_bufsize,h.level=e,h.strategy=i,h.method=a,lt(t)}(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(0!==n)throw Error(O[n]);if(t.header&&(e=this.strm,a=t.header,e&&e.state&&(2!==e.state.wrap||(e.state.gzhead=a))),t.dictionary){var r;if(r="[object ArrayBuffer]"===ct.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,0!==(n=function(t,e){var a=e.length;if(!t||!t.state)return G;var n=t.state,r=n.wrap;if(2===r||1===r&&42!==n.status||n.lookahead)return G;if(1===r&&(t.adler=L(t.adler,e,a,0)),n.wrap=0,a>=n.w_size){0===r&&(V(n.head),n.strstart=0,n.block_start=0,n.insert=0);var i=new Uint8Array(n.w_size);i.set(e.subarray(a-n.w_size,a),0),e=i,a=n.w_size}var s=t.avail_in,h=t.next_in,l=t.input;for(t.avail_in=a,t.next_in=0,t.input=e,at(n);n.lookahead>=3;){var _=n.strstart,o=n.lookahead-2;do{n.ins_h=W(n,n.ins_h,n.window[_+3-1]),n.prev[_&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=_,_++}while(--o);n.strstart=_,n.lookahead=2,at(n)}return n.strstart+=n.lookahead,n.block_start=n.strstart,n.insert=n.lookahead,n.lookahead=0,n.match_length=n.prev_length=2,n.match_available=0,t.next_in=h,t.input=l,t.avail_in=s,n.wrap=r,0}(this.strm,r)))throw Error(O[n]);this._dict_set=!0}}function gt(t,e,a){try{t.postMessage({type:"errored",error:e,streamId:a})}catch(n){t.postMessage({type:"errored",error:e+"",streamId:a})}}function vt(t){const e=t.strm.adler;return new Uint8Array([3,0,e>>>24&255,e>>>16&255,e>>>8&255,255&e])}pt.prototype.push=function(t,e){var a,n,r=this.strm,i=this.options.chunkSize;if(this.ended)return!1;for(n=e===~~e?e:!0===e?4:0,"[object ArrayBuffer]"===ct.call(t)?r.input=new Uint8Array(t):r.input=t,r.next_in=0,r.avail_in=r.input.length;;)if(0===r.avail_out&&(r.output=new Uint8Array(i),r.next_out=0,r.avail_out=i),(2===n||3===n)&&r.avail_out<=6)this.onData(r.output.subarray(0,r.next_out)),r.avail_out=0;else{if(1===(a=_t(r,n)))return r.next_out>0&&this.onData(r.output.subarray(0,r.next_out)),a=ot(this.strm),this.onEnd(a),this.ended=!0,0===a;if(0!==r.avail_out){if(n>0&&r.next_out>0)this.onData(r.output.subarray(0,r.next_out)),r.avail_out=0;else if(0===r.avail_in)break}else this.onData(r.output)}return!0},pt.prototype.onData=function(t){this.chunks.push(t)},pt.prototype.onEnd=function(t){0===t&&(this.result=function(t){for(var e=0,a=0,n=t.length;a<n;a++)e+=t[a].length;for(var r=new Uint8Array(e),i=0,s=0,h=t.length;i<h;i++){var l=t[i];r.set(l,s),s+=l.length}return r}(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},function(e=self){try{const a=new Map;e.addEventListener("message",n=>{try{const r=function(e,a){switch(a.action){case"init":return{type:"initialized",version:"6.18.1"};case"write":{let n=e.get(a.streamId);n||(n=new pt,e.set(a.streamId,n));const r=n.chunks.length,i=function(t){if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(t);let e,a,n,r,i,s=t.length,h=0;for(r=0;r<s;r++)a=t.charCodeAt(r),55296==(64512&a)&&r+1<s&&(n=t.charCodeAt(r+1),56320==(64512&n)&&(a=65536+(a-55296<<10)+(n-56320),r++)),h+=a<128?1:a<2048?2:a<65536?3:4;for(e=new Uint8Array(h),i=0,r=0;i<h;r++)a=t.charCodeAt(r),55296==(64512&a)&&r+1<s&&(n=t.charCodeAt(r+1),56320==(64512&n)&&(a=65536+(a-55296<<10)+(n-56320),r++)),a<128?e[i++]=a:a<2048?(e[i++]=192|a>>>6,e[i++]=128|63&a):a<65536?(e[i++]=224|a>>>12,e[i++]=128|a>>>6&63,e[i++]=128|63&a):(e[i++]=240|a>>>18,e[i++]=128|a>>>12&63,e[i++]=128|a>>>6&63,e[i++]=128|63&a);return e}(a.data);return n.push(i,2),{type:"wrote",id:a.id,streamId:a.streamId,result:t(n.chunks.slice(r)),trailer:vt(n),additionalBytesCount:i.length}}case"reset":e.delete(a.streamId)}}(a,n.data);r&&e.postMessage(r)}catch(t){gt(e,t,n.data&&"streamId"in n.data?n.data.streamId:void 0)}})}catch(t){gt(e,t)}}()})();'])))
            }
            let v = {
                status: 0
            };

            function b(t, e, i, s = y) {
                switch (0 === v.status && function(t, e, i = y) {
                    try {
                        const s = i(t),
                            {
                                stop: r
                            } = (0, d.O)(t, s, "error", (i => {
                                E(t, e, i)
                            })),
                            {
                                stop: n
                            } = (0, d.O)(t, s, "message", (({
                                data: i
                            }) => {
                                var s;
                                "errored" === i.type ? E(t, e, i.error, i.streamId) : "initialized" === i.type && (s = i.version, 1 === v.status && (v = {
                                    status: 3,
                                    worker: v.worker,
                                    stop: v.stop,
                                    version: s
                                }))
                            }));
                        s.postMessage({
                            action: "init"
                        }), (0, h.iK)((() => function(t) {
                            1 === v.status && (f.jf.error(`${t} failed to start: a timeout occurred while initializing the Worker`), v.initializationFailureCallbacks.forEach((t => t())), v = {
                                status: 2
                            })
                        }(e)), m), v = {
                            status: 1,
                            worker: s,
                            stop: () => {
                                r(), n()
                            },
                            initializationFailureCallbacks: []
                        }
                    } catch (i) {
                        E(t, e, i)
                    }
                }(t, e, s), v.status) {
                    case 1:
                        return v.initializationFailureCallbacks.push(i), v.worker;
                    case 3:
                        return v.worker
                }
            }

            function T() {
                return v.status
            }

            function E(t, e, i, s) {
                1 === v.status || 0 === v.status ? ((0, g.j)({
                    configuredUrl: t.workerUrl,
                    error: i,
                    source: e,
                    scriptType: "worker"
                }), 1 === v.status && v.initializationFailureCallbacks.forEach((t => t())), v = {
                    status: 2
                }) : (0, p.Sz)(i, {
                    worker_version: 3 === v.status && v.version,
                    stream_id: s
                })
            }
            var S = i(8259),
                w = i(3473),
                k = i(193),
                A = i(4933);
            var _ = i(9031);

            function L(t, e, i, s, r, a, o) {
                let l, c = 0;
                e.subscribe(9, (() => {
                    2 !== c && 3 !== c || (f(), c = 1)
                })), e.subscribe(10, (() => {
                    1 === c && h()
                }));
                const u = new w.y$;
                (0, _.M)(t, o, u);
                const d = async n => {
                    u.notify({
                        type: "start",
                        forced: n
                    });
                    const [d] = await Promise.all([R(u, {
                        type: "recorder-settled"
                    }, r()), R(u, {
                        type: "document-ready"
                    }, (0, k._)(t, "interactive"))]);
                    if (2 !== c) return void u.notify({
                        type: "aborted"
                    });
                    if (!d) return c = 0, void u.notify({
                        type: "recorder-load-failed"
                    });
                    const h = a();
                    if (!h) return c = 0, void u.notify({
                        type: "deflate-encoder-load-failed"
                    });
                    ({
                        stop: l
                    } = d(e, t, i, s, h, o)), c = 3, u.notify({
                        type: "succeeded"
                    })
                };

                function h(t) {
                    const e = i.findTrackedSession();
                    if (function(t, e) {
                            return !t || 0 === t.sessionReplay && (!e || !e.force)
                        }(e, t)) return void(c = 1);
                    if (function(t) {
                            return 2 === t || 3 === t
                        }(c)) return;
                    c = 2;
                    const s = function(t, e) {
                        return e && e.force && 0 === t.sessionReplay
                    }(e, t) || !1;
                    d(s).catch(A.$y), s && i.setForcedReplay()
                }

                function f() {
                    3 === c && (null == l || l()), c = 0
                }
                return {
                    start: h,
                    stop: f,
                    getSessionReplayLink: () => function(t, e, i, s) {
                        const r = e.findTrackedSession(),
                            a = function(t, e) {
                                return (0, S.T)() ? t ? 0 === t.sessionReplay ? "incorrect-session-plan" : e ? void 0 : "replay-not-started" : "rum-not-tracked" : "browser-not-supported"
                            }(r, s),
                            o = i.findView();
                        return (0, n.Gm)(t, {
                            viewContext: o,
                            errorType: a,
                            session: r
                        })
                    }(t, i, s, 0 !== c),
                    isRecording: () => 3 === c
                }
            }
            async function R(t, e, i) {
                try {
                    return await i
                } finally {
                    t.notify(e)
                }
            }
            var I = i(2910);
            async function C() {
                return (await i.e(216).then(i.bind(i, 1061))).startRecording
            }
            var D = i(8491),
                x = i(9643),
                P = i(4903);
            const O = function(t, e) {
                    if ((0, a.xT)() && !(0, a.ke)("records") || !(0, S.T)()) return {
                        start: o.Z,
                        stop: o.Z,
                        getReplayStats: () => {},
                        onRumStart: o.Z,
                        isRecording: () => !1,
                        getSessionReplayLink: () => {}
                    };
                    let {
                        strategy: i,
                        shouldStartImmediately: s
                    } = (0, I.w)();
                    return {
                        start: t => i.start(t),
                        stop: () => i.stop(),
                        getSessionReplayLink: () => i.getSessionReplayLink(),
                        onRumStart: function(e, r, n, a, o, l) {
                            let u;
                            i = L(r, e, n, a, t, (function() {
                                return u || (null != o || (o = b(r, "Datadog Session Replay", (() => {
                                    i.stop()
                                }), undefined)), o && (u = (0, c.x)(r, o, 1))), u
                            }), l), s(r) && i.start()
                        },
                        isRecording: () => 3 === T() && i.isRecording(),
                        getReplayStats: t => 3 === T() ? (0, l.MA)(t) : void 0
                    }
                }((async function(t = C) {
                    try {
                        return await t()
                    } catch (t) {
                        (0, g.j)({
                            error: t,
                            source: "Recorder",
                            scriptType: "module"
                        })
                    }
                })),
                M = function() {
                    let t;
                    return {
                        onRumStart: function(e, i, s, r, a) {
                            const o = r.findTrackedSession();
                            if (!o) return;
                            if (!(0, n.HR)(o.id, s.profilingSampleRate)) return;
                            const l = (t => {
                                let e = {
                                    status: "starting"
                                };
                                return t.register(0, (({
                                    eventType: t
                                }) => t !== n.D$.VIEW && t !== n.D$.LONG_TASK ? x.kb : {
                                    type: t,
                                    _dd: {
                                        profiling: e
                                    }
                                })), {
                                    get: () => e,
                                    set: t => {
                                        e = t
                                    }
                                }
                            })(i);
                            (0, D.Y)() ? (0, P.n)().then((i => {
                                if (!i) return (0, p.eJ)("[DD_RUM] Failed to lazy load the RUM Profiler"), void l.set({
                                    status: "error",
                                    error_reason: "failed-to-lazy-load"
                                });
                                t = i(s, e, r, l), t.start(a.findView())
                            })).catch(A.$y): l.set({
                                status: "error",
                                error_reason: "not-supported-by-browser"
                            })
                        },
                        stop: () => {
                            null == t || t.stop().catch(A.$y)
                        }
                    }
                }(),
                N = (0, n._r)(n.iB, O, M, {
                    startDeflateWorker: b,
                    createDeflateEncoder: c.x,
                    sdkName: "rum"
                });
            (0, s.y)((0, r.R)(), "DD_RUM", N)
        },
        1443: function(t, e, i) {
            "object" == typeof navigator && (t.exports = function() {
                "use strict";

                function t(t, e, i) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: i,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = i, t
                }

                function e(t, e) {
                    for (var i = 0; i < e.length; i++) {
                        var s = e[i];
                        s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(t, s.key, s)
                    }
                }

                function s(t, e, i) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: i,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = i, t
                }

                function r(t, e) {
                    var i = Object.keys(t);
                    if (Object.getOwnPropertySymbols) {
                        var s = Object.getOwnPropertySymbols(t);
                        e && (s = s.filter((function(e) {
                            return Object.getOwnPropertyDescriptor(t, e).enumerable
                        }))), i.push.apply(i, s)
                    }
                    return i
                }

                function n(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var i = null != arguments[e] ? arguments[e] : {};
                        e % 2 ? r(Object(i), !0).forEach((function(e) {
                            s(t, e, i[e])
                        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : r(Object(i)).forEach((function(e) {
                            Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e))
                        }))
                    }
                    return t
                }
                var a = {
                    addCSS: !0,
                    thumbWidth: 15,
                    watch: !0
                };
                var o = function(t) {
                        return null != t ? t.constructor : null
                    },
                    l = function(t, e) {
                        return !!(t && e && t instanceof e)
                    },
                    c = function(t) {
                        return o(t) === String
                    },
                    u = function(t) {
                        return Array.isArray(t)
                    },
                    d = function(t) {
                        return l(t, NodeList)
                    },
                    h = c,
                    f = u,
                    p = d,
                    g = function(t) {
                        return l(t, Element)
                    },
                    m = function(t) {
                        return l(t, Event)
                    },
                    y = function(t) {
                        return function(t) {
                            return null == t
                        }(t) || (c(t) || u(t) || d(t)) && !t.length || function(t) {
                            return o(t) === Object
                        }(t) && !Object.keys(t).length
                    };
                var v = function() {
                    function t(e, i) {
                        (function(t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        })(this, t), g(e) ? this.element = e : h(e) && (this.element = document.querySelector(e)), g(this.element) && y(this.element.rangeTouch) && (this.config = n({}, a, {}, i), this.init())
                    }
                    return function(t, i, s) {
                        i && e(t.prototype, i), s && e(t, s)
                    }(t, [{
                        key: "init",
                        value: function() {
                            t.enabled && (this.config.addCSS && (this.element.style.userSelect = "none", this.element.style.webKitUserSelect = "none", this.element.style.touchAction = "manipulation"), this.listeners(!0), this.element.rangeTouch = this)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            t.enabled && (this.config.addCSS && (this.element.style.userSelect = "", this.element.style.webKitUserSelect = "", this.element.style.touchAction = ""), this.listeners(!1), this.element.rangeTouch = null)
                        }
                    }, {
                        key: "listeners",
                        value: function(t) {
                            var e = this,
                                i = t ? "addEventListener" : "removeEventListener";
                            ["touchstart", "touchmove", "touchend"].forEach((function(t) {
                                e.element[i](t, (function(t) {
                                    return e.set(t)
                                }), !1)
                            }))
                        }
                    }, {
                        key: "get",
                        value: function(e) {
                            if (!t.enabled || !m(e)) return null;
                            var i, s = e.target,
                                r = e.changedTouches[0],
                                n = parseFloat(s.getAttribute("min")) || 0,
                                a = parseFloat(s.getAttribute("max")) || 100,
                                o = parseFloat(s.getAttribute("step")) || 1,
                                l = s.getBoundingClientRect(),
                                c = 100 / l.width * (this.config.thumbWidth / 2) / 100;
                            return 0 > (i = 100 / l.width * (r.clientX - l.left)) ? i = 0 : 100 < i && (i = 100), 50 > i ? i -= (100 - 2 * i) * c : 50 < i && (i += 2 * (i - 50) * c), n + function(t, e) {
                                if (1 > e) {
                                    var i = function(t) {
                                        var e = "".concat(t).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
                                        return e ? Math.max(0, (e[1] ? e[1].length : 0) - (e[2] ? +e[2] : 0)) : 0
                                    }(e);
                                    return parseFloat(t.toFixed(i))
                                }
                                return Math.round(t / e) * e
                            }(i / 100 * (a - n), o)
                        }
                    }, {
                        key: "set",
                        value: function(e) {
                            t.enabled && m(e) && !e.target.disabled && (e.preventDefault(), e.target.value = this.get(e), function(t, e) {
                                if (t && e) {
                                    var i = new Event(e, {
                                        bubbles: !0
                                    });
                                    t.dispatchEvent(i)
                                }
                            }(e.target, "touchend" === e.type ? "change" : "input"))
                        }
                    }], [{
                        key: "setup",
                        value: function(e) {
                            var i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
                                s = null;
                            if (y(e) || h(e) ? s = Array.from(document.querySelectorAll(h(e) ? e : 'input[type="range"]')) : g(e) ? s = [e] : p(e) ? s = Array.from(e) : f(e) && (s = e.filter(g)), y(s)) return null;
                            var r = n({}, a, {}, i);
                            if (h(e) && r.watch) {
                                var o = new MutationObserver((function(i) {
                                    Array.from(i).forEach((function(i) {
                                        Array.from(i.addedNodes).forEach((function(i) {
                                            g(i) && function(t, e) {
                                                return function() {
                                                    return Array.from(document.querySelectorAll(e)).includes(this)
                                                }.call(t, e)
                                            }(i, e) && new t(i, r)
                                        }))
                                    }))
                                }));
                                o.observe(document.body, {
                                    childList: !0,
                                    subtree: !0
                                })
                            }
                            return s.map((function(e) {
                                return new t(e, i)
                            }))
                        }
                    }, {
                        key: "enabled",
                        get: function() {
                            return "ontouchstart" in document.documentElement
                        }
                    }]), t
                }();
                const b = t => null != t ? t.constructor : null,
                    T = (t, e) => Boolean(t && e && t instanceof e),
                    E = t => null == t,
                    S = t => b(t) === Object,
                    w = t => b(t) === String,
                    k = t => "function" == typeof t,
                    A = t => Array.isArray(t),
                    _ = t => T(t, NodeList),
                    L = t => E(t) || (w(t) || A(t) || _(t)) && !t.length || S(t) && !Object.keys(t).length;
                var R = E,
                    I = S,
                    C = t => b(t) === Number && !Number.isNaN(t),
                    D = w,
                    x = t => b(t) === Boolean,
                    P = k,
                    O = A,
                    M = _,
                    N = t => null !== t && "object" == typeof t && 1 === t.nodeType && "object" == typeof t.style && "object" == typeof t.ownerDocument,
                    F = t => T(t, Event),
                    $ = t => T(t, KeyboardEvent),
                    U = t => T(t, TextTrack) || !E(t) && w(t.kind),
                    B = t => {
                        if (T(t, window.URL)) return !0;
                        if (!w(t)) return !1;
                        let e = t;
                        t.startsWith("http://") && t.startsWith("https://") || (e = `http://${t}`);
                        try {
                            return !L(new URL(e).hostname)
                        } catch (t) {
                            return !1
                        }
                    },
                    j = L;
                const G = (() => {
                    const t = document.createElement("span"),
                        e = {
                            WebkitTransition: "webkitTransitionEnd",
                            MozTransition: "transitionend",
                            OTransition: "oTransitionEnd otransitionend",
                            transition: "transitionend"
                        },
                        i = Object.keys(e).find((e => void 0 !== t.style[e]));
                    return !!D(i) && e[i]
                })();

                function V(t, e) {
                    setTimeout((() => {
                        try {
                            t.hidden = !0, t.offsetHeight, t.hidden = !1
                        } catch (t) {}
                    }), e)
                }
                const H = {
                    isIE: Boolean(window.document.documentMode),
                    isEdge: /Edge/g.test(navigator.userAgent),
                    isWebkit: "WebkitAppearance" in document.documentElement.style && !/Edge/g.test(navigator.userAgent),
                    isIPhone: /iPhone|iPod/gi.test(navigator.userAgent) && navigator.maxTouchPoints > 1,
                    isIos: /iPad|iPhone|iPod/gi.test(navigator.userAgent) && navigator.maxTouchPoints > 1
                };

                function K(t, e) {
                    return e.split(".").reduce(((t, e) => t && t[e]), t)
                }

                function z(t = {}, ...e) {
                    if (!e.length) return t;
                    const i = e.shift();
                    return I(i) ? (Object.keys(i).forEach((e => {
                        I(i[e]) ? (Object.keys(t).includes(e) || Object.assign(t, {
                            [e]: {}
                        }), z(t[e], i[e])) : Object.assign(t, {
                            [e]: i[e]
                        })
                    })), z(t, ...e)) : t
                }

                function q(t, e) {
                    const i = t.length ? t : [t];
                    Array.from(i).reverse().forEach(((t, i) => {
                        const s = i > 0 ? e.cloneNode(!0) : e,
                            r = t.parentNode,
                            n = t.nextSibling;
                        s.appendChild(t), n ? r.insertBefore(s, n) : r.appendChild(s)
                    }))
                }

                function W(t, e) {
                    N(t) && !j(e) && Object.entries(e).filter((([, t]) => !R(t))).forEach((([e, i]) => t.setAttribute(e, i)))
                }

                function Y(t, e, i) {
                    const s = document.createElement(t);
                    return I(e) && W(s, e), D(i) && (s.innerText = i), s
                }

                function X(t, e, i, s) {
                    N(e) && e.appendChild(Y(t, i, s))
                }

                function Q(t) {
                    M(t) || O(t) ? Array.from(t).forEach(Q) : N(t) && N(t.parentNode) && t.parentNode.removeChild(t)
                }

                function J(t) {
                    if (!N(t)) return;
                    let {
                        length: e
                    } = t.childNodes;
                    for (; e > 0;) t.removeChild(t.lastChild), e -= 1
                }

                function Z(t, e) {
                    return N(e) && N(e.parentNode) && N(t) ? (e.parentNode.replaceChild(t, e), t) : null
                }

                function tt(t, e) {
                    if (!D(t) || j(t)) return {};
                    const i = {},
                        s = z({}, e);
                    return t.split(",").forEach((t => {
                        const e = t.trim(),
                            r = e.replace(".", ""),
                            n = e.replace(/[[\]]/g, "").split("="),
                            [a] = n,
                            o = n.length > 1 ? n[1].replace(/["']/g, "") : "";
                        switch (e.charAt(0)) {
                            case ".":
                                D(s.class) ? i.class = `${s.class} ${r}` : i.class = r;
                                break;
                            case "#":
                                i.id = e.replace("#", "");
                                break;
                            case "[":
                                i[a] = o
                        }
                    })), z(s, i)
                }

                function et(t, e) {
                    if (!N(t)) return;
                    let i = e;
                    x(i) || (i = !t.hidden), t.hidden = i
                }

                function it(t, e, i) {
                    if (M(t)) return Array.from(t).map((t => it(t, e, i)));
                    if (N(t)) {
                        let s = "toggle";
                        return void 0 !== i && (s = i ? "add" : "remove"), t.classList[s](e), t.classList.contains(e)
                    }
                    return !1
                }

                function st(t, e) {
                    return N(t) && t.classList.contains(e)
                }

                function rt(t, e) {
                    const {
                        prototype: i
                    } = Element;
                    return (i.matches || i.webkitMatchesSelector || i.mozMatchesSelector || i.msMatchesSelector || function() {
                        return Array.from(document.querySelectorAll(e)).includes(this)
                    }).call(t, e)
                }

                function nt(t) {
                    return this.elements.container.querySelectorAll(t)
                }

                function at(t) {
                    return this.elements.container.querySelector(t)
                }

                function ot(t = null, e = !1) {
                    N(t) && (t.focus({
                        preventScroll: !0
                    }), e && it(t, this.config.classNames.tabFocus))
                }
                const lt = {
                        "audio/ogg": "vorbis",
                        "audio/wav": "1",
                        "video/webm": "vp8, vorbis",
                        "video/mp4": "avc1.42E01E, mp4a.40.2",
                        "video/ogg": "theora"
                    },
                    ct = {
                        audio: "canPlayType" in document.createElement("audio"),
                        video: "canPlayType" in document.createElement("video"),
                        check(t, e, i) {
                            const s = H.isIPhone && i && ct.playsinline,
                                r = ct[t] || "html5" !== e;
                            return {
                                api: r,
                                ui: r && ct.rangeInput && ("video" !== t || !H.isIPhone || s)
                            }
                        },
                        pip: !(H.isIPhone || !P(Y("video").webkitSetPresentationMode) && (!document.pictureInPictureEnabled || Y("video").disablePictureInPicture)),
                        airplay: P(window.WebKitPlaybackTargetAvailabilityEvent),
                        playsinline: "playsInline" in document.createElement("video"),
                        mime(t) {
                            if (j(t)) return !1;
                            const [e] = t.split("/");
                            let i = t;
                            if (!this.isHTML5 || e !== this.type) return !1;
                            Object.keys(lt).includes(i) && (i += `; codecs="${lt[t]}"`);
                            try {
                                return Boolean(i && this.media.canPlayType(i).replace(/no/, ""))
                            } catch (t) {
                                return !1
                            }
                        },
                        textTracks: "textTracks" in document.createElement("video"),
                        rangeInput: (() => {
                            const t = document.createElement("input");
                            return t.type = "range", "range" === t.type
                        })(),
                        touch: "ontouchstart" in document.documentElement,
                        transitions: !1 !== G,
                        reducedMotion: "matchMedia" in window && window.matchMedia("(prefers-reduced-motion)").matches
                    },
                    ut = (() => {
                        let t = !1;
                        try {
                            const e = Object.defineProperty({}, "passive", {
                                get: () => (t = !0, null)
                            });
                            window.addEventListener("test", null, e), window.removeEventListener("test", null, e)
                        } catch (t) {}
                        return t
                    })();

                function dt(t, e, i, s = !1, r = !0, n = !1) {
                    if (!t || !("addEventListener" in t) || j(e) || !P(i)) return;
                    const a = e.split(" ");
                    let o = n;
                    ut && (o = {
                        passive: r,
                        capture: n
                    }), a.forEach((e => {
                        this && this.eventListeners && s && this.eventListeners.push({
                            element: t,
                            type: e,
                            callback: i,
                            options: o
                        }), t[s ? "addEventListener" : "removeEventListener"](e, i, o)
                    }))
                }

                function ht(t, e = "", i, s = !0, r = !1) {
                    dt.call(this, t, e, i, !0, s, r)
                }

                function ft(t, e = "", i, s = !0, r = !1) {
                    dt.call(this, t, e, i, !1, s, r)
                }

                function pt(t, e = "", i, s = !0, r = !1) {
                    const n = (...a) => {
                        ft(t, e, n, s, r), i.apply(this, a)
                    };
                    dt.call(this, t, e, n, !0, s, r)
                }

                function gt(t, e = "", i = !1, s = {}) {
                    if (!N(t) || j(e)) return;
                    const r = new CustomEvent(e, {
                        bubbles: i,
                        detail: { ...s,
                            plyr: this
                        }
                    });
                    t.dispatchEvent(r)
                }

                function mt() {
                    this && this.eventListeners && (this.eventListeners.forEach((t => {
                        const {
                            element: e,
                            type: i,
                            callback: s,
                            options: r
                        } = t;
                        e.removeEventListener(i, s, r)
                    })), this.eventListeners = [])
                }

                function yt() {
                    return new Promise((t => this.ready ? setTimeout(t, 0) : ht.call(this, this.elements.container, "ready", t))).then((() => {}))
                }

                function vt(t) {
                    (t => T(t, Promise) && k(t.then))(t) && t.then(null, (() => {}))
                }

                function bt(t) {
                    return O(t) ? t.filter(((e, i) => t.indexOf(e) === i)) : t
                }

                function Tt(t, e) {
                    return O(t) && t.length ? t.reduce(((t, i) => Math.abs(i - e) < Math.abs(t - e) ? i : t)) : null
                }

                function Et(t) {
                    return !(!window || !window.CSS) && window.CSS.supports(t)
                }
                const St = [
                    [1, 1],
                    [4, 3],
                    [3, 4],
                    [5, 4],
                    [4, 5],
                    [3, 2],
                    [2, 3],
                    [16, 10],
                    [10, 16],
                    [16, 9],
                    [9, 16],
                    [21, 9],
                    [9, 21],
                    [32, 9],
                    [9, 32]
                ].reduce(((t, [e, i]) => ({ ...t,
                    [e / i]: [e, i]
                })), {});

                function wt(t) {
                    return !!(O(t) || D(t) && t.includes(":")) && (O(t) ? t : t.split(":")).map(Number).every(C)
                }

                function kt(t) {
                    if (!O(t) || !t.every(C)) return null;
                    const [e, i] = t, s = (t, e) => 0 === e ? t : s(e, t % e), r = s(e, i);
                    return [e / r, i / r]
                }

                function At(t) {
                    const e = t => wt(t) ? t.split(":").map(Number) : null;
                    let i = e(t);
                    if (null === i && (i = e(this.config.ratio)), null === i && !j(this.embed) && O(this.embed.ratio) && ({
                            ratio: i
                        } = this.embed), null === i && this.isHTML5) {
                        const {
                            videoWidth: t,
                            videoHeight: e
                        } = this.media;
                        i = [t, e]
                    }
                    return kt(i)
                }

                function _t(t) {
                    if (!this.isVideo) return {};
                    const {
                        wrapper: e
                    } = this.elements, i = At.call(this, t);
                    if (!O(i)) return {};
                    const [s, r] = kt(i), n = 100 / s * r;
                    if (Et(`aspect-ratio: ${s}/${r}`) ? e.style.aspectRatio = `${s}/${r}` : e.style.paddingBottom = `${n}%`, this.isVimeo && !this.config.vimeo.premium && this.supported.ui) {
                        const t = 100 / this.media.offsetWidth * parseInt(window.getComputedStyle(this.media).paddingBottom, 10),
                            i = (t - n) / (t / 50);
                        this.fullscreen.active ? e.style.paddingBottom = null : this.media.style.transform = `translateY(-${i}%)`
                    } else this.isHTML5 && e.classList.add(this.config.classNames.videoFixedRatio);
                    return {
                        padding: n,
                        ratio: i
                    }
                }

                function Lt(t, e, i = .05) {
                    const s = t / e,
                        r = Tt(Object.keys(St), s);
                    return Math.abs(r - s) <= i ? St[r] : [t, e]
                }
                const Rt = {
                    getSources() {
                        return this.isHTML5 ? Array.from(this.media.querySelectorAll("source")).filter((t => {
                            const e = t.getAttribute("type");
                            return !!j(e) || ct.mime.call(this, e)
                        })) : []
                    },
                    getQualityOptions() {
                        return this.config.quality.forced ? this.config.quality.options : Rt.getSources.call(this).map((t => Number(t.getAttribute("size")))).filter(Boolean)
                    },
                    setup() {
                        if (!this.isHTML5) return;
                        const t = this;
                        t.options.speed = t.config.speed.options, j(this.config.ratio) || _t.call(t), Object.defineProperty(t.media, "quality", {
                            get() {
                                const e = Rt.getSources.call(t).find((e => e.getAttribute("src") === t.source));
                                return e && Number(e.getAttribute("size"))
                            },
                            set(e) {
                                if (t.quality !== e) {
                                    if (t.config.quality.forced && P(t.config.quality.onChange)) t.config.quality.onChange(e);
                                    else {
                                        const i = Rt.getSources.call(t).find((t => Number(t.getAttribute("size")) === e));
                                        if (!i) return;
                                        const {
                                            currentTime: s,
                                            paused: r,
                                            preload: n,
                                            readyState: a,
                                            playbackRate: o
                                        } = t.media;
                                        t.media.src = i.getAttribute("src"), ("none" !== n || a) && (t.once("loadedmetadata", (() => {
                                            t.speed = o, t.currentTime = s, r || vt(t.play())
                                        })), t.media.load())
                                    }
                                    gt.call(t, t.media, "qualitychange", !1, {
                                        quality: e
                                    })
                                }
                            }
                        })
                    },
                    cancelRequests() {
                        this.isHTML5 && (Q(Rt.getSources.call(this)), this.media.setAttribute("src", this.config.blankVideo), this.media.load(), this.debug.log("Cancelled network requests"))
                    }
                };

                function It(t, ...e) {
                    return j(t) ? t : t.toString().replace(/{(\d+)}/g, ((t, i) => e[i].toString()))
                }
                const Ct = (t = "", e = "", i = "") => t.replace(new RegExp(e.toString().replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1"), "g"), i.toString()),
                    Dt = (t = "") => t.toString().replace(/\w\S*/g, (t => t.charAt(0).toUpperCase() + t.slice(1).toLowerCase()));

                function xt(t) {
                    const e = document.createElement("div");
                    return e.appendChild(t), e.innerHTML
                }
                const Pt = {
                        pip: "PIP",
                        airplay: "AirPlay",
                        html5: "HTML5",
                        vimeo: "Vimeo",
                        youtube: "YouTube"
                    },
                    Ot = {
                        get(t = "", e = {}) {
                            if (j(t) || j(e)) return "";
                            let i = K(e.i18n, t);
                            if (j(i)) return Object.keys(Pt).includes(t) ? Pt[t] : "";
                            const s = {
                                "{seektime}": e.seekTime,
                                "{title}": e.title
                            };
                            return Object.entries(s).forEach((([t, e]) => {
                                i = Ct(i, t, e)
                            })), i
                        }
                    };
                class Mt {
                    constructor(e) {
                        t(this, "get", (t => {
                            if (!Mt.supported || !this.enabled) return null;
                            const e = window.localStorage.getItem(this.key);
                            if (j(e)) return null;
                            const i = JSON.parse(e);
                            return D(t) && t.length ? i[t] : i
                        })), t(this, "set", (t => {
                            if (!Mt.supported || !this.enabled) return;
                            if (!I(t)) return;
                            let e = this.get();
                            j(e) && (e = {}), z(e, t);
                            try {
                                window.localStorage.setItem(this.key, JSON.stringify(e))
                            } catch (t) {}
                        })), this.enabled = e.config.storage.enabled, this.key = e.config.storage.key
                    }
                    static get supported() {
                        try {
                            if (!("localStorage" in window)) return !1;
                            const t = "___test";
                            return window.localStorage.setItem(t, t), window.localStorage.removeItem(t), !0
                        } catch (t) {
                            return !1
                        }
                    }
                }

                function Nt(t, e = "text") {
                    return new Promise(((i, s) => {
                        try {
                            const s = new XMLHttpRequest;
                            if (!("withCredentials" in s)) return;
                            s.addEventListener("load", (() => {
                                if ("text" === e) try {
                                    i(JSON.parse(s.responseText))
                                } catch (t) {
                                    i(s.responseText)
                                } else i(s.response)
                            })), s.addEventListener("error", (() => {
                                throw new Error(s.status)
                            })), s.open("GET", t, !0), s.responseType = e, s.send()
                        } catch (t) {
                            s(t)
                        }
                    }))
                }

                function Ft(t, e) {
                    if (!D(t)) return;
                    const i = D(e);
                    let s = !1;
                    const r = () => null !== document.getElementById(e),
                        n = (t, e) => {
                            t.innerHTML = e, i && r() || document.body.insertAdjacentElement("afterbegin", t)
                        };
                    if (!i || !r()) {
                        const r = Mt.supported,
                            a = document.createElement("div");
                        if (a.setAttribute("hidden", ""), i && a.setAttribute("id", e), r) {
                            const t = window.localStorage.getItem(`cache-${e}`);
                            if (s = null !== t, s) {
                                const e = JSON.parse(t);
                                n(a, e.content)
                            }
                        }
                        Nt(t).then((t => {
                            if (!j(t)) {
                                if (r) try {
                                    window.localStorage.setItem(`cache-${e}`, JSON.stringify({
                                        content: t
                                    }))
                                } catch (t) {}
                                n(a, t)
                            }
                        })).catch((() => {}))
                    }
                }
                const $t = t => Math.trunc(t / 60 / 60 % 60, 10);

                function Ut(t = 0, e = !1, i = !1) {
                    if (!C(t)) return Ut(void 0, e, i);
                    const s = t => `0${t}`.slice(-2);
                    let r = $t(t);
                    const n = (a = t, Math.trunc(a / 60 % 60, 10));
                    var a;
                    const o = (t => Math.trunc(t % 60, 10))(t);
                    return r = e || r > 0 ? `${r}:` : "", `${i&&t>0?"-":""}${r}${s(n)}:${s(o)}`
                }
                const Bt = {
                    getIconUrl() {
                        const t = new URL(this.config.iconUrl, window.location),
                            e = window.location.host ? window.location.host : window.top.location.host,
                            i = t.host !== e || H.isIE && !window.svg4everybody;
                        return {
                            url: this.config.iconUrl,
                            cors: i
                        }
                    },
                    findElements() {
                        try {
                            return this.elements.controls = at.call(this, this.config.selectors.controls.wrapper), this.elements.buttons = {
                                play: nt.call(this, this.config.selectors.buttons.play),
                                pause: at.call(this, this.config.selectors.buttons.pause),
                                restart: at.call(this, this.config.selectors.buttons.restart),
                                rewind: at.call(this, this.config.selectors.buttons.rewind),
                                fastForward: at.call(this, this.config.selectors.buttons.fastForward),
                                mute: at.call(this, this.config.selectors.buttons.mute),
                                pip: at.call(this, this.config.selectors.buttons.pip),
                                airplay: at.call(this, this.config.selectors.buttons.airplay),
                                settings: at.call(this, this.config.selectors.buttons.settings),
                                captions: at.call(this, this.config.selectors.buttons.captions),
                                fullscreen: at.call(this, this.config.selectors.buttons.fullscreen)
                            }, this.elements.progress = at.call(this, this.config.selectors.progress), this.elements.inputs = {
                                seek: at.call(this, this.config.selectors.inputs.seek),
                                volume: at.call(this, this.config.selectors.inputs.volume)
                            }, this.elements.display = {
                                buffer: at.call(this, this.config.selectors.display.buffer),
                                currentTime: at.call(this, this.config.selectors.display.currentTime),
                                duration: at.call(this, this.config.selectors.display.duration)
                            }, N(this.elements.progress) && (this.elements.display.seekTooltip = this.elements.progress.querySelector(`.${this.config.classNames.tooltip}`)), !0
                        } catch (t) {
                            return this.debug.warn("It looks like there is a problem with your custom controls HTML", t), this.toggleNativeControls(!0), !1
                        }
                    },
                    createIcon(t, e) {
                        const i = "http://www.w3.org/2000/svg",
                            s = Bt.getIconUrl.call(this),
                            r = `${s.cors?"":s.url}#${this.config.iconPrefix}`,
                            n = document.createElementNS(i, "svg");
                        W(n, z(e, {
                            "aria-hidden": "true",
                            focusable: "false"
                        }));
                        const a = document.createElementNS(i, "use"),
                            o = `${r}-${t}`;
                        return "href" in a && a.setAttributeNS("http://www.w3.org/1999/xlink", "href", o), a.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", o), n.appendChild(a), n
                    },
                    createLabel(t, e = {}) {
                        const i = Ot.get(t, this.config);
                        return Y("span", { ...e,
                            class: [e.class, this.config.classNames.hidden].filter(Boolean).join(" ")
                        }, i)
                    },
                    createBadge(t) {
                        if (j(t)) return null;
                        const e = Y("span", {
                            class: this.config.classNames.menu.value
                        });
                        return e.appendChild(Y("span", {
                            class: this.config.classNames.menu.badge
                        }, t)), e
                    },
                    createButton(t, e) {
                        const i = z({}, e);
                        let s = function(t = "") {
                            let e = t.toString();
                            return e = function(t = "") {
                                let e = t.toString();
                                return e = Ct(e, "-", " "), e = Ct(e, "_", " "), e = Dt(e), Ct(e, " ", "")
                            }(e), e.charAt(0).toLowerCase() + e.slice(1)
                        }(t);
                        const r = {
                            element: "button",
                            toggle: !1,
                            label: null,
                            icon: null,
                            labelPressed: null,
                            iconPressed: null
                        };
                        switch (["element", "icon", "label"].forEach((t => {
                            Object.keys(i).includes(t) && (r[t] = i[t], delete i[t])
                        })), "button" !== r.element || Object.keys(i).includes("type") || (i.type = "button"), Object.keys(i).includes("class") ? i.class.split(" ").some((t => t === this.config.classNames.control)) || z(i, {
                            class: `${i.class} ${this.config.classNames.control}`
                        }) : i.class = this.config.classNames.control, t) {
                            case "play":
                                r.toggle = !0, r.label = "play", r.labelPressed = "pause", r.icon = "play", r.iconPressed = "pause";
                                break;
                            case "mute":
                                r.toggle = !0, r.label = "mute", r.labelPressed = "unmute", r.icon = "volume", r.iconPressed = "muted";
                                break;
                            case "captions":
                                r.toggle = !0, r.label = "enableCaptions", r.labelPressed = "disableCaptions", r.icon = "captions-off", r.iconPressed = "captions-on";
                                break;
                            case "fullscreen":
                                r.toggle = !0, r.label = "enterFullscreen", r.labelPressed = "exitFullscreen", r.icon = "enter-fullscreen", r.iconPressed = "exit-fullscreen";
                                break;
                            case "play-large":
                                i.class += ` ${this.config.classNames.control}--overlaid`, s = "play", r.label = "play", r.icon = "play";
                                break;
                            default:
                                j(r.label) && (r.label = s), j(r.icon) && (r.icon = t)
                        }
                        const n = Y(r.element);
                        return r.toggle ? (n.appendChild(Bt.createIcon.call(this, r.iconPressed, {
                            class: "icon--pressed"
                        })), n.appendChild(Bt.createIcon.call(this, r.icon, {
                            class: "icon--not-pressed"
                        })), n.appendChild(Bt.createLabel.call(this, r.labelPressed, {
                            class: "label--pressed"
                        })), n.appendChild(Bt.createLabel.call(this, r.label, {
                            class: "label--not-pressed"
                        }))) : (n.appendChild(Bt.createIcon.call(this, r.icon)), n.appendChild(Bt.createLabel.call(this, r.label))), z(i, tt(this.config.selectors.buttons[s], i)), W(n, i), "play" === s ? (O(this.elements.buttons[s]) || (this.elements.buttons[s] = []), this.elements.buttons[s].push(n)) : this.elements.buttons[s] = n, n
                    },
                    createRange(t, e) {
                        const i = Y("input", z(tt(this.config.selectors.inputs[t]), {
                            type: "range",
                            min: 0,
                            max: 100,
                            step: .01,
                            value: 0,
                            autocomplete: "off",
                            role: "slider",
                            "aria-label": Ot.get(t, this.config),
                            "aria-valuemin": 0,
                            "aria-valuemax": 100,
                            "aria-valuenow": 0
                        }, e));
                        return this.elements.inputs[t] = i, Bt.updateRangeFill.call(this, i), v.setup(i), i
                    },
                    createProgress(t, e) {
                        const i = Y("progress", z(tt(this.config.selectors.display[t]), {
                            min: 0,
                            max: 100,
                            value: 0,
                            role: "progressbar",
                            "aria-hidden": !0
                        }, e));
                        if ("volume" !== t) {
                            i.appendChild(Y("span", null, "0"));
                            const e = {
                                    played: "played",
                                    buffer: "buffered"
                                }[t],
                                s = e ? Ot.get(e, this.config) : "";
                            i.innerText = `% ${s.toLowerCase()}`
                        }
                        return this.elements.display[t] = i, i
                    },
                    createTime(t, e) {
                        const i = tt(this.config.selectors.display[t], e),
                            s = Y("div", z(i, {
                                class: `${i.class?i.class:""} ${this.config.classNames.display.time} `.trim(),
                                "aria-label": Ot.get(t, this.config)
                            }), "00:00");
                        return this.elements.display[t] = s, s
                    },
                    bindMenuItemShortcuts(t, e) {
                        ht.call(this, t, "keydown keyup", (i => {
                            if (!["Space", "ArrowUp", "ArrowDown", "ArrowRight"].includes(i.key)) return;
                            if (i.preventDefault(), i.stopPropagation(), "keydown" === i.type) return;
                            const s = rt(t, '[role="menuitemradio"]');
                            if (!s && ["Space", "ArrowRight"].includes(i.key)) Bt.showMenuPanel.call(this, e, !0);
                            else {
                                let e;
                                "Space" !== i.key && ("ArrowDown" === i.key || s && "ArrowRight" === i.key ? (e = t.nextElementSibling, N(e) || (e = t.parentNode.firstElementChild)) : (e = t.previousElementSibling, N(e) || (e = t.parentNode.lastElementChild)), ot.call(this, e, !0))
                            }
                        }), !1), ht.call(this, t, "keyup", (t => {
                            "Return" === t.key && Bt.focusFirstMenuItem.call(this, null, !0)
                        }))
                    },
                    createMenuItem({
                        value: t,
                        list: e,
                        type: i,
                        title: s,
                        badge: r = null,
                        checked: n = !1
                    }) {
                        const a = tt(this.config.selectors.inputs[i]),
                            o = Y("button", z(a, {
                                type: "button",
                                role: "menuitemradio",
                                class: `${this.config.classNames.control} ${a.class?a.class:""}`.trim(),
                                "aria-checked": n,
                                value: t
                            })),
                            l = Y("span");
                        l.innerHTML = s, N(r) && l.appendChild(r), o.appendChild(l), Object.defineProperty(o, "checked", {
                            enumerable: !0,
                            get: () => "true" === o.getAttribute("aria-checked"),
                            set(t) {
                                t && Array.from(o.parentNode.children).filter((t => rt(t, '[role="menuitemradio"]'))).forEach((t => t.setAttribute("aria-checked", "false"))), o.setAttribute("aria-checked", t ? "true" : "false")
                            }
                        }), this.listeners.bind(o, "click keyup", (e => {
                            if (!$(e) || "Space" === e.key) {
                                switch (e.preventDefault(), e.stopPropagation(), o.checked = !0, i) {
                                    case "language":
                                        this.currentTrack = Number(t);
                                        break;
                                    case "quality":
                                        this.quality = t;
                                        break;
                                    case "speed":
                                        this.speed = parseFloat(t)
                                }
                                Bt.showMenuPanel.call(this, "home", $(e))
                            }
                        }), i, !1), Bt.bindMenuItemShortcuts.call(this, o, i), e.appendChild(o)
                    },
                    formatTime(t = 0, e = !1) {
                        return C(t) ? Ut(t, $t(this.duration) > 0, e) : t
                    },
                    updateTimeDisplay(t = null, e = 0, i = !1) {
                        N(t) && C(e) && (t.innerText = Bt.formatTime(e, i))
                    },
                    updateVolume() {
                        this.supported.ui && (N(this.elements.inputs.volume) && Bt.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume), N(this.elements.buttons.mute) && (this.elements.buttons.mute.pressed = this.muted || 0 === this.volume))
                    },
                    setRange(t, e = 0) {
                        N(t) && (t.value = e, Bt.updateRangeFill.call(this, t))
                    },
                    updateProgress(t) {
                        if (!this.supported.ui || !F(t)) return;
                        let e = 0;
                        const i = (t, e) => {
                            const i = C(e) ? e : 0,
                                s = N(t) ? t : this.elements.display.buffer;
                            if (N(s)) {
                                s.value = i;
                                const t = s.getElementsByTagName("span")[0];
                                N(t) && (t.childNodes[0].nodeValue = i)
                            }
                        };
                        if (t) switch (t.type) {
                            case "timeupdate":
                            case "seeking":
                            case "seeked":
                                s = this.currentTime, r = this.duration, e = 0 === s || 0 === r || Number.isNaN(s) || Number.isNaN(r) ? 0 : (s / r * 100).toFixed(2), "timeupdate" === t.type && Bt.setRange.call(this, this.elements.inputs.seek, e);
                                break;
                            case "playing":
                            case "progress":
                                i(this.elements.display.buffer, 100 * this.buffered)
                        }
                        var s, r
                    },
                    updateRangeFill(t) {
                        const e = F(t) ? t.target : t;
                        if (N(e) && "range" === e.getAttribute("type")) {
                            if (rt(e, this.config.selectors.inputs.seek)) {
                                e.setAttribute("aria-valuenow", this.currentTime);
                                const t = Bt.formatTime(this.currentTime),
                                    i = Bt.formatTime(this.duration),
                                    s = Ot.get("seekLabel", this.config);
                                e.setAttribute("aria-valuetext", s.replace("{currentTime}", t).replace("{duration}", i))
                            } else if (rt(e, this.config.selectors.inputs.volume)) {
                                const t = 100 * e.value;
                                e.setAttribute("aria-valuenow", t), e.setAttribute("aria-valuetext", `${t.toFixed(1)}%`)
                            } else e.setAttribute("aria-valuenow", e.value);
                            H.isWebkit && e.style.setProperty("--value", e.value / e.max * 100 + "%")
                        }
                    },
                    updateSeekTooltip(t) {
                        var e, i;
                        if (!this.config.tooltips.seek || !N(this.elements.inputs.seek) || !N(this.elements.display.seekTooltip) || 0 === this.duration) return;
                        const s = this.elements.display.seekTooltip,
                            r = `${this.config.classNames.tooltip}--visible`,
                            n = t => it(s, r, t);
                        if (this.touch) return void n(!1);
                        let a = 0;
                        const o = this.elements.progress.getBoundingClientRect();
                        if (F(t)) a = 100 / o.width * (t.pageX - o.left);
                        else {
                            if (!st(s, r)) return;
                            a = parseFloat(s.style.left, 10)
                        }
                        a < 0 ? a = 0 : a > 100 && (a = 100);
                        const l = this.duration / 100 * a;
                        s.innerText = Bt.formatTime(l);
                        const c = null === (e = this.config.markers) || void 0 === e || null === (i = e.points) || void 0 === i ? void 0 : i.find((({
                            time: t
                        }) => t === Math.round(l)));
                        c && s.insertAdjacentHTML("afterbegin", `${c.label}<br>`), s.style.left = `${a}%`, F(t) && ["mouseenter", "mouseleave"].includes(t.type) && n("mouseenter" === t.type)
                    },
                    timeUpdate(t) {
                        const e = !N(this.elements.display.duration) && this.config.invertTime;
                        Bt.updateTimeDisplay.call(this, this.elements.display.currentTime, e ? this.duration - this.currentTime : this.currentTime, e), t && "timeupdate" === t.type && this.media.seeking || Bt.updateProgress.call(this, t)
                    },
                    durationUpdate() {
                        if (!this.supported.ui || !this.config.invertTime && this.currentTime) return;
                        if (this.duration >= 2 ** 32) return et(this.elements.display.currentTime, !0), void et(this.elements.progress, !0);
                        N(this.elements.inputs.seek) && this.elements.inputs.seek.setAttribute("aria-valuemax", this.duration);
                        const t = N(this.elements.display.duration);
                        !t && this.config.displayDuration && this.paused && Bt.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration), t && Bt.updateTimeDisplay.call(this, this.elements.display.duration, this.duration), this.config.markers.enabled && Bt.setMarkers.call(this), Bt.updateSeekTooltip.call(this)
                    },
                    toggleMenuButton(t, e) {
                        et(this.elements.settings.buttons[t], !e)
                    },
                    updateSetting(t, e, i) {
                        const s = this.elements.settings.panels[t];
                        let r = null,
                            n = e;
                        if ("captions" === t) r = this.currentTrack;
                        else {
                            if (r = j(i) ? this[t] : i, j(r) && (r = this.config[t].default), !j(this.options[t]) && !this.options[t].includes(r)) return void this.debug.warn(`Unsupported value of '${r}' for ${t}`);
                            if (!this.config[t].options.includes(r)) return void this.debug.warn(`Disabled value of '${r}' for ${t}`)
                        }
                        if (N(n) || (n = s && s.querySelector('[role="menu"]')), !N(n)) return;
                        this.elements.settings.buttons[t].querySelector(`.${this.config.classNames.menu.value}`).innerHTML = Bt.getLabel.call(this, t, r);
                        const a = n && n.querySelector(`[value="${r}"]`);
                        N(a) && (a.checked = !0)
                    },
                    getLabel(t, e) {
                        switch (t) {
                            case "speed":
                                return 1 === e ? Ot.get("normal", this.config) : `${e}&times;`;
                            case "quality":
                                if (C(e)) {
                                    const t = Ot.get(`qualityLabel.${e}`, this.config);
                                    return t.length ? t : `${e}p`
                                }
                                return Dt(e);
                            case "captions":
                                return Vt.getLabel.call(this);
                            default:
                                return null
                        }
                    },
                    setQualityMenu(t) {
                        if (!N(this.elements.settings.panels.quality)) return;
                        const e = "quality",
                            i = this.elements.settings.panels.quality.querySelector('[role="menu"]');
                        O(t) && (this.options.quality = bt(t).filter((t => this.config.quality.options.includes(t))));
                        const s = !j(this.options.quality) && this.options.quality.length > 1;
                        if (Bt.toggleMenuButton.call(this, e, s), J(i), Bt.checkMenu.call(this), !s) return;
                        const r = t => {
                            const e = Ot.get(`qualityBadge.${t}`, this.config);
                            return e.length ? Bt.createBadge.call(this, e) : null
                        };
                        this.options.quality.sort(((t, e) => {
                            const i = this.config.quality.options;
                            return i.indexOf(t) > i.indexOf(e) ? 1 : -1
                        })).forEach((t => {
                            Bt.createMenuItem.call(this, {
                                value: t,
                                list: i,
                                type: e,
                                title: Bt.getLabel.call(this, "quality", t),
                                badge: r(t)
                            })
                        })), Bt.updateSetting.call(this, e, i)
                    },
                    setCaptionsMenu() {
                        if (!N(this.elements.settings.panels.captions)) return;
                        const t = "captions",
                            e = this.elements.settings.panels.captions.querySelector('[role="menu"]'),
                            i = Vt.getTracks.call(this),
                            s = Boolean(i.length);
                        if (Bt.toggleMenuButton.call(this, t, s), J(e), Bt.checkMenu.call(this), !s) return;
                        const r = i.map(((t, i) => ({
                            value: i,
                            checked: this.captions.toggled && this.currentTrack === i,
                            title: Vt.getLabel.call(this, t),
                            badge: t.language && Bt.createBadge.call(this, t.language.toUpperCase()),
                            list: e,
                            type: "language"
                        })));
                        r.unshift({
                            value: -1,
                            checked: !this.captions.toggled,
                            title: Ot.get("disabled", this.config),
                            list: e,
                            type: "language"
                        }), r.forEach(Bt.createMenuItem.bind(this)), Bt.updateSetting.call(this, t, e)
                    },
                    setSpeedMenu() {
                        if (!N(this.elements.settings.panels.speed)) return;
                        const t = "speed",
                            e = this.elements.settings.panels.speed.querySelector('[role="menu"]');
                        this.options.speed = this.options.speed.filter((t => t >= this.minimumSpeed && t <= this.maximumSpeed));
                        const i = !j(this.options.speed) && this.options.speed.length > 1;
                        Bt.toggleMenuButton.call(this, t, i), J(e), Bt.checkMenu.call(this), i && (this.options.speed.forEach((i => {
                            Bt.createMenuItem.call(this, {
                                value: i,
                                list: e,
                                type: t,
                                title: Bt.getLabel.call(this, "speed", i)
                            })
                        })), Bt.updateSetting.call(this, t, e))
                    },
                    checkMenu() {
                        const {
                            buttons: t
                        } = this.elements.settings, e = !j(t) && Object.values(t).some((t => !t.hidden));
                        et(this.elements.settings.menu, !e)
                    },
                    focusFirstMenuItem(t, e = !1) {
                        if (this.elements.settings.popup.hidden) return;
                        let i = t;
                        N(i) || (i = Object.values(this.elements.settings.panels).find((t => !t.hidden)));
                        const s = i.querySelector('[role^="menuitem"]');
                        ot.call(this, s, e)
                    },
                    toggleMenu(t) {
                        const {
                            popup: e
                        } = this.elements.settings, i = this.elements.buttons.settings;
                        if (!N(e) || !N(i)) return;
                        const {
                            hidden: s
                        } = e;
                        let r = s;
                        if (x(t)) r = t;
                        else if ($(t) && "Escape" === t.key) r = !1;
                        else if (F(t)) {
                            const s = P(t.composedPath) ? t.composedPath()[0] : t.target,
                                n = e.contains(s);
                            if (n || !n && t.target !== i && r) return
                        }
                        i.setAttribute("aria-expanded", r), et(e, !r), it(this.elements.container, this.config.classNames.menu.open, r), r && $(t) ? Bt.focusFirstMenuItem.call(this, null, !0) : r || s || ot.call(this, i, $(t))
                    },
                    getMenuSize(t) {
                        const e = t.cloneNode(!0);
                        e.style.position = "absolute", e.style.opacity = 0, e.removeAttribute("hidden"), t.parentNode.appendChild(e);
                        const i = e.scrollWidth,
                            s = e.scrollHeight;
                        return Q(e), {
                            width: i,
                            height: s
                        }
                    },
                    showMenuPanel(t = "", e = !1) {
                        const i = this.elements.container.querySelector(`#plyr-settings-${this.id}-${t}`);
                        if (!N(i)) return;
                        const s = i.parentNode,
                            r = Array.from(s.children).find((t => !t.hidden));
                        if (ct.transitions && !ct.reducedMotion) {
                            s.style.width = `${r.scrollWidth}px`, s.style.height = `${r.scrollHeight}px`;
                            const t = Bt.getMenuSize.call(this, i),
                                e = t => {
                                    t.target === s && ["width", "height"].includes(t.propertyName) && (s.style.width = "", s.style.height = "", ft.call(this, s, G, e))
                                };
                            ht.call(this, s, G, e), s.style.width = `${t.width}px`, s.style.height = `${t.height}px`
                        }
                        et(r, !0), et(i, !1), Bt.focusFirstMenuItem.call(this, i, e)
                    },
                    setDownloadUrl() {
                        const t = this.elements.buttons.download;
                        N(t) && t.setAttribute("href", this.download)
                    },
                    create(t) {
                        const {
                            bindMenuItemShortcuts: e,
                            createButton: i,
                            createProgress: s,
                            createRange: r,
                            createTime: n,
                            setQualityMenu: a,
                            setSpeedMenu: o,
                            showMenuPanel: l
                        } = Bt;
                        this.elements.controls = null, O(this.config.controls) && this.config.controls.includes("play-large") && this.elements.container.appendChild(i.call(this, "play-large"));
                        const c = Y("div", tt(this.config.selectors.controls.wrapper));
                        this.elements.controls = c;
                        const u = {
                            class: "plyr__controls__item"
                        };
                        return bt(O(this.config.controls) ? this.config.controls : []).forEach((a => {
                            if ("restart" === a && c.appendChild(i.call(this, "restart", u)), "rewind" === a && c.appendChild(i.call(this, "rewind", u)), "play" === a && c.appendChild(i.call(this, "play", u)), "fast-forward" === a && c.appendChild(i.call(this, "fast-forward", u)), "progress" === a) {
                                const e = Y("div", {
                                        class: `${u.class} plyr__progress__container`
                                    }),
                                    i = Y("div", tt(this.config.selectors.progress));
                                if (i.appendChild(r.call(this, "seek", {
                                        id: `plyr-seek-${t.id}`
                                    })), i.appendChild(s.call(this, "buffer")), this.config.tooltips.seek) {
                                    const t = Y("span", {
                                        class: this.config.classNames.tooltip
                                    }, "00:00");
                                    i.appendChild(t), this.elements.display.seekTooltip = t
                                }
                                this.elements.progress = i, e.appendChild(this.elements.progress), c.appendChild(e)
                            }
                            if ("current-time" === a && c.appendChild(n.call(this, "currentTime", u)), "duration" === a && c.appendChild(n.call(this, "duration", u)), "mute" === a || "volume" === a) {
                                let {
                                    volume: e
                                } = this.elements;
                                if (N(e) && c.contains(e) || (e = Y("div", z({}, u, {
                                        class: `${u.class} plyr__volume`.trim()
                                    })), this.elements.volume = e, c.appendChild(e)), "mute" === a && e.appendChild(i.call(this, "mute")), "volume" === a && !H.isIos) {
                                    const i = {
                                        max: 1,
                                        step: .05,
                                        value: this.config.volume
                                    };
                                    e.appendChild(r.call(this, "volume", z(i, {
                                        id: `plyr-volume-${t.id}`
                                    })))
                                }
                            }
                            if ("captions" === a && c.appendChild(i.call(this, "captions", u)), "settings" === a && !j(this.config.settings)) {
                                const s = Y("div", z({}, u, {
                                    class: `${u.class} plyr__menu`.trim(),
                                    hidden: ""
                                }));
                                s.appendChild(i.call(this, "settings", {
                                    "aria-haspopup": !0,
                                    "aria-controls": `plyr-settings-${t.id}`,
                                    "aria-expanded": !1
                                }));
                                const r = Y("div", {
                                        class: "plyr__menu__container",
                                        id: `plyr-settings-${t.id}`,
                                        hidden: ""
                                    }),
                                    n = Y("div"),
                                    a = Y("div", {
                                        id: `plyr-settings-${t.id}-home`
                                    }),
                                    o = Y("div", {
                                        role: "menu"
                                    });
                                a.appendChild(o), n.appendChild(a), this.elements.settings.panels.home = a, this.config.settings.forEach((i => {
                                    const s = Y("button", z(tt(this.config.selectors.buttons.settings), {
                                        type: "button",
                                        class: `${this.config.classNames.control} ${this.config.classNames.control}--forward`,
                                        role: "menuitem",
                                        "aria-haspopup": !0,
                                        hidden: ""
                                    }));
                                    e.call(this, s, i), ht.call(this, s, "click", (() => {
                                        l.call(this, i, !1)
                                    }));
                                    const r = Y("span", null, Ot.get(i, this.config)),
                                        a = Y("span", {
                                            class: this.config.classNames.menu.value
                                        });
                                    a.innerHTML = t[i], r.appendChild(a), s.appendChild(r), o.appendChild(s);
                                    const c = Y("div", {
                                            id: `plyr-settings-${t.id}-${i}`,
                                            hidden: ""
                                        }),
                                        u = Y("button", {
                                            type: "button",
                                            class: `${this.config.classNames.control} ${this.config.classNames.control}--back`
                                        });
                                    u.appendChild(Y("span", {
                                        "aria-hidden": !0
                                    }, Ot.get(i, this.config))), u.appendChild(Y("span", {
                                        class: this.config.classNames.hidden
                                    }, Ot.get("menuBack", this.config))), ht.call(this, c, "keydown", (t => {
                                        "ArrowLeft" === t.key && (t.preventDefault(), t.stopPropagation(), l.call(this, "home", !0))
                                    }), !1), ht.call(this, u, "click", (() => {
                                        l.call(this, "home", !1)
                                    })), c.appendChild(u), c.appendChild(Y("div", {
                                        role: "menu"
                                    })), n.appendChild(c), this.elements.settings.buttons[i] = s, this.elements.settings.panels[i] = c
                                })), r.appendChild(n), s.appendChild(r), c.appendChild(s), this.elements.settings.popup = r, this.elements.settings.menu = s
                            }
                            if ("pip" === a && ct.pip && c.appendChild(i.call(this, "pip", u)), "airplay" === a && ct.airplay && c.appendChild(i.call(this, "airplay", u)), "download" === a) {
                                const t = z({}, u, {
                                    element: "a",
                                    href: this.download,
                                    target: "_blank"
                                });
                                this.isHTML5 && (t.download = "");
                                const {
                                    download: e
                                } = this.config.urls;
                                !B(e) && this.isEmbed && z(t, {
                                    icon: `logo-${this.provider}`,
                                    label: this.provider
                                }), c.appendChild(i.call(this, "download", t))
                            }
                            "fullscreen" === a && c.appendChild(i.call(this, "fullscreen", u))
                        })), this.isHTML5 && a.call(this, Rt.getQualityOptions.call(this)), o.call(this), c
                    },
                    inject() {
                        if (this.config.loadSprite) {
                            const t = Bt.getIconUrl.call(this);
                            t.cors && Ft(t.url, "sprite-plyr")
                        }
                        this.id = Math.floor(1e4 * Math.random());
                        let t = null;
                        this.elements.controls = null;
                        const e = {
                            id: this.id,
                            seektime: this.config.seekTime,
                            title: this.config.title
                        };
                        let i, s = !0;
                        if (P(this.config.controls) && (this.config.controls = this.config.controls.call(this, e)), this.config.controls || (this.config.controls = []), N(this.config.controls) || D(this.config.controls) ? t = this.config.controls : (t = Bt.create.call(this, {
                                id: this.id,
                                seektime: this.config.seekTime,
                                speed: this.speed,
                                quality: this.quality,
                                captions: Vt.getLabel.call(this)
                            }), s = !1), s && D(this.config.controls) && (t = (t => {
                                let i = t;
                                return Object.entries(e).forEach((([t, e]) => {
                                    i = Ct(i, `{${t}}`, e)
                                })), i
                            })(t)), D(this.config.selectors.controls.container) && (i = document.querySelector(this.config.selectors.controls.container)), N(i) || (i = this.elements.container), i[N(t) ? "insertAdjacentElement" : "insertAdjacentHTML"]("afterbegin", t), N(this.elements.controls) || Bt.findElements.call(this), !j(this.elements.buttons)) {
                            const t = t => {
                                const e = this.config.classNames.controlPressed;
                                t.setAttribute("aria-pressed", "false"), Object.defineProperty(t, "pressed", {
                                    configurable: !0,
                                    enumerable: !0,
                                    get: () => st(t, e),
                                    set(i = !1) {
                                        it(t, e, i), t.setAttribute("aria-pressed", i ? "true" : "false")
                                    }
                                })
                            };
                            Object.values(this.elements.buttons).filter(Boolean).forEach((e => {
                                O(e) || M(e) ? Array.from(e).filter(Boolean).forEach(t) : t(e)
                            }))
                        }
                        if (H.isEdge && V(i), this.config.tooltips.controls) {
                            const {
                                classNames: t,
                                selectors: e
                            } = this.config, i = `${e.controls.wrapper} ${e.labels} .${t.hidden}`, s = nt.call(this, i);
                            Array.from(s).forEach((t => {
                                it(t, this.config.classNames.hidden, !1), it(t, this.config.classNames.tooltip, !0)
                            }))
                        }
                    },
                    setMediaMetadata() {
                        try {
                            "mediaSession" in navigator && (navigator.mediaSession.metadata = new window.MediaMetadata({
                                title: this.config.mediaMetadata.title,
                                artist: this.config.mediaMetadata.artist,
                                album: this.config.mediaMetadata.album,
                                artwork: this.config.mediaMetadata.artwork
                            }))
                        } catch (t) {}
                    },
                    setMarkers() {
                        var t, e;
                        if (!this.duration || this.elements.markers) return;
                        const i = null === (t = this.config.markers) || void 0 === t || null === (e = t.points) || void 0 === e ? void 0 : e.filter((({
                            time: t
                        }) => t > 0 && t < this.duration));
                        if (null == i || !i.length) return;
                        const s = document.createDocumentFragment(),
                            r = document.createDocumentFragment();
                        let n = null;
                        const a = `${this.config.classNames.tooltip}--visible`,
                            o = t => it(n, a, t);
                        i.forEach((t => {
                            const e = Y("span", {
                                    class: this.config.classNames.marker
                                }, ""),
                                i = t.time / this.duration * 100 + "%";
                            n && (e.addEventListener("mouseenter", (() => {
                                t.label || (n.style.left = i, n.innerHTML = t.label, o(!0))
                            })), e.addEventListener("mouseleave", (() => {
                                o(!1)
                            }))), e.addEventListener("click", (() => {
                                this.currentTime = t.time
                            })), e.style.left = i, r.appendChild(e)
                        })), s.appendChild(r), this.config.tooltips.seek || (n = Y("span", {
                            class: this.config.classNames.tooltip
                        }, ""), s.appendChild(n)), this.elements.markers = {
                            points: r,
                            tip: n
                        }, this.elements.progress.appendChild(s)
                    }
                };

                function jt(t, e = !0) {
                    let i = t;
                    if (e) {
                        const t = document.createElement("a");
                        t.href = i, i = t.href
                    }
                    try {
                        return new URL(i)
                    } catch (t) {
                        return null
                    }
                }

                function Gt(t) {
                    const e = new URLSearchParams;
                    return I(t) && Object.entries(t).forEach((([t, i]) => {
                        e.set(t, i)
                    })), e
                }
                const Vt = {
                        setup() {
                            if (!this.supported.ui) return;
                            if (!this.isVideo || this.isYouTube || this.isHTML5 && !ct.textTracks) return void(O(this.config.controls) && this.config.controls.includes("settings") && this.config.settings.includes("captions") && Bt.setCaptionsMenu.call(this));
                            var t, e;
                            if (N(this.elements.captions) || (this.elements.captions = Y("div", tt(this.config.selectors.captions)), this.elements.captions.setAttribute("dir", "auto"), t = this.elements.captions, e = this.elements.wrapper, N(t) && N(e) && e.parentNode.insertBefore(t, e.nextSibling)), H.isIE && window.URL) {
                                const t = this.media.querySelectorAll("track");
                                Array.from(t).forEach((t => {
                                    const e = t.getAttribute("src"),
                                        i = jt(e);
                                    null !== i && i.hostname !== window.location.href.hostname && ["http:", "https:"].includes(i.protocol) && Nt(e, "blob").then((e => {
                                        t.setAttribute("src", window.URL.createObjectURL(e))
                                    })).catch((() => {
                                        Q(t)
                                    }))
                                }))
                            }
                            const i = bt((navigator.languages || [navigator.language || navigator.userLanguage || "en"]).map((t => t.split("-")[0])));
                            let s = (this.storage.get("language") || this.config.captions.language || "auto").toLowerCase();
                            "auto" === s && ([s] = i);
                            let r = this.storage.get("captions");
                            if (x(r) || ({
                                    active: r
                                } = this.config.captions), Object.assign(this.captions, {
                                    toggled: !1,
                                    active: r,
                                    language: s,
                                    languages: i
                                }), this.isHTML5) {
                                const t = this.config.captions.update ? "addtrack removetrack" : "removetrack";
                                ht.call(this, this.media.textTracks, t, Vt.update.bind(this))
                            }
                            setTimeout(Vt.update.bind(this), 0)
                        },
                        update() {
                            const t = Vt.getTracks.call(this, !0),
                                {
                                    active: e,
                                    language: i,
                                    meta: s,
                                    currentTrackNode: r
                                } = this.captions,
                                n = Boolean(t.find((t => t.language === i)));
                            this.isHTML5 && this.isVideo && t.filter((t => !s.get(t))).forEach((t => {
                                this.debug.log("Track added", t), s.set(t, {
                                    default: "showing" === t.mode
                                }), "showing" === t.mode && (t.mode = "hidden"), ht.call(this, t, "cuechange", (() => Vt.updateCues.call(this)))
                            })), (n && this.language !== i || !t.includes(r)) && (Vt.setLanguage.call(this, i), Vt.toggle.call(this, e && n)), this.elements && it(this.elements.container, this.config.classNames.captions.enabled, !j(t)), O(this.config.controls) && this.config.controls.includes("settings") && this.config.settings.includes("captions") && Bt.setCaptionsMenu.call(this)
                        },
                        toggle(t, e = !0) {
                            if (!this.supported.ui) return;
                            const {
                                toggled: i
                            } = this.captions, s = this.config.classNames.captions.active, r = R(t) ? !i : t;
                            if (r !== i) {
                                if (e || (this.captions.active = r, this.storage.set({
                                        captions: r
                                    })), !this.language && r && !e) {
                                    const t = Vt.getTracks.call(this),
                                        e = Vt.findTrack.call(this, [this.captions.language, ...this.captions.languages], !0);
                                    return this.captions.language = e.language, void Vt.set.call(this, t.indexOf(e))
                                }
                                this.elements.buttons.captions && (this.elements.buttons.captions.pressed = r), it(this.elements.container, s, r), this.captions.toggled = r, Bt.updateSetting.call(this, "captions"), gt.call(this, this.media, r ? "captionsenabled" : "captionsdisabled")
                            }
                            setTimeout((() => {
                                r && this.captions.toggled && (this.captions.currentTrackNode.mode = "hidden")
                            }))
                        },
                        set(t, e = !0) {
                            const i = Vt.getTracks.call(this);
                            if (-1 !== t)
                                if (C(t))
                                    if (t in i) {
                                        if (this.captions.currentTrack !== t) {
                                            this.captions.currentTrack = t;
                                            const s = i[t],
                                                {
                                                    language: r
                                                } = s || {};
                                            this.captions.currentTrackNode = s, Bt.updateSetting.call(this, "captions"), e || (this.captions.language = r, this.storage.set({
                                                language: r
                                            })), this.isVimeo && this.embed.enableTextTrack(r), gt.call(this, this.media, "languagechange")
                                        }
                                        Vt.toggle.call(this, !0, e), this.isHTML5 && this.isVideo && Vt.updateCues.call(this)
                                    } else this.debug.warn("Track not found", t);
                            else this.debug.warn("Invalid caption argument", t);
                            else Vt.toggle.call(this, !1, e)
                        },
                        setLanguage(t, e = !0) {
                            if (!D(t)) return void this.debug.warn("Invalid language argument", t);
                            const i = t.toLowerCase();
                            this.captions.language = i;
                            const s = Vt.getTracks.call(this),
                                r = Vt.findTrack.call(this, [i]);
                            Vt.set.call(this, s.indexOf(r), e)
                        },
                        getTracks(t = !1) {
                            return Array.from((this.media || {}).textTracks || []).filter((e => !this.isHTML5 || t || this.captions.meta.has(e))).filter((t => ["captions", "subtitles"].includes(t.kind)))
                        },
                        findTrack(t, e = !1) {
                            const i = Vt.getTracks.call(this),
                                s = t => Number((this.captions.meta.get(t) || {}).default),
                                r = Array.from(i).sort(((t, e) => s(e) - s(t)));
                            let n;
                            return t.every((t => (n = r.find((e => e.language === t)), !n))), n || (e ? r[0] : void 0)
                        },
                        getCurrentTrack() {
                            return Vt.getTracks.call(this)[this.currentTrack]
                        },
                        getLabel(t) {
                            let e = t;
                            return !U(e) && ct.textTracks && this.captions.toggled && (e = Vt.getCurrentTrack.call(this)), U(e) ? j(e.label) ? j(e.language) ? Ot.get("enabled", this.config) : t.language.toUpperCase() : e.label : Ot.get("disabled", this.config)
                        },
                        updateCues(t) {
                            if (!this.supported.ui) return;
                            if (!N(this.elements.captions)) return void this.debug.warn("No captions element to render to");
                            if (!R(t) && !Array.isArray(t)) return void this.debug.warn("updateCues: Invalid input", t);
                            let e = t;
                            if (!e) {
                                const t = Vt.getCurrentTrack.call(this);
                                e = Array.from((t || {}).activeCues || []).map((t => t.getCueAsHTML())).map(xt)
                            }
                            const i = e.map((t => t.trim())).join("\n");
                            if (i !== this.elements.captions.innerHTML) {
                                J(this.elements.captions);
                                const t = Y("span", tt(this.config.selectors.caption));
                                t.innerHTML = i, this.elements.captions.appendChild(t), gt.call(this, this.media, "cuechange")
                            }
                        }
                    },
                    Ht = {
                        enabled: !0,
                        title: "",
                        debug: !1,
                        autoplay: !1,
                        autopause: !0,
                        playsinline: !0,
                        seekTime: 10,
                        volume: 1,
                        muted: !1,
                        duration: null,
                        displayDuration: !0,
                        invertTime: !0,
                        toggleInvert: !0,
                        ratio: null,
                        clickToPlay: !0,
                        hideControls: !0,
                        resetOnEnd: !1,
                        disableContextMenu: !0,
                        loadSprite: !0,
                        iconPrefix: "plyr",
                        iconUrl: "https://cdn.plyr.io/3.7.3/plyr.svg",
                        blankVideo: "https://cdn.plyr.io/static/blank.mp4",
                        quality: {
                            default: 576,
                            options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240],
                            forced: !1,
                            onChange: null
                        },
                        loop: {
                            active: !1
                        },
                        speed: {
                            selected: 1,
                            options: [.5, .75, 1, 1.25, 1.5, 1.75, 2, 4]
                        },
                        keyboard: {
                            focused: !0,
                            global: !1
                        },
                        tooltips: {
                            controls: !1,
                            seek: !0
                        },
                        captions: {
                            active: !1,
                            language: "auto",
                            update: !1
                        },
                        fullscreen: {
                            enabled: !0,
                            fallback: !0,
                            iosNative: !1
                        },
                        storage: {
                            enabled: !0,
                            key: "plyr"
                        },
                        controls: ["play-large", "play", "progress", "current-time", "mute", "volume", "captions", "settings", "pip", "airplay", "fullscreen"],
                        settings: ["captions", "quality", "speed"],
                        i18n: {
                            restart: "Restart",
                            rewind: "Rewind {seektime}s",
                            play: "Play",
                            pause: "Pause",
                            fastForward: "Forward {seektime}s",
                            seek: "Seek",
                            seekLabel: "{currentTime} of {duration}",
                            played: "Played",
                            buffered: "Buffered",
                            currentTime: "Current time",
                            duration: "Duration",
                            volume: "Volume",
                            mute: "Mute",
                            unmute: "Unmute",
                            enableCaptions: "Enable captions",
                            disableCaptions: "Disable captions",
                            download: "Download",
                            enterFullscreen: "Enter fullscreen",
                            exitFullscreen: "Exit fullscreen",
                            frameTitle: "Player for {title}",
                            captions: "Captions",
                            settings: "Settings",
                            pip: "PIP",
                            menuBack: "Go back to previous menu",
                            speed: "Speed",
                            normal: "Normal",
                            quality: "Quality",
                            loop: "Loop",
                            start: "Start",
                            end: "End",
                            all: "All",
                            reset: "Reset",
                            disabled: "Disabled",
                            enabled: "Enabled",
                            advertisement: "Ad",
                            qualityBadge: {
                                2160: "4K",
                                1440: "HD",
                                1080: "HD",
                                720: "HD",
                                576: "SD",
                                480: "SD"
                            }
                        },
                        urls: {
                            download: null,
                            vimeo: {
                                sdk: "https://player.vimeo.com/api/player.js",
                                iframe: "https://player.vimeo.com/video/{0}?{1}",
                                api: "https://vimeo.com/api/oembed.json?url={0}"
                            },
                            youtube: {
                                sdk: "https://www.youtube.com/iframe_api",
                                api: "https://noembed.com/embed?url=https://www.youtube.com/watch?v={0}"
                            },
                            googleIMA: {
                                sdk: "https://imasdk.googleapis.com/js/sdkloader/ima3.js"
                            }
                        },
                        listeners: {
                            seek: null,
                            play: null,
                            pause: null,
                            restart: null,
                            rewind: null,
                            fastForward: null,
                            mute: null,
                            volume: null,
                            captions: null,
                            download: null,
                            fullscreen: null,
                            pip: null,
                            airplay: null,
                            speed: null,
                            quality: null,
                            loop: null,
                            language: null
                        },
                        events: ["ended", "progress", "stalled", "playing", "waiting", "canplay", "canplaythrough", "loadstart", "loadeddata", "loadedmetadata", "timeupdate", "volumechange", "play", "pause", "error", "seeking", "seeked", "emptied", "ratechange", "cuechange", "download", "enterfullscreen", "exitfullscreen", "captionsenabled", "captionsdisabled", "languagechange", "controlshidden", "controlsshown", "ready", "statechange", "qualitychange", "adsloaded", "adscontentpause", "adscontentresume", "adstarted", "adsmidpoint", "adscomplete", "adsallcomplete", "adsimpression", "adsclick"],
                        selectors: {
                            editable: "input, textarea, select, [contenteditable]",
                            container: ".plyr",
                            controls: {
                                container: null,
                                wrapper: ".plyr__controls"
                            },
                            labels: "[data-plyr]",
                            buttons: {
                                play: '[data-plyr="play"]',
                                pause: '[data-plyr="pause"]',
                                restart: '[data-plyr="restart"]',
                                rewind: '[data-plyr="rewind"]',
                                fastForward: '[data-plyr="fast-forward"]',
                                mute: '[data-plyr="mute"]',
                                captions: '[data-plyr="captions"]',
                                download: '[data-plyr="download"]',
                                fullscreen: '[data-plyr="fullscreen"]',
                                pip: '[data-plyr="pip"]',
                                airplay: '[data-plyr="airplay"]',
                                settings: '[data-plyr="settings"]',
                                loop: '[data-plyr="loop"]'
                            },
                            inputs: {
                                seek: '[data-plyr="seek"]',
                                volume: '[data-plyr="volume"]',
                                speed: '[data-plyr="speed"]',
                                language: '[data-plyr="language"]',
                                quality: '[data-plyr="quality"]'
                            },
                            display: {
                                currentTime: ".plyr__time--current",
                                duration: ".plyr__time--duration",
                                buffer: ".plyr__progress__buffer",
                                loop: ".plyr__progress__loop",
                                volume: ".plyr__volume--display"
                            },
                            progress: ".plyr__progress",
                            captions: ".plyr__captions",
                            caption: ".plyr__caption"
                        },
                        classNames: {
                            type: "plyr--{0}",
                            provider: "plyr--{0}",
                            video: "plyr__video-wrapper",
                            embed: "plyr__video-embed",
                            videoFixedRatio: "plyr__video-wrapper--fixed-ratio",
                            embedContainer: "plyr__video-embed__container",
                            poster: "plyr__poster",
                            posterEnabled: "plyr__poster-enabled",
                            ads: "plyr__ads",
                            control: "plyr__control",
                            controlPressed: "plyr__control--pressed",
                            playing: "plyr--playing",
                            paused: "plyr--paused",
                            stopped: "plyr--stopped",
                            loading: "plyr--loading",
                            hover: "plyr--hover",
                            tooltip: "plyr__tooltip",
                            cues: "plyr__cues",
                            marker: "plyr__progress__marker",
                            hidden: "plyr__sr-only",
                            hideControls: "plyr--hide-controls",
                            isIos: "plyr--is-ios",
                            isTouch: "plyr--is-touch",
                            uiSupported: "plyr--full-ui",
                            noTransition: "plyr--no-transition",
                            display: {
                                time: "plyr__time"
                            },
                            menu: {
                                value: "plyr__menu__value",
                                badge: "plyr__badge",
                                open: "plyr--menu-open"
                            },
                            captions: {
                                enabled: "plyr--captions-enabled",
                                active: "plyr--captions-active"
                            },
                            fullscreen: {
                                enabled: "plyr--fullscreen-enabled",
                                fallback: "plyr--fullscreen-fallback"
                            },
                            pip: {
                                supported: "plyr--pip-supported",
                                active: "plyr--pip-active"
                            },
                            airplay: {
                                supported: "plyr--airplay-supported",
                                active: "plyr--airplay-active"
                            },
                            tabFocus: "plyr__tab-focus",
                            previewThumbnails: {
                                thumbContainer: "plyr__preview-thumb",
                                thumbContainerShown: "plyr__preview-thumb--is-shown",
                                imageContainer: "plyr__preview-thumb__image-container",
                                timeContainer: "plyr__preview-thumb__time-container",
                                scrubbingContainer: "plyr__preview-scrubbing",
                                scrubbingContainerShown: "plyr__preview-scrubbing--is-shown"
                            }
                        },
                        attributes: {
                            embed: {
                                provider: "data-plyr-provider",
                                id: "data-plyr-embed-id",
                                hash: "data-plyr-embed-hash"
                            }
                        },
                        ads: {
                            enabled: !1,
                            publisherId: "",
                            tagUrl: ""
                        },
                        previewThumbnails: {
                            enabled: !1,
                            src: ""
                        },
                        vimeo: {
                            byline: !1,
                            portrait: !1,
                            title: !1,
                            speed: !0,
                            transparent: !1,
                            customControls: !0,
                            referrerPolicy: null,
                            premium: !1
                        },
                        youtube: {
                            rel: 0,
                            showinfo: 0,
                            iv_load_policy: 3,
                            modestbranding: 1,
                            customControls: !0,
                            noCookie: !1
                        },
                        mediaMetadata: {
                            title: "",
                            artist: "",
                            album: "",
                            artwork: []
                        },
                        markers: {
                            enabled: !1,
                            points: []
                        }
                    },
                    Kt = "picture-in-picture",
                    zt = {
                        html5: "html5",
                        youtube: "youtube",
                        vimeo: "vimeo"
                    },
                    qt = "video",
                    Wt = () => {};
                class Yt {
                    constructor(t = !1) {
                        this.enabled = window.console && t, this.enabled && this.log("Debugging enabled")
                    }
                    get log() {
                        return this.enabled ? Function.prototype.bind.call(console.log, console) : Wt
                    }
                    get warn() {
                        return this.enabled ? Function.prototype.bind.call(console.warn, console) : Wt
                    }
                    get error() {
                        return this.enabled ? Function.prototype.bind.call(console.error, console) : Wt
                    }
                }
                class Xt {
                    constructor(e) {
                        t(this, "onChange", (() => {
                            if (!this.enabled) return;
                            const t = this.player.elements.buttons.fullscreen;
                            N(t) && (t.pressed = this.active);
                            const e = this.target === this.player.media ? this.target : this.player.elements.container;
                            gt.call(this.player, e, this.active ? "enterfullscreen" : "exitfullscreen", !0)
                        })), t(this, "toggleFallback", ((t = !1) => {
                            if (t ? this.scrollPosition = {
                                    x: window.scrollX || 0,
                                    y: window.scrollY || 0
                                } : window.scrollTo(this.scrollPosition.x, this.scrollPosition.y), document.body.style.overflow = t ? "hidden" : "", it(this.target, this.player.config.classNames.fullscreen.fallback, t), H.isIos) {
                                let e = document.head.querySelector('meta[name="viewport"]');
                                const i = "viewport-fit=cover";
                                e || (e = document.createElement("meta"), e.setAttribute("name", "viewport"));
                                const s = D(e.content) && e.content.includes(i);
                                t ? (this.cleanupViewport = !s, s || (e.content += `,${i}`)) : this.cleanupViewport && (e.content = e.content.split(",").filter((t => t.trim() !== i)).join(","))
                            }
                            this.onChange()
                        })), t(this, "trapFocus", (t => {
                            if (H.isIos || !this.active || "Tab" !== t.key) return;
                            const e = document.activeElement,
                                i = nt.call(this.player, "a[href], button:not(:disabled), input:not(:disabled), [tabindex]"),
                                [s] = i,
                                r = i[i.length - 1];
                            e !== r || t.shiftKey ? e === s && t.shiftKey && (r.focus(), t.preventDefault()) : (s.focus(), t.preventDefault())
                        })), t(this, "update", (() => {
                            if (this.enabled) {
                                let t;
                                t = this.forceFallback ? "Fallback (forced)" : Xt.native ? "Native" : "Fallback", this.player.debug.log(`${t} fullscreen enabled`)
                            } else this.player.debug.log("Fullscreen not supported and fallback disabled");
                            it(this.player.elements.container, this.player.config.classNames.fullscreen.enabled, this.enabled)
                        })), t(this, "enter", (() => {
                            this.enabled && (H.isIos && this.player.config.fullscreen.iosNative ? this.player.isVimeo ? this.player.embed.requestFullscreen() : this.target.webkitEnterFullscreen() : !Xt.native || this.forceFallback ? this.toggleFallback(!0) : this.prefix ? j(this.prefix) || this.target[`${this.prefix}Request${this.property}`]() : this.target.requestFullscreen({
                                navigationUI: "hide"
                            }))
                        })), t(this, "exit", (() => {
                            if (this.enabled)
                                if (H.isIos && this.player.config.fullscreen.iosNative) this.target.webkitExitFullscreen(), vt(this.player.play());
                                else if (!Xt.native || this.forceFallback) this.toggleFallback(!1);
                            else if (this.prefix) {
                                if (!j(this.prefix)) {
                                    const t = "moz" === this.prefix ? "Cancel" : "Exit";
                                    document[`${this.prefix}${t}${this.property}`]()
                                }
                            } else(document.cancelFullScreen || document.exitFullscreen).call(document)
                        })), t(this, "toggle", (() => {
                            this.active ? this.exit() : this.enter()
                        })), this.player = e, this.prefix = Xt.prefix, this.property = Xt.property, this.scrollPosition = {
                            x: 0,
                            y: 0
                        }, this.forceFallback = "force" === e.config.fullscreen.fallback, this.player.elements.fullscreen = e.config.fullscreen.container && function(t, e) {
                            const {
                                prototype: i
                            } = Element;
                            return (i.closest || function() {
                                let t = this;
                                do {
                                    if (rt.matches(t, e)) return t;
                                    t = t.parentElement || t.parentNode
                                } while (null !== t && 1 === t.nodeType);
                                return null
                            }).call(t, e)
                        }(this.player.elements.container, e.config.fullscreen.container), ht.call(this.player, document, "ms" === this.prefix ? "MSFullscreenChange" : `${this.prefix}fullscreenchange`, (() => {
                            this.onChange()
                        })), ht.call(this.player, this.player.elements.container, "dblclick", (t => {
                            N(this.player.elements.controls) && this.player.elements.controls.contains(t.target) || this.player.listeners.proxy(t, this.toggle, "fullscreen")
                        })), ht.call(this, this.player.elements.container, "keydown", (t => this.trapFocus(t))), this.update()
                    }
                    static get native() {
                        return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled)
                    }
                    get usingNative() {
                        return Xt.native && !this.forceFallback
                    }
                    static get prefix() {
                        if (P(document.exitFullscreen)) return "";
                        let t = "";
                        return ["webkit", "moz", "ms"].some((e => !(!P(document[`${e}ExitFullscreen`]) && !P(document[`${e}CancelFullScreen`]) || (t = e, 0)))), t
                    }
                    static get property() {
                        return "moz" === this.prefix ? "FullScreen" : "Fullscreen"
                    }
                    get enabled() {
                        return (Xt.native || this.player.config.fullscreen.fallback) && this.player.config.fullscreen.enabled && this.player.supported.ui && this.player.isVideo
                    }
                    get active() {
                        if (!this.enabled) return !1;
                        if (!Xt.native || this.forceFallback) return st(this.target, this.player.config.classNames.fullscreen.fallback);
                        const t = this.prefix ? this.target.getRootNode()[`${this.prefix}${this.property}Element`] : this.target.getRootNode().fullscreenElement;
                        return t && t.shadowRoot ? t === this.target.getRootNode().host : t === this.target
                    }
                    get target() {
                        return H.isIos && this.player.config.fullscreen.iosNative ? this.player.media : this.player.elements.fullscreen || this.player.elements.container
                    }
                }

                function Qt(t, e = 1) {
                    return new Promise(((i, s) => {
                        const r = new Image,
                            n = () => {
                                delete r.onload, delete r.onerror, (r.naturalWidth >= e ? i : s)(r)
                            };
                        Object.assign(r, {
                            onload: n,
                            onerror: n,
                            src: t
                        })
                    }))
                }
                const Jt = {
                    addStyleHook() {
                        it(this.elements.container, this.config.selectors.container.replace(".", ""), !0), it(this.elements.container, this.config.classNames.uiSupported, this.supported.ui)
                    },
                    toggleNativeControls(t = !1) {
                        t && this.isHTML5 ? this.media.setAttribute("controls", "") : this.media.removeAttribute("controls")
                    },
                    build() {
                        if (this.listeners.media(), !this.supported.ui) return this.debug.warn(`Basic support only for ${this.provider} ${this.type}`), void Jt.toggleNativeControls.call(this, !0);
                        N(this.elements.controls) || (Bt.inject.call(this), this.listeners.controls()), Jt.toggleNativeControls.call(this), this.isHTML5 && Vt.setup.call(this), this.volume = null, this.muted = null, this.loop = null, this.quality = null, this.speed = null, Bt.updateVolume.call(this), Bt.timeUpdate.call(this), Bt.durationUpdate.call(this), Jt.checkPlaying.call(this), it(this.elements.container, this.config.classNames.pip.supported, ct.pip && this.isHTML5 && this.isVideo), it(this.elements.container, this.config.classNames.airplay.supported, ct.airplay && this.isHTML5), it(this.elements.container, this.config.classNames.isIos, H.isIos), it(this.elements.container, this.config.classNames.isTouch, this.touch), this.ready = !0, setTimeout((() => {
                            gt.call(this, this.media, "ready")
                        }), 0), Jt.setTitle.call(this), this.poster && Jt.setPoster.call(this, this.poster, !1).catch((() => {})), this.config.duration && Bt.durationUpdate.call(this), this.config.mediaMetadata && Bt.setMediaMetadata.call(this)
                    },
                    setTitle() {
                        let t = Ot.get("play", this.config);
                        if (D(this.config.title) && !j(this.config.title) && (t += `, ${this.config.title}`), Array.from(this.elements.buttons.play || []).forEach((e => {
                                e.setAttribute("aria-label", t)
                            })), this.isEmbed) {
                            const t = at.call(this, "iframe");
                            if (!N(t)) return;
                            const e = j(this.config.title) ? "video" : this.config.title,
                                i = Ot.get("frameTitle", this.config);
                            t.setAttribute("title", i.replace("{title}", e))
                        }
                    },
                    togglePoster(t) {
                        it(this.elements.container, this.config.classNames.posterEnabled, t)
                    },
                    setPoster(t, e = !0) {
                        return e && this.poster ? Promise.reject(new Error("Poster already set")) : (this.media.setAttribute("data-poster", t), this.elements.poster.removeAttribute("hidden"), yt.call(this).then((() => Qt(t))).catch((e => {
                            throw t === this.poster && Jt.togglePoster.call(this, !1), e
                        })).then((() => {
                            if (t !== this.poster) throw new Error("setPoster cancelled by later call to setPoster")
                        })).then((() => (Object.assign(this.elements.poster.style, {
                            backgroundImage: `url('${t}')`,
                            backgroundSize: ""
                        }), Jt.togglePoster.call(this, !0), t))))
                    },
                    checkPlaying(t) {
                        it(this.elements.container, this.config.classNames.playing, this.playing), it(this.elements.container, this.config.classNames.paused, this.paused), it(this.elements.container, this.config.classNames.stopped, this.stopped), Array.from(this.elements.buttons.play || []).forEach((t => {
                            Object.assign(t, {
                                pressed: this.playing
                            }), t.setAttribute("aria-label", Ot.get(this.playing ? "pause" : "play", this.config))
                        })), F(t) && "timeupdate" === t.type || Jt.toggleControls.call(this)
                    },
                    checkLoading(t) {
                        this.loading = ["stalled", "waiting"].includes(t.type), clearTimeout(this.timers.loading), this.timers.loading = setTimeout((() => {
                            it(this.elements.container, this.config.classNames.loading, this.loading), Jt.toggleControls.call(this)
                        }), this.loading ? 250 : 0)
                    },
                    toggleControls(t) {
                        const {
                            controls: e
                        } = this.elements;
                        if (e && this.config.hideControls) {
                            const i = this.touch && this.lastSeekTime + 2e3 > Date.now();
                            this.toggleControls(Boolean(t || this.loading || this.paused || e.pressed || e.hover || i))
                        }
                    },
                    migrateStyles() {
                        Object.values({ ...this.media.style
                        }).filter((t => !j(t) && D(t) && t.startsWith("--plyr"))).forEach((t => {
                            this.elements.container.style.setProperty(t, this.media.style.getPropertyValue(t)), this.media.style.removeProperty(t)
                        })), j(this.media.style) && this.media.removeAttribute("style")
                    }
                };
                class Zt {
                    constructor(e) {
                        t(this, "firstTouch", (() => {
                            const {
                                player: t
                            } = this, {
                                elements: e
                            } = t;
                            t.touch = !0, it(e.container, t.config.classNames.isTouch, !0)
                        })), t(this, "setTabFocus", (t => {
                            const {
                                player: e
                            } = this, {
                                elements: i
                            } = e, {
                                key: s,
                                type: r,
                                timeStamp: n
                            } = t;
                            if (clearTimeout(this.focusTimer), "keydown" === r && "Tab" !== s) return;
                            "keydown" === r && (this.lastKeyDown = n);
                            const a = n - this.lastKeyDown <= 20;
                            ("focus" !== r || a) && ((() => {
                                const t = e.config.classNames.tabFocus;
                                it(nt.call(e, `.${t}`), t, !1)
                            })(), "focusout" !== r && (this.focusTimer = setTimeout((() => {
                                const t = document.activeElement;
                                i.container.contains(t) && it(document.activeElement, e.config.classNames.tabFocus, !0)
                            }), 10)))
                        })), t(this, "global", ((t = !0) => {
                            const {
                                player: e
                            } = this;
                            e.config.keyboard.global && dt.call(e, window, "keydown keyup", this.handleKey, t, !1), dt.call(e, document.body, "click", this.toggleMenu, t), pt.call(e, document.body, "touchstart", this.firstTouch), dt.call(e, document.body, "keydown focus blur focusout", this.setTabFocus, t, !1, !0)
                        })), t(this, "container", (() => {
                            const {
                                player: t
                            } = this, {
                                config: e,
                                elements: i,
                                timers: s
                            } = t;
                            !e.keyboard.global && e.keyboard.focused && ht.call(t, i.container, "keydown keyup", this.handleKey, !1), ht.call(t, i.container, "mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen", (e => {
                                const {
                                    controls: r
                                } = i;
                                r && "enterfullscreen" === e.type && (r.pressed = !1, r.hover = !1);
                                let n = 0;
                                ["touchstart", "touchmove", "mousemove"].includes(e.type) && (Jt.toggleControls.call(t, !0), n = t.touch ? 3e3 : 2e3), clearTimeout(s.controls), s.controls = setTimeout((() => Jt.toggleControls.call(t, !1)), n)
                            }));
                            const r = () => {
                                    if (!t.isVimeo || t.config.vimeo.premium) return;
                                    const e = i.wrapper,
                                        {
                                            active: s
                                        } = t.fullscreen,
                                        [r, n] = At.call(t),
                                        a = Et(`aspect-ratio: ${r} / ${n}`);
                                    if (!s) return void(a ? (e.style.width = null, e.style.height = null) : (e.style.maxWidth = null, e.style.margin = null));
                                    const [o, l] = [Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0), Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)], c = o / l > r / n;
                                    a ? (e.style.width = c ? "auto" : "100%", e.style.height = c ? "100%" : "auto") : (e.style.maxWidth = c ? l / n * r + "px" : null, e.style.margin = c ? "0 auto" : null)
                                },
                                n = () => {
                                    clearTimeout(s.resized), s.resized = setTimeout(r, 50)
                                };
                            ht.call(t, i.container, "enterfullscreen exitfullscreen", (e => {
                                const {
                                    target: s
                                } = t.fullscreen;
                                s === i.container && (!t.isEmbed && j(t.config.ratio) || (r(), ("enterfullscreen" === e.type ? ht : ft).call(t, window, "resize", n)))
                            }))
                        })), t(this, "media", (() => {
                            const {
                                player: t
                            } = this, {
                                elements: e
                            } = t;
                            if (ht.call(t, t.media, "timeupdate seeking seeked", (e => Bt.timeUpdate.call(t, e))), ht.call(t, t.media, "durationchange loadeddata loadedmetadata", (e => Bt.durationUpdate.call(t, e))), ht.call(t, t.media, "ended", (() => {
                                    t.isHTML5 && t.isVideo && t.config.resetOnEnd && (t.restart(), t.pause())
                                })), ht.call(t, t.media, "progress playing seeking seeked", (e => Bt.updateProgress.call(t, e))), ht.call(t, t.media, "volumechange", (e => Bt.updateVolume.call(t, e))), ht.call(t, t.media, "playing play pause ended emptied timeupdate", (e => Jt.checkPlaying.call(t, e))), ht.call(t, t.media, "waiting canplay seeked playing", (e => Jt.checkLoading.call(t, e))), t.supported.ui && t.config.clickToPlay && !t.isAudio) {
                                const i = at.call(t, `.${t.config.classNames.video}`);
                                if (!N(i)) return;
                                ht.call(t, e.container, "click", (s => {
                                    ([e.container, i].includes(s.target) || i.contains(s.target)) && (t.touch && t.config.hideControls || (t.ended ? (this.proxy(s, t.restart, "restart"), this.proxy(s, (() => {
                                        vt(t.play())
                                    }), "play")) : this.proxy(s, (() => {
                                        vt(t.togglePlay())
                                    }), "play")))
                                }))
                            }
                            t.supported.ui && t.config.disableContextMenu && ht.call(t, e.wrapper, "contextmenu", (t => {
                                t.preventDefault()
                            }), !1), ht.call(t, t.media, "volumechange", (() => {
                                t.storage.set({
                                    volume: t.volume,
                                    muted: t.muted
                                })
                            })), ht.call(t, t.media, "ratechange", (() => {
                                Bt.updateSetting.call(t, "speed"), t.storage.set({
                                    speed: t.speed
                                })
                            })), ht.call(t, t.media, "qualitychange", (e => {
                                Bt.updateSetting.call(t, "quality", null, e.detail.quality)
                            })), ht.call(t, t.media, "ready qualitychange", (() => {
                                Bt.setDownloadUrl.call(t)
                            }));
                            const i = t.config.events.concat(["keyup", "keydown"]).join(" ");
                            ht.call(t, t.media, i, (i => {
                                let {
                                    detail: s = {}
                                } = i;
                                "error" === i.type && (s = t.media.error), gt.call(t, e.container, i.type, !0, s)
                            }))
                        })), t(this, "proxy", ((t, e, i) => {
                            const {
                                player: s
                            } = this, r = s.config.listeners[i];
                            let n = !0;
                            P(r) && (n = r.call(s, t)), !1 !== n && P(e) && e.call(s, t)
                        })), t(this, "bind", ((t, e, i, s, r = !0) => {
                            const {
                                player: n
                            } = this, a = n.config.listeners[s], o = P(a);
                            ht.call(n, t, e, (t => this.proxy(t, i, s)), r && !o)
                        })), t(this, "controls", (() => {
                            const {
                                player: t
                            } = this, {
                                elements: e
                            } = t, i = H.isIE ? "change" : "input";
                            if (e.buttons.play && Array.from(e.buttons.play).forEach((e => {
                                    this.bind(e, "click", (() => {
                                        vt(t.togglePlay())
                                    }), "play")
                                })), this.bind(e.buttons.restart, "click", t.restart, "restart"), this.bind(e.buttons.rewind, "click", (() => {
                                    t.lastSeekTime = Date.now(), t.rewind()
                                }), "rewind"), this.bind(e.buttons.fastForward, "click", (() => {
                                    t.lastSeekTime = Date.now(), t.forward()
                                }), "fastForward"), this.bind(e.buttons.mute, "click", (() => {
                                    t.muted = !t.muted
                                }), "mute"), this.bind(e.buttons.captions, "click", (() => t.toggleCaptions())), this.bind(e.buttons.download, "click", (() => {
                                    gt.call(t, t.media, "download")
                                }), "download"), this.bind(e.buttons.fullscreen, "click", (() => {
                                    t.fullscreen.toggle()
                                }), "fullscreen"), this.bind(e.buttons.pip, "click", (() => {
                                    t.pip = "toggle"
                                }), "pip"), this.bind(e.buttons.airplay, "click", t.airplay, "airplay"), this.bind(e.buttons.settings, "click", (e => {
                                    e.stopPropagation(), e.preventDefault(), Bt.toggleMenu.call(t, e)
                                }), null, !1), this.bind(e.buttons.settings, "keyup", (e => {
                                    ["Space", "Enter"].includes(e.key) && ("Enter" !== e.key ? (e.preventDefault(), e.stopPropagation(), Bt.toggleMenu.call(t, e)) : Bt.focusFirstMenuItem.call(t, null, !0))
                                }), null, !1), this.bind(e.settings.menu, "keydown", (e => {
                                    "Escape" === e.key && Bt.toggleMenu.call(t, e)
                                })), this.bind(e.inputs.seek, "mousedown mousemove", (t => {
                                    const i = e.progress.getBoundingClientRect(),
                                        s = 100 / i.width * (t.pageX - i.left);
                                    t.currentTarget.setAttribute("seek-value", s)
                                })), this.bind(e.inputs.seek, "mousedown mouseup keydown keyup touchstart touchend", (e => {
                                    const i = e.currentTarget,
                                        s = "play-on-seeked";
                                    if ($(e) && !["ArrowLeft", "ArrowRight"].includes(e.key)) return;
                                    t.lastSeekTime = Date.now();
                                    const r = i.hasAttribute(s),
                                        n = ["mouseup", "touchend", "keyup"].includes(e.type);
                                    r && n ? (i.removeAttribute(s), vt(t.play())) : !n && t.playing && (i.setAttribute(s, ""), t.pause())
                                })), H.isIos) {
                                const e = nt.call(t, 'input[type="range"]');
                                Array.from(e).forEach((t => this.bind(t, i, (t => V(t.target)))))
                            }
                            this.bind(e.inputs.seek, i, (e => {
                                const i = e.currentTarget;
                                let s = i.getAttribute("seek-value");
                                j(s) && (s = i.value), i.removeAttribute("seek-value"), t.currentTime = s / i.max * t.duration
                            }), "seek"), this.bind(e.progress, "mouseenter mouseleave mousemove", (e => Bt.updateSeekTooltip.call(t, e))), this.bind(e.progress, "mousemove touchmove", (e => {
                                const {
                                    previewThumbnails: i
                                } = t;
                                i && i.loaded && i.startMove(e)
                            })), this.bind(e.progress, "mouseleave touchend click", (() => {
                                const {
                                    previewThumbnails: e
                                } = t;
                                e && e.loaded && e.endMove(!1, !0)
                            })), this.bind(e.progress, "mousedown touchstart", (e => {
                                const {
                                    previewThumbnails: i
                                } = t;
                                i && i.loaded && i.startScrubbing(e)
                            })), this.bind(e.progress, "mouseup touchend", (e => {
                                const {
                                    previewThumbnails: i
                                } = t;
                                i && i.loaded && i.endScrubbing(e)
                            })), H.isWebkit && Array.from(nt.call(t, 'input[type="range"]')).forEach((e => {
                                this.bind(e, "input", (e => Bt.updateRangeFill.call(t, e.target)))
                            })), t.config.toggleInvert && !N(e.display.duration) && this.bind(e.display.currentTime, "click", (() => {
                                0 !== t.currentTime && (t.config.invertTime = !t.config.invertTime, Bt.timeUpdate.call(t))
                            })), this.bind(e.inputs.volume, i, (e => {
                                t.volume = e.target.value
                            }), "volume"), this.bind(e.controls, "mouseenter mouseleave", (i => {
                                e.controls.hover = !t.touch && "mouseenter" === i.type
                            })), e.fullscreen && Array.from(e.fullscreen.children).filter((t => !t.contains(e.container))).forEach((i => {
                                this.bind(i, "mouseenter mouseleave", (i => {
                                    e.controls && (e.controls.hover = !t.touch && "mouseenter" === i.type)
                                }))
                            })), this.bind(e.controls, "mousedown mouseup touchstart touchend touchcancel", (t => {
                                e.controls.pressed = ["mousedown", "touchstart"].includes(t.type)
                            })), this.bind(e.controls, "focusin", (() => {
                                const {
                                    config: i,
                                    timers: s
                                } = t;
                                it(e.controls, i.classNames.noTransition, !0), Jt.toggleControls.call(t, !0), setTimeout((() => {
                                    it(e.controls, i.classNames.noTransition, !1)
                                }), 0);
                                const r = this.touch ? 3e3 : 4e3;
                                clearTimeout(s.controls), s.controls = setTimeout((() => Jt.toggleControls.call(t, !1)), r)
                            })), this.bind(e.inputs.volume, "wheel", (e => {
                                const i = e.webkitDirectionInvertedFromDevice,
                                    [s, r] = [e.deltaX, -e.deltaY].map((t => i ? -t : t)),
                                    n = Math.sign(Math.abs(s) > Math.abs(r) ? s : r);
                                t.increaseVolume(n / 50);
                                const {
                                    volume: a
                                } = t.media;
                                (1 === n && a < 1 || -1 === n && a > 0) && e.preventDefault()
                            }), "volume", !1)
                        })), this.player = e, this.lastKey = null, this.focusTimer = null, this.lastKeyDown = null, this.handleKey = this.handleKey.bind(this), this.toggleMenu = this.toggleMenu.bind(this), this.setTabFocus = this.setTabFocus.bind(this), this.firstTouch = this.firstTouch.bind(this)
                    }
                    handleKey(t) {
                        const {
                            player: e
                        } = this, {
                            elements: i
                        } = e, {
                            key: s,
                            type: r,
                            altKey: n,
                            ctrlKey: a,
                            metaKey: o,
                            shiftKey: l
                        } = t, c = "keydown" === r, u = c && s === this.lastKey;
                        var d;
                        if (!(n || a || o || l) && s)
                            if (c) {
                                const r = document.activeElement;
                                if (N(r)) {
                                    const {
                                        editable: s
                                    } = e.config.selectors, {
                                        seek: n
                                    } = i.inputs;
                                    if (r !== n && rt(r, s)) return;
                                    if ("Space" === t.key && rt(r, 'button, [role^="menuitem"]')) return
                                }
                                switch (["Space", "ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "c", "f", "k", "l", "m"].includes(s) && (t.preventDefault(), t.stopPropagation()), s) {
                                    case "0":
                                    case "1":
                                    case "2":
                                    case "3":
                                    case "4":
                                    case "5":
                                    case "6":
                                    case "7":
                                    case "8":
                                    case "9":
                                        u || (d = parseInt(s, 10), e.currentTime = e.duration / 10 * d);
                                        break;
                                    case "Space":
                                    case "k":
                                        u || vt(e.togglePlay());
                                        break;
                                    case "ArrowUp":
                                        e.increaseVolume(.1);
                                        break;
                                    case "ArrowDown":
                                        e.decreaseVolume(.1);
                                        break;
                                    case "m":
                                        u || (e.muted = !e.muted);
                                        break;
                                    case "ArrowRight":
                                        e.forward();
                                        break;
                                    case "ArrowLeft":
                                        e.rewind();
                                        break;
                                    case "f":
                                        e.fullscreen.toggle();
                                        break;
                                    case "c":
                                        u || e.toggleCaptions();
                                        break;
                                    case "l":
                                        e.loop = !e.loop
                                }
                                "Escape" === s && !e.fullscreen.usingNative && e.fullscreen.active && e.fullscreen.toggle(), this.lastKey = s
                            } else this.lastKey = null
                    }
                    toggleMenu(t) {
                        Bt.toggleMenu.call(this.player, t)
                    }
                }
                "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== i.g ? i.g : "undefined" != typeof self && self;
                var te = function(t, e) {
                    return function(t, e) {
                        t.exports = function() {
                            var t = function() {},
                                e = {},
                                i = {},
                                s = {};

                            function r(t, e) {
                                t = t.push ? t : [t];
                                var r, n, a, o = [],
                                    l = t.length,
                                    c = l;
                                for (r = function(t, i) {
                                        i.length && o.push(t), --c || e(o)
                                    }; l--;) n = t[l], (a = i[n]) ? r(n, a) : (s[n] = s[n] || []).push(r)
                            }

                            function n(t, e) {
                                if (t) {
                                    var r = s[t];
                                    if (i[t] = e, r)
                                        for (; r.length;) r[0](t, e), r.splice(0, 1)
                                }
                            }

                            function a(e, i) {
                                e.call && (e = {
                                    success: e
                                }), i.length ? (e.error || t)(i) : (e.success || t)(e)
                            }

                            function o(e, i, s, r) {
                                var n, a, l = document,
                                    c = s.async,
                                    u = (s.numRetries || 0) + 1,
                                    d = s.before || t,
                                    h = e.replace(/[\?|#].*$/, ""),
                                    f = e.replace(/^(css|img)!/, "");
                                r = r || 0, /(^css!|\.css$)/.test(h) ? ((a = l.createElement("link")).rel = "stylesheet", a.href = f, (n = "hideFocus" in a) && a.relList && (n = 0, a.rel = "preload", a.as = "style")) : /(^img!|\.(png|gif|jpg|svg|webp)$)/.test(h) ? (a = l.createElement("img")).src = f : ((a = l.createElement("script")).src = e, a.async = void 0 === c || c), a.onload = a.onerror = a.onbeforeload = function(t) {
                                    var l = t.type[0];
                                    if (n) try {
                                        a.sheet.cssText.length || (l = "e")
                                    } catch (t) {
                                        18 != t.code && (l = "e")
                                    }
                                    if ("e" == l) {
                                        if ((r += 1) < u) return o(e, i, s, r)
                                    } else if ("preload" == a.rel && "style" == a.as) return a.rel = "stylesheet";
                                    i(e, l, t.defaultPrevented)
                                }, !1 !== d(e, a) && l.head.appendChild(a)
                            }

                            function l(t, e, i) {
                                var s, r, n = (t = t.push ? t : [t]).length,
                                    a = n,
                                    l = [];
                                for (s = function(t, i, s) {
                                        if ("e" == i && l.push(t), "b" == i) {
                                            if (!s) return;
                                            l.push(t)
                                        }--n || e(l)
                                    }, r = 0; r < a; r++) o(t[r], s, i)
                            }

                            function c(t, i, s) {
                                var r, o;
                                if (i && i.trim && (r = i), o = (r ? s : i) || {}, r) {
                                    if (r in e) throw "LoadJS";
                                    e[r] = !0
                                }

                                function c(e, i) {
                                    l(t, (function(t) {
                                        a(o, t), e && a({
                                            success: e,
                                            error: i
                                        }, t), n(r, t)
                                    }), o)
                                }
                                if (o.returnPromise) return new Promise(c);
                                c()
                            }
                            return c.ready = function(t, e) {
                                return r(t, (function(t) {
                                    a(e, t)
                                })), c
                            }, c.done = function(t) {
                                n(t, [])
                            }, c.reset = function() {
                                e = {}, i = {}, s = {}
                            }, c.isDefined = function(t) {
                                return t in e
                            }, c
                        }()
                    }(e = {
                        exports: {}
                    }), e.exports
                }();

                function ee(t) {
                    return new Promise(((e, i) => {
                        te(t, {
                            success: e,
                            error: i
                        })
                    }))
                }

                function ie(t) {
                    t && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === t && (this.media.paused = !t, gt.call(this, this.media, t ? "play" : "pause"))
                }
                const se = {
                    setup() {
                        const t = this;
                        it(t.elements.wrapper, t.config.classNames.embed, !0), t.options.speed = t.config.speed.options, _t.call(t), I(window.Vimeo) ? se.ready.call(t) : ee(t.config.urls.vimeo.sdk).then((() => {
                            se.ready.call(t)
                        })).catch((e => {
                            t.debug.warn("Vimeo SDK (player.js) failed to load", e)
                        }))
                    },
                    ready() {
                        const t = this,
                            e = t.config.vimeo,
                            {
                                premium: i,
                                referrerPolicy: s,
                                ...r
                            } = e;
                        let n = t.media.getAttribute("src"),
                            a = "";
                        j(n) ? (n = t.media.getAttribute(t.config.attributes.embed.id), a = t.media.getAttribute(t.config.attributes.embed.hash)) : a = function(t) {
                            const e = t.match(/^.*(vimeo.com\/|video\/)(\d+)(\?.*&*h=|\/)+([\d,a-f]+)/);
                            return e && 5 === e.length ? e[4] : null
                        }(n);
                        const o = a ? {
                            h: a
                        } : {};
                        i && Object.assign(r, {
                            controls: !1,
                            sidedock: !1
                        });
                        const l = Gt({
                                loop: t.config.loop.active,
                                autoplay: t.autoplay,
                                muted: t.muted,
                                gesture: "media",
                                playsinline: !this.config.fullscreen.iosNative,
                                ...o,
                                ...r
                            }),
                            c = j(u = n) ? null : C(Number(u)) ? u : u.match(/^.*(vimeo.com\/|video\/)(\d+).*/) ? RegExp.$2 : u;
                        var u;
                        const d = Y("iframe"),
                            h = It(t.config.urls.vimeo.iframe, c, l);
                        if (d.setAttribute("src", h), d.setAttribute("allowfullscreen", ""), d.setAttribute("allow", ["autoplay", "fullscreen", "picture-in-picture", "encrypted-media", "accelerometer", "gyroscope"].join("; ")), j(s) || d.setAttribute("referrerPolicy", s), i || !e.customControls) d.setAttribute("data-poster", t.poster), t.media = Z(d, t.media);
                        else {
                            const e = Y("div", {
                                class: t.config.classNames.embedContainer,
                                "data-poster": t.poster
                            });
                            e.appendChild(d), t.media = Z(e, t.media)
                        }
                        e.customControls || Nt(It(t.config.urls.vimeo.api, h)).then((e => {
                            !j(e) && e.thumbnail_url && Jt.setPoster.call(t, e.thumbnail_url).catch((() => {}))
                        })), t.embed = new window.Vimeo.Player(d, {
                            autopause: t.config.autopause,
                            muted: t.muted
                        }), t.media.paused = !0, t.media.currentTime = 0, t.supported.ui && t.embed.disableTextTrack(), t.media.play = () => (ie.call(t, !0), t.embed.play()), t.media.pause = () => (ie.call(t, !1), t.embed.pause()), t.media.stop = () => {
                            t.pause(), t.currentTime = 0
                        };
                        let {
                            currentTime: f
                        } = t.media;
                        Object.defineProperty(t.media, "currentTime", {
                            get: () => f,
                            set(e) {
                                const {
                                    embed: i,
                                    media: s,
                                    paused: r,
                                    volume: n
                                } = t, a = r && !i.hasPlayed;
                                s.seeking = !0, gt.call(t, s, "seeking"), Promise.resolve(a && i.setVolume(0)).then((() => i.setCurrentTime(e))).then((() => a && i.pause())).then((() => a && i.setVolume(n))).catch((() => {}))
                            }
                        });
                        let p = t.config.speed.selected;
                        Object.defineProperty(t.media, "playbackRate", {
                            get: () => p,
                            set(e) {
                                t.embed.setPlaybackRate(e).then((() => {
                                    p = e, gt.call(t, t.media, "ratechange")
                                })).catch((() => {
                                    t.options.speed = [1]
                                }))
                            }
                        });
                        let {
                            volume: g
                        } = t.config;
                        Object.defineProperty(t.media, "volume", {
                            get: () => g,
                            set(e) {
                                t.embed.setVolume(e).then((() => {
                                    g = e, gt.call(t, t.media, "volumechange")
                                }))
                            }
                        });
                        let {
                            muted: m
                        } = t.config;
                        Object.defineProperty(t.media, "muted", {
                            get: () => m,
                            set(e) {
                                const i = !!x(e) && e;
                                t.embed.setVolume(i ? 0 : t.config.volume).then((() => {
                                    m = i, gt.call(t, t.media, "volumechange")
                                }))
                            }
                        });
                        let y, {
                            loop: v
                        } = t.config;
                        Object.defineProperty(t.media, "loop", {
                            get: () => v,
                            set(e) {
                                const i = x(e) ? e : t.config.loop.active;
                                t.embed.setLoop(i).then((() => {
                                    v = i
                                }))
                            }
                        }), t.embed.getVideoUrl().then((e => {
                            y = e, Bt.setDownloadUrl.call(t)
                        })).catch((t => {
                            this.debug.warn(t)
                        })), Object.defineProperty(t.media, "currentSrc", {
                            get: () => y
                        }), Object.defineProperty(t.media, "ended", {
                            get: () => t.currentTime === t.duration
                        }), Promise.all([t.embed.getVideoWidth(), t.embed.getVideoHeight()]).then((e => {
                            const [i, s] = e;
                            t.embed.ratio = Lt(i, s), _t.call(this)
                        })), t.embed.setAutopause(t.config.autopause).then((e => {
                            t.config.autopause = e
                        })), t.embed.getVideoTitle().then((e => {
                            t.config.title = e, Jt.setTitle.call(this)
                        })), t.embed.getCurrentTime().then((e => {
                            f = e, gt.call(t, t.media, "timeupdate")
                        })), t.embed.getDuration().then((e => {
                            t.media.duration = e, gt.call(t, t.media, "durationchange")
                        })), t.embed.getTextTracks().then((e => {
                            t.media.textTracks = e, Vt.setup.call(t)
                        })), t.embed.on("cuechange", (({
                            cues: e = []
                        }) => {
                            const i = e.map((t => function(t) {
                                const e = document.createDocumentFragment(),
                                    i = document.createElement("div");
                                return e.appendChild(i), i.innerHTML = t, e.firstChild.innerText
                            }(t.text)));
                            Vt.updateCues.call(t, i)
                        })), t.embed.on("loaded", (() => {
                            t.embed.getPaused().then((e => {
                                ie.call(t, !e), e || gt.call(t, t.media, "playing")
                            })), N(t.embed.element) && t.supported.ui && t.embed.element.setAttribute("tabindex", -1)
                        })), t.embed.on("bufferstart", (() => {
                            gt.call(t, t.media, "waiting")
                        })), t.embed.on("bufferend", (() => {
                            gt.call(t, t.media, "playing")
                        })), t.embed.on("play", (() => {
                            ie.call(t, !0), gt.call(t, t.media, "playing")
                        })), t.embed.on("pause", (() => {
                            ie.call(t, !1)
                        })), t.embed.on("timeupdate", (e => {
                            t.media.seeking = !1, f = e.seconds, gt.call(t, t.media, "timeupdate")
                        })), t.embed.on("progress", (e => {
                            t.media.buffered = e.percent, gt.call(t, t.media, "progress"), 1 === parseInt(e.percent, 10) && gt.call(t, t.media, "canplaythrough"), t.embed.getDuration().then((e => {
                                e !== t.media.duration && (t.media.duration = e, gt.call(t, t.media, "durationchange"))
                            }))
                        })), t.embed.on("seeked", (() => {
                            t.media.seeking = !1, gt.call(t, t.media, "seeked")
                        })), t.embed.on("ended", (() => {
                            t.media.paused = !0, gt.call(t, t.media, "ended")
                        })), t.embed.on("error", (e => {
                            t.media.error = e, gt.call(t, t.media, "error")
                        })), e.customControls && setTimeout((() => Jt.build.call(t)), 0)
                    }
                };

                function re(t) {
                    t && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === t && (this.media.paused = !t, gt.call(this, this.media, t ? "play" : "pause"))
                }

                function ne(t) {
                    return t.noCookie ? "https://www.youtube-nocookie.com" : "http:" === window.location.protocol ? "http://www.youtube.com" : void 0
                }
                const ae = {
                        setup() {
                            if (it(this.elements.wrapper, this.config.classNames.embed, !0), I(window.YT) && P(window.YT.Player)) ae.ready.call(this);
                            else {
                                const t = window.onYouTubeIframeAPIReady;
                                window.onYouTubeIframeAPIReady = () => {
                                    P(t) && t(), ae.ready.call(this)
                                }, ee(this.config.urls.youtube.sdk).catch((t => {
                                    this.debug.warn("YouTube API failed to load", t)
                                }))
                            }
                        },
                        getTitle(t) {
                            Nt(It(this.config.urls.youtube.api, t)).then((t => {
                                if (I(t)) {
                                    const {
                                        title: e,
                                        height: i,
                                        width: s
                                    } = t;
                                    this.config.title = e, Jt.setTitle.call(this), this.embed.ratio = Lt(s, i)
                                }
                                _t.call(this)
                            })).catch((() => {
                                _t.call(this)
                            }))
                        },
                        ready() {
                            const t = this,
                                e = t.config.youtube,
                                i = t.media && t.media.getAttribute("id");
                            if (!j(i) && i.startsWith("youtube-")) return;
                            let s = t.media.getAttribute("src");
                            j(s) && (s = t.media.getAttribute(this.config.attributes.embed.id));
                            const r = j(n = s) ? null : n.match(/^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/) ? RegExp.$2 : n;
                            var n;
                            const a = Y("div", {
                                id: `${t.provider}-${Math.floor(1e4*Math.random())}`,
                                "data-poster": e.customControls ? t.poster : void 0
                            });
                            if (t.media = Z(a, t.media), e.customControls) {
                                const e = t => `https://i.ytimg.com/vi/${r}/${t}default.jpg`;
                                Qt(e("maxres"), 121).catch((() => Qt(e("sd"), 121))).catch((() => Qt(e("hq")))).then((e => Jt.setPoster.call(t, e.src))).then((e => {
                                    e.includes("maxres") || (t.elements.poster.style.backgroundSize = "cover")
                                })).catch((() => {}))
                            }
                            t.embed = new window.YT.Player(t.media, {
                                videoId: r,
                                host: ne(e),
                                playerVars: z({}, {
                                    autoplay: t.config.autoplay ? 1 : 0,
                                    hl: t.config.hl,
                                    controls: t.supported.ui && e.customControls ? 0 : 1,
                                    disablekb: 1,
                                    playsinline: t.config.fullscreen.iosNative ? 0 : 1,
                                    cc_load_policy: t.captions.active ? 1 : 0,
                                    cc_lang_pref: t.config.captions.language,
                                    widget_referrer: window ? window.location.href : null
                                }, e),
                                events: {
                                    onError(e) {
                                        if (!t.media.error) {
                                            const i = e.data,
                                                s = {
                                                    2: "The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.",
                                                    5: "The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.",
                                                    100: "The video requested was not found. This error occurs when a video has been removed (for any reason) or has been marked as private.",
                                                    101: "The owner of the requested video does not allow it to be played in embedded players.",
                                                    150: "The owner of the requested video does not allow it to be played in embedded players."
                                                }[i] || "An unknown error occured";
                                            t.media.error = {
                                                code: i,
                                                message: s
                                            }, gt.call(t, t.media, "error")
                                        }
                                    },
                                    onPlaybackRateChange(e) {
                                        const i = e.target;
                                        t.media.playbackRate = i.getPlaybackRate(), gt.call(t, t.media, "ratechange")
                                    },
                                    onReady(i) {
                                        if (P(t.media.play)) return;
                                        const s = i.target;
                                        ae.getTitle.call(t, r), t.media.play = () => {
                                            re.call(t, !0), s.playVideo()
                                        }, t.media.pause = () => {
                                            re.call(t, !1), s.pauseVideo()
                                        }, t.media.stop = () => {
                                            s.stopVideo()
                                        }, t.media.duration = s.getDuration(), t.media.paused = !0, t.media.currentTime = 0, Object.defineProperty(t.media, "currentTime", {
                                            get: () => Number(s.getCurrentTime()),
                                            set(e) {
                                                t.paused && !t.embed.hasPlayed && t.embed.mute(), t.media.seeking = !0, gt.call(t, t.media, "seeking"), s.seekTo(e)
                                            }
                                        }), Object.defineProperty(t.media, "playbackRate", {
                                            get: () => s.getPlaybackRate(),
                                            set(t) {
                                                s.setPlaybackRate(t)
                                            }
                                        });
                                        let {
                                            volume: n
                                        } = t.config;
                                        Object.defineProperty(t.media, "volume", {
                                            get: () => n,
                                            set(e) {
                                                n = e, s.setVolume(100 * n), gt.call(t, t.media, "volumechange")
                                            }
                                        });
                                        let {
                                            muted: a
                                        } = t.config;
                                        Object.defineProperty(t.media, "muted", {
                                            get: () => a,
                                            set(e) {
                                                const i = x(e) ? e : a;
                                                a = i, s[i ? "mute" : "unMute"](), s.setVolume(100 * n), gt.call(t, t.media, "volumechange")
                                            }
                                        }), Object.defineProperty(t.media, "currentSrc", {
                                            get: () => s.getVideoUrl()
                                        }), Object.defineProperty(t.media, "ended", {
                                            get: () => t.currentTime === t.duration
                                        });
                                        const o = s.getAvailablePlaybackRates();
                                        t.options.speed = o.filter((e => t.config.speed.options.includes(e))), t.supported.ui && e.customControls && t.media.setAttribute("tabindex", -1), gt.call(t, t.media, "timeupdate"), gt.call(t, t.media, "durationchange"), clearInterval(t.timers.buffering), t.timers.buffering = setInterval((() => {
                                            t.media.buffered = s.getVideoLoadedFraction(), (null === t.media.lastBuffered || t.media.lastBuffered < t.media.buffered) && gt.call(t, t.media, "progress"), t.media.lastBuffered = t.media.buffered, 1 === t.media.buffered && (clearInterval(t.timers.buffering), gt.call(t, t.media, "canplaythrough"))
                                        }), 200), e.customControls && setTimeout((() => Jt.build.call(t)), 50)
                                    },
                                    onStateChange(i) {
                                        const s = i.target;
                                        switch (clearInterval(t.timers.playing), t.media.seeking && [1, 2].includes(i.data) && (t.media.seeking = !1, gt.call(t, t.media, "seeked")), i.data) {
                                            case -1:
                                                gt.call(t, t.media, "timeupdate"), t.media.buffered = s.getVideoLoadedFraction(), gt.call(t, t.media, "progress");
                                                break;
                                            case 0:
                                                re.call(t, !1), t.media.loop ? (s.stopVideo(), s.playVideo()) : gt.call(t, t.media, "ended");
                                                break;
                                            case 1:
                                                e.customControls && !t.config.autoplay && t.media.paused && !t.embed.hasPlayed ? t.media.pause() : (re.call(t, !0), gt.call(t, t.media, "playing"), t.timers.playing = setInterval((() => {
                                                    gt.call(t, t.media, "timeupdate")
                                                }), 50), t.media.duration !== s.getDuration() && (t.media.duration = s.getDuration(), gt.call(t, t.media, "durationchange")));
                                                break;
                                            case 2:
                                                t.muted || t.embed.unMute(), re.call(t, !1);
                                                break;
                                            case 3:
                                                gt.call(t, t.media, "waiting")
                                        }
                                        gt.call(t, t.elements.container, "statechange", !1, {
                                            code: i.data
                                        })
                                    }
                                }
                            })
                        }
                    },
                    oe = {
                        setup() {
                            this.media ? (it(this.elements.container, this.config.classNames.type.replace("{0}", this.type), !0), it(this.elements.container, this.config.classNames.provider.replace("{0}", this.provider), !0), this.isEmbed && it(this.elements.container, this.config.classNames.type.replace("{0}", "video"), !0), this.isVideo && (this.elements.wrapper = Y("div", {
                                class: this.config.classNames.video
                            }), q(this.media, this.elements.wrapper), this.elements.poster = Y("div", {
                                class: this.config.classNames.poster
                            }), this.elements.wrapper.appendChild(this.elements.poster)), this.isHTML5 ? Rt.setup.call(this) : this.isYouTube ? ae.setup.call(this) : this.isVimeo && se.setup.call(this)) : this.debug.warn("No media element found!")
                        }
                    };
                class le {
                    constructor(e) {
                        t(this, "load", (() => {
                            this.enabled && (I(window.google) && I(window.google.ima) ? this.ready() : ee(this.player.config.urls.googleIMA.sdk).then((() => {
                                this.ready()
                            })).catch((() => {
                                this.trigger("error", new Error("Google IMA SDK failed to load"))
                            })))
                        })), t(this, "ready", (() => {
                            var t;
                            this.enabled || ((t = this).manager && t.manager.destroy(), t.elements.displayContainer && t.elements.displayContainer.destroy(), t.elements.container.remove()), this.startSafetyTimer(12e3, "ready()"), this.managerPromise.then((() => {
                                this.clearSafetyTimer("onAdsManagerLoaded()")
                            })), this.listeners(), this.setupIMA()
                        })), t(this, "setupIMA", (() => {
                            this.elements.container = Y("div", {
                                class: this.player.config.classNames.ads
                            }), this.player.elements.container.appendChild(this.elements.container), google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED), google.ima.settings.setLocale(this.player.config.ads.language), google.ima.settings.setDisableCustomPlaybackForIOS10Plus(this.player.config.playsinline), this.elements.displayContainer = new google.ima.AdDisplayContainer(this.elements.container, this.player.media), this.loader = new google.ima.AdsLoader(this.elements.displayContainer), this.loader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, (t => this.onAdsManagerLoaded(t)), !1), this.loader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, (t => this.onAdError(t)), !1), this.requestAds()
                        })), t(this, "requestAds", (() => {
                            const {
                                container: t
                            } = this.player.elements;
                            try {
                                const e = new google.ima.AdsRequest;
                                e.adTagUrl = this.tagUrl, e.linearAdSlotWidth = t.offsetWidth, e.linearAdSlotHeight = t.offsetHeight, e.nonLinearAdSlotWidth = t.offsetWidth, e.nonLinearAdSlotHeight = t.offsetHeight, e.forceNonLinearFullSlot = !1, e.setAdWillPlayMuted(!this.player.muted), this.loader.requestAds(e)
                            } catch (t) {
                                this.onAdError(t)
                            }
                        })), t(this, "pollCountdown", ((t = !1) => {
                            if (!t) return clearInterval(this.countdownTimer), void this.elements.container.removeAttribute("data-badge-text");
                            this.countdownTimer = setInterval((() => {
                                const t = Ut(Math.max(this.manager.getRemainingTime(), 0)),
                                    e = `${Ot.get("advertisement",this.player.config)} - ${t}`;
                                this.elements.container.setAttribute("data-badge-text", e)
                            }), 100)
                        })), t(this, "onAdsManagerLoaded", (t => {
                            if (!this.enabled) return;
                            const e = new google.ima.AdsRenderingSettings;
                            e.restoreCustomPlaybackStateOnAdBreakComplete = !0, e.enablePreloading = !0, this.manager = t.getAdsManager(this.player, e), this.cuePoints = this.manager.getCuePoints(), this.manager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, (t => this.onAdError(t))), Object.keys(google.ima.AdEvent.Type).forEach((t => {
                                this.manager.addEventListener(google.ima.AdEvent.Type[t], (t => this.onAdEvent(t)))
                            })), this.trigger("loaded")
                        })), t(this, "addCuePoints", (() => {
                            j(this.cuePoints) || this.cuePoints.forEach((t => {
                                if (0 !== t && -1 !== t && t < this.player.duration) {
                                    const e = this.player.elements.progress;
                                    if (N(e)) {
                                        const i = 100 / this.player.duration * t,
                                            s = Y("span", {
                                                class: this.player.config.classNames.cues
                                            });
                                        s.style.left = `${i.toString()}%`, e.appendChild(s)
                                    }
                                }
                            }))
                        })), t(this, "onAdEvent", (t => {
                            const {
                                container: e
                            } = this.player.elements, i = t.getAd(), s = t.getAdData();
                            switch ((t => {
                                gt.call(this.player, this.player.media, `ads${t.replace(/_/g,"").toLowerCase()}`)
                            })(t.type), t.type) {
                                case google.ima.AdEvent.Type.LOADED:
                                    this.trigger("loaded"), this.pollCountdown(!0), i.isLinear() || (i.width = e.offsetWidth, i.height = e.offsetHeight);
                                    break;
                                case google.ima.AdEvent.Type.STARTED:
                                    this.manager.setVolume(this.player.volume);
                                    break;
                                case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:
                                    this.player.ended ? this.loadAds() : this.loader.contentComplete();
                                    break;
                                case google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED:
                                    this.pauseContent();
                                    break;
                                case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED:
                                    this.pollCountdown(), this.resumeContent();
                                    break;
                                case google.ima.AdEvent.Type.LOG:
                                    s.adError && this.player.debug.warn(`Non-fatal ad error: ${s.adError.getMessage()}`)
                            }
                        })), t(this, "onAdError", (t => {
                            this.cancel(), this.player.debug.warn("Ads error", t)
                        })), t(this, "listeners", (() => {
                            const {
                                container: t
                            } = this.player.elements;
                            let e;
                            this.player.on("canplay", (() => {
                                this.addCuePoints()
                            })), this.player.on("ended", (() => {
                                this.loader.contentComplete()
                            })), this.player.on("timeupdate", (() => {
                                e = this.player.currentTime
                            })), this.player.on("seeked", (() => {
                                const t = this.player.currentTime;
                                j(this.cuePoints) || this.cuePoints.forEach(((i, s) => {
                                    e < i && i < t && (this.manager.discardAdBreak(), this.cuePoints.splice(s, 1))
                                }))
                            })), window.addEventListener("resize", (() => {
                                this.manager && this.manager.resize(t.offsetWidth, t.offsetHeight, google.ima.ViewMode.NORMAL)
                            }))
                        })), t(this, "play", (() => {
                            const {
                                container: t
                            } = this.player.elements;
                            this.managerPromise || this.resumeContent(), this.managerPromise.then((() => {
                                this.manager.setVolume(this.player.volume), this.elements.displayContainer.initialize();
                                try {
                                    this.initialized || (this.manager.init(t.offsetWidth, t.offsetHeight, google.ima.ViewMode.NORMAL), this.manager.start()), this.initialized = !0
                                } catch (t) {
                                    this.onAdError(t)
                                }
                            })).catch((() => {}))
                        })), t(this, "resumeContent", (() => {
                            this.elements.container.style.zIndex = "", this.playing = !1, vt(this.player.media.play())
                        })), t(this, "pauseContent", (() => {
                            this.elements.container.style.zIndex = 3, this.playing = !0, this.player.media.pause()
                        })), t(this, "cancel", (() => {
                            this.initialized && this.resumeContent(), this.trigger("error"), this.loadAds()
                        })), t(this, "loadAds", (() => {
                            this.managerPromise.then((() => {
                                this.manager && this.manager.destroy(), this.managerPromise = new Promise((t => {
                                    this.on("loaded", t), this.player.debug.log(this.manager)
                                })), this.initialized = !1, this.requestAds()
                            })).catch((() => {}))
                        })), t(this, "trigger", ((t, ...e) => {
                            const i = this.events[t];
                            O(i) && i.forEach((t => {
                                P(t) && t.apply(this, e)
                            }))
                        })), t(this, "on", ((t, e) => (O(this.events[t]) || (this.events[t] = []), this.events[t].push(e), this))), t(this, "startSafetyTimer", ((t, e) => {
                            this.player.debug.log(`Safety timer invoked from: ${e}`), this.safetyTimer = setTimeout((() => {
                                this.cancel(), this.clearSafetyTimer("startSafetyTimer()")
                            }), t)
                        })), t(this, "clearSafetyTimer", (t => {
                            R(this.safetyTimer) || (this.player.debug.log(`Safety timer cleared from: ${t}`), clearTimeout(this.safetyTimer), this.safetyTimer = null)
                        })), this.player = e, this.config = e.config.ads, this.playing = !1, this.initialized = !1, this.elements = {
                            container: null,
                            displayContainer: null
                        }, this.manager = null, this.loader = null, this.cuePoints = null, this.events = {}, this.safetyTimer = null, this.countdownTimer = null, this.managerPromise = new Promise(((t, e) => {
                            this.on("loaded", t), this.on("error", e)
                        })), this.load()
                    }
                    get enabled() {
                        const {
                            config: t
                        } = this;
                        return this.player.isHTML5 && this.player.isVideo && t.enabled && (!j(t.publisherId) || B(t.tagUrl))
                    }
                    get tagUrl() {
                        const {
                            config: t
                        } = this;
                        return B(t.tagUrl) ? t.tagUrl : `https://go.aniview.com/api/adserver6/vast/?${Gt({AV_PUBLISHERID:"58c25bb0073ef448b1087ad6",AV_CHANNELID:"5a0458dc28a06145e4519d21",AV_URL:window.location.hostname,cb:Date.now(),AV_WIDTH:640,AV_HEIGHT:480,AV_CDIM2:t.publisherId})}`
                    }
                }

                function ce(t = 0, e = 0, i = 255) {
                    return Math.min(Math.max(t, e), i)
                }
                const ue = t => {
                        const e = [];
                        return t.split(/\r\n\r\n|\n\n|\r\r/).forEach((t => {
                            const i = {};
                            t.split(/\r\n|\n|\r/).forEach((t => {
                                if (C(i.startTime)) {
                                    if (!j(t.trim()) && j(i.text)) {
                                        const e = t.trim().split("#xywh=");
                                        [i.text] = e, e[1] && ([i.x, i.y, i.w, i.h] = e[1].split(","))
                                    }
                                } else {
                                    const e = t.match(/([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})( ?--> ?)([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})/);
                                    e && (i.startTime = 60 * Number(e[1] || 0) * 60 + 60 * Number(e[2]) + Number(e[3]) + Number(`0.${e[4]}`), i.endTime = 60 * Number(e[6] || 0) * 60 + 60 * Number(e[7]) + Number(e[8]) + Number(`0.${e[9]}`))
                                }
                            })), i.text && e.push(i)
                        })), e
                    },
                    de = (t, e) => {
                        const i = {};
                        return t > e.width / e.height ? (i.width = e.width, i.height = 1 / t * e.width) : (i.height = e.height, i.width = t * e.height), i
                    };
                class he {
                    constructor(e) {
                        t(this, "load", (() => {
                            this.player.elements.display.seekTooltip && (this.player.elements.display.seekTooltip.hidden = this.enabled), this.enabled && this.getThumbnails().then((() => {
                                this.enabled && (this.render(), this.determineContainerAutoSizing(), this.loaded = !0)
                            }))
                        })), t(this, "getThumbnails", (() => new Promise((t => {
                            const {
                                src: e
                            } = this.player.config.previewThumbnails;
                            if (j(e)) throw new Error("Missing previewThumbnails.src config attribute");
                            const i = () => {
                                this.thumbnails.sort(((t, e) => t.height - e.height)), this.player.debug.log("Preview thumbnails", this.thumbnails), t()
                            };
                            if (P(e)) e((t => {
                                this.thumbnails = t, i()
                            }));
                            else {
                                const t = (D(e) ? [e] : e).map((t => this.getThumbnail(t)));
                                Promise.all(t).then(i)
                            }
                        })))), t(this, "getThumbnail", (t => new Promise((e => {
                            Nt(t).then((i => {
                                const s = {
                                    frames: ue(i),
                                    height: null,
                                    urlPrefix: ""
                                };
                                s.frames[0].text.startsWith("/") || s.frames[0].text.startsWith("http://") || s.frames[0].text.startsWith("https://") || (s.urlPrefix = t.substring(0, t.lastIndexOf("/") + 1));
                                const r = new Image;
                                r.onload = () => {
                                    s.height = r.naturalHeight, s.width = r.naturalWidth, this.thumbnails.push(s), e()
                                }, r.src = s.urlPrefix + s.frames[0].text
                            }))
                        })))), t(this, "startMove", (t => {
                            if (this.loaded && F(t) && ["touchmove", "mousemove"].includes(t.type) && this.player.media.duration) {
                                if ("touchmove" === t.type) this.seekTime = this.player.media.duration * (this.player.elements.inputs.seek.value / 100);
                                else {
                                    var e, i;
                                    const s = this.player.elements.progress.getBoundingClientRect(),
                                        r = 100 / s.width * (t.pageX - s.left);
                                    this.seekTime = this.player.media.duration * (r / 100), this.seekTime < 0 && (this.seekTime = 0), this.seekTime > this.player.media.duration - 1 && (this.seekTime = this.player.media.duration - 1), this.mousePosX = t.pageX, this.elements.thumb.time.innerText = Ut(this.seekTime);
                                    const n = null === (e = this.player.config.markers) || void 0 === e || null === (i = e.points) || void 0 === i ? void 0 : i.find((({
                                        time: t
                                    }) => t === Math.round(this.seekTime)));
                                    n && this.elements.thumb.time.insertAdjacentHTML("afterbegin", `${n.label}<br>`)
                                }
                                this.showImageAtCurrentTime()
                            }
                        })), t(this, "endMove", (() => {
                            this.toggleThumbContainer(!1, !0)
                        })), t(this, "startScrubbing", (t => {
                            (R(t.button) || !1 === t.button || 0 === t.button) && (this.mouseDown = !0, this.player.media.duration && (this.toggleScrubbingContainer(!0), this.toggleThumbContainer(!1, !0), this.showImageAtCurrentTime()))
                        })), t(this, "endScrubbing", (() => {
                            this.mouseDown = !1, Math.ceil(this.lastTime) === Math.ceil(this.player.media.currentTime) ? this.toggleScrubbingContainer(!1) : pt.call(this.player, this.player.media, "timeupdate", (() => {
                                this.mouseDown || this.toggleScrubbingContainer(!1)
                            }))
                        })), t(this, "listeners", (() => {
                            this.player.on("play", (() => {
                                this.toggleThumbContainer(!1, !0)
                            })), this.player.on("seeked", (() => {
                                this.toggleThumbContainer(!1)
                            })), this.player.on("timeupdate", (() => {
                                this.lastTime = this.player.media.currentTime
                            }))
                        })), t(this, "render", (() => {
                            this.elements.thumb.container = Y("div", {
                                class: this.player.config.classNames.previewThumbnails.thumbContainer
                            }), this.elements.thumb.imageContainer = Y("div", {
                                class: this.player.config.classNames.previewThumbnails.imageContainer
                            }), this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer);
                            const t = Y("div", {
                                class: this.player.config.classNames.previewThumbnails.timeContainer
                            });
                            this.elements.thumb.time = Y("span", {}, "00:00"), t.appendChild(this.elements.thumb.time), this.elements.thumb.imageContainer.appendChild(t), N(this.player.elements.progress) && this.player.elements.progress.appendChild(this.elements.thumb.container), this.elements.scrubbing.container = Y("div", {
                                class: this.player.config.classNames.previewThumbnails.scrubbingContainer
                            }), this.player.elements.wrapper.appendChild(this.elements.scrubbing.container)
                        })), t(this, "destroy", (() => {
                            this.elements.thumb.container && this.elements.thumb.container.remove(), this.elements.scrubbing.container && this.elements.scrubbing.container.remove()
                        })), t(this, "showImageAtCurrentTime", (() => {
                            this.mouseDown ? this.setScrubbingContainerSize() : this.setThumbContainerSizeAndPos();
                            const t = this.thumbnails[0].frames.findIndex((t => this.seekTime >= t.startTime && this.seekTime <= t.endTime)),
                                e = t >= 0;
                            let i = 0;
                            this.mouseDown || this.toggleThumbContainer(e), e && (this.thumbnails.forEach(((e, s) => {
                                this.loadedImages.includes(e.frames[t].text) && (i = s)
                            })), t !== this.showingThumb && (this.showingThumb = t, this.loadImage(i)))
                        })), t(this, "loadImage", ((t = 0) => {
                            const e = this.showingThumb,
                                i = this.thumbnails[t],
                                {
                                    urlPrefix: s
                                } = i,
                                r = i.frames[e],
                                n = i.frames[e].text,
                                a = s + n;
                            if (this.currentImageElement && this.currentImageElement.dataset.filename === n) this.showImage(this.currentImageElement, r, t, e, n, !1), this.currentImageElement.dataset.index = e, this.removeOldImages(this.currentImageElement);
                            else {
                                this.loadingImage && this.usingSprites && (this.loadingImage.onload = null);
                                const i = new Image;
                                i.src = a, i.dataset.index = e, i.dataset.filename = n, this.showingThumbFilename = n, this.player.debug.log(`Loading image: ${a}`), i.onload = () => this.showImage(i, r, t, e, n, !0), this.loadingImage = i, this.removeOldImages(i)
                            }
                        })), t(this, "showImage", ((t, e, i, s, r, n = !0) => {
                            this.player.debug.log(`Showing thumb: ${r}. num: ${s}. qual: ${i}. newimg: ${n}`), this.setImageSizeAndOffset(t, e), n && (this.currentImageContainer.appendChild(t), this.currentImageElement = t, this.loadedImages.includes(r) || this.loadedImages.push(r)), this.preloadNearby(s, !0).then(this.preloadNearby(s, !1)).then(this.getHigherQuality(i, t, e, r))
                        })), t(this, "removeOldImages", (t => {
                            Array.from(this.currentImageContainer.children).forEach((e => {
                                if ("img" !== e.tagName.toLowerCase()) return;
                                const i = this.usingSprites ? 500 : 1e3;
                                if (e.dataset.index !== t.dataset.index && !e.dataset.deleting) {
                                    e.dataset.deleting = !0;
                                    const {
                                        currentImageContainer: t
                                    } = this;
                                    setTimeout((() => {
                                        t.removeChild(e), this.player.debug.log(`Removing thumb: ${e.dataset.filename}`)
                                    }), i)
                                }
                            }))
                        })), t(this, "preloadNearby", ((t, e = !0) => new Promise((i => {
                            setTimeout((() => {
                                const s = this.thumbnails[0].frames[t].text;
                                if (this.showingThumbFilename === s) {
                                    let r;
                                    r = e ? this.thumbnails[0].frames.slice(t) : this.thumbnails[0].frames.slice(0, t).reverse();
                                    let n = !1;
                                    r.forEach((t => {
                                        const e = t.text;
                                        if (e !== s && !this.loadedImages.includes(e)) {
                                            n = !0, this.player.debug.log(`Preloading thumb filename: ${e}`);
                                            const {
                                                urlPrefix: t
                                            } = this.thumbnails[0], s = t + e, r = new Image;
                                            r.src = s, r.onload = () => {
                                                this.player.debug.log(`Preloaded thumb filename: ${e}`), this.loadedImages.includes(e) || this.loadedImages.push(e), i()
                                            }
                                        }
                                    })), n || i()
                                }
                            }), 300)
                        })))), t(this, "getHigherQuality", ((t, e, i, s) => {
                            if (t < this.thumbnails.length - 1) {
                                let r = e.naturalHeight;
                                this.usingSprites && (r = i.h), r < this.thumbContainerHeight && setTimeout((() => {
                                    this.showingThumbFilename === s && (this.player.debug.log(`Showing higher quality thumb for: ${s}`), this.loadImage(t + 1))
                                }), 300)
                            }
                        })), t(this, "toggleThumbContainer", ((t = !1, e = !1) => {
                            const i = this.player.config.classNames.previewThumbnails.thumbContainerShown;
                            this.elements.thumb.container.classList.toggle(i, t), !t && e && (this.showingThumb = null, this.showingThumbFilename = null)
                        })), t(this, "toggleScrubbingContainer", ((t = !1) => {
                            const e = this.player.config.classNames.previewThumbnails.scrubbingContainerShown;
                            this.elements.scrubbing.container.classList.toggle(e, t), t || (this.showingThumb = null, this.showingThumbFilename = null)
                        })), t(this, "determineContainerAutoSizing", (() => {
                            (this.elements.thumb.imageContainer.clientHeight > 20 || this.elements.thumb.imageContainer.clientWidth > 20) && (this.sizeSpecifiedInCSS = !0)
                        })), t(this, "setThumbContainerSizeAndPos", (() => {
                            const {
                                imageContainer: t
                            } = this.elements.thumb;
                            if (this.sizeSpecifiedInCSS) {
                                if (t.clientHeight > 20 && t.clientWidth < 20) {
                                    const e = Math.floor(t.clientHeight * this.thumbAspectRatio);
                                    t.style.width = `${e}px`
                                } else if (t.clientHeight < 20 && t.clientWidth > 20) {
                                    const e = Math.floor(t.clientWidth / this.thumbAspectRatio);
                                    t.style.height = `${e}px`
                                }
                            } else {
                                const e = Math.floor(this.thumbContainerHeight * this.thumbAspectRatio);
                                t.style.height = `${this.thumbContainerHeight}px`, t.style.width = `${e}px`
                            }
                            this.setThumbContainerPos()
                        })), t(this, "setThumbContainerPos", (() => {
                            const t = this.player.elements.progress.getBoundingClientRect(),
                                e = this.player.elements.container.getBoundingClientRect(),
                                {
                                    container: i
                                } = this.elements.thumb,
                                s = e.left - t.left + 10,
                                r = e.right - t.left - i.clientWidth - 10,
                                n = this.mousePosX - t.left - i.clientWidth / 2,
                                a = ce(n, s, r);
                            i.style.left = `${a}px`, i.style.setProperty("--preview-arrow-offset", n - a + "px")
                        })), t(this, "setScrubbingContainerSize", (() => {
                            const {
                                width: t,
                                height: e
                            } = de(this.thumbAspectRatio, {
                                width: this.player.media.clientWidth,
                                height: this.player.media.clientHeight
                            });
                            this.elements.scrubbing.container.style.width = `${t}px`, this.elements.scrubbing.container.style.height = `${e}px`
                        })), t(this, "setImageSizeAndOffset", ((t, e) => {
                            if (!this.usingSprites) return;
                            const i = this.thumbContainerHeight / e.h;
                            t.style.height = t.naturalHeight * i + "px", t.style.width = t.naturalWidth * i + "px", t.style.left = `-${e.x*i}px`, t.style.top = `-${e.y*i}px`
                        })), this.player = e, this.thumbnails = [], this.loaded = !1, this.lastMouseMoveTime = Date.now(), this.mouseDown = !1, this.loadedImages = [], this.elements = {
                            thumb: {},
                            scrubbing: {}
                        }, this.load()
                    }
                    get enabled() {
                        return this.player.isHTML5 && this.player.isVideo && this.player.config.previewThumbnails.enabled
                    }
                    get currentImageContainer() {
                        return this.mouseDown ? this.elements.scrubbing.container : this.elements.thumb.imageContainer
                    }
                    get usingSprites() {
                        return Object.keys(this.thumbnails[0].frames[0]).includes("w")
                    }
                    get thumbAspectRatio() {
                        return this.usingSprites ? this.thumbnails[0].frames[0].w / this.thumbnails[0].frames[0].h : this.thumbnails[0].width / this.thumbnails[0].height
                    }
                    get thumbContainerHeight() {
                        if (this.mouseDown) {
                            const {
                                height: t
                            } = de(this.thumbAspectRatio, {
                                width: this.player.media.clientWidth,
                                height: this.player.media.clientHeight
                            });
                            return t
                        }
                        return this.sizeSpecifiedInCSS ? this.elements.thumb.imageContainer.clientHeight : Math.floor(this.player.media.clientWidth / this.thumbAspectRatio / 4)
                    }
                    get currentImageElement() {
                        return this.mouseDown ? this.currentScrubbingImageElement : this.currentThumbnailImageElement
                    }
                    set currentImageElement(t) {
                        this.mouseDown ? this.currentScrubbingImageElement = t : this.currentThumbnailImageElement = t
                    }
                }
                const fe = {
                    insertElements(t, e) {
                        D(e) ? X(t, this.media, {
                            src: e
                        }) : O(e) && e.forEach((e => {
                            X(t, this.media, e)
                        }))
                    },
                    change(t) {
                        K(t, "sources.length") ? (Rt.cancelRequests.call(this), this.destroy.call(this, (() => {
                            this.options.quality = [], Q(this.media), this.media = null, N(this.elements.container) && this.elements.container.removeAttribute("class");
                            const {
                                sources: e,
                                type: i
                            } = t, [{
                                provider: s = zt.html5,
                                src: r
                            }] = e, n = "html5" === s ? i : "div", a = "html5" === s ? {} : {
                                src: r
                            };
                            Object.assign(this, {
                                provider: s,
                                type: i,
                                supported: ct.check(i, s, this.config.playsinline),
                                media: Y(n, a)
                            }), this.elements.container.appendChild(this.media), x(t.autoplay) && (this.config.autoplay = t.autoplay), this.isHTML5 && (this.config.crossorigin && this.media.setAttribute("crossorigin", ""), this.config.autoplay && this.media.setAttribute("autoplay", ""), j(t.poster) || (this.poster = t.poster), this.config.loop.active && this.media.setAttribute("loop", ""), this.config.muted && this.media.setAttribute("muted", ""), this.config.playsinline && this.media.setAttribute("playsinline", "")), Jt.addStyleHook.call(this), this.isHTML5 && fe.insertElements.call(this, "source", e), this.config.title = t.title, oe.setup.call(this), this.isHTML5 && Object.keys(t).includes("tracks") && fe.insertElements.call(this, "track", t.tracks), (this.isHTML5 || this.isEmbed && !this.supported.ui) && Jt.build.call(this), this.isHTML5 && this.media.load(), j(t.previewThumbnails) || (Object.assign(this.config.previewThumbnails, t.previewThumbnails), this.previewThumbnails && this.previewThumbnails.loaded && (this.previewThumbnails.destroy(), this.previewThumbnails = null), this.config.previewThumbnails.enabled && (this.previewThumbnails = new he(this))), this.fullscreen.update()
                        }), !0)) : this.debug.warn("Invalid source format")
                    }
                };
                class pe {
                    constructor(e, i) {
                        if (t(this, "play", (() => P(this.media.play) ? (this.ads && this.ads.enabled && this.ads.managerPromise.then((() => this.ads.play())).catch((() => vt(this.media.play()))), this.media.play()) : null)), t(this, "pause", (() => this.playing && P(this.media.pause) ? this.media.pause() : null)), t(this, "togglePlay", (t => (x(t) ? t : !this.playing) ? this.play() : this.pause())), t(this, "stop", (() => {
                                this.isHTML5 ? (this.pause(), this.restart()) : P(this.media.stop) && this.media.stop()
                            })), t(this, "restart", (() => {
                                this.currentTime = 0
                            })), t(this, "rewind", (t => {
                                this.currentTime -= C(t) ? t : this.config.seekTime
                            })), t(this, "forward", (t => {
                                this.currentTime += C(t) ? t : this.config.seekTime
                            })), t(this, "increaseVolume", (t => {
                                const e = this.media.muted ? 0 : this.volume;
                                this.volume = e + (C(t) ? t : 0)
                            })), t(this, "decreaseVolume", (t => {
                                this.increaseVolume(-t)
                            })), t(this, "airplay", (() => {
                                ct.airplay && this.media.webkitShowPlaybackTargetPicker()
                            })), t(this, "toggleControls", (t => {
                                if (this.supported.ui && !this.isAudio) {
                                    const e = st(this.elements.container, this.config.classNames.hideControls),
                                        i = void 0 === t ? void 0 : !t,
                                        s = it(this.elements.container, this.config.classNames.hideControls, i);
                                    if (s && O(this.config.controls) && this.config.controls.includes("settings") && !j(this.config.settings) && Bt.toggleMenu.call(this, !1), s !== e) {
                                        const t = s ? "controlshidden" : "controlsshown";
                                        gt.call(this, this.media, t)
                                    }
                                    return !s
                                }
                                return !1
                            })), t(this, "on", ((t, e) => {
                                ht.call(this, this.elements.container, t, e)
                            })), t(this, "once", ((t, e) => {
                                pt.call(this, this.elements.container, t, e)
                            })), t(this, "off", ((t, e) => {
                                ft(this.elements.container, t, e)
                            })), t(this, "destroy", ((t, e = !1) => {
                                if (!this.ready) return;
                                const i = () => {
                                    document.body.style.overflow = "", this.embed = null, e ? (Object.keys(this.elements).length && (Q(this.elements.buttons.play), Q(this.elements.captions), Q(this.elements.controls), Q(this.elements.wrapper), this.elements.buttons.play = null, this.elements.captions = null, this.elements.controls = null, this.elements.wrapper = null), P(t) && t()) : (mt.call(this), Rt.cancelRequests.call(this), Z(this.elements.original, this.elements.container), gt.call(this, this.elements.original, "destroyed", !0), P(t) && t.call(this.elements.original), this.ready = !1, setTimeout((() => {
                                        this.elements = null, this.media = null
                                    }), 200))
                                };
                                this.stop(), clearTimeout(this.timers.loading), clearTimeout(this.timers.controls), clearTimeout(this.timers.resized), this.isHTML5 ? (Jt.toggleNativeControls.call(this, !0), i()) : this.isYouTube ? (clearInterval(this.timers.buffering), clearInterval(this.timers.playing), null !== this.embed && P(this.embed.destroy) && this.embed.destroy(), i()) : this.isVimeo && (null !== this.embed && this.embed.unload().then(i), setTimeout(i, 200))
                            })), t(this, "supports", (t => ct.mime.call(this, t))), this.timers = {}, this.ready = !1, this.loading = !1, this.failed = !1, this.touch = ct.touch, this.media = e, D(this.media) && (this.media = document.querySelectorAll(this.media)), (window.jQuery && this.media instanceof jQuery || M(this.media) || O(this.media)) && (this.media = this.media[0]), this.config = z({}, Ht, pe.defaults, i || {}, (() => {
                                try {
                                    return JSON.parse(this.media.getAttribute("data-plyr-config"))
                                } catch (t) {
                                    return {}
                                }
                            })()), this.elements = {
                                container: null,
                                fullscreen: null,
                                captions: null,
                                buttons: {},
                                display: {},
                                progress: {},
                                inputs: {},
                                settings: {
                                    popup: null,
                                    menu: null,
                                    panels: {},
                                    buttons: {}
                                }
                            }, this.captions = {
                                active: null,
                                currentTrack: -1,
                                meta: new WeakMap
                            }, this.fullscreen = {
                                active: !1
                            }, this.options = {
                                speed: [],
                                quality: []
                            }, this.debug = new Yt(this.config.debug), this.debug.log("Config", this.config), this.debug.log("Support", ct), R(this.media) || !N(this.media)) return void this.debug.error("Setup failed: no suitable element passed");
                        if (this.media.plyr) return void this.debug.warn("Target already setup");
                        if (!this.config.enabled) return void this.debug.error("Setup failed: disabled by config");
                        if (!ct.check().api) return void this.debug.error("Setup failed: no support");
                        const s = this.media.cloneNode(!0);
                        s.autoplay = !1, this.elements.original = s;
                        const r = this.media.tagName.toLowerCase();
                        let n = null,
                            a = null;
                        switch (r) {
                            case "div":
                                if (n = this.media.querySelector("iframe"), N(n)) {
                                    if (a = jt(n.getAttribute("src")), this.provider = function(t) {
                                            return /^(https?:\/\/)?(www\.)?(youtube\.com|youtube-nocookie\.com|youtu\.?be)\/.+$/.test(t) ? zt.youtube : /^https?:\/\/player.vimeo.com\/video\/\d{0,9}(?=\b|\/)/.test(t) ? zt.vimeo : null
                                        }(a.toString()), this.elements.container = this.media, this.media = n, this.elements.container.className = "", a.search.length) {
                                        const t = ["1", "true"];
                                        t.includes(a.searchParams.get("autoplay")) && (this.config.autoplay = !0), t.includes(a.searchParams.get("loop")) && (this.config.loop.active = !0), this.isYouTube ? (this.config.playsinline = t.includes(a.searchParams.get("playsinline")), this.config.youtube.hl = a.searchParams.get("hl")) : this.config.playsinline = !0
                                    }
                                } else this.provider = this.media.getAttribute(this.config.attributes.embed.provider), this.media.removeAttribute(this.config.attributes.embed.provider);
                                if (j(this.provider) || !Object.values(zt).includes(this.provider)) return void this.debug.error("Setup failed: Invalid provider");
                                this.type = qt;
                                break;
                            case "video":
                            case "audio":
                                this.type = r, this.provider = zt.html5, this.media.hasAttribute("crossorigin") && (this.config.crossorigin = !0), this.media.hasAttribute("autoplay") && (this.config.autoplay = !0), (this.media.hasAttribute("playsinline") || this.media.hasAttribute("webkit-playsinline")) && (this.config.playsinline = !0), this.media.hasAttribute("muted") && (this.config.muted = !0), this.media.hasAttribute("loop") && (this.config.loop.active = !0);
                                break;
                            default:
                                return void this.debug.error("Setup failed: unsupported type")
                        }
                        this.supported = ct.check(this.type, this.provider, this.config.playsinline), this.supported.api ? (this.eventListeners = [], this.listeners = new Zt(this), this.storage = new Mt(this), this.media.plyr = this, N(this.elements.container) || (this.elements.container = Y("div", {
                            tabindex: 0
                        }), q(this.media, this.elements.container)), Jt.migrateStyles.call(this), Jt.addStyleHook.call(this), oe.setup.call(this), this.config.debug && ht.call(this, this.elements.container, this.config.events.join(" "), (t => {
                            this.debug.log(`event: ${t.type}`)
                        })), this.fullscreen = new Xt(this), (this.isHTML5 || this.isEmbed && !this.supported.ui) && Jt.build.call(this), this.listeners.container(), this.listeners.global(), this.config.ads.enabled && (this.ads = new le(this)), this.isHTML5 && this.config.autoplay && this.once("canplay", (() => vt(this.play()))), this.lastSeekTime = 0, this.config.previewThumbnails.enabled && (this.previewThumbnails = new he(this))) : this.debug.error("Setup failed: no support")
                    }
                    get isHTML5() {
                        return this.provider === zt.html5
                    }
                    get isEmbed() {
                        return this.isYouTube || this.isVimeo
                    }
                    get isYouTube() {
                        return this.provider === zt.youtube
                    }
                    get isVimeo() {
                        return this.provider === zt.vimeo
                    }
                    get isVideo() {
                        return this.type === qt
                    }
                    get isAudio() {
                        return "audio" === this.type
                    }
                    get playing() {
                        return Boolean(this.ready && !this.paused && !this.ended)
                    }
                    get paused() {
                        return Boolean(this.media.paused)
                    }
                    get stopped() {
                        return Boolean(this.paused && 0 === this.currentTime)
                    }
                    get ended() {
                        return Boolean(this.media.ended)
                    }
                    set currentTime(t) {
                        if (!this.duration) return;
                        const e = C(t) && t > 0;
                        this.media.currentTime = e ? Math.min(t, this.duration) : 0, this.debug.log(`Seeking to ${this.currentTime} seconds`)
                    }
                    get currentTime() {
                        return Number(this.media.currentTime)
                    }
                    get buffered() {
                        const {
                            buffered: t
                        } = this.media;
                        return C(t) ? t : t && t.length && this.duration > 0 ? t.end(0) / this.duration : 0
                    }
                    get seeking() {
                        return Boolean(this.media.seeking)
                    }
                    get duration() {
                        const t = parseFloat(this.config.duration),
                            e = (this.media || {}).duration,
                            i = C(e) && e !== 1 / 0 ? e : 0;
                        return t || i
                    }
                    set volume(t) {
                        let e = t;
                        D(e) && (e = Number(e)), C(e) || (e = this.storage.get("volume")), C(e) || ({
                            volume: e
                        } = this.config), e > 1 && (e = 1), e < 0 && (e = 0), this.config.volume = e, this.media.volume = e, !j(t) && this.muted && e > 0 && (this.muted = !1)
                    }
                    get volume() {
                        return Number(this.media.volume)
                    }
                    set muted(t) {
                        let e = t;
                        x(e) || (e = this.storage.get("muted")), x(e) || (e = this.config.muted), this.config.muted = e, this.media.muted = e
                    }
                    get muted() {
                        return Boolean(this.media.muted)
                    }
                    get hasAudio() {
                        return !this.isHTML5 || !!this.isAudio || Boolean(this.media.mozHasAudio) || Boolean(this.media.webkitAudioDecodedByteCount) || Boolean(this.media.audioTracks && this.media.audioTracks.length)
                    }
                    set speed(t) {
                        let e = null;
                        C(t) && (e = t), C(e) || (e = this.storage.get("speed")), C(e) || (e = this.config.speed.selected);
                        const {
                            minimumSpeed: i,
                            maximumSpeed: s
                        } = this;
                        e = ce(e, i, s), this.config.speed.selected = e, setTimeout((() => {
                            this.media && (this.media.playbackRate = e)
                        }), 0)
                    }
                    get speed() {
                        return Number(this.media.playbackRate)
                    }
                    get minimumSpeed() {
                        return this.isYouTube ? Math.min(...this.options.speed) : this.isVimeo ? .5 : .0625
                    }
                    get maximumSpeed() {
                        return this.isYouTube ? Math.max(...this.options.speed) : this.isVimeo ? 2 : 16
                    }
                    set quality(t) {
                        const e = this.config.quality,
                            i = this.options.quality;
                        if (!i.length) return;
                        let s = [!j(t) && Number(t), this.storage.get("quality"), e.selected, e.default].find(C),
                            r = !0;
                        if (!i.includes(s)) {
                            const t = Tt(i, s);
                            this.debug.warn(`Unsupported quality option: ${s}, using ${t} instead`), s = t, r = !1
                        }
                        e.selected = s, this.media.quality = s, r && this.storage.set({
                            quality: s
                        })
                    }
                    get quality() {
                        return this.media.quality
                    }
                    set loop(t) {
                        const e = x(t) ? t : this.config.loop.active;
                        this.config.loop.active = e, this.media.loop = e
                    }
                    get loop() {
                        return Boolean(this.media.loop)
                    }
                    set source(t) {
                        fe.change.call(this, t)
                    }
                    get source() {
                        return this.media.currentSrc
                    }
                    get download() {
                        const {
                            download: t
                        } = this.config.urls;
                        return B(t) ? t : this.source
                    }
                    set download(t) {
                        B(t) && (this.config.urls.download = t, Bt.setDownloadUrl.call(this))
                    }
                    set poster(t) {
                        this.isVideo ? Jt.setPoster.call(this, t, !1).catch((() => {})) : this.debug.warn("Poster can only be set for video")
                    }
                    get poster() {
                        return this.isVideo ? this.media.getAttribute("poster") || this.media.getAttribute("data-poster") : null
                    }
                    get ratio() {
                        if (!this.isVideo) return null;
                        const t = kt(At.call(this));
                        return O(t) ? t.join(":") : t
                    }
                    set ratio(t) {
                        this.isVideo ? D(t) && wt(t) ? (this.config.ratio = kt(t), _t.call(this)) : this.debug.error(`Invalid aspect ratio specified (${t})`) : this.debug.warn("Aspect ratio can only be set for video")
                    }
                    set autoplay(t) {
                        this.config.autoplay = x(t) ? t : this.config.autoplay
                    }
                    get autoplay() {
                        return Boolean(this.config.autoplay)
                    }
                    toggleCaptions(t) {
                        Vt.toggle.call(this, t, !1)
                    }
                    set currentTrack(t) {
                        Vt.set.call(this, t, !1), Vt.setup.call(this)
                    }
                    get currentTrack() {
                        const {
                            toggled: t,
                            currentTrack: e
                        } = this.captions;
                        return t ? e : -1
                    }
                    set language(t) {
                        Vt.setLanguage.call(this, t, !1)
                    }
                    get language() {
                        return (Vt.getCurrentTrack.call(this) || {}).language
                    }
                    set pip(t) {
                        if (!ct.pip) return;
                        const e = x(t) ? t : !this.pip;
                        P(this.media.webkitSetPresentationMode) && this.media.webkitSetPresentationMode(e ? Kt : "inline"), P(this.media.requestPictureInPicture) && (!this.pip && e ? this.media.requestPictureInPicture() : this.pip && !e && document.exitPictureInPicture())
                    }
                    get pip() {
                        return ct.pip ? j(this.media.webkitPresentationMode) ? this.media === document.pictureInPictureElement : this.media.webkitPresentationMode === Kt : null
                    }
                    setPreviewThumbnails(t) {
                        this.previewThumbnails && this.previewThumbnails.loaded && (this.previewThumbnails.destroy(), this.previewThumbnails = null), Object.assign(this.config.previewThumbnails, t), this.config.previewThumbnails.enabled && (this.previewThumbnails = new he(this))
                    }
                    static supported(t, e, i) {
                        return ct.check(t, e, i)
                    }
                    static loadSprite(t, e) {
                        return Ft(t, e)
                    }
                    static setup(t, e = {}) {
                        let i = null;
                        return D(t) ? i = Array.from(document.querySelectorAll(t)) : M(t) ? i = Array.from(t) : O(t) && (i = t.filter(N)), j(i) ? null : i.map((t => new pe(t, e)))
                    }
                }
                var ge;
                return pe.defaults = (ge = Ht, JSON.parse(JSON.stringify(ge))), pe
            }())
        },
        6242: (t, e, i) => {
            "use strict";
            i.d(e, {
                Z: () => s
            });
            const s = {
                categoriesLabel: "Categorias",
                emojiUnsupportedMessage: "Seu navegador no suporta emojis coloridos.",
                favoritesLabel: "Favoritos",
                loadingMessage: "Carregando",
                networkErrorMessage: "No foi possvel carregar o emoji.",
                regionLabel: "Seletor de emoji",
                searchDescription: "Quando os resultados da pesquisa estiverem disponveis, pressione para cima ou para baixo para selecionar e enter para escolher.",
                searchLabel: "Procurar",
                searchResultsLabel: "Resultados da pesquisa",
                skinToneDescription: "Quando expandido, pressione para cima ou para baixo para selecionar e enter para escolher.",
                skinToneLabel: "Escolha um tom de pele (atualmente {skinTone})",
                skinTonesLabel: "Tons de pele",
                skinTones: ["Padro", "Claro", "Claro mdio", "Mdio", "Escuro mdio", "Escuro"],
                categories: {
                    custom: "Personalizar",
                    "smileys-emotion": "Carinhas e emoticons",
                    "people-body": "Pessoas e corpo",
                    "animals-nature": "Animais e natureza",
                    "food-drink": "Alimentos e bebidas",
                    "travel-places": "Viagem e lugares",
                    activities: "Atividades",
                    objects: "Objetos",
                    symbols: "Smbolos",
                    flags: "Bandeiras"
                }
            }
        },
        8014: (t, e, i) => {
            "use strict";

            function s(t) {
                if ("string" != typeof t || !t) throw new Error("expected a non-empty string, got: " + t)
            }

            function r(t) {
                if ("number" != typeof t) throw new Error("expected a number, got: " + t)
            }
            i.d(e, {
                Z: () => It
            });
            const n = "emoji",
                a = "keyvalue",
                o = "favorites",
                l = "tokens",
                c = "count",
                u = "group-order",
                d = "eTag",
                h = "url",
                f = "skinTone",
                p = "readonly",
                g = "readwrite",
                m = "skinUnicodes";

            function y(t) {
                return function(t, e) {
                    const i = new Set,
                        s = [];
                    for (const e of t) {
                        const t = e.unicode;
                        i.has(t) || (i.add(t), s.push(e))
                    }
                    return s
                }(t)
            }
            const v = {},
                b = {},
                T = {};

            function E(t, e, i) {
                i.onerror = () => e(i.error), i.onblocked = () => e(new Error("IDB blocked")), i.onsuccess = () => t(i.result)
            }

            function S(t, e, i, s) {
                return new Promise(((r, n) => {
                    const a = t.transaction(e, i, {
                            durability: "relaxed"
                        }),
                        o = "string" == typeof e ? a.objectStore(e) : e.map((t => a.objectStore(t)));
                    let l;
                    s(o, a, (t => {
                        l = t
                    })), a.oncomplete = () => r(l), a.onerror = () => n(a.error)
                }))
            }

            function w(t) {
                const e = v[t],
                    i = e && e.result;
                if (i) {
                    i.close();
                    const e = T[t];
                    if (e)
                        for (const t of e) t()
                }
                delete v[t], delete b[t], delete T[t]
            }
            const k = new Set([":D", "XD", ":'D", "O:)", ":X", ":P", ";P", "XP", ":L", ":Z", ":j", "8D", "XO", "8)", ":B", ":O", ":S", ":'o", "Dx", "X(", "D:", ":C", ">0)", ":3", "</3", "<3", "\\M/", ":E", "8#"]);

            function A(t) {
                return t.split(/[\s_]+/).map((t => !t.match(/\w/) || k.has(t) ? t.toLowerCase() : t.replace(/[)(:,]/g, "").replace(//g, "'").toLowerCase())).filter(Boolean)
            }
            const _ = 2;

            function L(t) {
                return t.filter(Boolean).map((t => t.toLowerCase())).filter((t => t.length >= _))
            }

            function R(t, e, i, s) {
                t[e](i).onsuccess = t => s && s(t.target.result)
            }

            function I(t, e, i) {
                R(t, "get", e, i)
            }

            function C(t, e, i) {
                R(t, "getAll", e, i)
            }

            function D(t) {
                t.commit && t.commit()
            }

            function x(t, e) {
                const i = function(t, e) {
                        let i = t[0];
                        for (let s = 1; s < t.length; s++) {
                            const r = t[s];
                            e(i) > e(r) && (i = r)
                        }
                        return i
                    }(t, (t => t.length)),
                    s = [];
                for (const r of i) t.some((t => -1 === t.findIndex((t => e(t) === e(r))))) || s.push(r);
                return s
            }
            async function P(t, e, i, s) {
                try {
                    const r = function(t) {
                        return t.map((({
                            annotation: t,
                            emoticon: e,
                            group: i,
                            order: s,
                            shortcodes: r,
                            skins: n,
                            tags: a,
                            emoji: o,
                            version: l
                        }) => {
                            const c = [...new Set(L([...(r || []).map(A).flat(), ...a.map(A).flat(), ...A(t), e]))].sort(),
                                u = {
                                    annotation: t,
                                    group: i,
                                    order: s,
                                    tags: a,
                                    tokens: c,
                                    unicode: o,
                                    version: l
                                };
                            if (e && (u.emoticon = e), r && (u.shortcodes = r), n) {
                                u.skinTones = [], u.skinUnicodes = [], u.skinVersions = [];
                                for (const {
                                        tone: t,
                                        emoji: e,
                                        version: i
                                    } of n) u.skinTones.push(t), u.skinUnicodes.push(e), u.skinVersions.push(i)
                            }
                            return u
                        }))
                    }(e);
                    await S(t, [n, a], g, (([t, e], n) => {
                        let a, o, l = 0;

                        function c() {
                            2 == ++l && function() {
                                if (a !== s || o !== i) {
                                    t.clear();
                                    for (const e of r) t.put(e);
                                    e.put(s, d), e.put(i, h), D(n)
                                }
                            }()
                        }
                        I(e, d, (t => {
                            a = t, c()
                        })), I(e, h, (t => {
                            o = t, c()
                        }))
                    }))
                } finally {}
            }
            async function O(t, e) {
                const i = L(A(e));
                return i.length ? S(t, n, p, ((t, e, s) => {
                    const r = [],
                        n = () => {
                            const t = x(r, (t => t.unicode));
                            s(t.sort(((t, e) => t.order < e.order ? -1 : 1)))
                        };
                    for (let e = 0; e < i.length; e++) {
                        const s = i[e],
                            a = e === i.length - 1 ? IDBKeyRange.bound(s, s + "", !1, !0) : IDBKeyRange.only(s);
                        C(t.index(l), a, (t => {
                            r.push(t), r.length === i.length && n()
                        }))
                    }
                })) : []
            }

            function M(t, e, i) {
                return S(t, e, p, ((t, e, s) => I(t, i, s)))
            }
            const N = ["name", "url"];

            function F(t) {
                ! function(t) {
                    const e = t && Array.isArray(t),
                        i = e && t.length && (!t[0] || N.some((e => !(e in t[0]))));
                    if (!e || i) throw new Error("Custom emojis are in the wrong format")
                }(t);
                const e = (t, e) => t.name.toLowerCase() < e.name.toLowerCase() ? -1 : 1,
                    i = t.sort(e),
                    s = function(t, e) {
                        const i = new Map;
                        for (const e of t) {
                            const t = [...new Set((e.shortcodes || []).map((t => A(t))).flat())];
                            for (const s of t) {
                                let t = i;
                                for (let e = 0; e < s.length; e++) {
                                    const i = s.charAt(e);
                                    let r = t.get(i);
                                    r || (r = new Map, t.set(i, r)), t = r
                                }
                                let r = t.get("");
                                r || (r = [], t.set("", r)), r.push(e)
                            }
                        }
                        return (t, e) => {
                            let s = i;
                            for (let e = 0; e < t.length; e++) {
                                const i = t.charAt(e),
                                    r = s.get(i);
                                if (!r) return [];
                                s = r
                            }
                            if (e) return s.get("") || [];
                            const r = [],
                                n = [s];
                            for (; n.length;) {
                                const t = [...n.shift().entries()].sort(((t, e) => t[0] < e[0] ? -1 : 1));
                                for (const [e, i] of t) "" === e ? r.push(...i) : n.push(i)
                            }
                            return r
                        }
                    }(t),
                    r = t => s(t, !0),
                    n = t => s(t, !1),
                    a = new Map,
                    o = new Map;
                for (const e of t) {
                    o.set(e.name.toLowerCase(), e);
                    for (const t of e.shortcodes || []) a.set(t.toLowerCase(), e)
                }
                return {
                    all: i,
                    search: t => {
                        const i = A(t);
                        return x(i.map(((t, e) => (e < i.length - 1 ? r : n)(t))), (t => t.name)).sort(e)
                    },
                    byShortcode: t => a.get(t.toLowerCase()),
                    byName: t => o.get(t.toLowerCase())
                }
            }
            const $ = "undefined" != typeof wrappedJSObject;

            function U(t) {
                if (!t) return t;
                if ($ && (t = structuredClone(t)), delete t.tokens, t.skinTones) {
                    const e = t.skinTones.length;
                    t.skins = Array(e);
                    for (let i = 0; i < e; i++) t.skins[i] = {
                        tone: t.skinTones[i],
                        unicode: t.skinUnicodes[i],
                        version: t.skinVersions[i]
                    };
                    delete t.skinTones, delete t.skinUnicodes, delete t.skinVersions
                }
                return t
            }

            function B(t) {
                t || console.warn("emoji-picker-element is more efficient if the dataSource server exposes an ETag header.")
            }
            const j = ["annotation", "emoji", "group", "order", "tags", "version"];

            function G(t, e) {
                if (2 !== Math.floor(t.status / 100)) throw new Error("Failed to fetch: " + e + ":  " + t.status)
            }
            async function V(t) {
                const e = await fetch(t);
                G(e, t);
                const i = e.headers.get("etag");
                B(i);
                const s = await e.json();
                return function(t) {
                    if (!t || !Array.isArray(t) || !t[0] || "object" != typeof t[0] || j.some((e => !(e in t[0])))) throw new Error("Emoji data is in the wrong format")
                }(s), [i, s]
            }
            async function H(t) {
                const e = function(t) {
                        for (var e = t.length, i = new ArrayBuffer(e), s = new Uint8Array(i), r = -1; ++r < e;) s[r] = t.charCodeAt(r);
                        return i
                    }(JSON.stringify(t)),
                    i = function(t) {
                        for (var e = "", i = new Uint8Array(t), s = i.byteLength, r = -1; ++r < s;) e += String.fromCharCode(i[r]);
                        return e
                    }(await crypto.subtle.digest("SHA-1", e));
                return btoa(i)
            }
            class K {
                constructor({
                    dataSource: t = "https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json",
                    locale: e = "en",
                    customEmoji: i = []
                } = {}) {
                    this.dataSource = t, this.locale = e, this._dbName = `emoji-picker-element-${this.locale}`, this._db = void 0, this._lazyUpdate = void 0, this._custom = F(i), this._clear = this._clear.bind(this), this._ready = this._init()
                }
                async _init() {
                    const t = this._db = await (e = this._dbName, b[e] || (b[e] = async function(t) {
                        const e = await new Promise(((e, i) => {
                            const s = indexedDB.open(t, 1);
                            v[t] = s, s.onupgradeneeded = t => {
                                t.oldVersion < 1 && function(t) {
                                    function e(e, i, s) {
                                        const r = i ? t.createObjectStore(e, {
                                            keyPath: i
                                        }) : t.createObjectStore(e);
                                        if (s)
                                            for (const [t, [e, i]] of Object.entries(s)) r.createIndex(t, e, {
                                                multiEntry: i
                                            });
                                        return r
                                    }
                                    e(a), e(n, "unicode", {
                                        [l]: ["tokens", !0],
                                        [u]: [
                                            ["group", "order"]
                                        ],
                                        [m]: ["skinUnicodes", !0]
                                    }), e(o, void 0, {
                                        [c]: [""]
                                    })
                                }(s.result)
                            }, E(e, i, s)
                        }));
                        return e.onclose = () => w(t), e
                    }(e)), b[e]);
                    var e;
                    ! function(t, e) {
                        let i = T[t];
                        i || (i = T[t] = []), i.push(e)
                    }(this._dbName, this._clear);
                    const i = this.dataSource,
                        s = await async function(t) {
                            return !await M(t, a, h)
                        }(t);
                    s ? await async function(t, e) {
                        let [i, s] = await V(e);
                        i || (i = await H(s)), await P(t, s, e, i)
                    }(t, i) : this._lazyUpdate = async function(t, e) {
                        let i, s = await async function(t) {
                            const e = await fetch(t, {
                                method: "HEAD"
                            });
                            G(e, t);
                            const i = e.headers.get("etag");
                            return B(i), i
                        }(e);
                        if (!s) {
                            const t = await V(e);
                            s = t[0], i = t[1], s || (s = await H(i))
                        }
                        await async function(t, e, i) {
                            const [s, r] = await Promise.all([d, h].map((e => M(t, a, e))));
                            return s === i && r === e
                        }(t, e, s) || (i || (i = (await V(e))[1]), await P(t, i, e, s))
                    }(t, i)
                }
                async ready() {
                    const t = async () => (this._ready || (this._ready = this._init()), this._ready);
                    await t(), this._db || await t()
                }
                async getEmojiByGroup(t) {
                    return r(t), await this.ready(), y(await async function(t, e) {
                        return S(t, n, p, ((t, i, s) => {
                            const r = IDBKeyRange.bound([e, 0], [e + 1, 0], !1, !0);
                            C(t.index(u), r, s)
                        }))
                    }(this._db, t)).map(U)
                }
                async getEmojiBySearchQuery(t) {
                    return s(t), await this.ready(), [...this._custom.search(t), ...y(await O(this._db, t)).map(U)]
                }
                async getEmojiByShortcode(t) {
                    s(t), await this.ready();
                    return this._custom.byShortcode(t) || U(await async function(t, e) {
                        const i = await O(t, e);
                        if (!i.length) {
                            const i = t => (t.shortcodes || []).includes(e.toLowerCase());
                            return await async function(t, e) {
                                return S(t, n, p, ((t, i, s) => {
                                    let r;
                                    const n = () => {
                                        t.getAll(r && IDBKeyRange.lowerBound(r, !0), 50).onsuccess = t => {
                                            const i = t.target.result;
                                            for (const t of i)
                                                if (r = t.unicode, e(t)) return s(t);
                                            if (i.length < 50) return s();
                                            n()
                                        }
                                    };
                                    n()
                                }))
                            }(t, i) || null
                        }
                        return i.filter((t => {
                            const i = (t.shortcodes || []).map((t => t.toLowerCase()));
                            return i.includes(e.toLowerCase())
                        }))[0] || null
                    }(this._db, t))
                }
                async getEmojiByUnicodeOrName(t) {
                    s(t), await this.ready();
                    return this._custom.byName(t) || U(await async function(t, e) {
                        return S(t, n, p, ((t, i, s) => I(t, e, (i => {
                            if (i) return s(i);
                            I(t.index(m), e, (t => s(t || null)))
                        }))))
                    }(this._db, t))
                }
                async getPreferredSkinTone() {
                    return await this.ready(), await M(this._db, a, f) || 0
                }
                async setPreferredSkinTone(t) {
                    return r(t), await this.ready(), e = this._db, i = f, s = t, S(e, a, g, ((t, e) => {
                        t.put(s, i), D(e)
                    }));
                    var e, i, s
                }
                async incrementFavoriteEmojiCount(t) {
                    return s(t), await this.ready(), e = this._db, i = t, S(e, o, g, ((t, e) => I(t, i, (s => {
                        t.put((s || 0) + 1, i), D(e)
                    }))));
                    var e, i
                }
                async getTopFavoriteEmoji(t) {
                    return r(t), await this.ready(), (await
                        function(t, e, i) {
                            return 0 === i ? [] : S(t, [o, n], p, (([t, s], r, n) => {
                                const a = [];
                                t.index(c).openCursor(void 0, "prev").onsuccess = t => {
                                    const r = t.target.result;
                                    if (!r) return n(a);

                                    function o(t) {
                                        if (a.push(t), a.length === i) return n(a);
                                        r.continue()
                                    }
                                    const l = r.primaryKey,
                                        c = e.byName(l);
                                    if (c) return o(c);
                                    I(s, l, (t => {
                                        if (t) return o(t);
                                        r.continue()
                                    }))
                                }
                            }))
                        }(this._db, this._custom, t)).map(U)
                }
                set customEmoji(t) {
                    this._custom = F(t)
                }
                get customEmoji() {
                    return this._custom.all
                }
                async _shutdown() {
                    await this.ready();
                    try {
                        await this._lazyUpdate
                    } catch (t) {}
                }
                _clear() {
                    this._db = this._ready = this._lazyUpdate = void 0
                }
                async close() {
                    await this._shutdown(), await w(this._dbName)
                }
                async delete() {
                    var t;
                    await this._shutdown(), await (t = this._dbName, new Promise(((e, i) => {
                        w(t), E(e, i, indexedDB.deleteDatabase(t))
                    })))
                }
            }
            const z = [
                    [-1, "", "custom"],
                    [0, "", "smileys-emotion"],
                    [1, "", "people-body"],
                    [3, "", "animals-nature"],
                    [4, "", "food-drink"],
                    [5, "", "travel-places"],
                    [6, "", "activities"],
                    [7, "", "objects"],
                    [8, "", "symbols"],
                    [9, "", "flags"]
                ].map((([t, e, i]) => ({
                    id: t,
                    emoji: e,
                    name: i
                }))),
                q = z.slice(1),
                W = "function" == typeof requestIdleCallback ? requestIdleCallback : setTimeout;

            function Y(t) {
                return t.unicode.includes("")
            }
            const X = {
                    "": 15.1,
                    "": 14,
                    "": 13.1,
                    "": 12.1,
                    "": 11,
                    "": 5,
                    "": 4,
                    "": 3,
                    "": 2,
                    "": 1,
                    "": .7,
                    "": .6
                },
                Q = ["", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                J = '"Twemoji Mozilla","Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji","EmojiOne Color","Android Emoji",sans-serif',
                Z = (t, e) => t < e ? -1 : t > e ? 1 : 0,
                tt = (t, e) => {
                    const i = document.createElement("canvas");
                    i.width = i.height = 1;
                    const s = i.getContext("2d");
                    return s.textBaseline = "top", s.font = `100px ${J}`, s.fillStyle = e, s.scale(.01, .01), s.fillText(t, 0, 0), s.getImageData(0, 0, 1, 1).data
                };

            function et(t) {
                const e = tt(t, "#000"),
                    i = tt(t, "#fff");
                return e && i && ((t, e) => {
                    const i = [...t].join(",");
                    return i === [...e].join(",") && !i.startsWith("0,0,0,")
                })(e, i)
            }
            let it;
            const st = () => (it || (it = new Promise((t => W((() => t(function() {
                    const t = Object.entries(X);
                    try {
                        for (const [e, i] of t)
                            if (et(e)) return i
                    } catch (t) {}
                    return t[0][1]
                }())))))), it),
                rt = new Map;

            function nt(t) {
                t.preventDefault(), t.stopPropagation()
            }

            function at(t, e, i) {
                return (e += t ? -1 : 1) < 0 ? e = i.length - 1 : e >= i.length && (e = 0), e
            }

            function ot(t, e) {
                const i = new Set,
                    s = [];
                for (const r of t) {
                    const t = e(r);
                    i.has(t) || (i.add(t), s.push(r))
                }
                return s
            }
            const lt = requestAnimationFrame;
            let ct, ut = "function" == typeof ResizeObserver;

            function dt(t) {
                {
                    const e = document.createRange();
                    return e.selectNode(t.firstChild), e.getBoundingClientRect().width
                }
            }

            function ht(t, e, i) {
                let s = t.get(e);
                return s || (s = i(), t.set(e, s)), s
            }

            function ft(t) {
                return "" + t
            }
            const pt = new WeakMap,
                gt = new WeakMap,
                mt = Symbol("un-keyed"),
                yt = "replaceChildren" in Element.prototype;

            function vt(t, e) {
                const {
                    targetNode: i
                } = e;
                let {
                    targetParentNode: s
                } = e, r = !1;
                s ? r = function(t, e) {
                    let i = t.firstChild,
                        s = 0;
                    for (; i;) {
                        if (e[s] !== i) return !0;
                        i = i.nextSibling, s++
                    }
                    return s !== e.length
                }(s, t) : (r = !0, e.targetNode = void 0, e.targetParentNode = s = i.parentNode), r && function(t, e) {
                    yt ? t.replaceChildren(...e) : (t.innerHTML = "", t.append(...e))
                }(s, t)
            }

            function bt(t, e) {
                let i = t.firstChild;
                for (; i;) {
                    if (i.nodeType === Node.COMMENT_NODE && i.nodeValue === ft(e)) return i;
                    i = i.nextSibling
                }
            }

            function Tt(t) {
                const {
                    template: e,
                    elementsToBindings: i
                } = ht(pt, t, (() => function(t) {
                    let e = "",
                        i = !1,
                        s = !1,
                        r = -1;
                    const n = new Map,
                        a = [];
                    for (let o = 0, l = t.length; o < l; o++) {
                        const c = t[o];
                        if (e += c, o === l - 1) break;
                        for (let t = 0; t < c.length; t++) switch (c.charAt(t)) {
                            case "<":
                                "/" === c.charAt(t + 1) ? a.pop() : (i = !0, a.push(++r));
                                break;
                            case ">":
                                i = !1, s = !1;
                                break;
                            case "=":
                                s = !0
                        }
                        const u = ht(n, a[a.length - 1], (() => []));
                        let d, h, f;
                        if (s) {
                            const e = /(\S+)="?([^"=]*)$/.exec(c);
                            d = e[1], h = e[2], f = /^[^">]*/.exec(t[o + 1])[0]
                        }
                        const p = {
                            attributeName: d,
                            attributeValuePre: h,
                            attributeValuePost: f,
                            expressionIndex: o
                        };
                        u.push(p), e += i || s ? "" : `\x3c!--${u.length-1}--\x3e`
                    }
                    const o = function(t) {
                        const e = document.createElement("template");
                        return e.innerHTML = t, e
                    }(e);
                    return {
                        template: o,
                        elementsToBindings: n
                    }
                }(t))), s = e.cloneNode(!0).content.firstElementChild, r = function(t, e) {
                    const i = [],
                        s = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT);
                    let r = t,
                        n = -1;
                    do {
                        const t = e.get(++n);
                        if (t)
                            for (let e = 0; e < t.length; e++) {
                                const s = t[e],
                                    n = {
                                        binding: s,
                                        targetNode: s.attributeName ? r : bt(r, e),
                                        targetParentNode: void 0,
                                        currentExpression: void 0
                                    };
                                i.push(n)
                            }
                    } while (r = s.nextNode());
                    return i
                }(s, i);
                return function(t) {
                    return function(t, e) {
                        for (const i of e) {
                            const {
                                targetNode: e,
                                currentExpression: s,
                                binding: {
                                    expressionIndex: r,
                                    attributeName: n,
                                    attributeValuePre: a,
                                    attributeValuePost: o
                                }
                            } = i, l = t[r];
                            if (s !== l)
                                if (i.currentExpression = l, n) e.setAttribute(n, a + ft(l) + o);
                                else {
                                    let t;
                                    Array.isArray(l) ? vt(l, i) : l instanceof Element ? (t = l, e.replaceWith(t)) : e.nodeType === Node.TEXT_NODE ? e.nodeValue = ft(l) : (t = document.createTextNode(ft(l)), e.replaceWith(t)), t && (i.targetNode = t)
                                }
                        }
                    }(t, r), s
                }
            }
            const Et = "function" == typeof queueMicrotask ? queueMicrotask : t => Promise.resolve().then(t);

            function St(t, e, i) {
                if (t.length !== e.length) return !1;
                for (let s = 0; s < t.length; s++)
                    if (!i(t[s], e[s])) return !1;
                return !0
            }
            const wt = [],
                {
                    assign: kt
                } = Object;

            function At(t, e) {
                const i = {},
                    s = new AbortController,
                    r = s.signal,
                    {
                        state: n,
                        createEffect: a
                    } = function(t) {
                        let e, i = !1;
                        const s = new Map,
                            r = new Set;
                        let n;
                        const a = () => {
                                if (i) return;
                                const t = [...r];
                                r.clear();
                                try {
                                    for (const e of t) e()
                                } finally {
                                    n = !1, r.size && (n = !0, Et(a))
                                }
                            },
                            o = new Proxy({}, {
                                get(t, i) {
                                    if (e) {
                                        let t = s.get(i);
                                        t || (t = new Set, s.set(i, t)), t.add(e)
                                    }
                                    return t[i]
                                },
                                set(t, e, i) {
                                    t[e] = i;
                                    const o = s.get(e);
                                    if (o) {
                                        for (const t of o) r.add(t);
                                        n || (n = !0, Et(a))
                                    }
                                    return !0
                                }
                            });
                        return t.addEventListener("abort", (() => {
                            i = !0
                        })), {
                            state: o,
                            createEffect: t => {
                                const i = () => {
                                    const s = e;
                                    e = i;
                                    try {
                                        return t()
                                    } finally {
                                        e = s
                                    }
                                };
                                return i()
                            }
                        }
                    }(r);
                kt(n, {
                    skinToneEmoji: void 0,
                    i18n: void 0,
                    database: void 0,
                    customEmoji: void 0,
                    customCategorySorting: void 0,
                    emojiVersion: void 0
                }), kt(n, e), kt(n, {
                    initialLoad: !0,
                    currentEmojis: [],
                    currentEmojisWithCategories: [],
                    rawSearchText: "",
                    searchText: "",
                    searchMode: !1,
                    activeSearchItem: -1,
                    message: void 0,
                    skinTonePickerExpanded: !1,
                    skinTonePickerExpandedAfterAnimation: !1,
                    currentSkinTone: 0,
                    activeSkinTone: 0,
                    skinToneButtonText: void 0,
                    pickerStyle: void 0,
                    skinToneButtonLabel: "",
                    skinTones: [],
                    currentFavorites: [],
                    defaultFavoriteEmojis: void 0,
                    numColumns: 8,
                    isRtl: !1,
                    scrollbarWidth: 0,
                    currentGroupIndex: 0,
                    groups: q,
                    databaseLoaded: !1,
                    activeSearchItemId: void 0
                }), a((() => {
                    n.currentGroup !== n.groups[n.currentGroupIndex] && (n.currentGroup = n.groups[n.currentGroupIndex])
                }));
                const o = e => {
                        t.getElementById(e).focus()
                    },
                    l = e => t.getElementById(`emo-${e.id}`),
                    c = (t, e) => {
                        i.rootElement.dispatchEvent(new CustomEvent(t, {
                            detail: e,
                            bubbles: !0,
                            composed: !0
                        }))
                    },
                    u = (t, e) => t.id === e.id,
                    d = (t, e) => {
                        const {
                            category: i,
                            emojis: s
                        } = t, {
                            category: r,
                            emojis: n
                        } = e;
                        return i === r && St(s, n, u)
                    },
                    h = t => {
                        St(n.currentEmojis, t, u) || (n.currentEmojis = t)
                    },
                    f = t => {
                        n.searchMode !== t && (n.searchMode = t)
                    },
                    p = (t, e) => e && t.skins && t.skins[e] || t.unicode,
                    g = {
                        labelWithSkin: (t, e) => {
                            return (i = [t.name || p(t, e), t.annotation, ...t.shortcodes || wt].filter(Boolean), ot(i, (t => t))).join(", ");
                            var i
                        },
                        titleForEmoji: t => t.annotation || (t.shortcodes || wt).join(", "),
                        unicodeWithSkin: p
                    },
                    m = {
                        onClickSkinToneButton: function(t) {
                            n.skinTonePickerExpanded = !n.skinTonePickerExpanded, n.activeSkinTone = n.currentSkinTone, n.skinTonePickerExpanded && (nt(t), lt((() => o("skintone-list"))))
                        },
                        onEmojiClick: async function(t) {
                            const {
                                target: e
                            } = t;
                            e.classList.contains("emoji") && (nt(t), w(e.id.substring(4)))
                        },
                        onNavClick: function(t) {
                            const {
                                target: e
                            } = t, s = e.closest(".nav-button");
                            if (!s) return;
                            const r = parseInt(s.dataset.groupId, 10);
                            i.searchElement.value = "", n.rawSearchText = "", n.searchText = "", n.activeSearchItem = -1, n.currentGroupIndex = n.groups.findIndex((t => t.id === r))
                        },
                        onNavKeydown: function(t) {
                            const {
                                target: e,
                                key: i
                            } = t, s = e => {
                                e && (nt(t), e.focus())
                            };
                            switch (i) {
                                case "ArrowLeft":
                                    return s(e.previousElementSibling);
                                case "ArrowRight":
                                    return s(e.nextElementSibling);
                                case "Home":
                                    return s(e.parentElement.firstElementChild);
                                case "End":
                                    return s(e.parentElement.lastElementChild)
                            }
                        },
                        onSearchKeydown: function(t) {
                            if (!n.searchMode || !n.currentEmojis.length) return;
                            const e = e => {
                                nt(t), n.activeSearchItem = at(e, n.activeSearchItem, n.currentEmojis)
                            };
                            switch (t.key) {
                                case "ArrowDown":
                                    return e(!1);
                                case "ArrowUp":
                                    return e(!0);
                                case "Enter":
                                    if (-1 !== n.activeSearchItem) return nt(t), w(n.currentEmojis[n.activeSearchItem].id);
                                    n.activeSearchItem = 0
                            }
                        },
                        onSkinToneOptionsClick: function(t) {
                            const {
                                target: {
                                    id: e
                                }
                            } = t, i = e && e.match(/^skintone-(\d)/);
                            i && (nt(t), k(parseInt(i[1], 10)))
                        },
                        onSkinToneOptionsFocusOut: async function(t) {
                            const {
                                relatedTarget: e
                            } = t;
                            e && "skintone-list" === e.id || (n.skinTonePickerExpanded = !1)
                        },
                        onSkinToneOptionsKeydown: function(t) {
                            if (!n.skinTonePickerExpanded) return;
                            const e = async e => {
                                nt(t), n.activeSkinTone = e
                            };
                            switch (t.key) {
                                case "ArrowUp":
                                    return e(at(!0, n.activeSkinTone, n.skinTones));
                                case "ArrowDown":
                                    return e(at(!1, n.activeSkinTone, n.skinTones));
                                case "Home":
                                    return e(0);
                                case "End":
                                    return e(n.skinTones.length - 1);
                                case "Enter":
                                    return nt(t), k(n.activeSkinTone);
                                case "Escape":
                                    return nt(t), n.skinTonePickerExpanded = !1, o("skintone-button")
                            }
                        },
                        onSkinToneOptionsKeyup: function(t) {
                            if (n.skinTonePickerExpanded) return " " === t.key ? (nt(t), k(n.activeSkinTone)) : void 0
                        },
                        onSearchInput: function(t) {
                            n.rawSearchText = t.target.value
                        }
                    },
                    y = {
                        calculateEmojiGridStyle: function(t) {
                            ! function(t, e, i) {
                                let s;
                                ut ? (s = new ResizeObserver((t => i(t[0].contentRect.width))), s.observe(t)) : lt((() => i(t.getBoundingClientRect().width))), e.addEventListener("abort", (() => {
                                    s && s.disconnect()
                                }))
                            }(t, r, (e => {
                                {
                                    const s = getComputedStyle(i.rootElement),
                                        r = parseInt(s.getPropertyValue("--num-columns"), 10),
                                        a = "rtl" === s.getPropertyValue("direction"),
                                        o = t.parentElement.getBoundingClientRect().width - e;
                                    n.numColumns = r, n.scrollbarWidth = o, n.isRtl = a
                                }
                            }))
                        }
                    };
                let v = !0;

                function b() {
                    n.database.customEmoji = n.customEmoji || wt
                }

                function T(t) {
                    return !t.unicode || !Y(t) || rt.get(t.unicode)
                }
                async function E(t) {
                    const e = n.emojiVersion || await st();
                    return t.filter((({
                        version: t
                    }) => !t || t <= e))
                }
                async function S(t) {
                    return function(t, e) {
                        const i = t => {
                            const i = {};
                            for (const s of t) "number" == typeof s.tone && s.version <= e && (i[s.tone] = s.unicode);
                            return i
                        };
                        return t.map((({
                            unicode: t,
                            skins: e,
                            shortcodes: s,
                            url: r,
                            name: n,
                            category: a,
                            annotation: o
                        }) => ({
                            unicode: t,
                            name: n,
                            shortcodes: s,
                            url: r,
                            category: a,
                            annotation: o,
                            id: t || n,
                            skins: e && i(e)
                        })))
                    }(t, n.emojiVersion || await st())
                }
                async function w(t) {
                    const e = await n.database.getEmojiByUnicodeOrName(t),
                        i = [...n.currentEmojis, ...n.currentFavorites].find((e => e.id === t)),
                        s = i.unicode && p(i, n.currentSkinTone);
                    await n.database.incrementFavoriteEmojiCount(t), c("emoji-click", {
                        emoji: e,
                        skinTone: n.currentSkinTone,
                        ...s && {
                            unicode: s
                        },
                        ...i.name && {
                            name: i.name
                        }
                    })
                }

                function k(t) {
                    n.currentSkinTone = t, n.skinTonePickerExpanded = !1, o("skintone-button"), c("skin-tone-change", {
                        skinTone: t
                    }), n.database.setPreferredSkinTone(t)
                }
                return a((() => {
                    (function(t, e, i, s, r, n, a, o) {
                        const {
                            labelWithSkin: l,
                            titleForEmoji: c,
                            unicodeWithSkin: u
                        } = i, {
                            html: d,
                            map: h
                        } = function(t) {
                            const e = ht(gt, t, (() => new Map));
                            let i = mt;
                            return {
                                map: function(t, e, s) {
                                    return t.map(((t, r) => {
                                        const n = i;
                                        i = s(t);
                                        try {
                                            return e(t, r)
                                        } finally {
                                            i = n
                                        }
                                    }))
                                },
                                html: function(t, ...s) {
                                    const r = ht(e, t, (() => new Map));
                                    return ht(r, i, (() => Tt(t)))(s)
                                }
                            }
                        }(e);

                        function f(t, i, s) {
                            return h(t, ((t, r) => d `<button role="${i?"option":"menuitem"}" aria-selected="${e.searchMode?r===e.activeSearchItem:""}" aria-label="${l(t,e.currentSkinTone)}" title="${c(t)}" class="emoji ${i&&r===e.activeSearchItem?"active":""}" id="${`${s}-${t.id}`}">${t.unicode?u(t,e.currentSkinTone):d`<img class="custom-emoji" src="${t.url}" alt="" loading="lazy">`}</button>`), (t => `${s}-${t.id}`))
                        }
                        const p = d `<section data-ref="rootElement" class="picker" aria-label="${e.i18n.regionLabel}" style="${e.pickerStyle}"><div class="pad-top"></div><div class="search-row"><div class="search-wrapper"><input id="search" class="search" type="search" role="combobox" enterkeyhint="search" placeholder="${e.i18n.searchLabel}" autocapitalize="none" autocomplete="off" spellcheck="true" aria-expanded="${!(!e.searchMode||!e.currentEmojis.length)}" aria-controls="search-results" aria-describedby="search-description" aria-autocomplete="list" aria-activedescendant="${e.activeSearchItemId?`emo-${e.activeSearchItemId}`:""}" data-ref="searchElement" data-on-input="onSearchInput" data-on-keydown="onSearchKeydown"><label class="sr-only" for="search">${e.i18n.searchLabel}</label> <span id="search-description" class="sr-only">${e.i18n.searchDescription}</span></div><div class="skintone-button-wrapper ${e.skinTonePickerExpandedAfterAnimation?"expanded":""}"><button id="skintone-button" class="emoji ${e.skinTonePickerExpanded?"hide-focus":""}" aria-label="${e.skinToneButtonLabel}" title="${e.skinToneButtonLabel}" aria-describedby="skintone-description" aria-haspopup="listbox" aria-expanded="${e.skinTonePickerExpanded}" aria-controls="skintone-list" data-on-click="onClickSkinToneButton">${e.skinToneButtonText}</button></div><span id="skintone-description" class="sr-only">${e.i18n.skinToneDescription}</span><div data-ref="skinToneDropdown" id="skintone-list" class="skintone-list hide-focus ${e.skinTonePickerExpanded?"":"hidden no-animate"}" style="transform:translateY(${e.skinTonePickerExpanded?0:"calc(-1 * var(--num-skintones) * var(--total-emoji-size))"})" role="listbox" aria-label="${e.i18n.skinTonesLabel}" aria-activedescendant="skintone-${e.activeSkinTone}" aria-hidden="${!e.skinTonePickerExpanded}" tabIndex="-1" data-on-focusout="onSkinToneOptionsFocusOut" data-on-click="onSkinToneOptionsClick" data-on-keydown="onSkinToneOptionsKeydown" data-on-keyup="onSkinToneOptionsKeyup">${h(e.skinTones,((t,i)=>d`<div id="skintone-${i}" class="emoji ${i===e.activeSkinTone?"active":""}" aria-selected="${i===e.activeSkinTone}" role="option" title="${e.i18n.skinTones[i]}" aria-label="${e.i18n.skinTones[i]}">${t}</div>`),(t=>t))}</div></div><div class="nav" role="tablist" style="grid-template-columns:repeat(${e.groups.length},1fr)" aria-label="${e.i18n.categoriesLabel}" data-on-keydown="onNavKeydown" data-on-click="onNavClick">${h(e.groups,(t=>d`<button role="tab" class="nav-button" aria-controls="tab-${t.id}" aria-label="${e.i18n.categories[t.name]}" aria-selected="${!e.searchMode&&e.currentGroup.id===t.id}" title="${e.i18n.categories[t.name]}" data-group-id="${t.id}"><div class="nav-emoji emoji">${t.emoji}</div></button>`),(t=>t.id))}</div><div class="indicator-wrapper"><div class="indicator" style="transform:translateX(${(e.isRtl?-1:1)*e.currentGroupIndex*100}%)"></div></div><div class="message ${e.message?"":"gone"}" role="alert" aria-live="polite">${e.message}</div><div data-ref="tabpanelElement" class="tabpanel ${!e.databaseLoaded||e.message?"gone":""}" role="${e.searchMode?"region":"tabpanel"}" aria-label="${e.searchMode?e.i18n.searchResultsLabel:e.i18n.categories[e.currentGroup.name]}" id="${e.searchMode?"":`tab-${e.currentGroup.id}`}" tabIndex="0" data-on-click="onEmojiClick"><div data-action="calculateEmojiGridStyle">${h(e.currentEmojisWithCategories,((t,i)=>d`<div><div id="menu-label-${i}" class="category ${1===e.currentEmojisWithCategories.length&&""===e.currentEmojisWithCategories[0].category?"gone":""}" aria-hidden="true">${e.searchMode?e.i18n.searchResultsLabel:t.category?t.category:e.currentEmojisWithCategories.length>1?e.i18n.categories.custom:e.i18n.categories[e.currentGroup.name]}</div><div class="emoji-menu" role="${e.searchMode?"listbox":"menu"}" aria-labelledby="menu-label-${i}" id="${e.searchMode?"search-results":""}">${f(t.emojis,e.searchMode,"emo")}</div></div>`),(t=>t.category))}</div></div><div class="favorites emoji-menu ${e.message?"gone":""}" role="menu" aria-label="${e.i18n.favoritesLabel}" style="padding-inline-end:${`${e.scrollbarWidth}px`}" data-on-click="onEmojiClick">${f(e.currentFavorites,!1,"fav")}</div><button data-ref="baselineEmoji" aria-hidden="true" tabindex="-1" class="abs-pos hidden emoji baseline-emoji"></button></section>`;
                        if (o) {
                            t.appendChild(p);
                            const e = (e, i) => {
                                for (const s of t.querySelectorAll(`[${e}]`)) i(s, s.getAttribute(e))
                            };
                            for (const t of ["click", "focusout", "input", "keydown", "keyup"]) e(`data-on-${t}`, ((e, i) => {
                                e.addEventListener(t, s[i])
                            }));
                            e("data-ref", ((t, e) => {
                                n[e] = t
                            })), e("data-action", ((t, e) => {
                                r[e](t)
                            })), a.addEventListener("abort", (() => {
                                t.removeChild(p)
                            }))
                        }
                    })(t, n, g, m, y, i, r, v), v = !1
                })), n.emojiVersion || st().then((t => {
                    t || (n.message = n.i18n.emojiUnsupportedMessage)
                })), a((() => {
                    n.database && async function() {
                        let t = !1;
                        const e = setTimeout((() => {
                            t = !0, n.message = n.i18n.loadingMessage
                        }), 1e3);
                        try {
                            await n.database.ready(), n.databaseLoaded = !0
                        } catch (t) {
                            console.error(t), n.message = n.i18n.networkErrorMessage
                        } finally {
                            clearTimeout(e), t && (t = !1, n.message = "")
                        }
                    }()
                })), a((() => {
                    n.pickerStyle = `\n      --num-groups: ${n.groups.length}; \n      --indicator-opacity: ${n.searchMode?0:1}; \n      --num-skintones: 6;`
                })), a((() => {
                    n.customEmoji && n.database && b()
                })), a((() => {
                    n.customEmoji && n.customEmoji.length ? n.groups !== z && (n.groups = z) : n.groups !== q && (n.currentGroupIndex && n.currentGroupIndex--, n.groups = q)
                })), a((() => {
                    !async function() {
                        n.databaseLoaded && (n.currentSkinTone = await n.database.getPreferredSkinTone())
                    }()
                })), a((() => {
                    n.skinTones = Array(6).fill().map(((t, e) => function(t, e) {
                        if (0 === e) return t;
                        const i = t.indexOf("");
                        return -1 !== i ? t.substring(0, i) + String.fromCodePoint(127995 + e - 1) + t.substring(i) : (t.endsWith("") && (t = t.substring(0, t.length - 1)), t + "\ud83c" + String.fromCodePoint(57339 + e - 1))
                    }(n.skinToneEmoji, e)))
                })), a((() => {
                    n.skinToneButtonText = n.skinTones[n.currentSkinTone]
                })), a((() => {
                    n.skinToneButtonLabel = n.i18n.skinToneLabel.replace("{skinTone}", n.i18n.skinTones[n.currentSkinTone])
                })), a((() => {
                    n.databaseLoaded && async function() {
                        const {
                            database: t
                        } = n, e = (await Promise.all(Q.map((e => t.getEmojiByUnicodeOrName(e))))).filter(Boolean);
                        n.defaultFavoriteEmojis = e
                    }()
                })), a((() => {
                    n.databaseLoaded && n.defaultFavoriteEmojis && async function() {
                        b();
                        const {
                            database: t,
                            defaultFavoriteEmojis: e,
                            numColumns: i
                        } = n, s = await t.getTopFavoriteEmoji(i), r = await S(ot([...s, ...e], (t => t.unicode || t.name)).slice(0, i));
                        n.currentFavorites = r
                    }()
                })), a((() => {
                    !async function() {
                        const {
                            searchText: t,
                            currentGroup: e,
                            databaseLoaded: i,
                            customEmoji: s
                        } = n;
                        if (i)
                            if (t.length >= 2) {
                                const e = await async function(t) {
                                    return S(await E(await n.database.getEmojiBySearchQuery(t)))
                                }(t);
                                n.searchText === t && (h(e), f(!0))
                            } else {
                                const {
                                    id: t
                                } = e;
                                if (-1 !== t || s && s.length) {
                                    const e = await async function(t) {
                                        const e = -1 === t ? n.customEmoji : await n.database.getEmojiByGroup(t);
                                        return S(await E(e))
                                    }(t);
                                    n.currentGroup.id === t && (h(e), f(!1))
                                }
                            }
                        else n.currentEmojis = [], n.searchMode = !1
                    }()
                })), a((() => {
                    const {
                        currentEmojis: t,
                        emojiVersion: e
                    } = n, s = t.filter((t => t.unicode)).filter((t => Y(t) && !rt.has(t.unicode)));
                    if (!e && s.length) h(t), lt((() => function(t) {
                        (function(t, e, i) {
                            for (const s of t) {
                                const t = dt(i(s));
                                void 0 === ct && (ct = dt(e));
                                const r = t / 1.8 < ct;
                                rt.set(s.unicode, r)
                            }
                        })(t, i.baselineEmoji, l), n.currentEmojis = n.currentEmojis
                    }(s)));
                    else {
                        const s = e ? t : t.filter(T);
                        h(s), lt((() => {
                            var t;
                            (t = i.tabpanelElement) && (t.scrollTop = 0)
                        }))
                    }
                })), a((() => {})), a((() => {
                    var t;
                    t = function() {
                        const {
                            searchMode: t,
                            currentEmojis: e
                        } = n;
                        if (t) return [{
                            category: "",
                            emojis: e
                        }];
                        const i = new Map;
                        for (const t of e) {
                            const e = t.category || "";
                            let s = i.get(e);
                            s || (s = [], i.set(e, s)), s.push(t)
                        }
                        return [...i.entries()].map((([t, e]) => ({
                            category: t,
                            emojis: e
                        }))).sort(((t, e) => n.customCategorySorting(t.category, e.category)))
                    }(), St(n.currentEmojisWithCategories, t, d) || (n.currentEmojisWithCategories = t)
                })), a((() => {
                    n.activeSearchItemId = -1 !== n.activeSearchItem && n.currentEmojis[n.activeSearchItem].id
                })), a((() => {
                    const {
                        rawSearchText: t
                    } = n;
                    W((() => {
                        n.searchText = (t || "").trim(), n.activeSearchItem = -1
                    }))
                })), a((() => {
                    n.skinTonePickerExpanded ? i.skinToneDropdown.addEventListener("transitionend", (() => {
                        n.skinTonePickerExpandedAfterAnimation = !0
                    }), {
                        once: !0
                    }) : n.skinTonePickerExpandedAfterAnimation = !1
                })), {
                    $set(t) {
                        kt(n, t)
                    },
                    $destroy() {
                        s.abort()
                    }
                }
            }
            var _t = {
                categoriesLabel: "Categories",
                emojiUnsupportedMessage: "Your browser does not support color emoji.",
                favoritesLabel: "Favorites",
                loadingMessage: "Loading",
                networkErrorMessage: "Could not load emoji.",
                regionLabel: "Emoji picker",
                searchDescription: "When search results are available, press up or down to select and enter to choose.",
                searchLabel: "Search",
                searchResultsLabel: "Search results",
                skinToneDescription: "When expanded, press up or down to select and enter to choose.",
                skinToneLabel: "Choose a skin tone (currently {skinTone})",
                skinTonesLabel: "Skin tones",
                skinTones: ["Default", "Light", "Medium-Light", "Medium", "Medium-Dark", "Dark"],
                categories: {
                    custom: "Custom",
                    "smileys-emotion": "Smileys and emoticons",
                    "people-body": "People and body",
                    "animals-nature": "Animals and nature",
                    "food-drink": "Food and drink",
                    "travel-places": "Travel and places",
                    activities: "Activities",
                    objects: "Objects",
                    symbols: "Symbols",
                    flags: "Flags"
                }
            };
            const Lt = ["customEmoji", "customCategorySorting", "database", "dataSource", "i18n", "locale", "skinToneEmoji", "emojiVersion"],
                Rt = `:host{--emoji-font-family:${J}}`;
            class It extends HTMLElement {
                constructor(t) {
                    super(), this.attachShadow({
                        mode: "open"
                    });
                    const e = document.createElement("style");
                    e.textContent = ":host{--emoji-size:1.375rem;--emoji-padding:0.5rem;--category-emoji-size:var(--emoji-size);--category-emoji-padding:var(--emoji-padding);--indicator-height:3px;--input-border-radius:0.5rem;--input-border-size:1px;--input-font-size:1rem;--input-line-height:1.5;--input-padding:0.25rem;--num-columns:8;--outline-size:2px;--border-size:1px;--skintone-border-radius:1rem;--category-font-size:1rem;display:flex;width:min-content;height:400px}:host,:host(.light){color-scheme:light;--background:#fff;--border-color:#e0e0e0;--indicator-color:#385ac1;--input-border-color:#999;--input-font-color:#111;--input-placeholder-color:#999;--outline-color:#999;--category-font-color:#111;--button-active-background:#e6e6e6;--button-hover-background:#d9d9d9}:host(.dark){color-scheme:dark;--background:#222;--border-color:#444;--indicator-color:#5373ec;--input-border-color:#ccc;--input-font-color:#efefef;--input-placeholder-color:#ccc;--outline-color:#fff;--category-font-color:#efefef;--button-active-background:#555555;--button-hover-background:#484848}@media (prefers-color-scheme:dark){:host{color-scheme:dark;--background:#222;--border-color:#444;--indicator-color:#5373ec;--input-border-color:#ccc;--input-font-color:#efefef;--input-placeholder-color:#ccc;--outline-color:#fff;--category-font-color:#efefef;--button-active-background:#555555;--button-hover-background:#484848}}:host([hidden]){display:none}button{margin:0;padding:0;border:0;background:0 0;box-shadow:none;-webkit-tap-highlight-color:transparent}button::-moz-focus-inner{border:0}input{padding:0;margin:0;line-height:1.15;font-family:inherit}input[type=search]{-webkit-appearance:none}:focus{outline:var(--outline-color) solid var(--outline-size);outline-offset:calc(-1*var(--outline-size))}:host([data-js-focus-visible]) :focus:not([data-focus-visible-added]){outline:0}:focus:not(:focus-visible){outline:0}.hide-focus{outline:0}*{box-sizing:border-box}.picker{contain:content;display:flex;flex-direction:column;background:var(--background);border:var(--border-size) solid var(--border-color);width:100%;height:100%;overflow:hidden;--total-emoji-size:calc(var(--emoji-size) + (2 * var(--emoji-padding)));--total-category-emoji-size:calc(var(--category-emoji-size) + (2 * var(--category-emoji-padding)))}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.hidden{opacity:0;pointer-events:none}.abs-pos{position:absolute;left:0;top:0}.gone{display:none!important}.skintone-button-wrapper,.skintone-list{background:var(--background);z-index:3}.skintone-button-wrapper.expanded{z-index:1}.skintone-list{position:absolute;inset-inline-end:0;top:0;z-index:2;overflow:visible;border-bottom:var(--border-size) solid var(--border-color);border-radius:0 0 var(--skintone-border-radius) var(--skintone-border-radius);will-change:transform;transition:transform .2s ease-in-out;transform-origin:center 0}@media (prefers-reduced-motion:reduce){.skintone-list{transition-duration:.001s}}@supports not (inset-inline-end:0){.skintone-list{right:0}}.skintone-list.no-animate{transition:none}.tabpanel{overflow-y:auto;-webkit-overflow-scrolling:touch;will-change:transform;min-height:0;flex:1;contain:content}.emoji-menu{display:grid;grid-template-columns:repeat(var(--num-columns),var(--total-emoji-size));justify-content:space-around;align-items:flex-start;width:100%}.category{padding:var(--emoji-padding);font-size:var(--category-font-size);color:var(--category-font-color)}.custom-emoji,.emoji,button.emoji{height:var(--total-emoji-size);width:var(--total-emoji-size)}.emoji,button.emoji{font-size:var(--emoji-size);display:flex;align-items:center;justify-content:center;border-radius:100%;line-height:1;overflow:hidden;font-family:var(--emoji-font-family);cursor:pointer}@media (hover:hover) and (pointer:fine){.emoji:hover,button.emoji:hover{background:var(--button-hover-background)}}.emoji.active,.emoji:active,button.emoji.active,button.emoji:active{background:var(--button-active-background)}.custom-emoji{padding:var(--emoji-padding);object-fit:contain;pointer-events:none;background-repeat:no-repeat;background-position:center center;background-size:var(--emoji-size) var(--emoji-size)}.nav,.nav-button{align-items:center}.nav{display:grid;justify-content:space-between;contain:content}.nav-button{display:flex;justify-content:center}.nav-emoji{font-size:var(--category-emoji-size);width:var(--total-category-emoji-size);height:var(--total-category-emoji-size)}.indicator-wrapper{display:flex;border-bottom:1px solid var(--border-color)}.indicator{width:calc(100%/var(--num-groups));height:var(--indicator-height);opacity:var(--indicator-opacity);background-color:var(--indicator-color);will-change:transform,opacity;transition:opacity .1s linear,transform .25s ease-in-out}@media (prefers-reduced-motion:reduce){.indicator{will-change:opacity;transition:opacity .1s linear}}.pad-top,input.search{background:var(--background);width:100%}.pad-top{height:var(--emoji-padding);z-index:3}.search-row{display:flex;align-items:center;position:relative;padding-inline-start:var(--emoji-padding);padding-bottom:var(--emoji-padding)}.search-wrapper{flex:1;min-width:0}input.search{padding:var(--input-padding);border-radius:var(--input-border-radius);border:var(--input-border-size) solid var(--input-border-color);color:var(--input-font-color);font-size:var(--input-font-size);line-height:var(--input-line-height)}input.search::placeholder{color:var(--input-placeholder-color)}.favorites{display:flex;flex-direction:row;border-top:var(--border-size) solid var(--border-color);contain:content}.message{padding:var(--emoji-padding)}" + Rt, this.shadowRoot.appendChild(e), this._ctx = {
                        locale: "en",
                        dataSource: "https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json",
                        skinToneEmoji: "",
                        customCategorySorting: Z,
                        customEmoji: null,
                        i18n: _t,
                        emojiVersion: null,
                        ...t
                    };
                    for (const t of Lt) "database" !== t && Object.prototype.hasOwnProperty.call(this, t) && (this._ctx[t] = this[t], delete this[t]);
                    this._dbFlush()
                }
                connectedCallback() {
                    this._cmp || (this._cmp = At(this.shadowRoot, this._ctx))
                }
                disconnectedCallback() {
                    Et((() => {
                        if (!this.isConnected && this._cmp) {
                            this._cmp.$destroy(), this._cmp = void 0;
                            const {
                                database: t
                            } = this._ctx;
                            t.close().catch((t => console.error(t)))
                        }
                    }))
                }
                static get observedAttributes() {
                    return ["locale", "data-source", "skin-tone-emoji", "emoji-version"]
                }
                attributeChangedCallback(t, e, i) {
                    this._set(t.replace(/-([a-z])/g, ((t, e) => e.toUpperCase())), "emoji-version" === t ? parseFloat(i) : i)
                }
                _set(t, e) {
                    this._ctx[t] = e, this._cmp && this._cmp.$set({
                        [t]: e
                    }), ["locale", "dataSource"].includes(t) && this._dbFlush()
                }
                _dbCreate() {
                    const {
                        locale: t,
                        dataSource: e,
                        database: i
                    } = this._ctx;
                    i && i.locale === t && i.dataSource === e || this._set("database", new K({
                        locale: t,
                        dataSource: e
                    }))
                }
                _dbFlush() {
                    Et((() => this._dbCreate()))
                }
            }
            const Ct = {};
            for (const t of Lt) Ct[t] = {
                get() {
                    return "database" === t && this._dbCreate(), this._ctx[t]
                },
                set(e) {
                    if ("database" === t) throw new Error("database is read-only");
                    this._set(t, e)
                }
            };
            Object.defineProperties(It.prototype, Ct), customElements.get("emoji-picker") || customElements.define("emoji-picker", It)
        },
        3859: (t, e, i) => {
            "use strict";

            function s(t) {
                let e = "";
                for (let i in t) t.hasOwnProperty(i) && (e.length && (e += "&"), e += encodeURIComponent(i) + "=" + encodeURIComponent(t[i]));
                return e
            }

            function r(t) {
                let e = {},
                    i = t.split("&");
                for (let t = 0, s = i.length; t < s; t++) {
                    let s = i[t].split("=");
                    e[decodeURIComponent(s[0])] = decodeURIComponent(s[1])
                }
                return e
            }
            i.d(e, {
                J: () => r,
                c: () => s
            })
        },
        1928: (t, e, i) => {
            "use strict";
            i.d(e, {
                Q: () => n
            });
            const s = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
                r = 179 != i.j ? ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"] : null;

            function n(t) {
                if (t.length > 2e3) throw "URI too long";
                const e = t,
                    i = t.indexOf("["),
                    n = t.indexOf("]"); - 1 != i && -1 != n && (t = t.substring(0, i) + t.substring(i, n).replace(/:/g, ";") + t.substring(n, t.length));
                let a = s.exec(t || ""),
                    o = {},
                    l = 14;
                for (; l--;) o[r[l]] = a[l] || "";
                return -1 != i && -1 != n && (o.source = e, o.host = o.host.substring(1, o.host.length - 1).replace(/;/g, ":"), o.authority = o.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), o.ipv6uri = !0), o.pathNames = function(t, e) {
                    const i = e.replace(/\/{2,9}/g, "/").split("/");
                    return "/" != e.slice(0, 1) && 0 !== e.length || i.splice(0, 1), "/" == e.slice(-1) && i.splice(i.length - 1, 1), i
                }(0, o.path), o.queryKey = function(t, e) {
                    const i = {};
                    return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, (function(t, e, s) {
                        e && (i[e] = s)
                    })), i
                }(0, o.query), o
            }
        },
        3041: (t, e, i) => {
            "use strict";
            i.d(e, {
                ZP: () => io
            });
            const s = Number.isFinite || function(t) {
                    return "number" == typeof t && isFinite(t)
                },
                r = Number.isSafeInteger || function(t) {
                    return "number" == typeof t && Math.abs(t) <= n
                },
                n = Number.MAX_SAFE_INTEGER || 9007199254740991;
            let a = function(t) {
                    return t.NETWORK_ERROR = "networkError", t.MEDIA_ERROR = "mediaError", t.KEY_SYSTEM_ERROR = "keySystemError", t.MUX_ERROR = "muxError", t.OTHER_ERROR = "otherError", t
                }({}),
                o = function(t) {
                    return t.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", t.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", t.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", t.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", t.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", t.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", t.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", t.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", t.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", t.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", t.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR = "keySystemDestroyMediaKeysError", t.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR = "keySystemDestroyCloseSessionError", t.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR = "keySystemDestroyRemoveSessionError", t.MANIFEST_LOAD_ERROR = "manifestLoadError", t.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", t.MANIFEST_PARSING_ERROR = "manifestParsingError", t.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", t.LEVEL_EMPTY_ERROR = "levelEmptyError", t.LEVEL_LOAD_ERROR = "levelLoadError", t.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", t.LEVEL_PARSING_ERROR = "levelParsingError", t.LEVEL_SWITCH_ERROR = "levelSwitchError", t.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", t.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", t.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", t.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", t.FRAG_LOAD_ERROR = "fragLoadError", t.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", t.FRAG_DECRYPT_ERROR = "fragDecryptError", t.FRAG_PARSING_ERROR = "fragParsingError", t.FRAG_GAP = "fragGap", t.REMUX_ALLOC_ERROR = "remuxAllocError", t.KEY_LOAD_ERROR = "keyLoadError", t.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", t.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", t.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", t.BUFFER_APPEND_ERROR = "bufferAppendError", t.BUFFER_APPENDING_ERROR = "bufferAppendingError", t.BUFFER_STALLED_ERROR = "bufferStalledError", t.BUFFER_FULL_ERROR = "bufferFullError", t.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", t.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", t.ASSET_LIST_LOAD_ERROR = "assetListLoadError", t.ASSET_LIST_LOAD_TIMEOUT = "assetListLoadTimeout", t.ASSET_LIST_PARSING_ERROR = "assetListParsingError", t.INTERSTITIAL_ASSET_ITEM_ERROR = "interstitialAssetItemError", t.INTERNAL_EXCEPTION = "internalException", t.INTERNAL_ABORTED = "aborted", t.ATTACH_MEDIA_ERROR = "attachMediaError", t.UNKNOWN = "unknown", t
                }({}),
                l = function(t) {
                    return t.MEDIA_ATTACHING = "hlsMediaAttaching", t.MEDIA_ATTACHED = "hlsMediaAttached", t.MEDIA_DETACHING = "hlsMediaDetaching", t.MEDIA_DETACHED = "hlsMediaDetached", t.MEDIA_ENDED = "hlsMediaEnded", t.STALL_RESOLVED = "hlsStallResolved", t.BUFFER_RESET = "hlsBufferReset", t.BUFFER_CODECS = "hlsBufferCodecs", t.BUFFER_CREATED = "hlsBufferCreated", t.BUFFER_APPENDING = "hlsBufferAppending", t.BUFFER_APPENDED = "hlsBufferAppended", t.BUFFER_EOS = "hlsBufferEos", t.BUFFERED_TO_END = "hlsBufferedToEnd", t.BUFFER_FLUSHING = "hlsBufferFlushing", t.BUFFER_FLUSHED = "hlsBufferFlushed", t.MANIFEST_LOADING = "hlsManifestLoading", t.MANIFEST_LOADED = "hlsManifestLoaded", t.MANIFEST_PARSED = "hlsManifestParsed", t.LEVEL_SWITCHING = "hlsLevelSwitching", t.LEVEL_SWITCHED = "hlsLevelSwitched", t.LEVEL_LOADING = "hlsLevelLoading", t.LEVEL_LOADED = "hlsLevelLoaded", t.LEVEL_UPDATED = "hlsLevelUpdated", t.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", t.LEVELS_UPDATED = "hlsLevelsUpdated", t.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", t.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", t.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", t.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", t.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", t.AUDIO_TRACK_UPDATED = "hlsAudioTrackUpdated", t.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", t.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", t.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", t.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", t.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", t.SUBTITLE_TRACK_UPDATED = "hlsSubtitleTrackUpdated", t.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", t.CUES_PARSED = "hlsCuesParsed", t.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", t.INIT_PTS_FOUND = "hlsInitPtsFound", t.FRAG_LOADING = "hlsFragLoading", t.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", t.FRAG_LOADED = "hlsFragLoaded", t.FRAG_DECRYPTED = "hlsFragDecrypted", t.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", t.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", t.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", t.FRAG_PARSED = "hlsFragParsed", t.FRAG_BUFFERED = "hlsFragBuffered", t.FRAG_CHANGED = "hlsFragChanged", t.FPS_DROP = "hlsFpsDrop", t.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", t.MAX_AUTO_LEVEL_UPDATED = "hlsMaxAutoLevelUpdated", t.ERROR = "hlsError", t.DESTROYING = "hlsDestroying", t.KEY_LOADING = "hlsKeyLoading", t.KEY_LOADED = "hlsKeyLoaded", t.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", t.BACK_BUFFER_REACHED = "hlsBackBufferReached", t.STEERING_MANIFEST_LOADED = "hlsSteeringManifestLoaded", t.ASSET_LIST_LOADING = "hlsAssetListLoading", t.ASSET_LIST_LOADED = "hlsAssetListLoaded", t.INTERSTITIALS_UPDATED = "hlsInterstitialsUpdated", t.INTERSTITIALS_BUFFERED_TO_BOUNDARY = "hlsInterstitialsBufferedToBoundary", t.INTERSTITIAL_ASSET_PLAYER_CREATED = "hlsInterstitialAssetPlayerCreated", t.INTERSTITIAL_STARTED = "hlsInterstitialStarted", t.INTERSTITIAL_ASSET_STARTED = "hlsInterstitialAssetStarted", t.INTERSTITIAL_ASSET_ENDED = "hlsInterstitialAssetEnded", t.INTERSTITIAL_ASSET_ERROR = "hlsInterstitialAssetError", t.INTERSTITIAL_ENDED = "hlsInterstitialEnded", t.INTERSTITIALS_PRIMARY_RESUMED = "hlsInterstitialsPrimaryResumed", t.PLAYOUT_LIMIT_REACHED = "hlsPlayoutLimitReached", t.EVENT_CUE_ENTER = "hlsEventCueEnter", t
                }({});
            var c = "manifest",
                u = "level",
                d = "audioTrack",
                h = "subtitleTrack",
                f = "main",
                p = "audio",
                g = "subtitle";
            class m {
                constructor(t, e = 0, i = 0) {
                    this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = t, this.alpha_ = t ? Math.exp(Math.log(.5) / t) : 0, this.estimate_ = e, this.totalWeight_ = i
                }
                sample(t, e) {
                    const i = Math.pow(this.alpha_, t);
                    this.estimate_ = e * (1 - i) + i * this.estimate_, this.totalWeight_ += t
                }
                getTotalWeight() {
                    return this.totalWeight_
                }
                getEstimate() {
                    if (this.alpha_) {
                        const t = 1 - Math.pow(this.alpha_, this.totalWeight_);
                        if (t) return this.estimate_ / t
                    }
                    return this.estimate_
                }
            }
            class y {
                constructor(t, e, i, s = 100) {
                    this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = i, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new m(t), this.fast_ = new m(e), this.defaultTTFB_ = s, this.ttfb_ = new m(t)
                }
                update(t, e) {
                    const {
                        slow_: i,
                        fast_: s,
                        ttfb_: r
                    } = this;
                    i.halfLife !== t && (this.slow_ = new m(t, i.getEstimate(), i.getTotalWeight())), s.halfLife !== e && (this.fast_ = new m(e, s.getEstimate(), s.getTotalWeight())), r.halfLife !== t && (this.ttfb_ = new m(t, r.getEstimate(), r.getTotalWeight()))
                }
                sample(t, e) {
                    const i = (t = Math.max(t, this.minDelayMs_)) / 1e3,
                        s = 8 * e / i;
                    this.fast_.sample(i, s), this.slow_.sample(i, s)
                }
                sampleTTFB(t) {
                    const e = t / 1e3,
                        i = Math.sqrt(2) * Math.exp(-Math.pow(e, 2) / 2);
                    this.ttfb_.sample(i, Math.max(t, 5))
                }
                canEstimate() {
                    return this.fast_.getTotalWeight() >= this.minWeight_
                }
                getEstimate() {
                    return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_
                }
                getEstimateTTFB() {
                    return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_
                }
                get defaultEstimate() {
                    return this.defaultEstimate_
                }
                destroy() {}
            }

            function v(t, e, i) {
                return (e = function(t) {
                    var e = function(t, e) {
                        if ("object" != typeof t || !t) return t;
                        var i = t[Symbol.toPrimitive];
                        if (void 0 !== i) {
                            var s = i.call(t, e);
                            if ("object" != typeof s) return s;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return String(t)
                    }(t, "string");
                    return "symbol" == typeof e ? e : e + ""
                }(e)) in t ? Object.defineProperty(t, e, {
                    value: i,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = i, t
            }

            function b() {
                return b = Object.assign ? Object.assign.bind() : function(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var i = arguments[e];
                        for (var s in i)({}).hasOwnProperty.call(i, s) && (t[s] = i[s])
                    }
                    return t
                }, b.apply(null, arguments)
            }

            function T(t, e) {
                var i = Object.keys(t);
                if (Object.getOwnPropertySymbols) {
                    var s = Object.getOwnPropertySymbols(t);
                    e && (s = s.filter((function(e) {
                        return Object.getOwnPropertyDescriptor(t, e).enumerable
                    }))), i.push.apply(i, s)
                }
                return i
            }

            function E(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var i = null != arguments[e] ? arguments[e] : {};
                    e % 2 ? T(Object(i), !0).forEach((function(e) {
                        v(t, e, i[e])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : T(Object(i)).forEach((function(e) {
                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e))
                    }))
                }
                return t
            }
            class S {
                constructor(t, e) {
                    this.trace = void 0, this.debug = void 0, this.log = void 0, this.warn = void 0, this.info = void 0, this.error = void 0;
                    const i = `[${t}]:`;
                    this.trace = w, this.debug = e.debug.bind(null, i), this.log = e.log.bind(null, i), this.warn = e.warn.bind(null, i), this.info = e.info.bind(null, i), this.error = e.error.bind(null, i)
                }
            }
            const w = function() {},
                k = {
                    trace: w,
                    debug: w,
                    log: w,
                    warn: w,
                    info: w,
                    error: w
                };

            function A() {
                return b({}, k)
            }

            function _(t, e, i) {
                return e[t] ? e[t].bind(e) : function(t, e) {
                    const i = self.console[t];
                    return i ? i.bind(self.console, `${e?"["+e+"] ":""}[${t}] >`) : w
                }(t, i)
            }
            const L = A(),
                R = L;

            function I(t = !0) {
                if ("undefined" != typeof self) return (t || !self.MediaSource) && self.ManagedMediaSource || self.MediaSource || self.WebKitMediaSource
            }

            function C(t, e) {
                const i = Object.keys(t),
                    s = Object.keys(e),
                    r = i.length,
                    n = s.length;
                return !r || !n || r === n && !i.some((t => -1 === s.indexOf(t)))
            }

            function D(t, e = !1) {
                if ("undefined" != typeof TextDecoder) {
                    const i = new TextDecoder("utf-8").decode(t);
                    if (e) {
                        const t = i.indexOf("\0");
                        return -1 !== t ? i.substring(0, t) : i
                    }
                    return i.replace(/\0/g, "")
                }
                const i = t.length;
                let s, r, n, a = "",
                    o = 0;
                for (; o < i;) {
                    if (s = t[o++], 0 === s && e) return a;
                    if (0 !== s && 3 !== s) switch (s >> 4) {
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            a += String.fromCharCode(s);
                            break;
                        case 12:
                        case 13:
                            r = t[o++], a += String.fromCharCode((31 & s) << 6 | 63 & r);
                            break;
                        case 14:
                            r = t[o++], n = t[o++], a += String.fromCharCode((15 & s) << 12 | (63 & r) << 6 | (63 & n) << 0)
                    }
                }
                return a
            }
            const x = function(t) {
                let e = "";
                for (let i = 0; i < t.length; i++) {
                    let s = t[i].toString(16);
                    s.length < 2 && (s = "0" + s), e += s
                }
                return e
            };

            function P(t) {
                return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
            }
            var O, M, N, F, $, U, B = {
                    exports: {}
                },
                j = (O || (O = 1, M = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, N = /^(?=([^\/?#]*))\1([^]*)$/, F = /(?:\/|^)\.(?=\/)/g, $ = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, B.exports = U = {
                    buildAbsoluteURL: function(t, e, i) {
                        if (i = i || {}, t = t.trim(), !(e = e.trim())) {
                            if (!i.alwaysNormalize) return t;
                            var s = U.parseURL(t);
                            if (!s) throw new Error("Error trying to parse base URL.");
                            return s.path = U.normalizePath(s.path), U.buildURLFromParts(s)
                        }
                        var r = U.parseURL(e);
                        if (!r) throw new Error("Error trying to parse relative URL.");
                        if (r.scheme) return i.alwaysNormalize ? (r.path = U.normalizePath(r.path), U.buildURLFromParts(r)) : e;
                        var n = U.parseURL(t);
                        if (!n) throw new Error("Error trying to parse base URL.");
                        if (!n.netLoc && n.path && "/" !== n.path[0]) {
                            var a = N.exec(n.path);
                            n.netLoc = a[1], n.path = a[2]
                        }
                        n.netLoc && !n.path && (n.path = "/");
                        var o = {
                            scheme: n.scheme,
                            netLoc: r.netLoc,
                            path: null,
                            params: r.params,
                            query: r.query,
                            fragment: r.fragment
                        };
                        if (!r.netLoc && (o.netLoc = n.netLoc, "/" !== r.path[0]))
                            if (r.path) {
                                var l = n.path,
                                    c = l.substring(0, l.lastIndexOf("/") + 1) + r.path;
                                o.path = U.normalizePath(c)
                            } else o.path = n.path, r.params || (o.params = n.params, r.query || (o.query = n.query));
                        return null === o.path && (o.path = i.alwaysNormalize ? U.normalizePath(r.path) : r.path), U.buildURLFromParts(o)
                    },
                    parseURL: function(t) {
                        var e = M.exec(t);
                        return e ? {
                            scheme: e[1] || "",
                            netLoc: e[2] || "",
                            path: e[3] || "",
                            params: e[4] || "",
                            query: e[5] || "",
                            fragment: e[6] || ""
                        } : null
                    },
                    normalizePath: function(t) {
                        for (t = t.split("").reverse().join("").replace(F, ""); t.length !== (t = t.replace($, "")).length;);
                        return t.split("").reverse().join("")
                    },
                    buildURLFromParts: function(t) {
                        return t.scheme + t.netLoc + t.path + t.params + t.query + t.fragment
                    }
                }), B.exports);
            class G {
                constructor() {
                    this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {
                        start: 0,
                        first: 0,
                        end: 0
                    }, this.parsing = {
                        start: 0,
                        end: 0
                    }, this.buffering = {
                        start: 0,
                        first: 0,
                        end: 0
                    }
                }
            }
            var V = "audio",
                H = "video",
                K = "audiovideo";
            class z {
                constructor(t) {
                    this._byteRange = null, this._url = null, this._stats = null, this._streams = null, this.base = void 0, this.relurl = void 0, "string" == typeof t && (t = {
                            url: t
                        }), this.base = t,
                        function(t, e) {
                            const i = X(t, e);
                            i && (i.enumerable = !0, Object.defineProperty(t, e, i))
                        }(this, "stats")
                }
                setByteRange(t, e) {
                    const i = t.split("@", 2);
                    let s;
                    s = 1 === i.length ? (null == e ? void 0 : e.byteRangeEndOffset) || 0 : parseInt(i[1]), this._byteRange = [s, parseInt(i[0]) + s]
                }
                get baseurl() {
                    return this.base.url
                }
                get byteRange() {
                    return null === this._byteRange ? [] : this._byteRange
                }
                get byteRangeStartOffset() {
                    return this.byteRange[0]
                }
                get byteRangeEndOffset() {
                    return this.byteRange[1]
                }
                get elementaryStreams() {
                    return null === this._streams && (this._streams = {
                        [V]: null,
                        [H]: null,
                        [K]: null
                    }), this._streams
                }
                set elementaryStreams(t) {
                    this._streams = t
                }
                get hasStats() {
                    return null !== this._stats
                }
                get hasStreams() {
                    return null !== this._streams
                }
                get stats() {
                    return null === this._stats && (this._stats = new G), this._stats
                }
                set stats(t) {
                    this._stats = t
                }
                get url() {
                    return !this._url && this.baseurl && this.relurl && (this._url = j.buildAbsoluteURL(this.baseurl, this.relurl, {
                        alwaysNormalize: !0
                    })), this._url || ""
                }
                set url(t) {
                    this._url = t
                }
                clearElementaryStreamInfo() {
                    const {
                        elementaryStreams: t
                    } = this;
                    t[V] = null, t[H] = null, t[K] = null
                }
            }

            function q(t) {
                return "initSegment" !== t.sn
            }
            class W extends z {
                constructor(t, e) {
                    super(e), this._decryptdata = null, this._programDateTime = null, this._ref = null, this._bitrate = void 0, this.rawProgramDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.playlistOffset = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.urlId = 0, this.type = t
                }
                get byteLength() {
                    if (this.hasStats) {
                        const t = this.stats.total;
                        if (t) return t
                    }
                    if (this.byteRange) {
                        const t = this.byteRange[0],
                            e = this.byteRange[1];
                        if (s(t) && s(e)) return e - t
                    }
                    return null
                }
                get bitrate() {
                    return this.byteLength ? 8 * this.byteLength / this.duration : this._bitrate ? this._bitrate : null
                }
                set bitrate(t) {
                    this._bitrate = t
                }
                get decryptdata() {
                    const {
                        levelkeys: t
                    } = this;
                    if (!t && !this._decryptdata) return null;
                    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
                        const t = this.levelkeys.identity;
                        if (t) this._decryptdata = t.getDecryptData(this.sn);
                        else {
                            const t = Object.keys(this.levelkeys);
                            if (1 === t.length) return this._decryptdata = this.levelkeys[t[0]].getDecryptData(this.sn)
                        }
                    }
                    return this._decryptdata
                }
                get end() {
                    return this.start + this.duration
                }
                get endProgramDateTime() {
                    if (null === this.programDateTime) return null;
                    const t = s(this.duration) ? this.duration : 0;
                    return this.programDateTime + 1e3 * t
                }
                get encrypted() {
                    var t;
                    if (null != (t = this._decryptdata) && t.encrypted) return !0;
                    if (this.levelkeys) {
                        const t = Object.keys(this.levelkeys),
                            e = t.length;
                        if (e > 1 || 1 === e && this.levelkeys[t[0]].encrypted) return !0
                    }
                    return !1
                }
                get programDateTime() {
                    return null === this._programDateTime && this.rawProgramDateTime && (this.programDateTime = Date.parse(this.rawProgramDateTime)), this._programDateTime
                }
                set programDateTime(t) {
                    s(t) ? this._programDateTime = t : this._programDateTime = this.rawProgramDateTime = null
                }
                get ref() {
                    return q(this) ? (this._ref || (this._ref = {
                        base: this.base,
                        start: this.start,
                        duration: this.duration,
                        sn: this.sn,
                        programDateTime: this.programDateTime
                    }), this._ref) : null
                }
                addStart(t) {
                    this.setStart(this.start + t)
                }
                setStart(t) {
                    this.start = t, this._ref && (this._ref.start = t)
                }
                setDuration(t) {
                    this.duration = t, this._ref && (this._ref.duration = t)
                }
                setKeyFormat(t) {
                    if (this.levelkeys) {
                        const e = this.levelkeys[t];
                        e && !this._decryptdata && (this._decryptdata = e.getDecryptData(this.sn))
                    }
                }
                abortRequests() {
                    var t, e;
                    null == (t = this.loader) || t.abort(), null == (e = this.keyLoader) || e.abort()
                }
                setElementaryStreamInfo(t, e, i, s, r, n = !1) {
                    const {
                        elementaryStreams: a
                    } = this, o = a[t];
                    o ? (o.startPTS = Math.min(o.startPTS, e), o.endPTS = Math.max(o.endPTS, i), o.startDTS = Math.min(o.startDTS, s), o.endDTS = Math.max(o.endDTS, r)) : a[t] = {
                        startPTS: e,
                        endPTS: i,
                        startDTS: s,
                        endDTS: r,
                        partial: n
                    }
                }
            }
            class Y extends z {
                constructor(t, e, i, s, r) {
                    super(i), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.duration = t.decimalFloatingPoint("DURATION"), this.gap = t.bool("GAP"), this.independent = t.bool("INDEPENDENT"), this.relurl = t.enumeratedString("URI"), this.fragment = e, this.index = s;
                    const n = t.enumeratedString("BYTERANGE");
                    n && this.setByteRange(n, r), r && (this.fragOffset = r.fragOffset + r.duration)
                }
                get start() {
                    return this.fragment.start + this.fragOffset
                }
                get end() {
                    return this.start + this.duration
                }
                get loaded() {
                    const {
                        elementaryStreams: t
                    } = this;
                    return !!(t.audio || t.video || t.audiovideo)
                }
            }

            function X(t, e) {
                const i = Object.getPrototypeOf(t);
                if (i) {
                    return Object.getOwnPropertyDescriptor(i, e) || X(i, e)
                }
            }
            const Q = Math.pow(2, 32) - 1,
                J = [].push,
                Z = {
                    video: 1,
                    audio: 2,
                    id3: 3,
                    text: 4
                };

            function tt(t) {
                return String.fromCharCode.apply(null, t)
            }

            function et(t, e) {
                const i = t[e] << 8 | t[e + 1];
                return i < 0 ? 65536 + i : i
            }

            function it(t, e) {
                const i = rt(t, e);
                return i < 0 ? 4294967296 + i : i
            }

            function st(t, e) {
                let i = it(t, e);
                return i *= Math.pow(2, 32), i += it(t, e + 4), i
            }

            function rt(t, e) {
                return t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]
            }

            function nt(t, e, i) {
                t[e] = i >> 24, t[e + 1] = i >> 16 & 255, t[e + 2] = i >> 8 & 255, t[e + 3] = 255 & i
            }

            function at(t, e) {
                const i = [];
                if (!e.length) return i;
                const s = t.byteLength;
                for (let r = 0; r < s;) {
                    const n = it(t, r),
                        a = n > 1 ? r + n : s;
                    if (tt(t.subarray(r + 4, r + 8)) === e[0])
                        if (1 === e.length) i.push(t.subarray(r + 8, a));
                        else {
                            const s = at(t.subarray(r + 8, a), e.slice(1));
                            s.length && J.apply(i, s)
                        }
                    r = a
                }
                return i
            }

            function ot(t) {
                const e = [],
                    i = t[0];
                let s = 8;
                const r = it(t, s);
                s += 4;
                let n = 0,
                    a = 0;
                0 === i ? (n = it(t, s), a = it(t, s + 4), s += 8) : (n = st(t, s), a = st(t, s + 8), s += 16), s += 2;
                let o = t.length + a;
                const l = et(t, s);
                s += 2;
                for (let i = 0; i < l; i++) {
                    let i = s;
                    const n = it(t, i);
                    i += 4;
                    const a = 2147483647 & n;
                    if (1 == (2147483648 & n) >>> 31) return R.warn("SIDX has hierarchical references (not supported)"), null;
                    const l = it(t, i);
                    i += 4, e.push({
                        referenceSize: a,
                        subsegmentDuration: l,
                        info: {
                            duration: l / r,
                            start: o,
                            end: o + a - 1
                        }
                    }), o += a, i += 4, s = i
                }
                return {
                    earliestPresentationTime: n,
                    timescale: r,
                    version: i,
                    referencesCount: l,
                    references: e
                }
            }

            function lt(t) {
                const e = [],
                    i = at(t, ["moov", "trak"]);
                for (let t = 0; t < i.length; t++) {
                    const s = i[t],
                        r = at(s, ["tkhd"])[0];
                    if (r) {
                        let t = r[0];
                        const i = it(r, 0 === t ? 12 : 20),
                            n = at(s, ["mdia", "mdhd"])[0];
                        if (n) {
                            t = n[0];
                            const r = it(n, 0 === t ? 12 : 20),
                                a = at(s, ["mdia", "hdlr"])[0];
                            if (a) {
                                const t = tt(a.subarray(8, 12)),
                                    n = {
                                        soun: V,
                                        vide: H
                                    }[t],
                                    o = ct(at(s, ["mdia", "minf", "stbl", "stsd"])[0]);
                                n ? (e[i] = {
                                    timescale: r,
                                    type: n,
                                    stsd: o
                                }, e[n] = E({
                                    timescale: r,
                                    id: i
                                }, o)) : e[i] = {
                                    timescale: r,
                                    type: t,
                                    stsd: o
                                }
                            }
                        }
                    }
                }
                return at(t, ["moov", "mvex", "trex"]).forEach((t => {
                    const i = it(t, 4),
                        s = e[i];
                    s && (s.default = {
                        duration: it(t, 12),
                        flags: it(t, 20)
                    })
                })), e
            }

            function ct(t) {
                const e = t.subarray(8),
                    i = e.subarray(86),
                    s = tt(e.subarray(4, 8));
                let r, n = s;
                const a = "enca" === s || "encv" === s;
                if (a) {
                    const t = at(e, [s])[0];
                    at(t.subarray("enca" === s ? 28 : 78), ["sinf"]).forEach((t => {
                        const e = at(t, ["schm"])[0];
                        if (e) {
                            const i = tt(e.subarray(4, 8));
                            if ("cbcs" === i || "cenc" === i) {
                                const e = at(t, ["frma"])[0];
                                e && (n = tt(e))
                            }
                        }
                    }))
                }
                const o = n;
                switch (n) {
                    case "avc1":
                    case "avc2":
                    case "avc3":
                    case "avc4":
                        {
                            const t = at(i, ["avcC"])[0];t && t.length > 3 && (n += "." + ht(t[1]) + ht(t[2]) + ht(t[3]), r = ut("avc1" === o ? "dva1" : "dvav", i));
                            break
                        }
                    case "mp4a":
                        {
                            const t = at(e, [s])[0],
                                i = at(t.subarray(28), ["esds"])[0];
                            if (i && i.length > 7) {
                                let t = 4;
                                if (3 !== i[t++]) break;
                                t = dt(i, t), t += 2;
                                const e = i[t++];
                                if (128 & e && (t += 2), 64 & e && (t += i[t++]), 4 !== i[t++]) break;
                                t = dt(i, t);
                                const s = i[t++];
                                if (64 !== s) break;
                                if (n += "." + ht(s), t += 12, 5 !== i[t++]) break;
                                t = dt(i, t);
                                const r = i[t++];
                                let a = (248 & r) >> 3;
                                31 === a && (a += 1 + ((7 & r) << 3) + ((224 & i[t]) >> 5)), n += "." + a
                            }
                            break
                        }
                    case "hvc1":
                    case "hev1":
                        {
                            const t = at(i, ["hvcC"])[0];
                            if (t && t.length > 12) {
                                const e = t[1],
                                    i = ["", "A", "B", "C"][e >> 6],
                                    s = 31 & e,
                                    r = it(t, 2),
                                    a = (32 & e) >> 5 ? "H" : "L",
                                    o = t[12],
                                    l = t.subarray(6, 12);
                                n += "." + i + s, n += "." + r.toString(16).toUpperCase(), n += "." + a + o;
                                let c = "";
                                for (let t = l.length; t--;) {
                                    const e = l[t];
                                    (e || c) && (c = "." + e.toString(16).toUpperCase() + c)
                                }
                                n += c
                            }
                            r = ut("hev1" == o ? "dvhe" : "dvh1", i);
                            break
                        }
                    case "dvh1":
                    case "dvhe":
                    case "dvav":
                    case "dva1":
                    case "dav1":
                        n = ut(n, i) || n;
                        break;
                    case "vp09":
                        {
                            const t = at(i, ["vpcC"])[0];
                            if (t && t.length > 6) {
                                const e = t[4],
                                    i = t[5],
                                    s = t[6] >> 4 & 15;
                                n += "." + ft(e) + "." + ft(i) + "." + ft(s)
                            }
                            break
                        }
                    case "av01":
                        {
                            const t = at(i, ["av1C"])[0];
                            if (t && t.length > 2) {
                                const e = t[1] >>> 5,
                                    s = 31 & t[1],
                                    a = t[2] >>> 7 ? "H" : "M",
                                    o = (64 & t[2]) >> 6,
                                    l = (32 & t[2]) >> 5,
                                    c = 2 === e && o ? l ? 12 : 10 : o ? 10 : 8,
                                    u = (16 & t[2]) >> 4,
                                    d = (8 & t[2]) >> 3,
                                    h = (4 & t[2]) >> 2,
                                    f = 3 & t[2],
                                    p = 1,
                                    g = 1,
                                    m = 1,
                                    y = 0;
                                n += "." + e + "." + ft(s) + a + "." + ft(c) + "." + u + "." + d + h + f + "." + ft(p) + "." + ft(g) + "." + ft(m) + "." + y, r = ut("dav1", i)
                            }
                            break
                        }
                }
                return {
                    codec: n,
                    encrypted: a,
                    supplemental: r
                }
            }

            function ut(t, e) {
                const i = at(e, ["dvvC"]),
                    s = i.length ? i[0] : at(e, ["dvcC"])[0];
                if (s) {
                    const e = s[2] >> 1 & 127,
                        i = s[2] << 5 & 32 | s[3] >> 3 & 31;
                    return t + "." + ft(e) + "." + ft(i)
                }
            }

            function dt(t, e) {
                const i = e + 5;
                for (; 128 & t[e++] && e < i;);
                return e
            }

            function ht(t) {
                return ("0" + t.toString(16).toUpperCase()).slice(-2)
            }

            function ft(t) {
                return (t < 10 ? "0" : "") + t
            }

            function pt(t) {
                const e = at(t, ["schm"])[0];
                if (e) {
                    const i = tt(e.subarray(4, 8));
                    if ("cbcs" === i || "cenc" === i) return at(t, ["schi", "tenc"])[0]
                }
                return null
            }

            function gt(t) {
                const e = it(t, 0);
                let i = 8;
                1 & e && (i += 4), 4 & e && (i += 4);
                let s = 0;
                const r = it(t, 4);
                for (let n = 0; n < r; n++) 256 & e && (s += it(t, i), i += 4), 512 & e && (i += 4), 1024 & e && (i += 4), 2048 & e && (i += 4);
                return s
            }

            function mt(t, e) {
                const i = new Uint8Array(t.length + e.length);
                return i.set(t), i.set(e, t.length), i
            }

            function yt(t, e) {
                const i = [],
                    s = e.samples,
                    r = e.timescale,
                    n = e.id;
                let a = !1;
                return at(s, ["moof"]).map((o => {
                    const l = o.byteOffset - 8;
                    at(o, ["traf"]).map((o => {
                        const c = at(o, ["tfdt"]).map((t => {
                            const e = t[0];
                            let i = it(t, 4);
                            return 1 === e && (i *= Math.pow(2, 32), i += it(t, 8)), i / r
                        }))[0];
                        return void 0 !== c && (t = c), at(o, ["tfhd"]).map((c => {
                            const u = it(c, 4),
                                d = 16777215 & it(c, 0);
                            let h = 0;
                            const f = 0 != (16 & d);
                            let p = 0;
                            const g = 0 != (32 & d);
                            let m = 8;
                            u === n && (0 != (1 & d) && (m += 8), 0 != (2 & d) && (m += 4), 0 != (8 & d) && (h = it(c, m), m += 4), f && (p = it(c, m), m += 4), g && (m += 4), "video" === e.type && (a = vt(e.codec)), at(o, ["trun"]).map((n => {
                                const o = n[0],
                                    c = 16777215 & it(n, 0),
                                    u = 0 != (1 & c);
                                let d = 0;
                                const f = 0 != (4 & c),
                                    g = 0 != (256 & c);
                                let m = 0;
                                const y = 0 != (512 & c);
                                let v = 0;
                                const b = 0 != (1024 & c),
                                    T = 0 != (2048 & c);
                                let E = 0;
                                const S = it(n, 4);
                                let w = 8;
                                u && (d = it(n, w), w += 4), f && (w += 4);
                                let k = d + l;
                                for (let l = 0; l < S; l++) {
                                    if (g ? (m = it(n, w), w += 4) : m = h, y ? (v = it(n, w), w += 4) : v = p, b && (w += 4), T && (E = 0 === o ? it(n, w) : rt(n, w), w += 4), e.type === H) {
                                        let e = 0;
                                        for (; e < v;) {
                                            const n = it(s, k);
                                            k += 4, bt(a, s[k]) && Tt(s.subarray(k, k + n), a ? 2 : 1, t + E / r, i), k += n, e += n + 4
                                        }
                                    }
                                    t += m / r
                                }
                            })))
                        }))
                    }))
                })), i
            }

            function vt(t) {
                if (!t) return !1;
                const e = t.substring(0, 4);
                return "hvc1" === e || "hev1" === e || "dvh1" === e || "dvhe" === e
            }

            function bt(t, e) {
                if (t) {
                    const t = e >> 1 & 63;
                    return 39 === t || 40 === t
                }
                return 6 == (31 & e)
            }

            function Tt(t, e, i, s) {
                const r = Et(t);
                let n = 0;
                n += e;
                let a = 0,
                    o = 0,
                    l = 0;
                for (; n < r.length;) {
                    a = 0;
                    do {
                        if (n >= r.length) break;
                        l = r[n++], a += l
                    } while (255 === l);
                    o = 0;
                    do {
                        if (n >= r.length) break;
                        l = r[n++], o += l
                    } while (255 === l);
                    const t = r.length - n;
                    let e = n;
                    if (o < t) n += o;
                    else if (o > t) {
                        R.error(`Malformed SEI payload. ${o} is too small, only ${t} bytes left to parse.`);
                        break
                    }
                    if (4 === a) {
                        if (181 === r[e++]) {
                            const t = et(r, e);
                            if (e += 2, 49 === t) {
                                const t = it(r, e);
                                if (e += 4, 1195456820 === t) {
                                    const t = r[e++];
                                    if (3 === t) {
                                        const n = r[e++],
                                            o = 64 & n,
                                            l = o ? 2 + 3 * (31 & n) : 0,
                                            c = new Uint8Array(l);
                                        if (o) {
                                            c[0] = n;
                                            for (let t = 1; t < l; t++) c[t] = r[e++]
                                        }
                                        s.push({
                                            type: t,
                                            payloadType: a,
                                            pts: i,
                                            bytes: c
                                        })
                                    }
                                }
                            }
                        }
                    } else if (5 === a && o > 16) {
                        const t = [];
                        for (let i = 0; i < 16; i++) {
                            const s = r[e++].toString(16);
                            t.push(1 == s.length ? "0" + s : s), 3 !== i && 5 !== i && 7 !== i && 9 !== i || t.push("-")
                        }
                        const n = o - 16,
                            l = new Uint8Array(n);
                        for (let t = 0; t < n; t++) l[t] = r[e++];
                        s.push({
                            payloadType: a,
                            pts: i,
                            uuid: t.join(""),
                            userData: D(l),
                            userDataBytes: l
                        })
                    }
                }
            }

            function Et(t) {
                const e = t.byteLength,
                    i = [];
                let s = 1;
                for (; s < e - 2;) 0 === t[s] && 0 === t[s + 1] && 3 === t[s + 2] ? (i.push(s + 2), s += 2) : s++;
                if (0 === i.length) return t;
                const r = e - i.length,
                    n = new Uint8Array(r);
                let a = 0;
                for (s = 0; s < r; a++, s++) a === i[0] && (a++, i.shift()), n[s] = t[a];
                return n
            }

            function St(t) {
                const e = t.getUint32(0),
                    i = t.byteOffset,
                    s = t.byteLength;
                if (s < e) return {
                    offset: i,
                    size: s
                };
                if (1886614376 !== t.getUint32(4)) return {
                    offset: i,
                    size: e
                };
                const r = t.getUint32(8) >>> 24;
                if (0 !== r && 1 !== r) return {
                    offset: i,
                    size: e
                };
                const n = t.buffer,
                    a = x(new Uint8Array(n, i + 12, 16)),
                    o = t.getUint32(28);
                let l = null,
                    c = null;
                if (0 === r) {
                    if (e - 32 < o || o < 22) return {
                        offset: i,
                        size: e
                    };
                    c = new Uint8Array(n, i + 32, o)
                } else if (1 === r) {
                    if (!o || s < i + 32 + 16 * o + 16) return {
                        offset: i,
                        size: e
                    };
                    l = [];
                    for (let t = 0; t < o; t++) l.push(new Uint8Array(n, i + 32 + 16 * t, 16))
                }
                return {
                    version: r,
                    systemId: a,
                    kids: l,
                    data: c,
                    offset: i,
                    size: e
                }
            }
            const wt = () => /\(Windows.+Firefox\//i.test(navigator.userAgent),
                kt = {
                    audio: {
                        a3ds: 1,
                        "ac-3": .95,
                        "ac-4": 1,
                        alac: .9,
                        alaw: 1,
                        dra1: 1,
                        "dts+": 1,
                        "dts-": 1,
                        dtsc: 1,
                        dtse: 1,
                        dtsh: 1,
                        "ec-3": .9,
                        enca: 1,
                        fLaC: .9,
                        flac: .9,
                        FLAC: .9,
                        g719: 1,
                        g726: 1,
                        m4ae: 1,
                        mha1: 1,
                        mha2: 1,
                        mhm1: 1,
                        mhm2: 1,
                        mlpa: 1,
                        mp4a: 1,
                        "raw ": 1,
                        Opus: 1,
                        opus: 1,
                        samr: 1,
                        sawb: 1,
                        sawp: 1,
                        sevc: 1,
                        sqcp: 1,
                        ssmv: 1,
                        twos: 1,
                        ulaw: 1
                    },
                    video: {
                        avc1: 1,
                        avc2: 1,
                        avc3: 1,
                        avc4: 1,
                        avcp: 1,
                        av01: .8,
                        dav1: .8,
                        drac: 1,
                        dva1: 1,
                        dvav: 1,
                        dvh1: .7,
                        dvhe: .7,
                        encv: 1,
                        hev1: .75,
                        hvc1: .75,
                        mjp2: 1,
                        mp4v: 1,
                        mvc1: 1,
                        mvc2: 1,
                        mvc3: 1,
                        mvc4: 1,
                        resv: 1,
                        rv60: 1,
                        s263: 1,
                        svc1: 1,
                        svc2: 1,
                        "vc-1": 1,
                        vp08: 1,
                        vp09: .9
                    },
                    text: {
                        stpp: 1,
                        wvtt: 1
                    }
                };

            function At(t, e) {
                const i = kt[e];
                return !!i && !!i[t.slice(0, 4)]
            }

            function _t(t, e, i = !0) {
                return !t.split(",").some((t => !Lt(t, e, i)))
            }

            function Lt(t, e, i = !0) {
                var s;
                const r = I(i);
                return null != (s = null == r ? void 0 : r.isTypeSupported(Rt(t, e))) && s
            }

            function Rt(t, e) {
                return `${e}/mp4;codecs=${t}`
            }

            function It(t) {
                if (t) {
                    const e = t.substring(0, 4);
                    return kt.video[e]
                }
                return 2
            }

            function Ct(t) {
                const e = wt();
                return t.split(",").reduce(((t, i) => {
                    const s = e && vt(i) ? 9 : kt.video[i];
                    return s ? (2 * s + t) / (t ? 3 : 2) : (kt.audio[i] + t) / (t ? 2 : 1)
                }), 0)
            }
            const Dt = {},
                xt = /flac|opus|mp4a\.40\.34/i;

            function Pt(t, e = !0) {
                return t.replace(xt, (t => function(t, e = !0) {
                    if (Dt[t]) return Dt[t];
                    const i = {
                        flac: ["flac", "fLaC", "FLAC"],
                        opus: ["opus", "Opus"],
                        "mp4a.40.34": ["mp3"]
                    }[t];
                    for (let r = 0; r < i.length; r++) {
                        var s;
                        if (Lt(i[r], "audio", e)) return Dt[t] = i[r], i[r];
                        if ("mp3" === i[r] && null != (s = I(e)) && s.isTypeSupported("audio/mpeg")) return ""
                    }
                    return t
                }(t.toLowerCase(), e)))
            }

            function Ot(t, e) {
                if (t && (t.length > 4 || -1 !== ["ac-3", "ec-3", "alac", "fLaC", "Opus"].indexOf(t))) return t;
                if (e) {
                    const i = e.split(",");
                    if (i.length > 1) {
                        if (t)
                            for (let e = i.length; e--;)
                                if (i[e].substring(0, 4) === t.substring(0, 4)) return i[e];
                        return i[0]
                    }
                }
                return e || t
            }

            function Mt(t) {
                if (t.startsWith("av01.")) {
                    const e = t.split("."),
                        i = ["0", "111", "01", "01", "01", "0"];
                    for (let t = e.length; t > 4 && t < 10; t++) e[t] = i[t - 4];
                    return e.join(".")
                }
                return t
            }

            function Nt(t) {
                const e = I(t) || {
                    isTypeSupported: () => !1
                };
                return {
                    mpeg: e.isTypeSupported("audio/mpeg"),
                    mp3: e.isTypeSupported('audio/mp4; codecs="mp3"'),
                    ac3: e.isTypeSupported('audio/mp4; codecs="ac-3"')
                }
            }

            function Ft(t) {
                return t.replace(/^.+codecs=["']?([^"']+).*$/, "$1")
            }
            const $t = {
                supported: !0,
                configurations: [],
                decodingInfoResults: [{
                    supported: !0,
                    powerEfficient: !0,
                    smooth: !0
                }]
            };

            function Ut(t, e) {
                return {
                    supported: !1,
                    configurations: e,
                    decodingInfoResults: [{
                        supported: !1,
                        smooth: !1,
                        powerEfficient: !1
                    }],
                    error: t
                }
            }
            const Bt = {};

            function jt(t, e, i, r, n, a) {
                const o = t.audioCodec ? t.audioGroups : null,
                    l = null == a ? void 0 : a.audioCodec,
                    c = null == a ? void 0 : a.channels,
                    u = c ? parseInt(c) : l ? 1 / 0 : 2;
                let d = null;
                if (null != o && o.length) try {
                    d = 1 === o.length && o[0] ? e.groups[o[0]].channels : o.reduce(((t, i) => {
                        if (i) {
                            const s = e.groups[i];
                            if (!s) throw new Error(`Audio track group ${i} not found`);
                            Object.keys(s.channels).forEach((e => {
                                t[e] = (t[e] || 0) + s.channels[e]
                            }))
                        }
                        return t
                    }), {
                        2: 0
                    })
                } catch (t) {
                    return !0
                }
                return void 0 !== t.videoCodec && (t.width > 1920 && t.height > 1088 || t.height > 1920 && t.width > 1088 || t.frameRate > Math.max(r, 30) || "SDR" !== t.videoRange && t.videoRange !== i || t.bitrate > Math.max(n, 8e6)) || !!d && s(u) && Object.keys(d).some((t => parseInt(t) > u))
            }

            function Gt(t, e, i) {
                const r = t.videoCodec,
                    n = t.audioCodec;
                if (!r && !n || !i) return Promise.resolve($t);
                const a = [];
                if (r) {
                    const e = {
                            width: t.width,
                            height: t.height,
                            bitrate: Math.ceil(Math.max(.9 * t.bitrate, t.averageBitrate)),
                            framerate: t.frameRate || 30
                        },
                        i = t.videoRange;
                    "SDR" !== i && (e.transferFunction = i.toLowerCase());
                    const s = r.split(","),
                        n = navigator.userAgent;
                    if (s.some((t => vt(t))) && wt()) return Promise.resolve(Ut(new Error(`Overriding Windows Firefox HEVC MediaCapabilities result based on user-agent sting: (${n})`), a));
                    a.push.apply(a, s.map((t => ({
                        type: "media-source",
                        video: E(E({}, e), {}, {
                            contentType: Rt(Mt(t), "video")
                        })
                    }))))
                }
                return n && t.audioGroups && t.audioGroups.forEach((t => {
                    var i;
                    t && (null == (i = e.groups[t]) || i.tracks.forEach((e => {
                        if (e.groupId === t) {
                            const t = e.channels || "",
                                i = parseFloat(t);
                            s(i) && i > 2 && a.push.apply(a, n.split(",").map((t => ({
                                type: "media-source",
                                audio: {
                                    contentType: Rt(t, "audio"),
                                    channels: "" + i
                                }
                            }))))
                        }
                    })))
                })), Promise.all(a.map((t => {
                    const e = function(t) {
                        const {
                            audio: e,
                            video: i
                        } = t, s = i || e;
                        if (s) {
                            const t = Ft(s.contentType);
                            if (i) return `r${i.height}x${i.width}f${Math.ceil(i.framerate)}${i.transferFunction||"sd"}_${t}_${Math.ceil(i.bitrate/1e5)}`;
                            if (e) return `c${e.channels}${e.spatialRendering?"s":"n"}_${t}`
                        }
                        return ""
                    }(t);
                    return Bt[e] || (Bt[e] = i.decodingInfo(t))
                }))).then((t => ({
                    supported: !t.some((t => !t.supported)),
                    configurations: a,
                    decodingInfoResults: t
                }))).catch((t => ({
                    supported: !1,
                    configurations: a,
                    decodingInfoResults: [],
                    error: t
                })))
            }
            const Vt = ["NONE", "TYPE-0", "TYPE-1", null],
                Ht = ["SDR", "PQ", "HLG"];

            function Kt(t) {
                const {
                    canSkipUntil: e,
                    canSkipDateRanges: i,
                    age: s
                } = t;
                return e && s < e / 2 ? i ? "v2" : "YES" : ""
            }
            class zt {
                constructor(t, e, i) {
                    this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = t, this.part = e, this.skip = i
                }
                addDirectives(t) {
                    const e = new self.URL(t);
                    return void 0 !== this.msn && e.searchParams.set("_HLS_msn", this.msn.toString()), void 0 !== this.part && e.searchParams.set("_HLS_part", this.part.toString()), this.skip && e.searchParams.set("_HLS_skip", this.skip), e.href
                }
            }
            class qt {
                constructor(t) {
                    if (this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.url = void 0, this.frameRate = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.supplemental = void 0, this.videoCodec = void 0, this.width = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.supportedPromise = void 0, this.supportedResult = void 0, this._avgBitrate = 0, this._audioGroups = void 0, this._subtitleGroups = void 0, this._urlId = 0, this.url = [t.url], this._attrs = [t.attrs], this.bitrate = t.bitrate, t.details && (this.details = t.details), this.id = t.id || 0, this.name = t.name, this.width = t.width || 0, this.height = t.height || 0, this.frameRate = t.attrs.optionalFloat("FRAME-RATE", 0), this._avgBitrate = t.attrs.decimalInteger("AVERAGE-BANDWIDTH"), this.audioCodec = t.audioCodec, this.videoCodec = t.videoCodec, this.codecSet = [t.videoCodec, t.audioCodec].filter((t => !!t)).map((t => t.substring(0, 4))).join(","), "supplemental" in t) {
                        var e;
                        this.supplemental = t.supplemental;
                        const i = null == (e = t.supplemental) ? void 0 : e.videoCodec;
                        i && i !== t.videoCodec && (this.codecSet += `,${i.substring(0,4)}`)
                    }
                    this.addGroupId("audio", t.attrs.AUDIO), this.addGroupId("text", t.attrs.SUBTITLES)
                }
                get maxBitrate() {
                    return Math.max(this.realBitrate, this.bitrate)
                }
                get averageBitrate() {
                    return this._avgBitrate || this.realBitrate || this.bitrate
                }
                get attrs() {
                    return this._attrs[0]
                }
                get codecs() {
                    return this.attrs.CODECS || ""
                }
                get pathwayId() {
                    return this.attrs["PATHWAY-ID"] || "."
                }
                get videoRange() {
                    return this.attrs["VIDEO-RANGE"] || "SDR"
                }
                get score() {
                    return this.attrs.optionalFloat("SCORE", 0)
                }
                get uri() {
                    return this.url[0] || ""
                }
                hasAudioGroup(t) {
                    return Wt(this._audioGroups, t)
                }
                hasSubtitleGroup(t) {
                    return Wt(this._subtitleGroups, t)
                }
                get audioGroups() {
                    return this._audioGroups
                }
                get subtitleGroups() {
                    return this._subtitleGroups
                }
                addGroupId(t, e) {
                    if (e)
                        if ("audio" === t) {
                            let t = this._audioGroups;
                            t || (t = this._audioGroups = []), -1 === t.indexOf(e) && t.push(e)
                        } else if ("text" === t) {
                        let t = this._subtitleGroups;
                        t || (t = this._subtitleGroups = []), -1 === t.indexOf(e) && t.push(e)
                    }
                }
                get urlId() {
                    return 0
                }
                set urlId(t) {}
                get audioGroupIds() {
                    return this.audioGroups ? [this.audioGroupId] : void 0
                }
                get textGroupIds() {
                    return this.subtitleGroups ? [this.textGroupId] : void 0
                }
                get audioGroupId() {
                    var t;
                    return null == (t = this.audioGroups) ? void 0 : t[0]
                }
                get textGroupId() {
                    var t;
                    return null == (t = this.subtitleGroups) ? void 0 : t[0]
                }
                addFallback() {}
            }

            function Wt(t, e) {
                return !(!e || !t) && -1 !== t.indexOf(e)
            }
            const Yt = (t, e) => JSON.stringify(t, (t => {
                const e = new WeakSet;
                return (i, s) => {
                    if (t && (s = t(i, s)), "object" == typeof s && null !== s) {
                        if (e.has(s)) return;
                        e.add(s)
                    }
                    return s
                }
            })(e));

            function Xt(t, e) {
                R.log(`[abr] start candidates with "${t}" ignored because ${e}`)
            }

            function Qt(t) {
                return t.reduce(((t, e) => {
                    let i = t.groups[e.groupId];
                    i || (i = t.groups[e.groupId] = {
                        tracks: [],
                        channels: {
                            2: 0
                        },
                        hasDefault: !1,
                        hasAutoSelect: !1
                    }), i.tracks.push(e);
                    const s = e.channels || "2";
                    return i.channels[s] = (i.channels[s] || 0) + 1, i.hasDefault = i.hasDefault || e.default, i.hasAutoSelect = i.hasAutoSelect || e.autoselect, i.hasDefault && (t.hasDefaultAudio = !0), i.hasAutoSelect && (t.hasAutoSelectAudio = !0), t
                }), {
                    hasDefaultAudio: !1,
                    hasAutoSelectAudio: !1,
                    groups: {}
                })
            }

            function Jt(t) {
                if (!t) return t;
                const {
                    lang: e,
                    assocLang: i,
                    characteristics: s,
                    channels: r,
                    audioCodec: n
                } = t;
                return {
                    lang: e,
                    assocLang: i,
                    characteristics: s,
                    channels: r,
                    audioCodec: n
                }
            }

            function Zt(t, e, i) {
                if ("attrs" in t) {
                    const i = e.indexOf(t);
                    if (-1 !== i) return i
                }
                for (let s = 0; s < e.length; s++)
                    if (te(t, e[s], i)) return s;
                return -1
            }

            function te(t, e, i) {
                const {
                    groupId: s,
                    name: r,
                    lang: n,
                    assocLang: a,
                    default: o
                } = t, l = t.forced;
                return (void 0 === s || e.groupId === s) && (void 0 === r || e.name === r) && (void 0 === n || function(t, e = "--") {
                    return t.length === e.length ? t === e : t.startsWith(e) || e.startsWith(t)
                }(n, e.lang)) && (void 0 === n || e.assocLang === a) && (void 0 === o || e.default === o) && (void 0 === l || e.forced === l) && (!("characteristics" in t) || function(t, e = "") {
                    const i = t.split(","),
                        s = e.split(",");
                    return i.length === s.length && !i.some((t => -1 === s.indexOf(t)))
                }(t.characteristics || "", e.characteristics)) && (void 0 === i || i(t, e))
            }

            function ee(t, e) {
                const {
                    audioCodec: i,
                    channels: s
                } = t;
                return !(void 0 !== i && (e.audioCodec || "").substring(0, 4) !== i.substring(0, 4) || void 0 !== s && s !== (e.channels || "2"))
            }

            function ie(t, e, i) {
                for (let s = e; s > -1; s--)
                    if (i(t[s])) return s;
                for (let s = e + 1; s < t.length; s++)
                    if (i(t[s])) return s;
                return -1
            }

            function se(t, e) {
                var i;
                return !!t && t !== (null == (i = e.loadLevelObj) ? void 0 : i.uri)
            }
            const re = function(t, e) {
                let i = 0,
                    s = t.length - 1,
                    r = null,
                    n = null;
                for (; i <= s;) {
                    r = (i + s) / 2 | 0, n = t[r];
                    const a = e(n);
                    if (a > 0) i = r + 1;
                    else {
                        if (!(a < 0)) return n;
                        s = r - 1
                    }
                }
                return null
            };

            function ne(t, e, i = 0, s = 0, r = .005) {
                let n = null;
                if (t) {
                    n = e[1 + t.sn - e[0].sn] || null;
                    const s = t.endDTS - i;
                    s > 0 && s < 15e-7 && (i += 15e-7), n && t.level !== n.level && n.end <= t.end && (n = e[2 + t.sn - e[0].sn] || null)
                } else 0 === i && 0 === e[0].start && (n = e[0]);
                if (n && ((!t || t.level === n.level) && 0 === ae(i, s, n) || function(t, e, i) {
                        if (e && 0 === e.start && e.level < t.level && (e.endPTS || 0) > 0) {
                            const s = e.tagList.reduce(((t, e) => ("INF" === e[0] && (t += parseFloat(e[1])), t)), i);
                            return t.start <= s
                        }
                        return !1
                    }(n, t, Math.min(r, s)))) return n;
                const a = re(e, ae.bind(null, i, s));
                return !a || a === t && n ? n : a
            }

            function ae(t = 0, e = 0, i) {
                if (i.start <= t && i.start + i.duration > t) return 0;
                const s = Math.min(e, i.duration + (i.deltaPTS ? i.deltaPTS : 0));
                return i.start + i.duration - s <= t ? 1 : i.start - s > t && i.start ? -1 : 0
            }

            function oe(t, e, i) {
                const s = 1e3 * Math.min(e, i.duration + (i.deltaPTS ? i.deltaPTS : 0));
                return (i.endProgramDateTime || 0) - s > t
            }

            function le(t, e) {
                return re(t, (t => t.cc < e ? 1 : t.cc > e ? -1 : 0))
            }

            function ce(t) {
                switch (t.details) {
                    case o.FRAG_LOAD_TIMEOUT:
                    case o.KEY_LOAD_TIMEOUT:
                    case o.LEVEL_LOAD_TIMEOUT:
                    case o.MANIFEST_LOAD_TIMEOUT:
                        return !0
                }
                return !1
            }

            function ue(t, e) {
                const i = ce(e);
                return t.default[(i ? "timeout" : "error") + "Retry"]
            }

            function de(t, e) {
                const i = "linear" === t.backoff ? 1 : Math.pow(2, e);
                return Math.min(i * t.retryDelayMs, t.maxRetryDelayMs)
            }

            function he(t) {
                return E(E({}, t), {
                    errorRetry: null,
                    timeoutRetry: null
                })
            }

            function fe(t, e, i, s) {
                if (!t) return !1;
                const r = null == s ? void 0 : s.code,
                    n = e < t.maxNumRetry && (function(t) {
                        return 0 === t && !1 === navigator.onLine || !!t && (t < 400 || t > 499)
                    }(r) || !!i);
                return t.shouldRetry ? t.shouldRetry(t, e, i, s, n) : n
            }

            function pe(t) {
                const e = {
                    action: 0,
                    flags: 0
                };
                return t && (e.resolved = !0), e
            }
            var ge = "NOT_LOADED",
                me = "APPENDING",
                ye = "PARTIAL",
                ve = "OK";
            class be {
                constructor(t) {
                    this.activePartLists = Object.create(null), this.endListFragments = Object.create(null), this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hasGaps = !1, this.hls = t, this._registerListeners()
                }
                _registerListeners() {
                    const {
                        hls: t
                    } = this;
                    t.on(l.MANIFEST_LOADING, this.onManifestLoading, this), t.on(l.BUFFER_APPENDED, this.onBufferAppended, this), t.on(l.FRAG_BUFFERED, this.onFragBuffered, this), t.on(l.FRAG_LOADED, this.onFragLoaded, this)
                }
                _unregisterListeners() {
                    const {
                        hls: t
                    } = this;
                    t.off(l.MANIFEST_LOADING, this.onManifestLoading, this), t.off(l.BUFFER_APPENDED, this.onBufferAppended, this), t.off(l.FRAG_BUFFERED, this.onFragBuffered, this), t.off(l.FRAG_LOADED, this.onFragLoaded, this)
                }
                destroy() {
                    this._unregisterListeners(), this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null
                }
                getAppendedFrag(t, e) {
                    const i = this.activePartLists[e];
                    if (i)
                        for (let e = i.length; e--;) {
                            const s = i[e];
                            if (!s) break;
                            const r = s.end;
                            if (s.start <= t && null !== r && t <= r) return s
                        }
                    return this.getBufferedFrag(t, e)
                }
                getBufferedFrag(t, e) {
                    return this.getFragAtPos(t, e, !0)
                }
                getFragAtPos(t, e, i) {
                    const {
                        fragments: s
                    } = this, r = Object.keys(s);
                    for (let n = r.length; n--;) {
                        const a = s[r[n]];
                        if ((null == a ? void 0 : a.body.type) === e && (!i || a.buffered)) {
                            const e = a.body;
                            if (e.start <= t && t <= e.end) return e
                        }
                    }
                    return null
                }
                detectEvictedFragments(t, e, i, s, r) {
                    this.timeRanges && (this.timeRanges[t] = e);
                    const n = (null == s ? void 0 : s.fragment.sn) || -1;
                    Object.keys(this.fragments).forEach((s => {
                        const a = this.fragments[s];
                        if (!a) return;
                        if (n >= a.body.sn) return;
                        if (!a.buffered && (!a.loaded || r)) return void(a.body.type === i && this.removeFragment(a.body));
                        const o = a.range[t];
                        o && (0 !== o.time.length ? o.time.some((t => {
                            const i = !this.isTimeBuffered(t.startPTS, t.endPTS, e);
                            return i && this.removeFragment(a.body), i
                        })) : this.removeFragment(a.body))
                    }))
                }
                detectPartialFragments(t) {
                    const e = this.timeRanges;
                    if (!e || "initSegment" === t.frag.sn) return;
                    const i = t.frag,
                        s = Ee(i),
                        r = this.fragments[s];
                    if (!r || r.buffered && i.gap) return;
                    const n = !i.relurl;
                    Object.keys(e).forEach((s => {
                        const a = i.elementaryStreams[s];
                        if (!a) return;
                        const o = e[s],
                            l = n || !0 === a.partial;
                        r.range[s] = this.getBufferedTimes(i, t.part, l, o)
                    })), r.loaded = null, Object.keys(r.range).length ? (r.buffered = !0, (r.body.endList = i.endList || r.body.endList) && (this.endListFragments[r.body.type] = r), Te(r) || this.removeParts(i.sn - 1, i.type)) : this.removeFragment(r.body)
                }
                removeParts(t, e) {
                    const i = this.activePartLists[e];
                    i && (this.activePartLists[e] = i.filter((e => e.fragment.sn >= t)))
                }
                fragBuffered(t, e) {
                    const i = Ee(t);
                    let s = this.fragments[i];
                    !s && e && (s = this.fragments[i] = {
                        body: t,
                        appendedPTS: null,
                        loaded: null,
                        buffered: !1,
                        range: Object.create(null)
                    }, t.gap && (this.hasGaps = !0)), s && (s.loaded = null, s.buffered = !0)
                }
                getBufferedTimes(t, e, i, s) {
                    const r = {
                            time: [],
                            partial: i
                        },
                        n = t.start,
                        a = t.end,
                        o = t.minEndPTS || a,
                        l = t.maxStartPTS || n;
                    for (let t = 0; t < s.length; t++) {
                        const e = s.start(t) - this.bufferPadding,
                            i = s.end(t) + this.bufferPadding;
                        if (l >= e && o <= i) {
                            r.time.push({
                                startPTS: Math.max(n, s.start(t)),
                                endPTS: Math.min(a, s.end(t))
                            });
                            break
                        }
                        if (n < i && a > e) {
                            const e = Math.max(n, s.start(t)),
                                i = Math.min(a, s.end(t));
                            i > e && (r.partial = !0, r.time.push({
                                startPTS: e,
                                endPTS: i
                            }))
                        } else if (a <= e) break
                    }
                    return r
                }
                getPartialFragment(t) {
                    let e, i, s, r = null,
                        n = 0;
                    const {
                        bufferPadding: a,
                        fragments: o
                    } = this;
                    return Object.keys(o).forEach((l => {
                        const c = o[l];
                        c && Te(c) && (i = c.body.start - a, s = c.body.end + a, t >= i && t <= s && (e = Math.min(t - i, s - t), n <= e && (r = c.body, n = e)))
                    })), r
                }
                isEndListAppended(t) {
                    const e = this.endListFragments[t];
                    return void 0 !== e && (e.buffered || Te(e))
                }
                getState(t) {
                    const e = Ee(t),
                        i = this.fragments[e];
                    return i ? i.buffered ? Te(i) ? ye : ve : me : ge
                }
                isTimeBuffered(t, e, i) {
                    let s, r;
                    for (let n = 0; n < i.length; n++) {
                        if (s = i.start(n) - this.bufferPadding, r = i.end(n) + this.bufferPadding, t >= s && e <= r) return !0;
                        if (e <= s) return !1
                    }
                    return !1
                }
                onManifestLoading() {
                    this.removeAllFragments()
                }
                onFragLoaded(t, e) {
                    if ("initSegment" === e.frag.sn || e.frag.bitrateTest) return;
                    const i = e.frag,
                        s = e.part ? null : e,
                        r = Ee(i);
                    this.fragments[r] = {
                        body: i,
                        appendedPTS: null,
                        loaded: s,
                        buffered: !1,
                        range: Object.create(null)
                    }
                }
                onBufferAppended(t, e) {
                    const {
                        frag: i,
                        part: s,
                        timeRanges: r,
                        type: n
                    } = e;
                    if ("initSegment" === i.sn) return;
                    const a = i.type;
                    if (s) {
                        let t = this.activePartLists[a];
                        t || (this.activePartLists[a] = t = []), t.push(s)
                    }
                    this.timeRanges = r;
                    const o = r[n];
                    this.detectEvictedFragments(n, o, a, s)
                }
                onFragBuffered(t, e) {
                    this.detectPartialFragments(e)
                }
                hasFragment(t) {
                    const e = Ee(t);
                    return !!this.fragments[e]
                }
                hasFragments(t) {
                    const {
                        fragments: e
                    } = this, i = Object.keys(e);
                    if (!t) return i.length > 0;
                    for (let s = i.length; s--;) {
                        const r = e[i[s]];
                        if ((null == r ? void 0 : r.body.type) === t) return !0
                    }
                    return !1
                }
                hasParts(t) {
                    var e;
                    return !(null == (e = this.activePartLists[t]) || !e.length)
                }
                removeFragmentsInRange(t, e, i, s, r) {
                    s && !this.hasGaps || Object.keys(this.fragments).forEach((n => {
                        const a = this.fragments[n];
                        if (!a) return;
                        const o = a.body;
                        o.type !== i || s && !o.gap || o.start < e && o.end > t && (a.buffered || r) && this.removeFragment(o)
                    }))
                }
                removeFragment(t) {
                    const e = Ee(t);
                    t.clearElementaryStreamInfo();
                    const i = this.activePartLists[t.type];
                    if (i) {
                        const e = t.sn;
                        this.activePartLists[t.type] = i.filter((t => t.fragment.sn !== e))
                    }
                    delete this.fragments[e], t.endList && delete this.endListFragments[t.type]
                }
                removeAllFragments() {
                    var t, e;
                    this.fragments = Object.create(null), this.endListFragments = Object.create(null), this.activePartLists = Object.create(null), this.hasGaps = !1;
                    const i = null == (t = this.hls) || null == (e = t.latestLevelDetails) ? void 0 : e.partList;
                    i && i.forEach((t => t.clearElementaryStreamInfo()))
                }
            }

            function Te(t) {
                var e, i, s;
                return t.buffered && (t.body.gap || (null == (e = t.range.video) ? void 0 : e.partial) || (null == (i = t.range.audio) ? void 0 : i.partial) || (null == (s = t.range.audiovideo) ? void 0 : s.partial))
            }

            function Ee(t) {
                return `${t.type}_${t.level}_${t.sn}`
            }
            class Se {
                constructor(t, e, i) {
                    this.subtle = void 0, this.aesIV = void 0, this.aesMode = void 0, this.subtle = t, this.aesIV = e, this.aesMode = i
                }
                decrypt(t, e) {
                    switch (this.aesMode) {
                        case 0:
                            return this.subtle.decrypt({
                                name: "AES-CBC",
                                iv: this.aesIV
                            }, e, t);
                        case 1:
                            return this.subtle.decrypt({
                                name: "AES-CTR",
                                counter: this.aesIV,
                                length: 64
                            }, e, t);
                        default:
                            throw new Error(`[AESCrypto] invalid aes mode ${this.aesMode}`)
                    }
                }
            }
            class we {
                constructor() {
                    this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable()
                }
                uint8ArrayToUint32Array_(t) {
                    const e = new DataView(t),
                        i = new Uint32Array(4);
                    for (let t = 0; t < 4; t++) i[t] = e.getUint32(4 * t);
                    return i
                }
                initTable() {
                    const t = this.sBox,
                        e = this.invSBox,
                        i = this.subMix,
                        s = i[0],
                        r = i[1],
                        n = i[2],
                        a = i[3],
                        o = this.invSubMix,
                        l = o[0],
                        c = o[1],
                        u = o[2],
                        d = o[3],
                        h = new Uint32Array(256);
                    let f = 0,
                        p = 0,
                        g = 0;
                    for (g = 0; g < 256; g++) h[g] = g < 128 ? g << 1 : g << 1 ^ 283;
                    for (g = 0; g < 256; g++) {
                        let i = p ^ p << 1 ^ p << 2 ^ p << 3 ^ p << 4;
                        i = i >>> 8 ^ 255 & i ^ 99, t[f] = i, e[i] = f;
                        const o = h[f],
                            g = h[o],
                            m = h[g];
                        let y = 257 * h[i] ^ 16843008 * i;
                        s[f] = y << 24 | y >>> 8, r[f] = y << 16 | y >>> 16, n[f] = y << 8 | y >>> 24, a[f] = y, y = 16843009 * m ^ 65537 * g ^ 257 * o ^ 16843008 * f, l[i] = y << 24 | y >>> 8, c[i] = y << 16 | y >>> 16, u[i] = y << 8 | y >>> 24, d[i] = y, f ? (f = o ^ h[h[h[m ^ o]]], p ^= h[h[p]]) : f = p = 1
                    }
                }
                expandKey(t) {
                    const e = this.uint8ArrayToUint32Array_(t);
                    let i = !0,
                        s = 0;
                    for (; s < e.length && i;) i = e[s] === this.key[s], s++;
                    if (i) return;
                    this.key = e;
                    const r = this.keySize = e.length;
                    if (4 !== r && 6 !== r && 8 !== r) throw new Error("Invalid aes key size=" + r);
                    const n = this.ksRows = 4 * (r + 6 + 1);
                    let a, o;
                    const l = this.keySchedule = new Uint32Array(n),
                        c = this.invKeySchedule = new Uint32Array(n),
                        u = this.sBox,
                        d = this.rcon,
                        h = this.invSubMix,
                        f = h[0],
                        p = h[1],
                        g = h[2],
                        m = h[3];
                    let y, v;
                    for (a = 0; a < n; a++) a < r ? y = l[a] = e[a] : (v = y, a % r == 0 ? (v = v << 8 | v >>> 24, v = u[v >>> 24] << 24 | u[v >>> 16 & 255] << 16 | u[v >>> 8 & 255] << 8 | u[255 & v], v ^= d[a / r | 0] << 24) : r > 6 && a % r == 4 && (v = u[v >>> 24] << 24 | u[v >>> 16 & 255] << 16 | u[v >>> 8 & 255] << 8 | u[255 & v]), l[a] = y = (l[a - r] ^ v) >>> 0);
                    for (o = 0; o < n; o++) a = n - o, v = 3 & o ? l[a] : l[a - 4], c[o] = o < 4 || a <= 4 ? v : f[u[v >>> 24]] ^ p[u[v >>> 16 & 255]] ^ g[u[v >>> 8 & 255]] ^ m[u[255 & v]], c[o] = c[o] >>> 0
                }
                networkToHostOrderSwap(t) {
                    return t << 24 | (65280 & t) << 8 | (16711680 & t) >> 8 | t >>> 24
                }
                decrypt(t, e, i) {
                    const s = this.keySize + 6,
                        r = this.invKeySchedule,
                        n = this.invSBox,
                        a = this.invSubMix,
                        o = a[0],
                        l = a[1],
                        c = a[2],
                        u = a[3],
                        d = this.uint8ArrayToUint32Array_(i);
                    let h = d[0],
                        f = d[1],
                        p = d[2],
                        g = d[3];
                    const m = new Int32Array(t),
                        y = new Int32Array(m.length);
                    let v, b, T, E, S, w, k, A, _, L, R, I, C, D;
                    const x = this.networkToHostOrderSwap;
                    for (; e < m.length;) {
                        for (_ = x(m[e]), L = x(m[e + 1]), R = x(m[e + 2]), I = x(m[e + 3]), S = _ ^ r[0], w = I ^ r[1], k = R ^ r[2], A = L ^ r[3], C = 4, D = 1; D < s; D++) v = o[S >>> 24] ^ l[w >> 16 & 255] ^ c[k >> 8 & 255] ^ u[255 & A] ^ r[C], b = o[w >>> 24] ^ l[k >> 16 & 255] ^ c[A >> 8 & 255] ^ u[255 & S] ^ r[C + 1], T = o[k >>> 24] ^ l[A >> 16 & 255] ^ c[S >> 8 & 255] ^ u[255 & w] ^ r[C + 2], E = o[A >>> 24] ^ l[S >> 16 & 255] ^ c[w >> 8 & 255] ^ u[255 & k] ^ r[C + 3], S = v, w = b, k = T, A = E, C += 4;
                        v = n[S >>> 24] << 24 ^ n[w >> 16 & 255] << 16 ^ n[k >> 8 & 255] << 8 ^ n[255 & A] ^ r[C], b = n[w >>> 24] << 24 ^ n[k >> 16 & 255] << 16 ^ n[A >> 8 & 255] << 8 ^ n[255 & S] ^ r[C + 1], T = n[k >>> 24] << 24 ^ n[A >> 16 & 255] << 16 ^ n[S >> 8 & 255] << 8 ^ n[255 & w] ^ r[C + 2], E = n[A >>> 24] << 24 ^ n[S >> 16 & 255] << 16 ^ n[w >> 8 & 255] << 8 ^ n[255 & k] ^ r[C + 3], y[e] = x(v ^ h), y[e + 1] = x(E ^ f), y[e + 2] = x(T ^ p), y[e + 3] = x(b ^ g), h = _, f = L, p = R, g = I, e += 4
                    }
                    return y.buffer
                }
            }
            class ke {
                constructor(t, e, i) {
                    this.subtle = void 0, this.key = void 0, this.aesMode = void 0, this.subtle = t, this.key = e, this.aesMode = i
                }
                expandKey() {
                    const t = function(t) {
                        switch (t) {
                            case 0:
                                return "AES-CBC";
                            case 1:
                                return "AES-CTR";
                            default:
                                throw new Error(`[FastAESKey] invalid aes mode ${t}`)
                        }
                    }(this.aesMode);
                    return this.subtle.importKey("raw", this.key, {
                        name: t
                    }, !1, ["encrypt", "decrypt"])
                }
            }
            class Ae {
                constructor(t, {
                    removePKCS7Padding: e = !0
                } = {}) {
                    if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.enableSoftwareAES = void 0, this.enableSoftwareAES = t.enableSoftwareAES, this.removePKCS7Padding = e, e) try {
                        const t = self.crypto;
                        t && (this.subtle = t.subtle || t.webkitSubtle)
                    } catch (t) {}
                    this.useSoftware = !this.subtle
                }
                destroy() {
                    this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null
                }
                isSync() {
                    return this.useSoftware
                }
                flush() {
                    const {
                        currentResult: t,
                        remainderData: e
                    } = this;
                    if (!t || e) return this.reset(), null;
                    const i = new Uint8Array(t);
                    return this.reset(), this.removePKCS7Padding ? function(t) {
                        const e = t.byteLength,
                            i = e && new DataView(t.buffer).getUint8(e - 1);
                        return i ? t.slice(0, e - i) : t
                    }(i) : i
                }
                reset() {
                    this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null)
                }
                decrypt(t, e, i, s) {
                    return this.useSoftware ? new Promise(((r, n) => {
                        const a = ArrayBuffer.isView(t) ? t : new Uint8Array(t);
                        this.softwareDecrypt(a, e, i, s);
                        const o = this.flush();
                        o ? r(o.buffer) : n(new Error("[softwareDecrypt] Failed to decrypt data"))
                    })) : this.webCryptoDecrypt(new Uint8Array(t), e, i, s)
                }
                softwareDecrypt(t, e, i, s) {
                    const {
                        currentIV: r,
                        currentResult: n,
                        remainderData: a
                    } = this;
                    if (0 !== s || 16 !== e.byteLength) return R.warn("SoftwareDecrypt: can only handle AES-128-CBC"), null;
                    this.logOnce("JS AES decrypt"), a && (t = mt(a, t), this.remainderData = null);
                    const o = this.getValidChunk(t);
                    if (!o.length) return null;
                    r && (i = r);
                    let l = this.softwareDecrypter;
                    l || (l = this.softwareDecrypter = new we), l.expandKey(e);
                    const c = n;
                    return this.currentResult = l.decrypt(o.buffer, 0, i), this.currentIV = o.slice(-16).buffer, c || null
                }
                webCryptoDecrypt(t, e, i, s) {
                    if (this.key !== e || !this.fastAesKey) {
                        if (!this.subtle) return Promise.resolve(this.onWebCryptoError(t, e, i, s));
                        this.key = e, this.fastAesKey = new ke(this.subtle, e, s)
                    }
                    return this.fastAesKey.expandKey().then((e => this.subtle ? (this.logOnce("WebCrypto AES decrypt"), new Se(this.subtle, new Uint8Array(i), s).decrypt(t.buffer, e)) : Promise.reject(new Error("web crypto not initialized")))).catch((r => (R.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${r.name}: ${r.message}`), this.onWebCryptoError(t, e, i, s))))
                }
                onWebCryptoError(t, e, i, s) {
                    const r = this.enableSoftwareAES;
                    if (r) {
                        this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(t, e, i, s);
                        const r = this.flush();
                        if (r) return r.buffer
                    }
                    throw new Error("WebCrypto" + (r ? " and softwareDecrypt" : "") + ": failed to decrypt data")
                }
                getValidChunk(t) {
                    let e = t;
                    const i = t.length - t.length % 16;
                    return i !== t.length && (e = t.slice(0, i), this.remainderData = t.slice(i)), e
                }
                logOnce(t) {
                    this.logEnabled && (R.log(`[decrypter]: ${t}`), this.logEnabled = !1)
                }
            }
            const _e = Math.pow(2, 17);
            class Le {
                constructor(t) {
                    this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = t
                }
                destroy() {
                    this.loader && (this.loader.destroy(), this.loader = null)
                }
                abort() {
                    this.loader && this.loader.abort()
                }
                load(t, e) {
                    const i = t.url;
                    if (!i) return Promise.reject(new Ce({
                        type: a.NETWORK_ERROR,
                        details: o.FRAG_LOAD_ERROR,
                        fatal: !1,
                        frag: t,
                        error: new Error("Fragment does not have a " + (i ? "part list" : "url")),
                        networkDetails: null
                    }));
                    this.abort();
                    const s = this.config,
                        r = s.fLoader,
                        n = s.loader;
                    return new Promise(((l, c) => {
                        if (this.loader && this.loader.destroy(), t.gap) {
                            if (t.tagList.some((t => "GAP" === t[0]))) return void c(Ie(t));
                            t.gap = !1
                        }
                        const u = this.loader = r ? new r(s) : new n(s),
                            d = Re(t);
                        t.loader = u;
                        const h = he(s.fragLoadPolicy.default),
                            f = {
                                loadPolicy: h,
                                timeout: h.maxLoadTimeMs,
                                maxRetry: 0,
                                retryDelay: 0,
                                maxRetryDelay: 0,
                                highWaterMark: "initSegment" === t.sn ? 1 / 0 : _e
                            };
                        t.stats = u.stats;
                        const p = {
                            onSuccess: (e, i, s, r) => {
                                this.resetLoader(t, u);
                                let n = e.data;
                                s.resetIV && t.decryptdata && (t.decryptdata.iv = new Uint8Array(n.slice(0, 16)), n = n.slice(16)), l({
                                    frag: t,
                                    part: null,
                                    payload: n,
                                    networkDetails: r
                                })
                            },
                            onError: (e, s, r, n) => {
                                this.resetLoader(t, u), c(new Ce({
                                    type: a.NETWORK_ERROR,
                                    details: o.FRAG_LOAD_ERROR,
                                    fatal: !1,
                                    frag: t,
                                    response: E({
                                        url: i,
                                        data: void 0
                                    }, e),
                                    error: new Error(`HTTP Error ${e.code} ${e.text}`),
                                    networkDetails: r,
                                    stats: n
                                }))
                            },
                            onAbort: (e, i, s) => {
                                this.resetLoader(t, u), c(new Ce({
                                    type: a.NETWORK_ERROR,
                                    details: o.INTERNAL_ABORTED,
                                    fatal: !1,
                                    frag: t,
                                    error: new Error("Aborted"),
                                    networkDetails: s,
                                    stats: e
                                }))
                            },
                            onTimeout: (e, i, s) => {
                                this.resetLoader(t, u), c(new Ce({
                                    type: a.NETWORK_ERROR,
                                    details: o.FRAG_LOAD_TIMEOUT,
                                    fatal: !1,
                                    frag: t,
                                    error: new Error(`Timeout after ${f.timeout}ms`),
                                    networkDetails: s,
                                    stats: e
                                }))
                            }
                        };
                        e && (p.onProgress = (i, s, r, n) => e({
                            frag: t,
                            part: null,
                            payload: r,
                            networkDetails: n
                        })), u.load(d, f, p)
                    }))
                }
                loadPart(t, e, i) {
                    this.abort();
                    const s = this.config,
                        r = s.fLoader,
                        n = s.loader;
                    return new Promise(((l, c) => {
                        if (this.loader && this.loader.destroy(), t.gap || e.gap) return void c(Ie(t, e));
                        const u = this.loader = r ? new r(s) : new n(s),
                            d = Re(t, e);
                        t.loader = u;
                        const h = he(s.fragLoadPolicy.default),
                            f = {
                                loadPolicy: h,
                                timeout: h.maxLoadTimeMs,
                                maxRetry: 0,
                                retryDelay: 0,
                                maxRetryDelay: 0,
                                highWaterMark: _e
                            };
                        e.stats = u.stats, u.load(d, f, {
                            onSuccess: (s, r, n, a) => {
                                this.resetLoader(t, u), this.updateStatsFromPart(t, e);
                                const o = {
                                    frag: t,
                                    part: e,
                                    payload: s.data,
                                    networkDetails: a
                                };
                                i(o), l(o)
                            },
                            onError: (i, s, r, n) => {
                                this.resetLoader(t, u), c(new Ce({
                                    type: a.NETWORK_ERROR,
                                    details: o.FRAG_LOAD_ERROR,
                                    fatal: !1,
                                    frag: t,
                                    part: e,
                                    response: E({
                                        url: d.url,
                                        data: void 0
                                    }, i),
                                    error: new Error(`HTTP Error ${i.code} ${i.text}`),
                                    networkDetails: r,
                                    stats: n
                                }))
                            },
                            onAbort: (i, s, r) => {
                                t.stats.aborted = e.stats.aborted, this.resetLoader(t, u), c(new Ce({
                                    type: a.NETWORK_ERROR,
                                    details: o.INTERNAL_ABORTED,
                                    fatal: !1,
                                    frag: t,
                                    part: e,
                                    error: new Error("Aborted"),
                                    networkDetails: r,
                                    stats: i
                                }))
                            },
                            onTimeout: (i, s, r) => {
                                this.resetLoader(t, u), c(new Ce({
                                    type: a.NETWORK_ERROR,
                                    details: o.FRAG_LOAD_TIMEOUT,
                                    fatal: !1,
                                    frag: t,
                                    part: e,
                                    error: new Error(`Timeout after ${f.timeout}ms`),
                                    networkDetails: r,
                                    stats: i
                                }))
                            }
                        })
                    }))
                }
                updateStatsFromPart(t, e) {
                    const i = t.stats,
                        s = e.stats,
                        r = s.total;
                    if (i.loaded += s.loaded, r) {
                        const s = Math.round(t.duration / e.duration),
                            n = Math.min(Math.round(i.loaded / r), s),
                            a = (s - n) * Math.round(i.loaded / n);
                        i.total = i.loaded + a
                    } else i.total = Math.max(i.loaded, i.total);
                    const n = i.loading,
                        a = s.loading;
                    n.start ? n.first += a.first - a.start : (n.start = a.start, n.first = a.first), n.end = a.end
                }
                resetLoader(t, e) {
                    t.loader = null, this.loader === e && (self.clearTimeout(this.partLoadTimeout), this.loader = null), e.destroy()
                }
            }

            function Re(t, e = null) {
                const i = e || t,
                    r = {
                        frag: t,
                        part: e,
                        responseType: "arraybuffer",
                        url: i.url,
                        headers: {},
                        rangeStart: 0,
                        rangeEnd: 0
                    },
                    n = i.byteRangeStartOffset,
                    a = i.byteRangeEndOffset;
                if (s(n) && s(a)) {
                    var o;
                    let e = n,
                        i = a;
                    if ("initSegment" === t.sn && ("AES-128" === (l = null == (o = t.decryptdata) ? void 0 : o.method) || "AES-256" === l)) {
                        const t = a - n;
                        t % 16 && (i = a + (16 - t % 16)), 0 !== n && (r.resetIV = !0, e = n - 16)
                    }
                    r.rangeStart = e, r.rangeEnd = i
                }
                var l;
                return r
            }

            function Ie(t, e) {
                const i = new Error(`GAP ${t.gap?"tag":"attribute"} found`),
                    s = {
                        type: a.MEDIA_ERROR,
                        details: o.FRAG_GAP,
                        fatal: !1,
                        frag: t,
                        error: i,
                        networkDetails: null
                    };
                return e && (s.part = e), (e || t).stats.aborted = !0, new Ce(s)
            }
            class Ce extends Error {
                constructor(t) {
                    super(t.error.message), this.data = void 0, this.data = t
                }
            }
            class De extends S {
                constructor(t, e) {
                    super(t, e), this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this)
                }
                destroy() {
                    this.onHandlerDestroying(), this.onHandlerDestroyed()
                }
                onHandlerDestroying() {
                    this.clearNextTick(), this.clearInterval()
                }
                onHandlerDestroyed() {}
                hasInterval() {
                    return !!this._tickInterval
                }
                hasNextTick() {
                    return !!this._tickTimer
                }
                setInterval(t) {
                    return !this._tickInterval && (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, t), !0)
                }
                clearInterval() {
                    return !!this._tickInterval && (self.clearInterval(this._tickInterval), this._tickInterval = null, !0)
                }
                clearNextTick() {
                    return !!this._tickTimer && (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0)
                }
                tick() {
                    this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0)
                }
                tickImmediate() {
                    this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0)
                }
                doTick() {}
            }
            class xe {
                constructor(t, e, i, s = 0, r = -1, n = !1) {
                    this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = {
                        start: 0,
                        executeStart: 0,
                        executeEnd: 0,
                        end: 0
                    }, this.buffering = {
                        audio: {
                            start: 0,
                            executeStart: 0,
                            executeEnd: 0,
                            end: 0
                        },
                        video: {
                            start: 0,
                            executeStart: 0,
                            executeEnd: 0,
                            end: 0
                        },
                        audiovideo: {
                            start: 0,
                            executeStart: 0,
                            executeEnd: 0,
                            end: 0
                        }
                    }, this.level = t, this.sn = e, this.id = i, this.size = s, this.part = r, this.partial = n
                }
            }
            const Pe = {
                length: 0,
                start: () => 0,
                end: () => 0
            };
            class Oe {
                static isBuffered(t, e) {
                    if (t) {
                        const i = Oe.getBuffered(t);
                        for (let t = i.length; t--;)
                            if (e >= i.start(t) && e <= i.end(t)) return !0
                    }
                    return !1
                }
                static bufferedRanges(t) {
                    if (t) {
                        const e = Oe.getBuffered(t);
                        return Oe.timeRangesToArray(e)
                    }
                    return []
                }
                static timeRangesToArray(t) {
                    const e = [];
                    for (let i = 0; i < t.length; i++) e.push({
                        start: t.start(i),
                        end: t.end(i)
                    });
                    return e
                }
                static bufferInfo(t, e, i) {
                    if (t) {
                        const s = Oe.bufferedRanges(t);
                        if (s.length) return Oe.bufferedInfo(s, e, i)
                    }
                    return {
                        len: 0,
                        start: e,
                        end: e,
                        bufferedIndex: -1
                    }
                }
                static bufferedInfo(t, e, i) {
                    e = Math.max(0, e), t.length > 1 && t.sort(((t, e) => t.start - e.start || e.end - t.end));
                    let s = -1,
                        r = [];
                    if (i)
                        for (let n = 0; n < t.length; n++) {
                            e >= t[n].start && e <= t[n].end && (s = n);
                            const a = r.length;
                            if (a) {
                                const e = r[a - 1].end;
                                t[n].start - e < i ? t[n].end > e && (r[a - 1].end = t[n].end) : r.push(t[n])
                            } else r.push(t[n])
                        } else r = t;
                    let n, a = 0,
                        o = e,
                        l = e;
                    for (let t = 0; t < r.length; t++) {
                        const c = r[t].start,
                            u = r[t].end;
                        if (-1 === s && e >= c && e <= u && (s = t), e + i >= c && e < u) o = c, l = u, a = l - e;
                        else if (e + i < c) {
                            n = c;
                            break
                        }
                    }
                    return {
                        len: a,
                        start: o || 0,
                        end: l || 0,
                        nextStart: n,
                        buffered: t,
                        bufferedIndex: s
                    }
                }
                static getBuffered(t) {
                    try {
                        return t.buffered || Pe
                    } catch (t) {
                        return R.log("failed to get media.buffered", t), Pe
                    }
                }
            }
            const Me = /\{\$([a-zA-Z0-9-_]+)\}/g;

            function Ne(t) {
                return Me.test(t)
            }

            function Fe(t, e) {
                if (null !== t.variableList || t.hasVariableRefs) {
                    const i = t.variableList;
                    return e.replace(Me, (e => {
                        const s = e.substring(2, e.length - 1),
                            r = null == i ? void 0 : i[s];
                        return void 0 === r ? (t.playlistParsingError || (t.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${s}"`)), e) : r
                    }))
                }
                return e
            }

            function $e(t, e, i) {
                let s, r, n = t.variableList;
                if (n || (t.variableList = n = {}), "QUERYPARAM" in e) {
                    s = e.QUERYPARAM;
                    try {
                        const t = new self.URL(i).searchParams;
                        if (!t.has(s)) throw new Error(`"${s}" does not match any query parameter in URI: "${i}"`);
                        r = t.get(s)
                    } catch (e) {
                        t.playlistParsingError || (t.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${e.message}`))
                    }
                } else s = e.NAME, r = e.VALUE;
                s in n ? t.playlistParsingError || (t.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${s}"`)) : n[s] = r || ""
            }

            function Ue(t, e, i) {
                const s = e.IMPORT;
                if (i && s in i) {
                    let e = t.variableList;
                    e || (t.variableList = e = {}), e[s] = i[s]
                } else t.playlistParsingError || (t.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${s}"`))
            }
            const Be = /^(\d+)x(\d+)$/,
                je = /(.+?)=(".*?"|.*?)(?:,|$)/g;
            class Ge {
                constructor(t, e) {
                    "string" == typeof t && (t = Ge.parseAttrList(t, e)), b(this, t)
                }
                get clientAttrs() {
                    return Object.keys(this).filter((t => "X-" === t.substring(0, 2)))
                }
                decimalInteger(t) {
                    const e = parseInt(this[t], 10);
                    return e > Number.MAX_SAFE_INTEGER ? 1 / 0 : e
                }
                hexadecimalInteger(t) {
                    if (this[t]) {
                        let e = (this[t] || "0x").slice(2);
                        e = (1 & e.length ? "0" : "") + e;
                        const i = new Uint8Array(e.length / 2);
                        for (let t = 0; t < e.length / 2; t++) i[t] = parseInt(e.slice(2 * t, 2 * t + 2), 16);
                        return i
                    }
                    return null
                }
                hexadecimalIntegerAsNumber(t) {
                    const e = parseInt(this[t], 16);
                    return e > Number.MAX_SAFE_INTEGER ? 1 / 0 : e
                }
                decimalFloatingPoint(t) {
                    return parseFloat(this[t])
                }
                optionalFloat(t, e) {
                    const i = this[t];
                    return i ? parseFloat(i) : e
                }
                enumeratedString(t) {
                    return this[t]
                }
                enumeratedStringList(t, e) {
                    const i = this[t];
                    return (i ? i.split(/[ ,]+/) : []).reduce(((t, e) => (t[e.toLowerCase()] = !0, t)), e)
                }
                bool(t) {
                    return "YES" === this[t]
                }
                decimalResolution(t) {
                    const e = Be.exec(this[t]);
                    if (null !== e) return {
                        width: parseInt(e[1], 10),
                        height: parseInt(e[2], 10)
                    }
                }
                static parseAttrList(t, e) {
                    let i;
                    const s = {};
                    for (je.lastIndex = 0; null !== (i = je.exec(t));) {
                        const r = i[1].trim();
                        let n = i[2];
                        const a = 0 === n.indexOf('"') && n.lastIndexOf('"') === n.length - 1;
                        let o = !1;
                        if (a) n = n.slice(1, -1);
                        else switch (r) {
                            case "IV":
                            case "SCTE35-CMD":
                            case "SCTE35-IN":
                            case "SCTE35-OUT":
                                o = !0
                        }
                        if (e && (a || o)) n = Fe(e, n);
                        else if (!o && !a) switch (r) {
                            case "CLOSED-CAPTIONS":
                                if ("NONE" === n) break;
                            case "ALLOWED-CPC":
                            case "CLASS":
                            case "ASSOC-LANGUAGE":
                            case "AUDIO":
                            case "BYTERANGE":
                            case "CHANNELS":
                            case "CHARACTERISTICS":
                            case "CODECS":
                            case "DATA-ID":
                            case "END-DATE":
                            case "GROUP-ID":
                            case "ID":
                            case "IMPORT":
                            case "INSTREAM-ID":
                            case "KEYFORMAT":
                            case "KEYFORMATVERSIONS":
                            case "LANGUAGE":
                            case "NAME":
                            case "PATHWAY-ID":
                            case "QUERYPARAM":
                            case "RECENTLY-REMOVED-DATERANGES":
                            case "SERVER-URI":
                            case "STABLE-RENDITION-ID":
                            case "STABLE-VARIANT-ID":
                            case "START-DATE":
                            case "SUBTITLES":
                            case "SUPPLEMENTAL-CODECS":
                            case "URI":
                            case "VALUE":
                            case "VIDEO":
                            case "X-ASSET-LIST":
                            case "X-ASSET-URI":
                                R.warn(`${t}: attribute ${r} is missing quotes`)
                        }
                        s[r] = n
                    }
                    return s
                }
            }

            function Ve(t) {
                return "SCTE35-OUT" === t || "SCTE35-IN" === t || "SCTE35-CMD" === t
            }
            class He {
                constructor(t, e, i = 0) {
                    var r;
                    if (this.attr = void 0, this.tagAnchor = void 0, this.tagOrder = void 0, this._startDate = void 0, this._endDate = void 0, this._dateAtEnd = void 0, this._cue = void 0, this._badValueForSameId = void 0, this.tagAnchor = (null == e ? void 0 : e.tagAnchor) || null, this.tagOrder = null != (r = null == e ? void 0 : e.tagOrder) ? r : i, e) {
                        const i = e.attr;
                        for (const e in i)
                            if (Object.prototype.hasOwnProperty.call(t, e) && t[e] !== i[e]) {
                                R.warn(`DATERANGE tag attribute: "${e}" does not match for tags with ID: "${t.ID}"`), this._badValueForSameId = e;
                                break
                            }
                        t = b(new Ge({}), i, t)
                    }
                    if (this.attr = t, e ? (this._startDate = e._startDate, this._cue = e._cue, this._endDate = e._endDate, this._dateAtEnd = e._dateAtEnd) : this._startDate = new Date(t["START-DATE"]), "END-DATE" in this.attr) {
                        const t = (null == e ? void 0 : e.endDate) || new Date(this.attr["END-DATE"]);
                        s(t.getTime()) && (this._endDate = t)
                    }
                }
                get id() {
                    return this.attr.ID
                }
                get class() {
                    return this.attr.CLASS
                }
                get cue() {
                    const t = this._cue;
                    return void 0 === t ? this._cue = this.attr.enumeratedStringList(this.attr.CUE ? "CUE" : "X-CUE", {
                        pre: !1,
                        post: !1,
                        once: !1
                    }) : t
                }
                get startTime() {
                    const {
                        tagAnchor: t
                    } = this;
                    return null === t || null === t.programDateTime ? (R.warn(`Expected tagAnchor Fragment with PDT set for DateRange "${this.id}": ${t}`), NaN) : t.start + (this.startDate.getTime() - t.programDateTime) / 1e3
                }
                get startDate() {
                    return this._startDate
                }
                get endDate() {
                    const t = this._endDate || this._dateAtEnd;
                    if (t) return t;
                    const e = this.duration;
                    return null !== e ? this._dateAtEnd = new Date(this._startDate.getTime() + 1e3 * e) : null
                }
                get duration() {
                    if ("DURATION" in this.attr) {
                        const t = this.attr.decimalFloatingPoint("DURATION");
                        if (s(t)) return t
                    } else if (this._endDate) return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
                    return null
                }
                get plannedDuration() {
                    return "PLANNED-DURATION" in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null
                }
                get endOnNext() {
                    return this.attr.bool("END-ON-NEXT")
                }
                get isInterstitial() {
                    return "com.apple.hls.interstitial" === this.class
                }
                get isValid() {
                    return !!this.id && !this._badValueForSameId && s(this.startDate.getTime()) && (null === this.duration || this.duration >= 0) && (!this.endOnNext || !!this.class) && (!this.attr.CUE || !this.cue.pre && !this.cue.post || this.cue.pre !== this.cue.post) && (!this.isInterstitial || "X-ASSET-URI" in this.attr || "X-ASSET-LIST" in this.attr)
                }
            }
            class Ke {
                constructor(t) {
                    this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.dateRangeTagCount = 0, this.live = !0, this.requestScheduled = -1, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.appliedTimelineOffset = void 0, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = t
                }
                reloaded(t) {
                    if (!t) return this.advanced = !0, void(this.updated = !0);
                    const e = this.lastPartSn - t.lastPartSn,
                        i = this.lastPartIndex - t.lastPartIndex;
                    this.updated = this.endSN !== t.endSN || !!i || !!e || !this.live, this.advanced = this.endSN > t.endSN || e > 0 || 0 === e && i > 0, this.updated || this.advanced ? this.misses = Math.floor(.6 * t.misses) : this.misses = t.misses + 1
                }
                get hasProgramDateTime() {
                    return !!this.fragments.length && s(this.fragments[this.fragments.length - 1].programDateTime)
                }
                get levelTargetDuration() {
                    return this.averagetargetduration || this.targetduration || 10
                }
                get drift() {
                    const t = this.driftEndTime - this.driftStartTime;
                    return t > 0 ? 1e3 * (this.driftEnd - this.driftStart) / t : 1
                }
                get edge() {
                    return this.partEnd || this.fragmentEnd
                }
                get partEnd() {
                    var t;
                    return null != (t = this.partList) && t.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd
                }
                get fragmentEnd() {
                    var t;
                    return null != (t = this.fragments) && t.length ? this.fragments[this.fragments.length - 1].end : 0
                }
                get fragmentStart() {
                    var t;
                    return null != (t = this.fragments) && t.length ? this.fragments[0].start : 0
                }
                get age() {
                    return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0
                }
                get lastPartIndex() {
                    var t;
                    return null != (t = this.partList) && t.length ? this.partList[this.partList.length - 1].index : -1
                }
                get maxPartIndex() {
                    const t = this.partList;
                    if (t) {
                        const e = this.lastPartIndex;
                        if (-1 !== e) {
                            for (let i = t.length; i--;)
                                if (t[i].index > e) return t[i].index;
                            return e
                        }
                    }
                    return 0
                }
                get lastPartSn() {
                    var t;
                    return null != (t = this.partList) && t.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN
                }
                get expired() {
                    if (this.live && this.age && this.misses < 3) {
                        const t = this.partEnd - this.fragmentStart;
                        return this.age > Math.max(t, this.totalduration) + this.levelTargetDuration
                    }
                    return !1
                }
            }

            function ze(t) {
                return "AES-128" === t || "AES-256" === t || "AES-256-CTR" === t
            }

            function qe(t) {
                switch (t) {
                    case "AES-128":
                    case "AES-256":
                        return 0;
                    case "AES-256-CTR":
                        return 1;
                    default:
                        throw new Error(`invalid full segment method ${t}`)
                }
            }

            function We(t) {
                return Uint8Array.from(atob(t), (t => t.charCodeAt(0)))
            }

            function Ye(t) {
                return Uint8Array.from(unescape(encodeURIComponent(t)), (t => t.charCodeAt(0)))
            }
            const Xe = "undefined" != typeof self ? self : void 0;
            var Qe = {
                    CLEARKEY: "org.w3.clearkey",
                    FAIRPLAY: "com.apple.fps",
                    PLAYREADY: "com.microsoft.playready",
                    WIDEVINE: "com.widevine.alpha"
                },
                Je = "org.w3.clearkey",
                Ze = "com.apple.streamingkeydelivery",
                ti = "com.microsoft.playready",
                ei = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";

            function ii(t) {
                switch (t) {
                    case Ze:
                        return Qe.FAIRPLAY;
                    case ti:
                        return Qe.PLAYREADY;
                    case ei:
                        return Qe.WIDEVINE;
                    case Je:
                        return Qe.CLEARKEY
                }
            }

            function si(t) {
                return "edef8ba979d64acea3c827dcd51d21ed" === t ? Qe.WIDEVINE : "9a04f07998404286ab92e65be0885f95" === t ? Qe.PLAYREADY : "1077efecc0b24d02ace33c1e52e2fb4b" === t || "e2719d58a985b3c9781ab030af78d30e" === t ? Qe.CLEARKEY : void 0
            }

            function ri(t) {
                switch (t) {
                    case Qe.FAIRPLAY:
                        return Ze;
                    case Qe.PLAYREADY:
                        return ti;
                    case Qe.WIDEVINE:
                        return ei;
                    case Qe.CLEARKEY:
                        return Je
                }
            }

            function ni(t) {
                const {
                    drmSystems: e,
                    widevineLicenseUrl: i
                } = t, s = e ? [Qe.FAIRPLAY, Qe.WIDEVINE, Qe.PLAYREADY, Qe.CLEARKEY].filter((t => !!e[t])) : [];
                return !s[Qe.WIDEVINE] && i && s.push(Qe.WIDEVINE), s
            }
            const ai = null != Xe && null != (oi = Xe.navigator) && oi.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null;
            var oi;

            function li(t) {
                const e = new Uint16Array(t.buffer, t.byteOffset, t.byteLength / 2),
                    i = String.fromCharCode.apply(null, Array.from(e)),
                    s = i.substring(i.indexOf("<"), i.length),
                    r = (new DOMParser).parseFromString(s, "text/xml").getElementsByTagName("KID")[0];
                if (r) {
                    const t = r.childNodes[0] ? r.childNodes[0].nodeValue : r.getAttribute("VALUE");
                    if (t) {
                        const e = We(t).subarray(0, 16);
                        return function(t) {
                            const e = function(t, e, i) {
                                const s = t[e];
                                t[e] = t[i], t[i] = s
                            };
                            e(t, 0, 3), e(t, 1, 2), e(t, 4, 5), e(t, 6, 7)
                        }(e), e
                    }
                }
                return null
            }
            let ci = {};
            class ui {
                static clearKeyUriToKeyIdMap() {
                    ci = {}
                }
                constructor(t, e, i, s = [1], r = null) {
                    this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = t, this.uri = e, this.keyFormat = i, this.keyFormatVersions = s, this.iv = r, this.encrypted = !!t && "NONE" !== t, this.isCommonEncryption = this.encrypted && !ze(t)
                }
                isSupported() {
                    if (this.method) {
                        if (ze(this.method) || "NONE" === this.method) return !0;
                        if ("identity" === this.keyFormat) return "SAMPLE-AES" === this.method;
                        switch (this.keyFormat) {
                            case Ze:
                            case ei:
                            case ti:
                            case Je:
                                return -1 !== ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method)
                        }
                    }
                    return !1
                }
                getDecryptData(t) {
                    if (!this.encrypted || !this.uri) return null;
                    if (ze(this.method) && this.uri && !this.iv) {
                        "number" != typeof t && (R.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`), t = 0);
                        const e = function(t) {
                            const e = new Uint8Array(16);
                            for (let i = 12; i < 16; i++) e[i] = t >> 8 * (15 - i) & 255;
                            return e
                        }(t);
                        return new ui(this.method, this.uri, "identity", this.keyFormatVersions, e)
                    }
                    const e = function(t) {
                        const e = t.split(":");
                        let i = null;
                        if ("data" === e[0] && 2 === e.length) {
                            const t = e[1].split(";"),
                                s = t[t.length - 1].split(",");
                            if (2 === s.length) {
                                const e = "base64" === s[0],
                                    r = s[1];
                                e ? (t.splice(-1, 1), i = We(r)) : i = function(t) {
                                    const e = Ye(t).subarray(0, 16),
                                        i = new Uint8Array(16);
                                    return i.set(e, 16 - e.length), i
                                }(r)
                            }
                        }
                        return i
                    }(this.uri);
                    if (e) switch (this.keyFormat) {
                        case ei:
                            this.pssh = e, e.length >= 22 && (this.keyId = e.subarray(e.length - 22, e.length - 6));
                            break;
                        case ti:
                            {
                                const t = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);this.pssh = function(t, e, i) {
                                    if (16 !== t.byteLength) throw new RangeError("Invalid system id");
                                    let s, r, n;
                                    s = 0, r = new Uint8Array, n = new Uint8Array;
                                    const a = new Uint8Array(4);
                                    return i && i.byteLength > 0 && new DataView(a.buffer).setUint32(0, i.byteLength, !1),
                                        function(t, ...e) {
                                            const i = e.length;
                                            let s = 8,
                                                r = i;
                                            for (; r--;) s += e[r].byteLength;
                                            const n = new Uint8Array(s);
                                            for (n[0] = s >> 24 & 255, n[1] = s >> 16 & 255, n[2] = s >> 8 & 255, n[3] = 255 & s, n.set(t, 4), r = 0, s = 8; r < i; r++) n.set(e[r], s), s += e[r].byteLength;
                                            return n
                                        }([112, 115, 115, 104], new Uint8Array([0, 0, 0, 0]), t, n, r, a, i || new Uint8Array)
                                }(t, 0, e),
                                this.keyId = li(e);
                                break
                            }
                        default:
                            {
                                let t = e.subarray(0, 16);
                                if (16 !== t.length) {
                                    const e = new Uint8Array(16);
                                    e.set(t, 16 - t.length), t = e
                                }
                                this.keyId = t;
                                break
                            }
                    }
                    if (!this.keyId || 16 !== this.keyId.byteLength) {
                        let t = ci[this.uri];
                        if (!t) {
                            const e = Object.keys(ci).length % Number.MAX_SAFE_INTEGER;
                            t = new Uint8Array(16), new DataView(t.buffer, 12, 4).setUint32(0, e), ci[this.uri] = t
                        }
                        this.keyId = t
                    }
                    return this
                }
            }
            const di = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g,
                hi = /#EXT-X-MEDIA:(.*)/g,
                fi = /^#EXT(?:INF|-X-TARGETDURATION):/m,
                pi = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[^\r\n]*)/.source, /#.*/.source].join("|"), "g"),
                gi = new RegExp([/#EXT-X-(PROGRAM-DATE-TIME|BYTERANGE|DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
            class mi {
                static findGroup(t, e) {
                    for (let i = 0; i < t.length; i++) {
                        const s = t[i];
                        if (s.id === e) return s
                    }
                }
                static resolve(t, e) {
                    return j.buildAbsoluteURL(e, t, {
                        alwaysNormalize: !0
                    })
                }
                static isMediaPlaylist(t) {
                    return fi.test(t)
                }
                static parseMasterPlaylist(t, e) {
                    const i = {
                            contentSteering: null,
                            levels: [],
                            playlistParsingError: null,
                            sessionData: null,
                            sessionKeys: null,
                            startTimeOffset: null,
                            variableList: null,
                            hasVariableRefs: Ne(t)
                        },
                        s = [];
                    let r;
                    for (di.lastIndex = 0; null != (r = di.exec(t));)
                        if (r[1]) {
                            var n;
                            const t = new Ge(r[1], i),
                                a = Fe(i, r[2]),
                                o = {
                                    attrs: t,
                                    bitrate: t.decimalInteger("BANDWIDTH") || t.decimalInteger("AVERAGE-BANDWIDTH"),
                                    name: t.NAME,
                                    url: mi.resolve(a, e)
                                },
                                l = t.decimalResolution("RESOLUTION");
                            l && (o.width = l.width, o.height = l.height), Ei(t.CODECS, o);
                            const c = t["SUPPLEMENTAL-CODECS"];
                            c && (o.supplemental = {}, Ei(c, o.supplemental)), null != (n = o.unknownCodecs) && n.length || s.push(o), i.levels.push(o)
                        } else if (r[3]) {
                        const t = r[3],
                            s = r[4];
                        switch (t) {
                            case "SESSION-DATA":
                                {
                                    const t = new Ge(s, i),
                                        e = t["DATA-ID"];e && (null === i.sessionData && (i.sessionData = {}), i.sessionData[e] = t);
                                    break
                                }
                            case "SESSION-KEY":
                                {
                                    const t = bi(s, e, i);t.encrypted && t.isSupported() ? (null === i.sessionKeys && (i.sessionKeys = []), i.sessionKeys.push(t)) : R.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${s}"`);
                                    break
                                }
                            case "DEFINE":
                                $e(i, new Ge(s, i), e);
                                break;
                            case "CONTENT-STEERING":
                                {
                                    const t = new Ge(s, i);i.contentSteering = {
                                        uri: mi.resolve(t["SERVER-URI"], e),
                                        pathwayId: t["PATHWAY-ID"] || "."
                                    };
                                    break
                                }
                            case "START":
                                i.startTimeOffset = Ti(s)
                        }
                    }
                    const a = s.length > 0 && s.length < i.levels.length;
                    return i.levels = a ? s : i.levels, 0 === i.levels.length && (i.playlistParsingError = new Error("no levels found in manifest")), i
                }
                static parseMasterPlaylistMedia(t, e, i) {
                    let s;
                    const r = {},
                        n = i.levels,
                        a = {
                            AUDIO: n.map((t => ({
                                id: t.attrs.AUDIO,
                                audioCodec: t.audioCodec
                            }))),
                            SUBTITLES: n.map((t => ({
                                id: t.attrs.SUBTITLES,
                                textCodec: t.textCodec
                            }))),
                            "CLOSED-CAPTIONS": []
                        };
                    let o = 0;
                    for (hi.lastIndex = 0; null !== (s = hi.exec(t));) {
                        const t = new Ge(s[1], i),
                            n = t.TYPE;
                        if (n) {
                            const i = a[n],
                                s = r[n] || [];
                            r[n] = s;
                            const l = t.LANGUAGE,
                                c = t["ASSOC-LANGUAGE"],
                                u = t.CHANNELS,
                                d = t.CHARACTERISTICS,
                                h = t["INSTREAM-ID"],
                                f = {
                                    attrs: t,
                                    bitrate: 0,
                                    id: o++,
                                    groupId: t["GROUP-ID"] || "",
                                    name: t.NAME || l || "",
                                    type: n,
                                    default: t.bool("DEFAULT"),
                                    autoselect: t.bool("AUTOSELECT"),
                                    forced: t.bool("FORCED"),
                                    lang: l,
                                    url: t.URI ? mi.resolve(t.URI, e) : ""
                                };
                            if (c && (f.assocLang = c), u && (f.channels = u), d && (f.characteristics = d), h && (f.instreamId = h), null != i && i.length) {
                                const t = mi.findGroup(i, f.groupId) || i[0];
                                Si(f, t, "audioCodec"), Si(f, t, "textCodec")
                            }
                            s.push(f)
                        }
                    }
                    return r
                }
                static parseLevelPlaylist(t, e, i, r, n, a) {
                    var o;
                    const l = {
                            url: e
                        },
                        c = new Ke(e),
                        u = c.fragments,
                        d = [];
                    let h, f, p, g, m = null,
                        y = 0,
                        v = 0,
                        T = 0,
                        E = 0,
                        S = 0,
                        w = null,
                        k = new W(r, l),
                        A = -1,
                        _ = !1,
                        L = null;
                    if (pi.lastIndex = 0, c.m3u8 = t, c.hasVariableRefs = Ne(t), "#EXTM3U" !== (null == (o = pi.exec(t)) ? void 0 : o[0])) return c.playlistParsingError = new Error("Missing format identifier #EXTM3U"), c;
                    for (; null !== (h = pi.exec(t));) {
                        _ && (_ = !1, k = new W(r, l), k.playlistOffset = T, k.start = T, k.sn = y, k.cc = E, S && (k.bitrate = S), k.level = i, m && (k.initSegment = m, m.rawProgramDateTime && (k.rawProgramDateTime = m.rawProgramDateTime, m.rawProgramDateTime = null), L && (k.setByteRange(L), L = null)));
                        const t = h[1];
                        if (t) {
                            k.duration = parseFloat(t);
                            const e = (" " + h[2]).slice(1);
                            k.title = e || null, k.tagList.push(e ? ["INF", t, e] : ["INF", t])
                        } else if (h[3]) {
                            if (s(k.duration)) {
                                k.playlistOffset = T, k.start = T, p && Ai(k, p, c), k.sn = y, k.level = i, k.cc = E, u.push(k);
                                const t = (" " + h[3]).slice(1);
                                k.relurl = Fe(c, t), wi(k, w, d), w = k, T += k.duration, y++, v = 0, _ = !0
                            }
                        } else {
                            if (h = h[0].match(gi), !h) {
                                R.warn("No matches on slow regex match for level playlist!");
                                continue
                            }
                            for (f = 1; f < h.length && void 0 === h[f]; f++);
                            const t = (" " + h[f]).slice(1),
                                n = (" " + h[f + 1]).slice(1),
                                o = h[f + 2] ? (" " + h[f + 2]).slice(1) : null;
                            switch (t) {
                                case "BYTERANGE":
                                    w ? k.setByteRange(n, w) : k.setByteRange(n);
                                    break;
                                case "PROGRAM-DATE-TIME":
                                    k.rawProgramDateTime = n, k.tagList.push(["PROGRAM-DATE-TIME", n]), -1 === A && (A = u.length);
                                    break;
                                case "PLAYLIST-TYPE":
                                    c.type && _i(c, t, h), c.type = n.toUpperCase();
                                    break;
                                case "MEDIA-SEQUENCE":
                                    0 !== c.startSN ? _i(c, t, h) : u.length > 0 && Li(c, t, h), y = c.startSN = parseInt(n);
                                    break;
                                case "SKIP":
                                    {
                                        c.skippedSegments && _i(c, t, h);
                                        const e = new Ge(n, c),
                                            i = e.decimalInteger("SKIPPED-SEGMENTS");
                                        if (s(i)) {
                                            c.skippedSegments += i;
                                            for (let t = i; t--;) u.push(null);
                                            y += i
                                        }
                                        const r = e.enumeratedString("RECENTLY-REMOVED-DATERANGES");r && (c.recentlyRemovedDateranges = (c.recentlyRemovedDateranges || []).concat(r.split("\t")));
                                        break
                                    }
                                case "TARGETDURATION":
                                    0 !== c.targetduration && _i(c, t, h), c.targetduration = Math.max(parseInt(n), 1);
                                    break;
                                case "VERSION":
                                    null !== c.version && _i(c, t, h), c.version = parseInt(n);
                                    break;
                                case "INDEPENDENT-SEGMENTS":
                                    break;
                                case "ENDLIST":
                                    c.live || _i(c, t, h), c.live = !1;
                                    break;
                                case "#":
                                    (n || o) && k.tagList.push(o ? [n, o] : [n]);
                                    break;
                                case "DISCONTINUITY":
                                    E++, k.tagList.push(["DIS"]);
                                    break;
                                case "GAP":
                                    k.gap = !0, k.tagList.push([t]);
                                    break;
                                case "BITRATE":
                                    k.tagList.push([t, n]), S = 1e3 * parseInt(n), s(S) ? k.bitrate = S : S = 0;
                                    break;
                                case "DATERANGE":
                                    {
                                        const t = new Ge(n, c),
                                            e = new He(t, c.dateRanges[t.ID], c.dateRangeTagCount);c.dateRangeTagCount++,
                                        e.isValid || c.skippedSegments ? c.dateRanges[e.id] = e : R.warn(`Ignoring invalid DATERANGE tag: "${n}"`),
                                        k.tagList.push(["EXT-X-DATERANGE", n]);
                                        break
                                    }
                                case "DEFINE":
                                    {
                                        const t = new Ge(n, c);
                                        "IMPORT" in t ? Ue(c, t, a) : $e(c, t, e)
                                    }
                                    break;
                                case "DISCONTINUITY-SEQUENCE":
                                    0 !== c.startCC ? _i(c, t, h) : u.length > 0 && Li(c, t, h), c.startCC = E = parseInt(n);
                                    break;
                                case "KEY":
                                    {
                                        const t = bi(n, e, c);
                                        if (t.isSupported()) {
                                            if ("NONE" === t.method) {
                                                p = void 0;
                                                break
                                            }
                                            p || (p = {}), p[t.keyFormat] && (p = b({}, p)), p[t.keyFormat] = t
                                        } else R.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${n}"`);
                                        break
                                    }
                                case "START":
                                    c.startTimeOffset = Ti(n);
                                    break;
                                case "MAP":
                                    {
                                        const t = new Ge(n, c);
                                        if (k.duration) {
                                            const e = new W(r, l);
                                            ki(e, t, i, p), m = e, k.initSegment = m, m.rawProgramDateTime && !k.rawProgramDateTime && (k.rawProgramDateTime = m.rawProgramDateTime)
                                        } else {
                                            const e = k.byteRangeEndOffset;
                                            if (e) {
                                                const t = k.byteRangeStartOffset;
                                                L = `${e-t}@${t}`
                                            } else L = null;
                                            ki(k, t, i, p), m = k, _ = !0
                                        }
                                        m.cc = E;
                                        break
                                    }
                                case "SERVER-CONTROL":
                                    g && _i(c, t, h), g = new Ge(n), c.canBlockReload = g.bool("CAN-BLOCK-RELOAD"), c.canSkipUntil = g.optionalFloat("CAN-SKIP-UNTIL", 0), c.canSkipDateRanges = c.canSkipUntil > 0 && g.bool("CAN-SKIP-DATERANGES"), c.partHoldBack = g.optionalFloat("PART-HOLD-BACK", 0), c.holdBack = g.optionalFloat("HOLD-BACK", 0);
                                    break;
                                case "PART-INF":
                                    {
                                        c.partTarget && _i(c, t, h);
                                        const e = new Ge(n);c.partTarget = e.decimalFloatingPoint("PART-TARGET");
                                        break
                                    }
                                case "PART":
                                    {
                                        let t = c.partList;t || (t = c.partList = []);
                                        const e = v > 0 ? t[t.length - 1] : void 0,
                                            i = v++,
                                            s = new Ge(n, c),
                                            r = new Y(s, k, l, i, e);t.push(r),
                                        k.duration += r.duration;
                                        break
                                    }
                                case "PRELOAD-HINT":
                                    {
                                        const t = new Ge(n, c);c.preloadHint = t;
                                        break
                                    }
                                case "RENDITION-REPORT":
                                    {
                                        const t = new Ge(n, c);c.renditionReports = c.renditionReports || [],
                                        c.renditionReports.push(t);
                                        break
                                    }
                                default:
                                    R.warn(`line parsed but not handled: ${h}`)
                            }
                        }
                    }
                    w && !w.relurl ? (u.pop(), T -= w.duration, c.partList && (c.fragmentHint = w)) : c.partList && (wi(k, w, d), k.cc = E, c.fragmentHint = k, p && Ai(k, p, c)), c.targetduration || (c.playlistParsingError = new Error("#EXT-X-TARGETDURATION is required"));
                    const I = u.length,
                        C = u[0],
                        D = u[I - 1];
                    if (T += c.skippedSegments * c.targetduration, T > 0 && I && D) {
                        c.averagetargetduration = T / I;
                        const t = D.sn;
                        c.endSN = "initSegment" !== t ? t : 0, c.live || (D.endList = !0), C && void 0 === c.startCC && (c.startCC = C.cc), A > 0 && (function(t, e) {
                            let i = t[e];
                            for (let s = e; s--;) {
                                const e = t[s];
                                if (!e) return;
                                e.programDateTime = i.programDateTime - 1e3 * e.duration, i = e
                            }
                        }(u, A), C && d.unshift(C))
                    } else c.endSN = 0, c.startCC = 0;
                    return c.fragmentHint && (T += c.fragmentHint.duration), c.totalduration = T, d.length && c.dateRangeTagCount && C && yi(d, c), c.endCC = E, c
                }
            }

            function yi(t, e) {
                const i = t.length,
                    s = t[i - 1],
                    r = e.live ? 1 / 0 : e.totalduration,
                    n = Object.keys(e.dateRanges);
                for (let a = n.length; a--;) {
                    const o = e.dateRanges[n[a]],
                        l = o.startDate.getTime();
                    o.tagAnchor = s.ref;
                    for (let s = i; s--;) {
                        const i = vi(e, l, t, s, r);
                        if (-1 !== i) {
                            o.tagAnchor = e.fragments[i].ref;
                            break
                        }
                    }
                }
            }

            function vi(t, e, i, s, r) {
                const n = i[s];
                if (n) {
                    const o = n.programDateTime;
                    var a;
                    if (e >= o || 0 === s)
                        if (e <= o + 1e3 * (((null == (a = i[s + 1]) ? void 0 : a.start) || r) - n.start)) {
                            const r = i[s].sn - t.startSN,
                                n = t.fragments;
                            if (n.length > i.length)
                                for (let a = (i[s + 1] || n[n.length - 1]).sn - t.startSN; a > r; a--) {
                                    const t = n[a].programDateTime;
                                    if (e >= t && e < t + 1e3 * n[a].duration) return a
                                }
                            return r
                        }
                }
                return -1
            }

            function bi(t, e, i) {
                var s, r;
                const n = new Ge(t, i),
                    a = null != (s = n.METHOD) ? s : "",
                    o = n.URI,
                    l = n.hexadecimalInteger("IV"),
                    c = n.KEYFORMATVERSIONS,
                    u = null != (r = n.KEYFORMAT) ? r : "identity";
                o && n.IV && !l && R.error(`Invalid IV: ${n.IV}`);
                const d = o ? mi.resolve(o, e) : "",
                    h = (c || "1").split("/").map(Number).filter(Number.isFinite);
                return new ui(a, d, u, h, l)
            }

            function Ti(t) {
                const e = new Ge(t).decimalFloatingPoint("TIME-OFFSET");
                return s(e) ? e : null
            }

            function Ei(t, e) {
                let i = (t || "").split(/[ ,]+/).filter((t => t));
                ["video", "audio", "text"].forEach((t => {
                    const s = i.filter((e => At(e, t)));
                    s.length && (e[`${t}Codec`] = s.map((t => t.split("/")[0])).join(","), i = i.filter((t => -1 === s.indexOf(t))))
                })), e.unknownCodecs = i
            }

            function Si(t, e, i) {
                const s = e[i];
                s && (t[i] = s)
            }

            function wi(t, e, i) {
                t.rawProgramDateTime ? i.push(t) : null != e && e.programDateTime && (t.programDateTime = e.endProgramDateTime)
            }

            function ki(t, e, i, s) {
                t.relurl = e.URI, e.BYTERANGE && t.setByteRange(e.BYTERANGE), t.level = i, t.sn = "initSegment", s && (t.levelkeys = s), t.initSegment = null
            }

            function Ai(t, e, i) {
                t.levelkeys = e;
                const {
                    encryptedFragments: s
                } = i;
                s.length && s[s.length - 1].levelkeys === e || !Object.keys(e).some((t => e[t].isCommonEncryption)) || s.push(t)
            }

            function _i(t, e, i) {
                t.playlistParsingError = new Error(`#EXT-X-${e} must not appear more than once (${i[0]})`)
            }

            function Li(t, e, i) {
                t.playlistParsingError = new Error(`#EXT-X-${e} must appear before the first Media Segment (${i[0]})`)
            }

            function Ri(t, e) {
                const i = e.startPTS;
                if (s(i)) {
                    let s, r = 0;
                    e.sn > t.sn ? (r = i - t.start, s = t) : (r = t.start - i, s = e), s.duration !== r && s.setDuration(r)
                } else e.sn > t.sn ? t.cc === e.cc && t.minEndPTS ? e.setStart(t.start + (t.minEndPTS - t.start)) : e.setStart(t.start + t.duration) : e.setStart(Math.max(t.start - e.duration, 0))
            }

            function Ii(t, e, i, r, n, a) {
                r - i <= 0 && (R.warn("Fragment should have a positive duration", e), r = i + e.duration, a = n + e.duration);
                let o = i,
                    l = r;
                const c = e.startPTS,
                    u = e.endPTS;
                if (s(c)) {
                    const t = Math.abs(c - i);
                    s(e.deltaPTS) ? e.deltaPTS = Math.max(t, e.deltaPTS) : e.deltaPTS = t, o = Math.max(i, c), i = Math.min(i, c), n = Math.min(n, e.startDTS), l = Math.min(r, u), r = Math.max(r, u), a = Math.max(a, e.endDTS)
                }
                const d = i - e.start;
                0 !== e.start && e.setStart(i), e.setDuration(r - e.start), e.startPTS = i, e.maxStartPTS = o, e.startDTS = n, e.endPTS = r, e.minEndPTS = l, e.endDTS = a;
                const h = e.sn;
                if (!t || h < t.startSN || h > t.endSN) return 0;
                let f;
                const p = h - t.startSN,
                    g = t.fragments;
                for (g[p] = e, f = p; f > 0; f--) Ri(g[f], g[f - 1]);
                for (f = p; f < g.length - 1; f++) Ri(g[f], g[f + 1]);
                return t.fragmentHint && Ri(g[g.length - 1], t.fragmentHint), t.PTSKnown = t.alignedSliding = !0, d
            }

            function Ci(t, e, i, s, r) {
                return new Error(`${t} ${r.url}\nPlaylist starting @${e.startSN}\n${e.m3u8}\n\nPlaylist starting @${i.startSN}\n${i.m3u8}`)
            }

            function Di(t, e, i = !0) {
                const s = e.startSN + e.skippedSegments - t.startSN,
                    r = t.fragments,
                    n = s >= 0;
                let a = 0;
                if (n && s < r.length) a = r[s].start;
                else if (n && e.startSN === t.endSN + 1) a = t.fragmentEnd;
                else if (n && i) a = t.fragmentStart + s * e.levelTargetDuration;
                else {
                    if (e.skippedSegments || 0 !== e.fragmentStart) return;
                    a = t.fragmentStart
                }
                xi(e, a)
            }

            function xi(t, e) {
                if (e) {
                    const i = t.fragments;
                    for (let s = t.skippedSegments; s < i.length; s++) i[s].addStart(e);
                    t.fragmentHint && t.fragmentHint.addStart(e)
                }
            }

            function Pi(t, e = 1 / 0) {
                let i = 1e3 * t.targetduration;
                if (t.updated) {
                    const s = t.fragments,
                        r = 4;
                    if (s.length && i * r > e) {
                        const t = 1e3 * s[s.length - 1].duration;
                        t < i && (i = t)
                    }
                } else i /= 2;
                return Math.round(i)
            }

            function Oi(t, e, i) {
                return t ? Mi(t.partList, e, i) : null
            }

            function Mi(t, e, i) {
                if (t)
                    for (let s = t.length; s--;) {
                        const r = t[s];
                        if (r.index === i && r.fragment.sn === e) return r
                    }
                return null
            }

            function Ni(t) {
                t.forEach(((t, e) => {
                    var i;
                    null == (i = t.details) || i.fragments.forEach((t => {
                        t.level = e, t.initSegment && (t.initSegment.level = e)
                    }))
                }))
            }

            function Fi(t, e) {
                for (let s = 0, r = t.length; s < r; s++) {
                    var i;
                    if ((null == (i = t[s]) ? void 0 : i.cc) === e) return t[s]
                }
                return null
            }

            function $i(t, e) {
                if (t) {
                    const i = t.start + e;
                    t.start = t.startPTS = i, t.endPTS = i + t.duration
                }
            }

            function Ui(t, e) {
                const i = e.fragments;
                for (let e = 0, s = i.length; e < s; e++) $i(i[e], t);
                e.fragmentHint && $i(e.fragmentHint, t), e.alignedSliding = !0
            }

            function Bi(t, e) {
                if (! function(t, e) {
                        return !!(t && e.startCC < t.endCC && e.endCC > t.startCC)
                    }(e, t)) return;
                const i = Math.min(e.endCC, t.endCC),
                    s = Fi(e.fragments, i),
                    r = Fi(t.fragments, i);
                s && r && (R.log(`Aligning playlist at start of dicontinuity sequence ${i}`), Ui(s.start - r.start, t))
            }

            function ji(t, e) {
                if (!t.hasProgramDateTime || !e.hasProgramDateTime) return;
                const i = t.fragments,
                    s = e.fragments;
                if (!i.length || !s.length) return;
                let r, n;
                const a = Math.min(e.endCC, t.endCC);
                e.startCC < a && t.startCC < a && (r = Fi(s, a), n = Fi(i, a)), r && n || (r = s[Math.floor(s.length / 2)], n = Fi(i, r.cc) || i[Math.floor(i.length / 2)]);
                const o = r.programDateTime,
                    l = n.programDateTime;
                o && l && Ui((l - o) / 1e3 - (n.start - r.start), t)
            }
            const Gi = {
                STOPPED: "STOPPED",
                IDLE: "IDLE",
                KEY_LOADING: "KEY_LOADING",
                FRAG_LOADING: "FRAG_LOADING",
                FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
                WAITING_TRACK: "WAITING_TRACK",
                PARSING: "PARSING",
                PARSED: "PARSED",
                ENDED: "ENDED",
                ERROR: "ERROR",
                WAITING_INIT_PTS: "WAITING_INIT_PTS",
                WAITING_LEVEL: "WAITING_LEVEL"
            };
            class Vi extends De {
                constructor(t, e, i, r, n) {
                    super(r, t.logger), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = Gi.STOPPED, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.buffering = !0, this.loadingParts = !1, this.loopSn = void 0, this.onMediaSeeking = () => {
                        const {
                            config: t,
                            fragCurrent: e,
                            media: i,
                            mediaBuffer: r,
                            state: n
                        } = this, a = i ? i.currentTime : 0, o = Oe.bufferInfo(r || i, a, t.maxBufferHole);
                        if (this.log(`media seeking to ${s(a)?a.toFixed(3):a}, state: ${n}`), this.state === Gi.ENDED) this.resetLoadingState();
                        else if (e) {
                            const i = t.maxFragLookUpTolerance,
                                s = e.start - i,
                                r = e.start + e.duration + i;
                            if (!o.len || r < o.start || s > o.end) {
                                const t = a > r;
                                (a < s || t) && (t && e.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), e.abortRequests(), this.resetLoadingState()), this.fragPrevious = null)
                            }
                        }
                        if (i && (this.fragmentTracker.removeFragmentsInRange(a, 1 / 0, this.playlistType, !0), a > this.lastCurrentTime && (this.lastCurrentTime = a), !this.loadingParts)) {
                            const t = Math.max(o.end, a),
                                e = this.shouldLoadParts(this.getLevelDetails(), t);
                            e && (this.log(`LL-Part loading ON after seeking to ${a.toFixed(2)} with buffer @${t.toFixed(2)}`), this.loadingParts = e)
                        }
                        this.hls.hasEnoughToStart || o.len || (this.log(`setting startPosition to ${a} because of seek before start`), this.nextLoadPosition = this.startPosition = a), this.tickImmediate()
                    }, this.onMediaEnded = () => {
                        this.log("setting startPosition to 0 because media ended"), this.startPosition = this.lastCurrentTime = 0
                    }, this.playlistType = n, this.hls = t, this.fragmentLoader = new Le(t.config), this.keyLoader = i, this.fragmentTracker = e, this.config = t.config, this.decrypter = new Ae(t.config)
                }
                registerListeners() {
                    const {
                        hls: t
                    } = this;
                    t.on(l.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(l.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(l.MANIFEST_LOADING, this.onManifestLoading, this), t.on(l.MANIFEST_LOADED, this.onManifestLoaded, this), t.on(l.ERROR, this.onError, this)
                }
                unregisterListeners() {
                    const {
                        hls: t
                    } = this;
                    t.off(l.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(l.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(l.MANIFEST_LOADING, this.onManifestLoading, this), t.off(l.MANIFEST_LOADED, this.onManifestLoaded, this), t.off(l.ERROR, this.onError, this)
                }
                doTick() {
                    this.onTickEnd()
                }
                onTickEnd() {}
                startLoad(t) {}
                stopLoad() {
                    if (this.state === Gi.STOPPED) return;
                    this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType);
                    const t = this.fragCurrent;
                    null != t && t.loader && (t.abortRequests(), this.fragmentTracker.removeFragment(t)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = Gi.STOPPED
                }
                get startPositionValue() {
                    const {
                        nextLoadPosition: t,
                        startPosition: e
                    } = this;
                    return -1 === e && t ? t : e
                }
                get bufferingEnabled() {
                    return this.buffering
                }
                pauseBuffering() {
                    this.buffering = !1
                }
                resumeBuffering() {
                    this.buffering = !0
                }
                get inFlightFrag() {
                    return {
                        frag: this.fragCurrent,
                        state: this.state
                    }
                }
                _streamEnded(t, e) {
                    if (e.live || !this.media) return !1;
                    const i = t.end || 0,
                        s = this.config.timelineOffset || 0;
                    if (i <= s) return !1;
                    const r = t.nextStart;
                    if (r && r > s && r < e.edge) return !1;
                    if (this.media.currentTime < t.start) return !1;
                    const n = e.partList;
                    if (null != n && n.length) {
                        const t = n[n.length - 1];
                        return Oe.isBuffered(this.media, t.start + t.duration / 2)
                    }
                    const a = e.fragments[e.fragments.length - 1].type;
                    return this.fragmentTracker.isEndListAppended(a)
                }
                getLevelDetails() {
                    var t;
                    if (this.levels && null !== this.levelLastLoaded) return null == (t = this.levelLastLoaded) ? void 0 : t.details
                }
                get timelineOffset() {
                    const t = this.config.timelineOffset;
                    var e;
                    return t ? (null == (e = this.getLevelDetails()) ? void 0 : e.appliedTimelineOffset) || t : 0
                }
                onMediaAttached(t, e) {
                    const i = this.media = this.mediaBuffer = e.media;
                    i.removeEventListener("seeking", this.onMediaSeeking), i.removeEventListener("ended", this.onMediaEnded), i.addEventListener("seeking", this.onMediaSeeking), i.addEventListener("ended", this.onMediaEnded);
                    const s = this.config;
                    this.levels && s.autoStartLoad && this.state === Gi.STOPPED && this.startLoad(s.startPosition)
                }
                onMediaDetaching(t, e) {
                    const i = !!e.transferMedia,
                        s = this.media;
                    if (null !== s) {
                        if (s.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), s.removeEventListener("seeking", this.onMediaSeeking), s.removeEventListener("ended", this.onMediaEnded), this.keyLoader && !i && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loopSn = void 0, i) return this.resetLoadingState(), void this.resetTransmuxer();
                        this.loadingParts = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad()
                    }
                }
                onManifestLoading() {
                    this.initPTS = [], this.levels = this.levelLastLoaded = this.fragCurrent = null, this.lastCurrentTime = this.startPosition = 0, this.startFragRequested = !1
                }
                onError(t, e) {}
                onManifestLoaded(t, e) {
                    this.startTimeOffset = e.startTimeOffset
                }
                onHandlerDestroying() {
                    this.stopLoad(), this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null), super.onHandlerDestroying(), this.hls = this.onMediaSeeking = this.onMediaEnded = null
                }
                onHandlerDestroyed() {
                    this.state = Gi.STOPPED, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed()
                }
                loadFragment(t, e, i) {
                    this.startFragRequested = !0, this._loadFragForPlayback(t, e, i)
                }
                _loadFragForPlayback(t, e, i) {
                    this._doFragLoad(t, e, i, (t => {
                        const e = t.frag;
                        if (this.fragContextChanged(e)) return this.warn(`${e.type} sn: ${e.sn}${t.part?" part: "+t.part.index:""} of ${this.fragInfo(e,!1,t.part)}) was dropped during download.`), void this.fragmentTracker.removeFragment(e);
                        e.stats.chunkCount++, this._handleFragmentLoadProgress(t)
                    })).then((t => {
                        if (!t) return;
                        const e = this.state,
                            i = t.frag;
                        this.fragContextChanged(i) ? (e === Gi.FRAG_LOADING || !this.fragCurrent && e === Gi.PARSING) && (this.fragmentTracker.removeFragment(i), this.state = Gi.IDLE) : ("payload" in t && (this.log(`Loaded ${i.type} sn: ${i.sn} of ${this.playlistLabel()} ${i.level}`), this.hls.trigger(l.FRAG_LOADED, t)), this._handleFragmentLoadComplete(t))
                    })).catch((e => {
                        this.state !== Gi.STOPPED && this.state !== Gi.ERROR && (this.warn(`Frag error: ${(null==e?void 0:e.message)||e}`), this.resetFragmentLoading(t))
                    }))
                }
                clearTrackerIfNeeded(t) {
                    var e;
                    const {
                        fragmentTracker: i
                    } = this;
                    if (i.getState(t) === me) {
                        const e = t.type,
                            s = this.getFwdBufferInfo(this.mediaBuffer, e),
                            r = Math.max(t.duration, s ? s.len : this.config.maxBufferLength),
                            n = this.backtrackFragment;
                        (1 == (n ? t.sn - n.sn : 0) || this.reduceMaxBufferLength(r, t.duration)) && i.removeFragment(t)
                    } else 0 === (null == (e = this.mediaBuffer) ? void 0 : e.buffered.length) ? i.removeAllFragments() : i.hasParts(t.type) && (i.detectPartialFragments({
                        frag: t,
                        part: null,
                        stats: t.stats,
                        id: t.type
                    }), i.getState(t) === ye && i.removeFragment(t))
                }
                checkLiveUpdate(t) {
                    if (t.updated && !t.live) {
                        const e = t.fragments[t.fragments.length - 1];
                        this.fragmentTracker.detectPartialFragments({
                            frag: e,
                            part: null,
                            stats: e.stats,
                            id: e.type
                        })
                    }
                    t.fragments[0] || (t.deltaUpdateFailed = !0)
                }
                waitForLive(t) {
                    const e = t.details;
                    return (null == e ? void 0 : e.live) && "EVENT" !== e.type && (this.levelLastLoaded !== t || e.expired)
                }
                flushMainBuffer(t, e, i = null) {
                    if (!(t - e)) return;
                    const s = {
                        startOffset: t,
                        endOffset: e,
                        type: i
                    };
                    this.hls.trigger(l.BUFFER_FLUSHING, s)
                }
                _loadInitSegment(t, e) {
                    this._doFragLoad(t, e).then((t => {
                        const e = null == t ? void 0 : t.frag;
                        if (!e || this.fragContextChanged(e) || !this.levels) throw new Error("init load aborted");
                        return t
                    })).then((t => {
                        const {
                            hls: e
                        } = this, {
                            frag: i,
                            payload: s
                        } = t, r = i.decryptdata;
                        if (s && s.byteLength > 0 && null != r && r.key && r.iv && ze(r.method)) {
                            const n = self.performance.now();
                            return this.decrypter.decrypt(new Uint8Array(s), r.key.buffer, r.iv.buffer, qe(r.method)).catch((t => {
                                throw e.trigger(l.ERROR, {
                                    type: a.MEDIA_ERROR,
                                    details: o.FRAG_DECRYPT_ERROR,
                                    fatal: !1,
                                    error: t,
                                    reason: t.message,
                                    frag: i
                                }), t
                            })).then((s => {
                                const r = self.performance.now();
                                return e.trigger(l.FRAG_DECRYPTED, {
                                    frag: i,
                                    payload: s,
                                    stats: {
                                        tstart: n,
                                        tdecrypt: r
                                    }
                                }), t.payload = s, this.completeInitSegmentLoad(t)
                            }))
                        }
                        return this.completeInitSegmentLoad(t)
                    })).catch((e => {
                        this.state !== Gi.STOPPED && this.state !== Gi.ERROR && (this.warn(e), this.resetFragmentLoading(t))
                    }))
                }
                completeInitSegmentLoad(t) {
                    const {
                        levels: e
                    } = this;
                    if (!e) throw new Error("init load aborted, missing levels");
                    const i = t.frag.stats;
                    this.state !== Gi.STOPPED && (this.state = Gi.IDLE), t.frag.data = new Uint8Array(t.payload), i.parsing.start = i.buffering.start = self.performance.now(), i.parsing.end = i.buffering.end = self.performance.now(), this.tick()
                }
                fragContextChanged(t) {
                    const {
                        fragCurrent: e
                    } = this;
                    return !t || !e || t.sn !== e.sn || t.level !== e.level
                }
                fragBufferedComplete(t, e) {
                    const i = this.mediaBuffer ? this.mediaBuffer : this.media;
                    if (this.log(`Buffered ${t.type} sn: ${t.sn}${e?" part: "+e.index:""} of ${this.fragInfo(t,!1,e)} > buffer:${i?function(t){let e="";const i=t.length;for(let s=0;s<i;s++)e+=`[${t.start(s).toFixed(3)}-${t.end(s).toFixed(3)}]`;return e}(Oe.getBuffered(i)):"(detached)"})`), q(t)) {
                        var s;
                        if (t.type !== g) {
                            const e = t.elementaryStreams;
                            if (!Object.keys(e).some((t => !!e[t]))) return void(this.state = Gi.IDLE)
                        }
                        const e = null == (s = this.levels) ? void 0 : s[t.level];
                        null != e && e.fragmentError && (this.log(`Resetting level fragment error count of ${e.fragmentError} on frag buffered`), e.fragmentError = 0)
                    }
                    this.state = Gi.IDLE
                }
                _handleFragmentLoadComplete(t) {
                    const {
                        transmuxer: e
                    } = this;
                    if (!e) return;
                    const {
                        frag: i,
                        part: s,
                        partsLoaded: r
                    } = t, n = !r || 0 === r.length || r.some((t => !t)), a = new xe(i.level, i.sn, i.stats.chunkCount + 1, 0, s ? s.index : -1, !n);
                    e.flush(a)
                }
                _handleFragmentLoadProgress(t) {}
                _doFragLoad(t, e, i = null, r) {
                    var n;
                    this.fragCurrent = t;
                    const a = null == e ? void 0 : e.details;
                    if (!this.levels || !a) throw new Error(`frag load aborted, missing level${a?"":" detail"}s`);
                    let o = null;
                    !t.encrypted || null != (n = t.decryptdata) && n.key ? !t.encrypted && a.encryptedFragments.length && this.keyLoader.loadClear(t, a.encryptedFragments) : (this.log(`Loading key for ${t.sn} of [${a.startSN}-${a.endSN}], ${this.playlistLabel()} ${t.level}`), this.state = Gi.KEY_LOADING, this.fragCurrent = t, o = this.keyLoader.load(t).then((t => {
                        if (!this.fragContextChanged(t.frag)) return this.hls.trigger(l.KEY_LOADED, t), this.state === Gi.KEY_LOADING && (this.state = Gi.IDLE), t
                    })), this.hls.trigger(l.KEY_LOADING, {
                        frag: t
                    }), null === this.fragCurrent && (o = Promise.reject(new Error("frag load aborted, context changed in KEY_LOADING"))));
                    const c = this.fragPrevious;
                    if (q(t) && (!c || t.sn !== c.sn)) {
                        const i = this.shouldLoadParts(e.details, t.end);
                        i !== this.loadingParts && (this.log(`LL-Part loading ${i?"ON":"OFF"} loading sn ${null==c?void 0:c.sn}->${t.sn}`), this.loadingParts = i)
                    }
                    if (i = Math.max(t.start, i || 0), this.loadingParts && q(t)) {
                        const s = a.partList;
                        if (s && r) {
                            i > t.end && a.fragmentHint && (t = a.fragmentHint);
                            const n = this.getNextPart(s, t, i);
                            if (n > -1) {
                                const c = s[n];
                                let u;
                                return t = this.fragCurrent = c.fragment, this.log(`Loading ${t.type} sn: ${t.sn} part: ${c.index} (${n}/${s.length-1}) of ${this.fragInfo(t,!1,c)}) cc: ${t.cc} [${a.startSN}-${a.endSN}], target: ${parseFloat(i.toFixed(3))}`), this.nextLoadPosition = c.start + c.duration, this.state = Gi.FRAG_LOADING, u = o ? o.then((i => !i || this.fragContextChanged(i.frag) ? null : this.doFragPartsLoad(t, c, e, r))).catch((t => this.handleFragLoadError(t))) : this.doFragPartsLoad(t, c, e, r).catch((t => this.handleFragLoadError(t))), this.hls.trigger(l.FRAG_LOADING, {
                                    frag: t,
                                    part: c,
                                    targetBufferTime: i
                                }), null === this.fragCurrent ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts")) : u
                            }
                            if (!t.url || this.loadedEndOfParts(s, i)) return Promise.resolve(null)
                        }
                    }
                    if (q(t) && this.loadingParts) this.log(`LL-Part loading OFF after next part miss @${i.toFixed(2)}`), this.loadingParts = !1;
                    else if (!t.url) return Promise.resolve(null);
                    this.log(`Loading ${t.type} sn: ${t.sn} of ${this.fragInfo(t,!1)}) cc: ${t.cc} ${a?"["+a.startSN+"-"+a.endSN+"]":""}, target: ${parseFloat(i.toFixed(3))}`), s(t.sn) && !this.bitrateTest && (this.nextLoadPosition = t.start + t.duration), this.state = Gi.FRAG_LOADING;
                    const u = this.config.progressive;
                    let d;
                    return d = u && o ? o.then((e => !e || this.fragContextChanged(null == e ? void 0 : e.frag) ? null : this.fragmentLoader.load(t, r))).catch((t => this.handleFragLoadError(t))) : Promise.all([this.fragmentLoader.load(t, u ? r : void 0), o]).then((([t]) => (!u && t && r && r(t), t))).catch((t => this.handleFragLoadError(t))), this.hls.trigger(l.FRAG_LOADING, {
                        frag: t,
                        targetBufferTime: i
                    }), null === this.fragCurrent ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING")) : d
                }
                doFragPartsLoad(t, e, i, s) {
                    return new Promise(((r, n) => {
                        var a;
                        const o = [],
                            c = null == (a = i.details) ? void 0 : a.partList,
                            u = e => {
                                this.fragmentLoader.loadPart(t, e, s).then((s => {
                                    o[e.index] = s;
                                    const n = s.part;
                                    this.hls.trigger(l.FRAG_LOADED, s);
                                    const a = Oi(i.details, t.sn, e.index + 1) || Mi(c, t.sn, e.index + 1);
                                    if (!a) return r({
                                        frag: t,
                                        part: n,
                                        partsLoaded: o
                                    });
                                    u(a)
                                })).catch(n)
                            };
                        u(e)
                    }))
                }
                handleFragLoadError(t) {
                    if ("data" in t) {
                        const e = t.data;
                        t.data && e.details === o.INTERNAL_ABORTED ? this.handleFragLoadAborted(e.frag, e.part) : this.hls.trigger(l.ERROR, e)
                    } else this.hls.trigger(l.ERROR, {
                        type: a.OTHER_ERROR,
                        details: o.INTERNAL_EXCEPTION,
                        err: t,
                        error: t,
                        fatal: !0
                    });
                    return null
                }
                _handleTransmuxerFlush(t) {
                    const e = this.getCurrentContext(t);
                    if (!e || this.state !== Gi.PARSING) return void(this.fragCurrent || this.state === Gi.STOPPED || this.state === Gi.ERROR || (this.state = Gi.IDLE));
                    const {
                        frag: i,
                        part: s,
                        level: r
                    } = e, n = self.performance.now();
                    i.stats.parsing.end = n, s && (s.stats.parsing.end = n);
                    const a = this.getLevelDetails(),
                        o = a && i.sn > a.endSN || this.shouldLoadParts(a, i.end);
                    o !== this.loadingParts && (this.log(`LL-Part loading ${o?"ON":"OFF"} after parsing segment ending @${i.end.toFixed(2)}`), this.loadingParts = o), this.updateLevelTiming(i, s, r, t.partial)
                }
                shouldLoadParts(t, e) {
                    if (this.config.lowLatencyMode) {
                        if (!t) return this.loadingParts;
                        if (null != t && t.partList) {
                            var i;
                            const r = t.partList[0];
                            var s;
                            if (e >= r.end + ((null == (i = t.fragmentHint) ? void 0 : i.duration) || 0))
                                if ((this.hls.hasEnoughToStart ? (null == (s = this.media) ? void 0 : s.currentTime) || this.lastCurrentTime : this.getLoadPosition()) > r.start - r.fragment.duration) return !0
                        }
                    }
                    return !1
                }
                getCurrentContext(t) {
                    const {
                        levels: e,
                        fragCurrent: i
                    } = this, {
                        level: s,
                        sn: r,
                        part: n
                    } = t;
                    if (null == e || !e[s]) return this.warn(`Levels object was unset while buffering fragment ${r} of ${this.playlistLabel()} ${s}. The current chunk will not be buffered.`), null;
                    const a = e[s],
                        o = a.details,
                        l = n > -1 ? Oi(o, r, n) : null,
                        c = l ? l.fragment : function(t, e, i) {
                            if (!t) return null;
                            let s = t.fragments[e - t.startSN];
                            return s || (s = t.fragmentHint, s && s.sn === e ? s : e < t.startSN && i && i.sn === e ? i : null)
                        }(o, r, i);
                    return c ? (i && i !== c && (c.stats = i.stats), {
                        frag: c,
                        part: l,
                        level: a
                    }) : null
                }
                bufferFragmentData(t, e, i, s, r) {
                    var n;
                    if (!t || this.state !== Gi.PARSING) return;
                    const {
                        data1: a,
                        data2: o
                    } = t;
                    let c = a;
                    if (a && o && (c = mt(a, o)), null == (n = c) || !n.length) return;
                    const u = {
                        type: t.type,
                        frag: e,
                        part: i,
                        chunkMeta: s,
                        parent: e.type,
                        data: c
                    };
                    if (this.hls.trigger(l.BUFFER_APPENDING, u), t.dropped && t.independent && !i) {
                        if (r) return;
                        this.flushBufferGap(e)
                    }
                }
                flushBufferGap(t) {
                    const e = this.media;
                    if (!e) return;
                    if (!Oe.isBuffered(e, e.currentTime)) return void this.flushMainBuffer(0, t.start);
                    const i = e.currentTime,
                        s = Oe.bufferInfo(e, i, 0),
                        r = t.duration,
                        n = Math.min(2 * this.config.maxFragLookUpTolerance, .25 * r),
                        a = Math.max(Math.min(t.start - n, s.end - n), i + n);
                    t.start - a > n && this.flushMainBuffer(a, t.start)
                }
                getFwdBufferInfo(t, e) {
                    var i;
                    const r = this.getLoadPosition();
                    if (!s(r)) return null;
                    const n = this.lastCurrentTime > r || null != (i = this.media) && i.paused ? 0 : this.config.maxBufferHole;
                    return this.getFwdBufferInfoAtPos(t, r, e, n)
                }
                getFwdBufferInfoAtPos(t, e, i, s) {
                    const r = Oe.bufferInfo(t, e, s);
                    if (0 === r.len && void 0 !== r.nextStart) {
                        const n = this.fragmentTracker.getBufferedFrag(e, i);
                        if (n && (r.nextStart <= n.end || n.gap)) {
                            const i = Math.max(Math.min(r.nextStart, n.end) - e, s);
                            return Oe.bufferInfo(t, e, i)
                        }
                    }
                    return r
                }
                getMaxBufferLength(t) {
                    const {
                        config: e
                    } = this;
                    let i;
                    return i = t ? Math.max(8 * e.maxBufferSize / t, e.maxBufferLength) : e.maxBufferLength, Math.min(i, e.maxMaxBufferLength)
                }
                reduceMaxBufferLength(t, e) {
                    const i = this.config,
                        s = Math.max(Math.min(t - e, i.maxBufferLength), e),
                        r = Math.max(t - 3 * e, i.maxMaxBufferLength / 2, s);
                    return r >= s && (i.maxMaxBufferLength = r, this.warn(`Reduce max buffer length to ${r}s`), !0)
                }
                getAppendedFrag(t, e = f) {
                    var i;
                    const s = null == (i = this.fragmentTracker) ? void 0 : i.getAppendedFrag(t, e);
                    return s && "fragment" in s ? s.fragment : s
                }
                getNextFragment(t, e) {
                    const i = e.fragments,
                        s = i.length;
                    if (!s) return null;
                    const {
                        config: r
                    } = this, n = i[0].start, a = r.lowLatencyMode && !!e.partList;
                    let o = null;
                    if (e.live) {
                        const c = r.initialLiveManifestSize;
                        if (s < c) return this.warn(`Not enough fragments to start playback (have: ${s}, need: ${c})`), null;
                        if (!e.PTSKnown && !this.startFragRequested && -1 === this.startPosition || t < n) {
                            var l;
                            a && !this.loadingParts && (this.log("LL-Part loading ON for initial live fragment"), this.loadingParts = !0), o = this.getInitialLiveFragment(e, i);
                            const s = this.hls.startPosition,
                                r = this.hls.liveSyncPosition,
                                c = o ? (-1 !== s && s >= n ? s : r) || o.start : t;
                            this.log(`Setting startPosition to ${c} to match start frag at live edge. mainStart: ${s} liveSyncPosition: ${r} frag.start: ${null==(l=o)?void 0:l.start}`), this.startPosition = this.nextLoadPosition = c
                        }
                    } else t <= n && (o = i[0]);
                    if (!o) {
                        const i = this.loadingParts ? e.partEnd : e.fragmentEnd;
                        o = this.getFragmentAtPosition(t, i, e)
                    }
                    let c = this.filterReplacedPrimary(o, e);
                    if (!c && o) {
                        const t = o.sn - e.startSN;
                        c = this.filterReplacedPrimary(i[t + 1] || null, e)
                    }
                    return this.mapToInitFragWhenRequired(c)
                }
                isLoopLoading(t, e) {
                    const i = this.fragmentTracker.getState(t);
                    return (i === ve || i === ye && !!t.gap) && this.nextLoadPosition > e
                }
                getNextFragmentLoopLoading(t, e, i, s, r) {
                    let n = null;
                    if (t.gap && (n = this.getNextFragment(this.nextLoadPosition, e), n && !n.gap && i.nextStart)) {
                        const t = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, i.nextStart, s, 0);
                        if (null !== t && i.len + t.len >= r) {
                            const t = n.sn;
                            return this.loopSn !== t && (this.log(`buffer full after gaps in "${s}" playlist starting at sn: ${t}`), this.loopSn = t), null
                        }
                    }
                    return this.loopSn = void 0, n
                }
                get primaryPrefetch() {
                    var t, e;
                    if (Hi(this.hls.config) && (null == (t = this.hls.interstitialsManager) || null == (e = t.playingItem) ? void 0 : e.event)) return !0;
                    return !1
                }
                filterReplacedPrimary(t, e) {
                    if (!t) return t;
                    if (Hi(this.hls.config) && t.type !== g) {
                        const i = this.hls.interstitialsManager,
                            s = null == i ? void 0 : i.bufferingItem;
                        if (s) {
                            const i = s.event;
                            if (i) {
                                if (i.appendInPlace || Math.abs(t.start - s.start) > 1 || 0 === s.start) return null
                            } else {
                                if (t.end <= s.start && !1 === (null == e ? void 0 : e.live)) return null;
                                if (t.start > s.end && s.nextEvent && (s.nextEvent.appendInPlace || t.start - s.end > 1)) return null
                            }
                        }
                        const r = null == i ? void 0 : i.playerQueue;
                        if (r)
                            for (let e = r.length; e--;) {
                                const i = r[e].interstitial;
                                if (i.appendInPlace && t.start >= i.startTime && t.end <= i.resumeTime) return null
                            }
                    }
                    return t
                }
                mapToInitFragWhenRequired(t) {
                    return null == t || !t.initSegment || null != t && t.initSegment.data || this.bitrateTest ? t : t.initSegment
                }
                getNextPart(t, e, i) {
                    let s = -1,
                        r = !1,
                        n = !0;
                    for (let a = 0, o = t.length; a < o; a++) {
                        const o = t[a];
                        if (n = n && !o.independent, s > -1 && i < o.start) break;
                        const l = o.loaded;
                        l ? s = -1 : (r || o.independent || n) && o.fragment === e && (s = a), r = l
                    }
                    return s
                }
                loadedEndOfParts(t, e) {
                    const i = t[t.length - 1];
                    return i && e > i.start && i.loaded
                }
                getInitialLiveFragment(t, e) {
                    const i = this.fragPrevious;
                    let r = null;
                    if (i) {
                        if (t.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${i.programDateTime}`), r = function(t, e, i) {
                                if (null === e || !Array.isArray(t) || !t.length || !s(e)) return null;
                                if (e < (t[0].programDateTime || 0)) return null;
                                if (e >= (t[t.length - 1].endProgramDateTime || 0)) return null;
                                i = i || 0;
                                for (let s = 0; s < t.length; ++s) {
                                    const r = t[s];
                                    if (oe(e, i, r)) return r
                                }
                                return null
                            }(e, i.endProgramDateTime, this.config.maxFragLookUpTolerance)), !r) {
                            const s = i.sn + 1;
                            if (s >= t.startSN && s <= t.endSN) {
                                const n = e[s - t.startSN];
                                i.cc === n.cc && (r = n, this.log(`Live playlist, switching playlist, load frag with next SN: ${r.sn}`))
                            }
                            r || (r = le(e, i.cc), r && this.log(`Live playlist, switching playlist, load frag with same CC: ${r.sn}`))
                        }
                    } else {
                        const e = this.hls.liveSyncPosition;
                        null !== e && (r = this.getFragmentAtPosition(e, this.bitrateTest ? t.fragmentEnd : t.edge, t))
                    }
                    return r
                }
                getFragmentAtPosition(t, e, i) {
                    const {
                        config: s
                    } = this;
                    let {
                        fragPrevious: r
                    } = this, {
                        fragments: n,
                        endSN: a
                    } = i;
                    const {
                        fragmentHint: o
                    } = i, {
                        maxFragLookUpTolerance: l
                    } = s, c = i.partList, u = !!(this.loadingParts && null != c && c.length && o);
                    let d;
                    var h;
                    (u && o && !this.bitrateTest && c[c.length - 1].fragment.sn === o.sn && (n = n.concat(o), a = o.sn), t < e) ? d = ne(r, n, t, t < this.lastCurrentTime || t > e - l || null != (h = this.media) && h.paused || !this.startFragRequested ? 0 : l): d = n[n.length - 1];
                    if (d) {
                        const t = d.sn - i.startSN,
                            e = this.fragmentTracker.getState(d);
                        if ((e === ve || e === ye && d.gap) && (r = d), r && d.sn === r.sn && (!u || c[0].fragment.sn > d.sn || !i.live && !u) && r && d.level === r.level) {
                            const e = n[t + 1];
                            d = d.sn < a && this.fragmentTracker.getState(e) !== ve ? e : null
                        }
                    }
                    return d
                }
                alignPlaylists(t, e, i) {
                    const r = t.fragments.length;
                    if (!r) return this.warn("No fragments in live playlist"), 0;
                    const n = t.fragmentStart,
                        a = !e,
                        o = t.alignedSliding && s(n);
                    if (a || !o && !n) {
                        ! function(t, e) {
                            t && (Bi(e, t), !e.alignedSliding && t && ji(e, t), e.alignedSliding || !t || e.skippedSegments || Di(t, e, !1))
                        }(i, t);
                        const s = t.fragmentStart;
                        return this.log(`Live playlist sliding: ${s.toFixed(2)} start-sn: ${e?e.startSN:"na"}->${t.startSN} fragments: ${r}`), s
                    }
                    return n
                }
                waitForCdnTuneIn(t) {
                    return t.live && t.canBlockReload && t.partTarget && t.tuneInGoal > Math.max(t.partHoldBack, 3 * t.partTarget)
                }
                setStartPosition(t, e) {
                    let i = this.startPosition;
                    i < e && (i = -1);
                    const r = this.timelineOffset;
                    if (-1 === i) {
                        const n = null !== this.startTimeOffset,
                            a = n ? this.startTimeOffset : t.startTimeOffset;
                        null !== a && s(a) ? (i = e + a, a < 0 && (i += t.edge), i = Math.min(Math.max(e, i), e + t.totalduration), this.log(`Setting startPosition to ${i} for start time offset ${a} found in ${n?"multivariant":"media"} playlist`), this.startPosition = i) : t.live ? (i = this.hls.liveSyncPosition || e, this.log(`Setting startPosition to -1 to start at live edge ${i}`), this.startPosition = -1) : (this.log("setting startPosition to 0 by default"), this.startPosition = i = 0), this.lastCurrentTime = i + r
                    }
                    this.nextLoadPosition = i + r
                }
                getLoadPosition() {
                    var t;
                    const {
                        media: e
                    } = this;
                    let i = 0;
                    return null != (t = this.hls) && t.hasEnoughToStart && e ? i = e.currentTime : this.nextLoadPosition >= 0 && (i = this.nextLoadPosition), i
                }
                handleFragLoadAborted(t, e) {
                    this.transmuxer && t.type === this.playlistType && q(t) && t.stats.aborted && (this.warn(`Fragment ${t.sn}${e?" part "+e.index:""} of ${this.playlistLabel()} ${t.level} was aborted`), this.resetFragmentLoading(t))
                }
                resetFragmentLoading(t) {
                    this.fragCurrent && (this.fragContextChanged(t) || this.state === Gi.FRAG_LOADING_WAITING_RETRY) || (this.state = Gi.IDLE)
                }
                onFragmentOrKeyLoadError(t, e) {
                    if (e.chunkMeta && !e.frag) {
                        const t = this.getCurrentContext(e.chunkMeta);
                        t && (e.frag = t.frag)
                    }
                    const i = e.frag;
                    if (!i || i.type !== t || !this.levels) return;
                    var s;
                    if (this.fragContextChanged(i)) return void this.warn(`Frag load error must match current frag to retry ${i.url} > ${null==(s=this.fragCurrent)?void 0:s.url}`);
                    const r = e.details === o.FRAG_GAP;
                    r && this.fragmentTracker.fragBuffered(i, !0);
                    const n = e.errorAction,
                        {
                            action: a,
                            flags: l,
                            retryCount: c = 0,
                            retryConfig: u
                        } = n || {},
                        d = !!n && !!u,
                        h = d && 5 === a,
                        f = d && !n.resolved && 1 === l;
                    if (!h && f && q(i) && !i.endList) this.resetFragmentErrors(t), this.treatAsGap(i), n.resolved = !0;
                    else if ((h || f) && c < u.maxNumRetry) {
                        this.resetStartWhenNotLoaded(this.levelLastLoaded);
                        const s = de(u, c);
                        this.warn(`Fragment ${i.sn} of ${t} ${i.level} errored with ${e.details}, retrying loading ${c+1}/${u.maxNumRetry} in ${s}ms`), n.resolved = !0, this.retryDate = self.performance.now() + s, this.state = Gi.FRAG_LOADING_WAITING_RETRY
                    } else if (u && n) {
                        if (this.resetFragmentErrors(t), !(c < u.maxNumRetry)) return void this.warn(`${e.details} reached or exceeded max retry (${c})`);
                        r || 3 === a || (n.resolved = !0)
                    } else this.state = 2 === a ? Gi.WAITING_LEVEL : Gi.ERROR;
                    this.tickImmediate()
                }
                reduceLengthAndFlushBuffer(t) {
                    if (this.state === Gi.PARSING || this.state === Gi.PARSED) {
                        const e = t.frag,
                            i = t.parent,
                            s = this.getFwdBufferInfo(this.mediaBuffer, i),
                            r = s && s.len > .5;
                        r && this.reduceMaxBufferLength(s.len, (null == e ? void 0 : e.duration) || 10);
                        const n = !r;
                        return n && this.warn(`Buffer full error while media.currentTime is not buffered, flush ${i} buffer`), e && (this.fragmentTracker.removeFragment(e), this.nextLoadPosition = e.start), this.resetLoadingState(), n
                    }
                    return !1
                }
                resetFragmentErrors(t) {
                    t === p && (this.fragCurrent = null), this.hls.hasEnoughToStart || (this.startFragRequested = !1), this.state !== Gi.STOPPED && (this.state = Gi.IDLE)
                }
                afterBufferFlushed(t, e, i) {
                    if (!t) return;
                    const s = Oe.getBuffered(t);
                    this.fragmentTracker.detectEvictedFragments(e, s, i), this.state === Gi.ENDED && this.resetLoadingState()
                }
                resetLoadingState() {
                    this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state !== Gi.STOPPED && (this.state = Gi.IDLE)
                }
                resetStartWhenNotLoaded(t) {
                    if (!this.hls.hasEnoughToStart) {
                        this.startFragRequested = !1;
                        const e = t ? t.details : null;
                        null != e && e.live ? (this.log("resetting startPosition for live start"), this.startPosition = -1, this.setStartPosition(e, e.fragmentStart), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition
                    }
                }
                resetWhenMissingContext(t) {
                    this.warn(`The loading context changed while buffering fragment ${t.sn} of ${this.playlistLabel()} ${t.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(this.levelLastLoaded), this.resetLoadingState()
                }
                removeUnbufferedFrags(t = 0) {
                    this.fragmentTracker.removeFragmentsInRange(t, 1 / 0, this.playlistType, !1, !0)
                }
                updateLevelTiming(t, e, i, s) {
                    const r = i.details;
                    if (r) {
                        var n;
                        if (!Object.keys(t.elementaryStreams).reduce(((e, n) => {
                                const a = t.elementaryStreams[n];
                                if (a) {
                                    const o = a.endPTS - a.startPTS;
                                    if (o <= 0) return this.warn(`Could not parse fragment ${t.sn} ${n} duration reliably (${o})`), e || !1;
                                    const c = s ? 0 : Ii(r, t, a.startPTS, a.endPTS, a.startDTS, a.endDTS);
                                    return this.hls.trigger(l.LEVEL_PTS_UPDATED, {
                                        details: r,
                                        level: i,
                                        drift: c,
                                        type: n,
                                        frag: t,
                                        start: a.startPTS,
                                        end: a.endPTS
                                    }), !0
                                }
                                return e
                            }), !1) && (0 === i.fragmentError && this.treatAsGap(t, i), null === (null == (n = this.transmuxer) ? void 0 : n.error))) {
                            const e = new Error(`Found no media in fragment ${t.sn} of ${this.playlistLabel()} ${t.level} resetting transmuxer to fallback to playlist timing`);
                            if (this.warn(e.message), this.hls.trigger(l.ERROR, {
                                    type: a.MEDIA_ERROR,
                                    details: o.FRAG_PARSING_ERROR,
                                    fatal: !1,
                                    error: e,
                                    frag: t,
                                    reason: `Found no media in msn ${t.sn} of ${this.playlistLabel()} "${i.url}"`
                                }), !this.hls) return;
                            this.resetTransmuxer()
                        }
                        this.state = Gi.PARSED, this.log(`Parsed ${t.type} sn: ${t.sn}${e?" part: "+e.index:""} of ${this.fragInfo(t,!1,e)})`), this.hls.trigger(l.FRAG_PARSED, {
                            frag: t,
                            part: e
                        })
                    } else this.warn("level.details undefined")
                }
                playlistLabel() {
                    return this.playlistType === f ? "level" : "track"
                }
                fragInfo(t, e = !0, i) {
                    var s, r;
                    return `${this.playlistLabel()} ${t.level} (${i?"part":"frag"}:[${(null!=(s=e&&!i?t.startPTS:(i||t).start)?s:NaN).toFixed(3)}-${(null!=(r=e&&!i?t.endPTS:(i||t).end)?r:NaN).toFixed(3)}]${i&&"main"===t.type?"INDEPENDENT="+(i.independent?"YES":"NO"):""}`
                }
                treatAsGap(t, e) {
                    e && e.fragmentError++, t.gap = !0, this.fragmentTracker.removeFragment(t), this.fragmentTracker.fragBuffered(t, !0)
                }
                resetTransmuxer() {
                    var t;
                    null == (t = this.transmuxer) || t.reset()
                }
                recoverWorkerError(t) {
                    "demuxerWorker" === t.event && (this.fragmentTracker.removeAllFragments(), this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null), this.resetStartWhenNotLoaded(this.levelLastLoaded), this.resetLoadingState())
                }
                set state(t) {
                    const e = this._state;
                    e !== t && (this._state = t, this.log(`${e}->${t}`))
                }
                get state() {
                    return this._state
                }
            }

            function Hi(t) {
                return !!t.interstitialsController && !1 !== t.enableInterstitialPlayback
            }
            class Ki {
                constructor() {
                    this.chunks = [], this.dataLength = 0
                }
                push(t) {
                    this.chunks.push(t), this.dataLength += t.length
                }
                flush() {
                    const {
                        chunks: t,
                        dataLength: e
                    } = this;
                    let i;
                    return t.length ? (i = 1 === t.length ? t[0] : function(t, e) {
                        const i = new Uint8Array(e);
                        let s = 0;
                        for (let e = 0; e < t.length; e++) {
                            const r = t[e];
                            i.set(r, s), s += r.length
                        }
                        return i
                    }(t, e), this.reset(), i) : new Uint8Array(0)
                }
                reset() {
                    this.chunks.length = 0, this.dataLength = 0
                }
            }
            var zi, qi = {
                    exports: {}
                },
                Wi = (zi || (zi = 1, function(t) {
                    var e = Object.prototype.hasOwnProperty,
                        i = "~";

                    function s() {}

                    function r(t, e, i) {
                        this.fn = t, this.context = e, this.once = i || !1
                    }

                    function n(t, e, s, n, a) {
                        if ("function" != typeof s) throw new TypeError("The listener must be a function");
                        var o = new r(s, n || t, a),
                            l = i ? i + e : e;
                        return t._events[l] ? t._events[l].fn ? t._events[l] = [t._events[l], o] : t._events[l].push(o) : (t._events[l] = o, t._eventsCount++), t
                    }

                    function a(t, e) {
                        0 == --t._eventsCount ? t._events = new s : delete t._events[e]
                    }

                    function o() {
                        this._events = new s, this._eventsCount = 0
                    }
                    Object.create && (s.prototype = Object.create(null), (new s).__proto__ || (i = !1)), o.prototype.eventNames = function() {
                        var t, s, r = [];
                        if (0 === this._eventsCount) return r;
                        for (s in t = this._events) e.call(t, s) && r.push(i ? s.slice(1) : s);
                        return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(t)) : r
                    }, o.prototype.listeners = function(t) {
                        var e = i ? i + t : t,
                            s = this._events[e];
                        if (!s) return [];
                        if (s.fn) return [s.fn];
                        for (var r = 0, n = s.length, a = new Array(n); r < n; r++) a[r] = s[r].fn;
                        return a
                    }, o.prototype.listenerCount = function(t) {
                        var e = i ? i + t : t,
                            s = this._events[e];
                        return s ? s.fn ? 1 : s.length : 0
                    }, o.prototype.emit = function(t, e, s, r, n, a) {
                        var o = i ? i + t : t;
                        if (!this._events[o]) return !1;
                        var l, c, u = this._events[o],
                            d = arguments.length;
                        if (u.fn) {
                            switch (u.once && this.removeListener(t, u.fn, void 0, !0), d) {
                                case 1:
                                    return u.fn.call(u.context), !0;
                                case 2:
                                    return u.fn.call(u.context, e), !0;
                                case 3:
                                    return u.fn.call(u.context, e, s), !0;
                                case 4:
                                    return u.fn.call(u.context, e, s, r), !0;
                                case 5:
                                    return u.fn.call(u.context, e, s, r, n), !0;
                                case 6:
                                    return u.fn.call(u.context, e, s, r, n, a), !0
                            }
                            for (c = 1, l = new Array(d - 1); c < d; c++) l[c - 1] = arguments[c];
                            u.fn.apply(u.context, l)
                        } else {
                            var h, f = u.length;
                            for (c = 0; c < f; c++) switch (u[c].once && this.removeListener(t, u[c].fn, void 0, !0), d) {
                                case 1:
                                    u[c].fn.call(u[c].context);
                                    break;
                                case 2:
                                    u[c].fn.call(u[c].context, e);
                                    break;
                                case 3:
                                    u[c].fn.call(u[c].context, e, s);
                                    break;
                                case 4:
                                    u[c].fn.call(u[c].context, e, s, r);
                                    break;
                                default:
                                    if (!l)
                                        for (h = 1, l = new Array(d - 1); h < d; h++) l[h - 1] = arguments[h];
                                    u[c].fn.apply(u[c].context, l)
                            }
                        }
                        return !0
                    }, o.prototype.on = function(t, e, i) {
                        return n(this, t, e, i, !1)
                    }, o.prototype.once = function(t, e, i) {
                        return n(this, t, e, i, !0)
                    }, o.prototype.removeListener = function(t, e, s, r) {
                        var n = i ? i + t : t;
                        if (!this._events[n]) return this;
                        if (!e) return a(this, n), this;
                        var o = this._events[n];
                        if (o.fn) o.fn !== e || r && !o.once || s && o.context !== s || a(this, n);
                        else {
                            for (var l = 0, c = [], u = o.length; l < u; l++)(o[l].fn !== e || r && !o[l].once || s && o[l].context !== s) && c.push(o[l]);
                            c.length ? this._events[n] = 1 === c.length ? c[0] : c : a(this, n)
                        }
                        return this
                    }, o.prototype.removeAllListeners = function(t) {
                        var e;
                        return t ? (e = i ? i + t : t, this._events[e] && a(this, e)) : (this._events = new s, this._eventsCount = 0), this
                    }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = i, o.EventEmitter = o, t.exports = o
                }(qi)), qi.exports),
                Yi = P(Wi);
            const Xi = "1.6.1",
                Qi = {};

            function Ji(t, e) {
                return e + 10 <= t.length && 51 === t[e] && 68 === t[e + 1] && 73 === t[e + 2] && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128
            }

            function Zi(t, e) {
                return e + 10 <= t.length && 73 === t[e] && 68 === t[e + 1] && 51 === t[e + 2] && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128
            }

            function ts(t, e) {
                let i = 0;
                return i = (127 & t[e]) << 21, i |= (127 & t[e + 1]) << 14, i |= (127 & t[e + 2]) << 7, i |= 127 & t[e + 3], i
            }

            function es(t, e) {
                const i = e;
                let s = 0;
                for (; Zi(t, e);) s += 10, s += ts(t, e + 6), Ji(t, e + 10) && (s += 10), e += s;
                if (s > 0) return t.subarray(i, i + s)
            }

            function is(t, e) {
                return 255 === t[e] && 240 == (246 & t[e + 1])
            }

            function ss(t, e) {
                return 1 & t[e + 1] ? 7 : 9
            }

            function rs(t, e) {
                return (3 & t[e + 3]) << 11 | t[e + 4] << 3 | (224 & t[e + 5]) >>> 5
            }

            function ns(t, e) {
                return e + 1 < t.length && is(t, e)
            }

            function as(t, e) {
                if (ns(t, e)) {
                    const i = ss(t, e);
                    if (e + i >= t.length) return !1;
                    const s = rs(t, e);
                    if (s <= i) return !1;
                    const r = e + s;
                    return r === t.length || ns(t, r)
                }
                return !1
            }

            function os(t, e, i, s, r) {
                if (!t.samplerate) {
                    const n = function(t, e, i, s) {
                        const r = e[i + 2],
                            n = r >> 2 & 15;
                        if (n > 12) {
                            const e = new Error(`invalid ADTS sampling index:${n}`);
                            return void t.emit(l.ERROR, l.ERROR, {
                                type: a.MEDIA_ERROR,
                                details: o.FRAG_PARSING_ERROR,
                                fatal: !0,
                                error: e,
                                reason: e.message
                            })
                        }
                        const c = 1 + (r >> 6 & 3),
                            u = e[i + 3] >> 6 & 3 | (1 & r) << 2,
                            d = "mp4a.40." + c,
                            h = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350][n];
                        let f = n;
                        5 !== c && 29 !== c || (f -= 3);
                        const p = [c << 3 | (14 & f) >> 1, (1 & f) << 7 | u << 3];
                        return R.log(`manifest codec:${s}, parsed codec:${d}, channels:${u}, rate:${h} (ADTS object type:${c} sampling index:${n})`), {
                            config: p,
                            samplerate: h,
                            channelCount: u,
                            codec: d,
                            parsedCodec: d,
                            manifestCodec: s
                        }
                    }(e, i, s, r);
                    if (!n) return;
                    b(t, n)
                }
            }

            function ls(t) {
                return 9216e4 / t
            }

            function cs(t, e, i, s, r) {
                const n = s + r * ls(t.samplerate),
                    a = function(t, e) {
                        const i = ss(t, e);
                        if (e + i <= t.length) {
                            const s = rs(t, e) - i;
                            if (s > 0) return {
                                headerLength: i,
                                frameLength: s
                            }
                        }
                    }(e, i);
                let o;
                if (a) {
                    const {
                        frameLength: s,
                        headerLength: r
                    } = a, l = r + s, c = Math.max(0, i + l - e.length);
                    c ? (o = new Uint8Array(l - r), o.set(e.subarray(i + r, e.length), 0)) : o = e.subarray(i + r, i + l);
                    const u = {
                        unit: o,
                        pts: n
                    };
                    return c || t.samples.push(u), {
                        sample: u,
                        length: l,
                        missing: c
                    }
                }
                const l = e.length - i;
                return o = new Uint8Array(l), o.set(e.subarray(i, e.length), 0), {
                    sample: {
                        unit: o,
                        pts: n
                    },
                    length: l,
                    missing: -1
                }
            }

            function us(t, e) {
                return Zi(t, e) && ts(t, e + 6) + 10 <= t.length - e
            }

            function ds(t, e) {
                if (t < 0) return -ds(-t, e);
                const i = Math.pow(10, e);
                if (Math.abs(t * i % 1 - .5) < Number.EPSILON) {
                    const e = Math.floor(t * i);
                    return (e % 2 == 0 ? e : e + 1) / i
                }
                return Math.round(t * i) / i
            }

            function hs(t, e = 0, i = 1 / 0) {
                return function(t, e, i, s) {
                    const r = (n = t) instanceof ArrayBuffer ? n : n.buffer;
                    var n;
                    let a = 1;
                    "BYTES_PER_ELEMENT" in s && (a = s.BYTES_PER_ELEMENT);
                    const o = (d = t) && d.buffer instanceof ArrayBuffer && void 0 !== d.byteLength && void 0 !== d.byteOffset ? t.byteOffset : 0,
                        l = (o + t.byteLength) / a,
                        c = (o + e) / a,
                        u = Math.floor(Math.max(0, Math.min(c, l)));
                    var d;
                    return new s(r, u, Math.floor(Math.min(u + Math.max(i, 0), l)) - u)
                }(t, e, i, Uint8Array)
            }

            function fs(t) {
                return "PRIV" === t.type ? function(t) {
                    if (t.size < 2) return;
                    const e = D(t.data, !0),
                        i = new Uint8Array(t.data.subarray(e.length + 1));
                    return {
                        key: t.type,
                        info: e,
                        data: i.buffer
                    }
                }(t) : "W" === t.type[0] ? function(t) {
                    if ("WXXX" === t.type) {
                        if (t.size < 2) return;
                        let e = 1;
                        const i = D(t.data.subarray(e), !0);
                        e += i.length + 1;
                        const s = D(t.data.subarray(e));
                        return {
                            key: t.type,
                            info: i,
                            data: s
                        }
                    }
                    const e = D(t.data);
                    return {
                        key: t.type,
                        info: "",
                        data: e
                    }
                }(t) : "APIC" === t.type ? function(t) {
                    const e = {
                        key: t.type,
                        description: "",
                        data: "",
                        mimeType: null,
                        pictureType: null
                    };
                    if (t.size < 2) return;
                    if (3 !== t.data[0]) return void console.log("Ignore frame with unrecognized character encoding");
                    const i = t.data.subarray(1).indexOf(0);
                    if (-1 === i) return;
                    const s = D(hs(t.data, 1, i)),
                        r = t.data[2 + i],
                        n = t.data.subarray(3 + i).indexOf(0);
                    if (-1 === n) return;
                    const a = D(hs(t.data, 3 + i, n));
                    let o;
                    return o = "--\x3e" === s ? D(hs(t.data, 4 + i + n)) : (l = t.data.subarray(4 + i + n)) instanceof ArrayBuffer ? l : 0 == l.byteOffset && l.byteLength == l.buffer.byteLength ? l.buffer : new Uint8Array(l).buffer, e.mimeType = s, e.pictureType = r, e.description = a, e.data = o, e;
                    var l
                }(t) : function(t) {
                    if (t.size < 2) return;
                    if ("TXXX" === t.type) {
                        let e = 1;
                        const i = D(t.data.subarray(e), !0);
                        e += i.length + 1;
                        const s = D(t.data.subarray(e));
                        return {
                            key: t.type,
                            info: i,
                            data: s
                        }
                    }
                    const e = D(t.data.subarray(1));
                    return {
                        key: t.type,
                        info: "",
                        data: e
                    }
                }(t)
            }

            function ps(t) {
                const e = String.fromCharCode(t[0], t[1], t[2], t[3]),
                    i = ts(t, 4);
                return {
                    type: e,
                    size: i,
                    data: t.subarray(10, 10 + i)
                }
            }
            const gs = 10,
                ms = 10;

            function ys(t) {
                let e = 0;
                const i = [];
                for (; Zi(t, e);) {
                    const s = ts(t, e + 6);
                    t[e + 5] >> 6 & 1 && (e += gs), e += gs;
                    const r = e + s;
                    for (; e + ms < r;) {
                        const s = ps(t.subarray(e)),
                            r = fs(s);
                        r && i.push(r), e += s.size + gs
                    }
                    Ji(t, e) && (e += gs)
                }
                return i
            }

            function vs(t) {
                return t && "PRIV" === t.key && "com.apple.streaming.transportStreamTimestamp" === t.info
            }

            function bs(t) {
                if (8 === t.data.byteLength) {
                    const e = new Uint8Array(t.data),
                        i = 1 & e[3];
                    let s = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7];
                    return s /= 45, i && (s += 47721858.84), Math.round(s)
                }
            }

            function Ts(t) {
                const e = ys(t);
                for (let t = 0; t < e.length; t++) {
                    const i = e[t];
                    if (vs(i)) return bs(i)
                }
            }
            let Es = function(t) {
                return t.audioId3 = "org.id3", t.dateRange = "com.apple.quicktime.HLS", t.emsg = "https://aomedia.org/emsg/ID3", t.misbklv = "urn:misb:KLV:bin:1910.1", t
            }({});

            function Ss(t = "", e = 9e4) {
                return {
                    type: t,
                    id: -1,
                    pid: -1,
                    inputTimeScale: e,
                    sequenceNumber: -1,
                    samples: [],
                    dropped: 0
                }
            }
            class ws {
                constructor() {
                    this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null
                }
                resetInitSegment(t, e, i, s) {
                    this._id3Track = {
                        type: "id3",
                        id: 3,
                        pid: -1,
                        inputTimeScale: 9e4,
                        sequenceNumber: 0,
                        samples: [],
                        dropped: 0
                    }
                }
                resetTimeStamp(t) {
                    this.initPTS = t, this.resetContiguity()
                }
                resetContiguity() {
                    this.basePTS = null, this.lastPTS = null, this.frameIndex = 0
                }
                canParse(t, e) {
                    return !1
                }
                appendFrame(t, e, i) {}
                demux(t, e) {
                    this.cachedData && (t = mt(this.cachedData, t), this.cachedData = null);
                    let i, r = es(t, 0),
                        n = r ? r.length : 0;
                    const a = this._audioTrack,
                        o = this._id3Track,
                        l = r ? Ts(r) : void 0,
                        c = t.length;
                    for ((null === this.basePTS || 0 === this.frameIndex && s(l)) && (this.basePTS = ks(l, e, this.initPTS), this.lastPTS = this.basePTS), null === this.lastPTS && (this.lastPTS = this.basePTS), r && r.length > 0 && o.samples.push({
                            pts: this.lastPTS,
                            dts: this.lastPTS,
                            data: r,
                            type: Es.audioId3,
                            duration: Number.POSITIVE_INFINITY
                        }); n < c;) {
                        if (this.canParse(t, n)) {
                            const e = this.appendFrame(a, t, n);
                            e ? (this.frameIndex++, this.lastPTS = e.sample.pts, n += e.length, i = n) : n = c
                        } else us(t, n) ? (r = es(t, n), o.samples.push({
                            pts: this.lastPTS,
                            dts: this.lastPTS,
                            data: r,
                            type: Es.audioId3,
                            duration: Number.POSITIVE_INFINITY
                        }), n += r.length, i = n) : n++;
                        if (n === c && i !== c) {
                            const e = t.slice(i);
                            this.cachedData ? this.cachedData = mt(this.cachedData, e) : this.cachedData = e
                        }
                    }
                    return {
                        audioTrack: a,
                        videoTrack: Ss(),
                        id3Track: o,
                        textTrack: Ss()
                    }
                }
                demuxSampleAes(t, e, i) {
                    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`))
                }
                flush(t) {
                    const e = this.cachedData;
                    return e && (this.cachedData = null, this.demux(e, 0)), {
                        audioTrack: this._audioTrack,
                        videoTrack: Ss(),
                        id3Track: this._id3Track,
                        textTrack: Ss()
                    }
                }
                destroy() {
                    this.cachedData = null, this._audioTrack = this._id3Track = void 0
                }
            }
            const ks = (t, e, i) => s(t) ? 90 * t : 9e4 * e + (i ? 9e4 * i.baseTime / i.timescale : 0);
            let As = null;
            const _s = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
                Ls = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
                Rs = [
                    [0, 72, 144, 12],
                    [0, 0, 0, 0],
                    [0, 72, 144, 12],
                    [0, 144, 144, 12]
                ],
                Is = [0, 1, 1, 4];

            function Cs(t, e, i, s, r) {
                if (i + 24 > e.length) return;
                const n = Ds(e, i);
                if (n && i + n.frameLength <= e.length) {
                    const a = s + r * (9e4 * n.samplesPerFrame / n.sampleRate),
                        o = {
                            unit: e.subarray(i, i + n.frameLength),
                            pts: a,
                            dts: a
                        };
                    return t.config = [], t.channelCount = n.channelCount, t.samplerate = n.sampleRate, t.samples.push(o), {
                        sample: o,
                        length: n.frameLength,
                        missing: 0
                    }
                }
            }

            function Ds(t, e) {
                const i = t[e + 1] >> 3 & 3,
                    s = t[e + 1] >> 1 & 3,
                    r = t[e + 2] >> 4 & 15,
                    n = t[e + 2] >> 2 & 3;
                if (1 !== i && 0 !== r && 15 !== r && 3 !== n) {
                    const a = t[e + 2] >> 1 & 1,
                        o = t[e + 3] >> 6,
                        l = 1e3 * _s[14 * (3 === i ? 3 - s : 3 === s ? 3 : 4) + r - 1],
                        c = Ls[3 * (3 === i ? 0 : 2 === i ? 1 : 2) + n],
                        u = 3 === o ? 1 : 2,
                        d = Rs[i][s],
                        h = Is[s],
                        f = 8 * d * h,
                        p = Math.floor(d * l / c + a) * h;
                    if (null === As) {
                        const t = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
                        As = t ? parseInt(t[1]) : 0
                    }
                    return !!As && As <= 87 && 2 === s && l >= 224e3 && 0 === o && (t[e + 3] = 128 | t[e + 3]), {
                        sampleRate: c,
                        channelCount: u,
                        frameLength: p,
                        samplesPerFrame: f
                    }
                }
            }

            function xs(t, e) {
                return 255 === t[e] && 224 == (224 & t[e + 1]) && 0 != (6 & t[e + 1])
            }

            function Ps(t, e) {
                return e + 1 < t.length && xs(t, e)
            }

            function Os(t, e) {
                if (e + 1 < t.length && xs(t, e)) {
                    const i = 4,
                        s = Ds(t, e);
                    let r = i;
                    null != s && s.frameLength && (r = s.frameLength);
                    const n = e + r;
                    return n === t.length || Ps(t, n)
                }
                return !1
            }
            const Ms = (t, e) => {
                let i = 0,
                    s = 5;
                e += s;
                const r = new Uint32Array(1),
                    n = new Uint32Array(1),
                    a = new Uint8Array(1);
                for (; s > 0;) {
                    a[0] = t[e];
                    const o = Math.min(s, 8),
                        l = 8 - o;
                    n[0] = 4278190080 >>> 24 + l << l, r[0] = (a[0] & n[0]) >> l, i = i ? i << o | r[0] : r[0], e += 1, s -= o
                }
                return i
            };

            function Ns(t, e, i, s, r) {
                if (i + 8 > e.length) return -1;
                if (11 !== e[i] || 119 !== e[i + 1]) return -1;
                const n = e[i + 4] >> 6;
                if (n >= 3) return -1;
                const a = [48e3, 44100, 32e3][n],
                    o = 63 & e[i + 4],
                    l = 2 * [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920][3 * o + n];
                if (i + l > e.length) return -1;
                const c = e[i + 6] >> 5;
                let u = 0;
                2 === c ? u += 2 : (1 & c && 1 !== c && (u += 2), 4 & c && (u += 2));
                const d = (e[i + 6] << 8 | e[i + 7]) >> 12 - u & 1,
                    h = [2, 1, 2, 3, 3, 4, 4, 5][c] + d,
                    f = e[i + 5] >> 3,
                    p = 7 & e[i + 5],
                    g = new Uint8Array([n << 6 | f << 1 | p >> 2, (3 & p) << 6 | c << 3 | d << 2 | o >> 4, o << 4 & 224]),
                    m = s + r * (1536 / a * 9e4),
                    y = e.subarray(i, i + l);
                return t.config = g, t.channelCount = h, t.samplerate = a, t.samples.push({
                    unit: y,
                    pts: m
                }), l
            }
            const Fs = /\/emsg[-/]ID3/i;

            function $s(t, e) {
                return s(t.presentationTime) ? t.presentationTime / t.timeScale : e + t.presentationTimeDelta / t.timeScale
            }
            class Us {
                constructor(t, e, i) {
                    this.keyData = void 0, this.decrypter = void 0, this.keyData = i, this.decrypter = new Ae(e, {
                        removePKCS7Padding: !1
                    })
                }
                decryptBuffer(t) {
                    return this.decrypter.decrypt(t, this.keyData.key.buffer, this.keyData.iv.buffer, 0)
                }
                decryptAacSample(t, e, i) {
                    const s = t[e].unit;
                    if (s.length <= 16) return;
                    const r = s.subarray(16, s.length - s.length % 16),
                        n = r.buffer.slice(r.byteOffset, r.byteOffset + r.length);
                    this.decryptBuffer(n).then((r => {
                        const n = new Uint8Array(r);
                        s.set(n, 16), this.decrypter.isSync() || this.decryptAacSamples(t, e + 1, i)
                    }))
                }
                decryptAacSamples(t, e, i) {
                    for (;; e++) {
                        if (e >= t.length) return void i();
                        if (!(t[e].unit.length < 32 || (this.decryptAacSample(t, e, i), this.decrypter.isSync()))) return
                    }
                }
                getAvcEncryptedData(t) {
                    const e = 16 * Math.floor((t.length - 48) / 160) + 16,
                        i = new Int8Array(e);
                    let s = 0;
                    for (let e = 32; e < t.length - 16; e += 160, s += 16) i.set(t.subarray(e, e + 16), s);
                    return i
                }
                getAvcDecryptedUnit(t, e) {
                    const i = new Uint8Array(e);
                    let s = 0;
                    for (let e = 32; e < t.length - 16; e += 160, s += 16) t.set(i.subarray(s, s + 16), e);
                    return t
                }
                decryptAvcSample(t, e, i, s, r) {
                    const n = Et(r.data),
                        a = this.getAvcEncryptedData(n);
                    this.decryptBuffer(a.buffer).then((a => {
                        r.data = this.getAvcDecryptedUnit(n, a), this.decrypter.isSync() || this.decryptAvcSamples(t, e, i + 1, s)
                    }))
                }
                decryptAvcSamples(t, e, i, s) {
                    if (t instanceof Uint8Array) throw new Error("Cannot decrypt samples of type Uint8Array");
                    for (;; e++, i = 0) {
                        if (e >= t.length) return void s();
                        const r = t[e].units;
                        for (; !(i >= r.length); i++) {
                            const n = r[i];
                            if (!(n.data.length <= 48 || 1 !== n.type && 5 !== n.type || (this.decryptAvcSample(t, e, i, s, n), this.decrypter.isSync()))) return
                        }
                    }
                }
            }
            class Bs {
                constructor() {
                    this.VideoSample = null
                }
                createVideoSample(t, e, i) {
                    return {
                        key: t,
                        frame: !1,
                        pts: e,
                        dts: i,
                        units: [],
                        length: 0
                    }
                }
                getLastNalUnit(t) {
                    var e;
                    let i, s = this.VideoSample;
                    if (s && 0 !== s.units.length || (s = t[t.length - 1]), null != (e = s) && e.units) {
                        const t = s.units;
                        i = t[t.length - 1]
                    }
                    return i
                }
                pushAccessUnit(t, e) {
                    if (t.units.length && t.frame) {
                        if (void 0 === t.pts) {
                            const i = e.samples,
                                s = i.length;
                            if (!s) return void e.dropped++; {
                                const e = i[s - 1];
                                t.pts = e.pts, t.dts = e.dts
                            }
                        }
                        e.samples.push(t)
                    }
                }
                parseNALu(t, e, i) {
                    const s = e.byteLength;
                    let r = t.naluState || 0;
                    const n = r,
                        a = [];
                    let o, l, c, u = 0,
                        d = -1,
                        h = 0;
                    for (-1 === r && (d = 0, h = this.getNALuType(e, 0), r = 0, u = 1); u < s;)
                        if (o = e[u++], r)
                            if (1 !== r)
                                if (o)
                                    if (1 === o) {
                                        if (l = u - r - 1, d >= 0) {
                                            const t = {
                                                data: e.subarray(d, l),
                                                type: h
                                            };
                                            a.push(t)
                                        } else {
                                            const i = this.getLastNalUnit(t.samples);
                                            i && (n && u <= 4 - n && i.state && (i.data = i.data.subarray(0, i.data.byteLength - n)), l > 0 && (i.data = mt(i.data, e.subarray(0, l)), i.state = 0))
                                        }
                                        u < s ? (c = this.getNALuType(e, u), d = u, h = c, r = 0) : r = -1
                                    } else r = 0;
                    else r = 3;
                    else r = o ? 0 : 2;
                    else r = o ? 0 : 1;
                    if (d >= 0 && r >= 0) {
                        const t = {
                            data: e.subarray(d, s),
                            type: h,
                            state: r
                        };
                        a.push(t)
                    }
                    if (0 === a.length) {
                        const i = this.getLastNalUnit(t.samples);
                        i && (i.data = mt(i.data, e))
                    }
                    return t.naluState = r, a
                }
            }
            class js {
                constructor(t) {
                    this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = t, this.bytesAvailable = t.byteLength, this.word = 0, this.bitsAvailable = 0
                }
                loadWord() {
                    const t = this.data,
                        e = this.bytesAvailable,
                        i = t.byteLength - e,
                        s = new Uint8Array(4),
                        r = Math.min(4, e);
                    if (0 === r) throw new Error("no bytes available");
                    s.set(t.subarray(i, i + r)), this.word = new DataView(s.buffer).getUint32(0), this.bitsAvailable = 8 * r, this.bytesAvailable -= r
                }
                skipBits(t) {
                    let e;
                    t = Math.min(t, 8 * this.bytesAvailable + this.bitsAvailable), this.bitsAvailable > t ? (this.word <<= t, this.bitsAvailable -= t) : (e = (t -= this.bitsAvailable) >> 3, t -= e << 3, this.bytesAvailable -= e, this.loadWord(), this.word <<= t, this.bitsAvailable -= t)
                }
                readBits(t) {
                    let e = Math.min(this.bitsAvailable, t);
                    const i = this.word >>> 32 - e;
                    if (t > 32 && R.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= e, this.bitsAvailable > 0) this.word <<= e;
                    else {
                        if (!(this.bytesAvailable > 0)) throw new Error("no bits available");
                        this.loadWord()
                    }
                    return e = t - e, e > 0 && this.bitsAvailable ? i << e | this.readBits(e) : i
                }
                skipLZ() {
                    let t;
                    for (t = 0; t < this.bitsAvailable; ++t)
                        if (0 != (this.word & 2147483648 >>> t)) return this.word <<= t, this.bitsAvailable -= t, t;
                    return this.loadWord(), t + this.skipLZ()
                }
                skipUEG() {
                    this.skipBits(1 + this.skipLZ())
                }
                skipEG() {
                    this.skipBits(1 + this.skipLZ())
                }
                readUEG() {
                    const t = this.skipLZ();
                    return this.readBits(t + 1) - 1
                }
                readEG() {
                    const t = this.readUEG();
                    return 1 & t ? 1 + t >>> 1 : -1 * (t >>> 1)
                }
                readBoolean() {
                    return 1 === this.readBits(1)
                }
                readUByte() {
                    return this.readBits(8)
                }
                readUShort() {
                    return this.readBits(16)
                }
                readUInt() {
                    return this.readBits(32)
                }
            }
            class Gs extends Bs {
                parsePES(t, e, i, s) {
                    const r = this.parseNALu(t, i.data, s);
                    let n, a = this.VideoSample,
                        o = !1;
                    i.data = null, a && r.length && !t.audFound && (this.pushAccessUnit(a, t), a = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts)), r.forEach((s => {
                        var r, l;
                        switch (s.type) {
                            case 1:
                                {
                                    let e = !1;n = !0;
                                    const r = s.data;
                                    if (o && r.length > 4) {
                                        const t = this.readSliceType(r);
                                        2 !== t && 4 !== t && 7 !== t && 9 !== t || (e = !0)
                                    }
                                    var c;e && null != (c = a) && c.frame && !a.key && (this.pushAccessUnit(a, t), a = this.VideoSample = null),
                                    a || (a = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts)),
                                    a.frame = !0,
                                    a.key = e;
                                    break
                                }
                            case 5:
                                n = !0, null != (r = a) && r.frame && !a.key && (this.pushAccessUnit(a, t), a = this.VideoSample = null), a || (a = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts)), a.key = !0, a.frame = !0;
                                break;
                            case 6:
                                n = !0, Tt(s.data, 1, i.pts, e.samples);
                                break;
                            case 7:
                                {
                                    var u, d;n = !0,
                                    o = !0;
                                    const e = s.data,
                                        i = this.readSPS(e);
                                    if (!t.sps || t.width !== i.width || t.height !== i.height || (null == (u = t.pixelRatio) ? void 0 : u[0]) !== i.pixelRatio[0] || (null == (d = t.pixelRatio) ? void 0 : d[1]) !== i.pixelRatio[1]) {
                                        t.width = i.width, t.height = i.height, t.pixelRatio = i.pixelRatio, t.sps = [e];
                                        const s = e.subarray(1, 4);
                                        let r = "avc1.";
                                        for (let t = 0; t < 3; t++) {
                                            let e = s[t].toString(16);
                                            e.length < 2 && (e = "0" + e), r += e
                                        }
                                        t.codec = r
                                    }
                                    break
                                }
                            case 8:
                                n = !0, t.pps = [s.data];
                                break;
                            case 9:
                                n = !0, t.audFound = !0, null != (l = a) && l.frame && (this.pushAccessUnit(a, t), a = null), a || (a = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts));
                                break;
                            case 12:
                                n = !0;
                                break;
                            default:
                                n = !1
                        }
                        a && n && a.units.push(s)
                    })), s && a && (this.pushAccessUnit(a, t), this.VideoSample = null)
                }
                getNALuType(t, e) {
                    return 31 & t[e]
                }
                readSliceType(t) {
                    const e = new js(t);
                    return e.readUByte(), e.readUEG(), e.readUEG()
                }
                skipScalingList(t, e) {
                    let i, s = 8,
                        r = 8;
                    for (let n = 0; n < t; n++) 0 !== r && (i = e.readEG(), r = (s + i + 256) % 256), s = 0 === r ? s : r
                }
                readSPS(t) {
                    const e = new js(t);
                    let i, s, r, n = 0,
                        a = 0,
                        o = 0,
                        l = 0;
                    const c = e.readUByte.bind(e),
                        u = e.readBits.bind(e),
                        d = e.readUEG.bind(e),
                        h = e.readBoolean.bind(e),
                        f = e.skipBits.bind(e),
                        p = e.skipEG.bind(e),
                        g = e.skipUEG.bind(e),
                        m = this.skipScalingList.bind(this);
                    c();
                    const y = c();
                    if (u(5), f(3), c(), g(), 100 === y || 110 === y || 122 === y || 244 === y || 44 === y || 83 === y || 86 === y || 118 === y || 128 === y) {
                        const t = d();
                        if (3 === t && f(1), g(), g(), f(1), h())
                            for (s = 3 !== t ? 8 : 12, r = 0; r < s; r++) h() && m(r < 6 ? 16 : 64, e)
                    }
                    g();
                    const v = d();
                    if (0 === v) d();
                    else if (1 === v)
                        for (f(1), p(), p(), i = d(), r = 0; r < i; r++) p();
                    g(), f(1);
                    const b = d(),
                        T = d(),
                        E = u(1);
                    0 === E && f(1), f(1), h() && (n = d(), a = d(), o = d(), l = d());
                    let S = [1, 1];
                    if (h() && h()) switch (c()) {
                        case 1:
                            S = [1, 1];
                            break;
                        case 2:
                            S = [12, 11];
                            break;
                        case 3:
                            S = [10, 11];
                            break;
                        case 4:
                            S = [16, 11];
                            break;
                        case 5:
                            S = [40, 33];
                            break;
                        case 6:
                            S = [24, 11];
                            break;
                        case 7:
                            S = [20, 11];
                            break;
                        case 8:
                            S = [32, 11];
                            break;
                        case 9:
                            S = [80, 33];
                            break;
                        case 10:
                            S = [18, 11];
                            break;
                        case 11:
                            S = [15, 11];
                            break;
                        case 12:
                            S = [64, 33];
                            break;
                        case 13:
                            S = [160, 99];
                            break;
                        case 14:
                            S = [4, 3];
                            break;
                        case 15:
                            S = [3, 2];
                            break;
                        case 16:
                            S = [2, 1];
                            break;
                        case 255:
                            S = [c() << 8 | c(), c() << 8 | c()]
                    }
                    return {
                        width: Math.ceil(16 * (b + 1) - 2 * n - 2 * a),
                        height: (2 - E) * (T + 1) * 16 - (E ? 2 : 4) * (o + l),
                        pixelRatio: S
                    }
                }
            }
            class Vs extends Bs {
                constructor(...t) {
                    super(...t), this.initVPS = null
                }
                parsePES(t, e, i, s) {
                    const r = this.parseNALu(t, i.data, s);
                    let n, a = this.VideoSample,
                        o = !1;
                    i.data = null, a && r.length && !t.audFound && (this.pushAccessUnit(a, t), a = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts)), r.forEach((s => {
                        var r, l;
                        switch (s.type) {
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                                a || (a = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts)), a.frame = !0, n = !0;
                                break;
                            case 16:
                            case 17:
                            case 18:
                            case 21:
                                var c;
                                n = !0, o && null != (c = a) && c.frame && !a.key && (this.pushAccessUnit(a, t), a = this.VideoSample = null), a || (a = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts)), a.key = !0, a.frame = !0;
                                break;
                            case 19:
                            case 20:
                                n = !0, null != (r = a) && r.frame && !a.key && (this.pushAccessUnit(a, t), a = this.VideoSample = null), a || (a = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts)), a.key = !0, a.frame = !0;
                                break;
                            case 39:
                                n = !0, Tt(s.data, 2, i.pts, e.samples);
                                break;
                            case 32:
                                n = !0, t.vps || ("object" != typeof t.params && (t.params = {}), t.params = b(t.params, this.readVPS(s.data)), this.initVPS = s.data), t.vps = [s.data];
                                break;
                            case 33:
                                if (n = !0, o = !0, void 0 === t.vps || t.vps[0] === this.initVPS || void 0 === t.sps || this.matchSPS(t.sps[0], s.data) || (this.initVPS = t.vps[0], t.sps = t.pps = void 0), !t.sps) {
                                    const e = this.readSPS(s.data);
                                    t.width = e.width, t.height = e.height, t.pixelRatio = e.pixelRatio, t.codec = e.codecString, t.sps = [], "object" != typeof t.params && (t.params = {});
                                    for (const i in e.params) t.params[i] = e.params[i]
                                }
                                this.pushParameterSet(t.sps, s.data, t.vps), a || (a = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts)), a.key = !0;
                                break;
                            case 34:
                                if (n = !0, "object" == typeof t.params) {
                                    if (!t.pps) {
                                        t.pps = [];
                                        const e = this.readPPS(s.data);
                                        for (const i in e) t.params[i] = e[i]
                                    }
                                    this.pushParameterSet(t.pps, s.data, t.vps)
                                }
                                break;
                            case 35:
                                n = !0, t.audFound = !0, null != (l = a) && l.frame && (this.pushAccessUnit(a, t), a = null), a || (a = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts));
                                break;
                            default:
                                n = !1
                        }
                        a && n && a.units.push(s)
                    })), s && a && (this.pushAccessUnit(a, t), this.VideoSample = null)
                }
                pushParameterSet(t, e, i) {
                    (i && i[0] === this.initVPS || !i && !t.length) && t.push(e)
                }
                getNALuType(t, e) {
                    return (126 & t[e]) >>> 1
                }
                ebsp2rbsp(t) {
                    const e = new Uint8Array(t.byteLength);
                    let i = 0;
                    for (let s = 0; s < t.byteLength; s++) s >= 2 && 3 === t[s] && 0 === t[s - 1] && 0 === t[s - 2] || (e[i] = t[s], i++);
                    return new Uint8Array(e.buffer, 0, i)
                }
                pushAccessUnit(t, e) {
                    super.pushAccessUnit(t, e), this.initVPS && (this.initVPS = null)
                }
                readVPS(t) {
                    const e = new js(t);
                    return e.readUByte(), e.readUByte(), e.readBits(4), e.skipBits(2), e.readBits(6), {
                        numTemporalLayers: e.readBits(3) + 1,
                        temporalIdNested: e.readBoolean()
                    }
                }
                readSPS(t) {
                    const e = new js(this.ebsp2rbsp(t));
                    e.readUByte(), e.readUByte(), e.readBits(4);
                    const i = e.readBits(3);
                    e.readBoolean();
                    const s = e.readBits(2),
                        r = e.readBoolean(),
                        n = e.readBits(5),
                        a = e.readUByte(),
                        o = e.readUByte(),
                        l = e.readUByte(),
                        c = e.readUByte(),
                        u = e.readUByte(),
                        d = e.readUByte(),
                        h = e.readUByte(),
                        f = e.readUByte(),
                        p = e.readUByte(),
                        g = e.readUByte(),
                        m = e.readUByte(),
                        y = [],
                        v = [];
                    for (let t = 0; t < i; t++) y.push(e.readBoolean()), v.push(e.readBoolean());
                    if (i > 0)
                        for (let t = i; t < 8; t++) e.readBits(2);
                    for (let t = 0; t < i; t++) y[t] && (e.readUByte(), e.readUByte(), e.readUByte(), e.readUByte(), e.readUByte(), e.readUByte(), e.readUByte(), e.readUByte(), e.readUByte(), e.readUByte(), e.readUByte()), v[t] && e.readUByte();
                    e.readUEG();
                    const b = e.readUEG();
                    3 == b && e.skipBits(1);
                    const T = e.readUEG(),
                        E = e.readUEG(),
                        S = e.readBoolean();
                    let w = 0,
                        k = 0,
                        A = 0,
                        _ = 0;
                    S && (w += e.readUEG(), k += e.readUEG(), A += e.readUEG(), _ += e.readUEG());
                    const L = e.readUEG(),
                        R = e.readUEG(),
                        I = e.readUEG();
                    for (let t = e.readBoolean() ? 0 : i; t <= i; t++) e.skipUEG(), e.skipUEG(), e.skipUEG();
                    if (e.skipUEG(), e.skipUEG(), e.skipUEG(), e.skipUEG(), e.skipUEG(), e.skipUEG(), e.readBoolean() && e.readBoolean())
                        for (let t = 0; t < 4; t++)
                            for (let i = 0; i < (3 === t ? 2 : 6); i++)
                                if (e.readBoolean()) {
                                    const i = Math.min(64, 1 << 4 + (t << 1));
                                    t > 1 && e.readEG();
                                    for (let t = 0; t < i; t++) e.readEG()
                                } else e.readUEG();
                    e.readBoolean(), e.readBoolean(), e.readBoolean() && (e.readUByte(), e.skipUEG(), e.skipUEG(), e.readBoolean());
                    const C = e.readUEG();
                    let D = 0;
                    for (let t = 0; t < C; t++) {
                        let i = !1;
                        if (0 !== t && (i = e.readBoolean()), i) {
                            t === C && e.readUEG(), e.readBoolean(), e.readUEG();
                            let i = 0;
                            for (let t = 0; t <= D; t++) {
                                const t = e.readBoolean();
                                let s = !1;
                                t || (s = e.readBoolean()), (t || s) && i++
                            }
                            D = i
                        } else {
                            const t = e.readUEG(),
                                i = e.readUEG();
                            D = t + i;
                            for (let i = 0; i < t; i++) e.readUEG(), e.readBoolean();
                            for (let t = 0; t < i; t++) e.readUEG(), e.readBoolean()
                        }
                    }
                    if (e.readBoolean()) {
                        const t = e.readUEG();
                        for (let i = 0; i < t; i++) {
                            for (let t = 0; t < I + 4; t++) e.readBits(1);
                            e.readBits(1)
                        }
                    }
                    let x = 0,
                        P = 1,
                        O = 1,
                        M = !0,
                        N = 1,
                        F = 0;
                    e.readBoolean(), e.readBoolean();
                    let $ = !1;
                    if (e.readBoolean()) {
                        if (e.readBoolean()) {
                            const t = e.readUByte();
                            t > 0 && t < 16 ? (P = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2][t - 1], O = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1][t - 1]) : 255 === t && (P = e.readBits(16), O = e.readBits(16))
                        }
                        if (e.readBoolean() && e.readBoolean(), e.readBoolean() && (e.readBits(3), e.readBoolean(), e.readBoolean() && (e.readUByte(), e.readUByte(), e.readUByte())), e.readBoolean() && (e.readUEG(), e.readUEG()), e.readBoolean(), e.readBoolean(), e.readBoolean(), $ = e.readBoolean(), $ && (w += e.readUEG(), k += e.readUEG(), A += e.readUEG(), _ += e.readUEG()), e.readBoolean() && (N = e.readBits(32), F = e.readBits(32), e.readBoolean() && e.readUEG(), e.readBoolean())) {
                            const t = e.readBoolean(),
                                s = e.readBoolean();
                            let r = !1;
                            (t || s) && (r = e.readBoolean(), r && (e.readUByte(), e.readBits(5), e.readBoolean(), e.readBits(5)), e.readBits(4), e.readBits(4), r && e.readBits(4), e.readBits(5), e.readBits(5), e.readBits(5));
                            for (let n = 0; n <= i; n++) {
                                M = e.readBoolean();
                                let i = !1;
                                M || e.readBoolean() ? e.readEG() : i = e.readBoolean();
                                const n = i ? 1 : e.readUEG() + 1;
                                if (t)
                                    for (let t = 0; t < n; t++) e.readUEG(), e.readUEG(), r && (e.readUEG(), e.readUEG()), e.skipBits(1);
                                if (s)
                                    for (let t = 0; t < n; t++) e.readUEG(), e.readUEG(), r && (e.readUEG(), e.readUEG()), e.skipBits(1)
                            }
                        }
                        e.readBoolean() && (e.readBoolean(), e.readBoolean(), e.readBoolean(), x = e.readUEG())
                    }
                    let U = T,
                        B = E;
                    if (S || $) {
                        let t = 1,
                            e = 1;
                        1 === b ? t = e = 2 : 2 == b && (t = 2), U = T - t * k - t * w, B = E - e * _ - e * A
                    }
                    const j = s ? ["A", "B", "C"][s] : "",
                        G = a << 24 | o << 16 | l << 8 | c;
                    let V = 0;
                    for (let t = 0; t < 32; t++) V = (V | (G >> t & 1) << 31 - t) >>> 0;
                    let H = V.toString(16);
                    return 1 === n && "2" === H && (H = "6"), {
                        codecString: `hvc1.${j}${n}.${H}.${r?"H":"L"}${m}.B0`,
                        params: {
                            general_tier_flag: r,
                            general_profile_idc: n,
                            general_profile_space: s,
                            general_profile_compatibility_flags: [a, o, l, c],
                            general_constraint_indicator_flags: [u, d, h, f, p, g],
                            general_level_idc: m,
                            bit_depth: L + 8,
                            bit_depth_luma_minus8: L,
                            bit_depth_chroma_minus8: R,
                            min_spatial_segmentation_idc: x,
                            chroma_format_idc: b,
                            frame_rate: {
                                fixed: M,
                                fps: F / N
                            }
                        },
                        width: U,
                        height: B,
                        pixelRatio: [P, O]
                    }
                }
                readPPS(t) {
                    const e = new js(this.ebsp2rbsp(t));
                    e.readUByte(), e.readUByte(), e.skipUEG(), e.skipUEG(), e.skipBits(2), e.skipBits(3), e.skipBits(2), e.skipUEG(), e.skipUEG(), e.skipEG(), e.skipBits(2), e.readBoolean() && e.skipUEG(), e.skipEG(), e.skipEG(), e.skipBits(4);
                    const i = e.readBoolean(),
                        s = e.readBoolean();
                    let r = 1;
                    return s && i ? r = 0 : s ? r = 3 : i && (r = 2), {
                        parallelismType: r
                    }
                }
                matchSPS(t, e) {
                    return String.fromCharCode.apply(null, t).substr(3) === String.fromCharCode.apply(null, e).substr(3)
                }
            }
            const Hs = 188;
            class Ks {
                constructor(t, e, i, s) {
                    this.logger = void 0, this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._pmtId = -1, this._videoTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.remainderData = null, this.videoParser = void 0, this.observer = t, this.config = e, this.typeSupported = i, this.logger = s, this.videoParser = null
                }
                static probe(t, e) {
                    const i = Ks.syncOffset(t);
                    return i > 0 && e.warn(`MPEG2-TS detected but first sync word found @ offset ${i}`), -1 !== i
                }
                static syncOffset(t) {
                    const e = t.length;
                    let i = Math.min(940, e - Hs) + 1,
                        s = 0;
                    for (; s < i;) {
                        let r = !1,
                            n = -1,
                            a = 0;
                        for (let o = s; o < e; o += Hs) {
                            if (71 !== t[o] || e - o !== Hs && 71 !== t[o + Hs]) {
                                if (a) return -1;
                                break
                            }
                            if (a++, -1 === n && (n = o, 0 !== n && (i = Math.min(n + 18612, t.length - Hs) + 1)), r || (r = 0 === zs(t, o)), r && a > 1 && (0 === n && a > 2 || o + Hs > i)) return n
                        }
                        s++
                    }
                    return -1
                }
                static createTrack(t, e) {
                    return {
                        container: "video" === t || "audio" === t ? "video/mp2t" : void 0,
                        type: t,
                        id: Z[t],
                        pid: -1,
                        inputTimeScale: 9e4,
                        sequenceNumber: 0,
                        samples: [],
                        dropped: 0,
                        duration: "audio" === t ? e : void 0
                    }
                }
                resetInitSegment(t, e, i, s) {
                    this.pmtParsed = !1, this._pmtId = -1, this._videoTrack = Ks.createTrack("video"), this._videoTrack.duration = s, this._audioTrack = Ks.createTrack("audio", s), this._id3Track = Ks.createTrack("id3"), this._txtTrack = Ks.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.aacOverFlow = null, this.remainderData = null, this.audioCodec = e, this.videoCodec = i
                }
                resetTimeStamp() {}
                resetContiguity() {
                    const {
                        _audioTrack: t,
                        _videoTrack: e,
                        _id3Track: i
                    } = this;
                    t && (t.pesData = null), e && (e.pesData = null), i && (i.pesData = null), this.aacOverFlow = null, this.remainderData = null
                }
                demux(t, e, i = !1, s = !1) {
                    let r;
                    i || (this.sampleAes = null);
                    const n = this._videoTrack,
                        a = this._audioTrack,
                        o = this._id3Track,
                        l = this._txtTrack;
                    let c = n.pid,
                        u = n.pesData,
                        d = a.pid,
                        h = o.pid,
                        f = a.pesData,
                        p = o.pesData,
                        g = null,
                        m = this.pmtParsed,
                        y = this._pmtId,
                        v = t.length;
                    if (this.remainderData && (v = (t = mt(this.remainderData, t)).length, this.remainderData = null), v < Hs && !s) return this.remainderData = t, {
                        audioTrack: a,
                        videoTrack: n,
                        id3Track: o,
                        textTrack: l
                    };
                    const b = Math.max(0, Ks.syncOffset(t));
                    v -= (v - b) % Hs, v < t.byteLength && !s && (this.remainderData = new Uint8Array(t.buffer, v, t.buffer.byteLength - v));
                    let T = 0;
                    for (let e = b; e < v; e += Hs)
                        if (71 === t[e]) {
                            const s = !!(64 & t[e + 1]),
                                v = zs(t, e);
                            let T;
                            if ((48 & t[e + 3]) >> 4 > 1) {
                                if (T = e + 5 + t[e + 4], T === e + Hs) continue
                            } else T = e + 4;
                            switch (v) {
                                case c:
                                    if (s) {
                                        if (u && (r = Qs(u, this.logger))) {
                                            if (null === this.videoParser) switch (n.segmentCodec) {
                                                case "avc":
                                                    this.videoParser = new Gs;
                                                    break;
                                                case "hevc":
                                                    this.videoParser = new Vs
                                            }
                                            null !== this.videoParser && this.videoParser.parsePES(n, l, r, !1)
                                        }
                                        u = {
                                            data: [],
                                            size: 0
                                        }
                                    }
                                    u && (u.data.push(t.subarray(T, e + Hs)), u.size += e + Hs - T);
                                    break;
                                case d:
                                    if (s) {
                                        if (f && (r = Qs(f, this.logger))) switch (a.segmentCodec) {
                                            case "aac":
                                                this.parseAACPES(a, r);
                                                break;
                                            case "mp3":
                                                this.parseMPEGPES(a, r);
                                                break;
                                            case "ac3":
                                                this.parseAC3PES(a, r)
                                        }
                                        f = {
                                            data: [],
                                            size: 0
                                        }
                                    }
                                    f && (f.data.push(t.subarray(T, e + Hs)), f.size += e + Hs - T);
                                    break;
                                case h:
                                    s && (p && (r = Qs(p, this.logger)) && this.parseID3PES(o, r), p = {
                                        data: [],
                                        size: 0
                                    }), p && (p.data.push(t.subarray(T, e + Hs)), p.size += e + Hs - T);
                                    break;
                                case 0:
                                    s && (T += t[T] + 1), y = this._pmtId = qs(t, T);
                                    break;
                                case y:
                                    {
                                        s && (T += t[T] + 1);
                                        const r = Ws(t, T, this.typeSupported, i, this.observer, this.logger);c = r.videoPid,
                                        c > 0 && (n.pid = c, n.segmentCodec = r.segmentVideoCodec),
                                        d = r.audioPid,
                                        d > 0 && (a.pid = d, a.segmentCodec = r.segmentAudioCodec),
                                        h = r.id3Pid,
                                        h > 0 && (o.pid = h),
                                        null === g || m || (this.logger.warn(`MPEG-TS PMT found at ${e} after unknown PID '${g}'. Backtracking to sync byte @${b} to parse all TS packets.`), g = null, e = b - 188),
                                        m = this.pmtParsed = !0;
                                        break
                                    }
                                case 17:
                                case 8191:
                                    break;
                                default:
                                    g = v
                            }
                        } else T++;
                    T > 0 && Ys(this.observer, new Error(`Found ${T} TS packet/s that do not start with 0x47`), void 0, this.logger), n.pesData = u, a.pesData = f, o.pesData = p;
                    const E = {
                        audioTrack: a,
                        videoTrack: n,
                        id3Track: o,
                        textTrack: l
                    };
                    return s && this.extractRemainingSamples(E), E
                }
                flush() {
                    const {
                        remainderData: t
                    } = this;
                    let e;
                    return this.remainderData = null, e = t ? this.demux(t, -1, !1, !0) : {
                        videoTrack: this._videoTrack,
                        audioTrack: this._audioTrack,
                        id3Track: this._id3Track,
                        textTrack: this._txtTrack
                    }, this.extractRemainingSamples(e), this.sampleAes ? this.decrypt(e, this.sampleAes) : e
                }
                extractRemainingSamples(t) {
                    const {
                        audioTrack: e,
                        videoTrack: i,
                        id3Track: s,
                        textTrack: r
                    } = t, n = i.pesData, a = e.pesData, o = s.pesData;
                    let l;
                    if (n && (l = Qs(n, this.logger))) {
                        if (null === this.videoParser) switch (i.segmentCodec) {
                            case "avc":
                                this.videoParser = new Gs;
                                break;
                            case "hevc":
                                this.videoParser = new Vs
                        }
                        null !== this.videoParser && (this.videoParser.parsePES(i, r, l, !0), i.pesData = null)
                    } else i.pesData = n;
                    if (a && (l = Qs(a, this.logger))) {
                        switch (e.segmentCodec) {
                            case "aac":
                                this.parseAACPES(e, l);
                                break;
                            case "mp3":
                                this.parseMPEGPES(e, l);
                                break;
                            case "ac3":
                                this.parseAC3PES(e, l)
                        }
                        e.pesData = null
                    } else null != a && a.size && this.logger.log("last AAC PES packet truncated,might overlap between fragments"), e.pesData = a;
                    o && (l = Qs(o, this.logger)) ? (this.parseID3PES(s, l), s.pesData = null) : s.pesData = o
                }
                demuxSampleAes(t, e, i) {
                    const s = this.demux(t, i, !0, !this.config.progressive),
                        r = this.sampleAes = new Us(this.observer, this.config, e);
                    return this.decrypt(s, r)
                }
                decrypt(t, e) {
                    return new Promise((i => {
                        const {
                            audioTrack: s,
                            videoTrack: r
                        } = t;
                        s.samples && "aac" === s.segmentCodec ? e.decryptAacSamples(s.samples, 0, (() => {
                            r.samples ? e.decryptAvcSamples(r.samples, 0, 0, (() => {
                                i(t)
                            })) : i(t)
                        })) : r.samples && e.decryptAvcSamples(r.samples, 0, 0, (() => {
                            i(t)
                        }))
                    }))
                }
                destroy() {
                    this.observer && this.observer.removeAllListeners(), this.config = this.logger = this.observer = null, this.aacOverFlow = this.videoParser = this.remainderData = this.sampleAes = null, this._videoTrack = this._audioTrack = this._id3Track = this._txtTrack = void 0
                }
                parseAACPES(t, e) {
                    let i = 0;
                    const s = this.aacOverFlow;
                    let r, n, a, o = e.data;
                    if (s) {
                        this.aacOverFlow = null;
                        const e = s.missing,
                            r = s.sample.unit.byteLength;
                        if (-1 === e) o = mt(s.sample.unit, o);
                        else {
                            const n = r - e;
                            s.sample.unit.set(o.subarray(0, e), n), t.samples.push(s.sample), i = s.missing
                        }
                    }
                    for (r = i, n = o.length; r < n - 1 && !ns(o, r); r++);
                    if (r !== i) {
                        let t;
                        const e = r < n - 1;
                        if (t = e ? `AAC PES did not start with ADTS header,offset:${r}` : "No ADTS header found in AAC PES", Ys(this.observer, new Error(t), e, this.logger), !e) return
                    }
                    if (os(t, this.observer, o, r, this.audioCodec), void 0 !== e.pts) a = e.pts;
                    else {
                        if (!s) return void this.logger.warn("[tsdemuxer]: AAC PES unknown PTS"); {
                            const e = ls(t.samplerate);
                            a = s.sample.pts + e
                        }
                    }
                    let l, c = 0;
                    for (; r < n;) {
                        if (l = cs(t, o, r, a, c), r += l.length, l.missing) {
                            this.aacOverFlow = l;
                            break
                        }
                        for (c++; r < n - 1 && !ns(o, r); r++);
                    }
                }
                parseMPEGPES(t, e) {
                    const i = e.data,
                        s = i.length;
                    let r = 0,
                        n = 0;
                    const a = e.pts;
                    if (void 0 !== a)
                        for (; n < s;)
                            if (Ps(i, n)) {
                                const e = Cs(t, i, n, a, r);
                                if (!e) break;
                                n += e.length, r++
                            } else n++;
                    else this.logger.warn("[tsdemuxer]: MPEG PES unknown PTS")
                }
                parseAC3PES(t, e) {
                    {
                        const i = e.data,
                            s = e.pts;
                        if (void 0 === s) return void this.logger.warn("[tsdemuxer]: AC3 PES unknown PTS");
                        const r = i.length;
                        let n, a = 0,
                            o = 0;
                        for (; o < r && (n = Ns(t, i, o, s, a++)) > 0;) o += n
                    }
                }
                parseID3PES(t, e) {
                    if (void 0 === e.pts) return void this.logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
                    const i = b({}, e, {
                        type: this._videoTrack ? Es.emsg : Es.audioId3,
                        duration: Number.POSITIVE_INFINITY
                    });
                    t.samples.push(i)
                }
            }

            function zs(t, e) {
                return ((31 & t[e + 1]) << 8) + t[e + 2]
            }

            function qs(t, e) {
                return (31 & t[e + 10]) << 8 | t[e + 11]
            }

            function Ws(t, e, i, s, r, n) {
                const a = {
                        audioPid: -1,
                        videoPid: -1,
                        id3Pid: -1,
                        segmentVideoCodec: "avc",
                        segmentAudioCodec: "aac"
                    },
                    o = e + 3 + ((15 & t[e + 1]) << 8 | t[e + 2]) - 4;
                for (e += 12 + ((15 & t[e + 10]) << 8 | t[e + 11]); e < o;) {
                    const o = zs(t, e),
                        l = (15 & t[e + 3]) << 8 | t[e + 4];
                    switch (t[e]) {
                        case 207:
                            if (!s) {
                                Xs("ADTS AAC", n);
                                break
                            }
                        case 15:
                            -1 === a.audioPid && (a.audioPid = o);
                            break;
                        case 21:
                            -1 === a.id3Pid && (a.id3Pid = o);
                            break;
                        case 219:
                            if (!s) {
                                Xs("H.264", n);
                                break
                            }
                        case 27:
                            -1 === a.videoPid && (a.videoPid = o);
                            break;
                        case 3:
                        case 4:
                            i.mpeg || i.mp3 ? -1 === a.audioPid && (a.audioPid = o, a.segmentAudioCodec = "mp3") : n.log("MPEG audio found, not supported in this browser");
                            break;
                        case 193:
                            if (!s) {
                                Xs("AC-3", n);
                                break
                            }
                        case 129:
                            i.ac3 ? -1 === a.audioPid && (a.audioPid = o, a.segmentAudioCodec = "ac3") : n.log("AC-3 audio found, not supported in this browser");
                            break;
                        case 6:
                            if (-1 === a.audioPid && l > 0) {
                                let s = e + 5,
                                    r = l;
                                for (; r > 2;) {
                                    106 === t[s] && (!0 !== i.ac3 ? n.log("AC-3 audio found, not supported in this browser for now") : (a.audioPid = o, a.segmentAudioCodec = "ac3"));
                                    const e = t[s + 1] + 2;
                                    s += e, r -= e
                                }
                            }
                            break;
                        case 194:
                        case 135:
                            return Ys(r, new Error("Unsupported EC-3 in M2TS found"), void 0, n), a;
                        case 36:
                            -1 === a.videoPid && (a.videoPid = o, a.segmentVideoCodec = "hevc", n.log("HEVC in M2TS found"))
                    }
                    e += l + 5
                }
                return a
            }

            function Ys(t, e, i, s) {
                s.warn(`parsing error: ${e.message}`), t.emit(l.ERROR, l.ERROR, {
                    type: a.MEDIA_ERROR,
                    details: o.FRAG_PARSING_ERROR,
                    fatal: !1,
                    levelRetry: i,
                    error: e,
                    reason: e.message
                })
            }

            function Xs(t, e) {
                e.log(`${t} with AES-128-CBC encryption found in unencrypted stream`)
            }

            function Qs(t, e) {
                let i, s, r, n, a, o = 0;
                const l = t.data;
                if (!t || 0 === t.size) return null;
                for (; l[0].length < 19 && l.length > 1;) l[0] = mt(l[0], l[1]), l.splice(1, 1);
                if (i = l[0], 1 === (i[0] << 16) + (i[1] << 8) + i[2]) {
                    if (s = (i[4] << 8) + i[5], s && s > t.size - 6) return null;
                    const c = i[7];
                    192 & c && (n = 536870912 * (14 & i[9]) + 4194304 * (255 & i[10]) + 16384 * (254 & i[11]) + 128 * (255 & i[12]) + (254 & i[13]) / 2, 64 & c ? (a = 536870912 * (14 & i[14]) + 4194304 * (255 & i[15]) + 16384 * (254 & i[16]) + 128 * (255 & i[17]) + (254 & i[18]) / 2, n - a > 54e5 && (e.warn(`${Math.round((n-a)/9e4)}s delta between PTS and DTS, align them`), n = a)) : a = n), r = i[8];
                    let u = r + 9;
                    if (t.size <= u) return null;
                    t.size -= u;
                    const d = new Uint8Array(t.size);
                    for (let t = 0, e = l.length; t < e; t++) {
                        i = l[t];
                        let e = i.byteLength;
                        if (u) {
                            if (u > e) {
                                u -= e;
                                continue
                            }
                            i = i.subarray(u), e -= u, u = 0
                        }
                        d.set(i, o), o += e
                    }
                    return s && (s -= r + 3), {
                        data: d,
                        pts: n,
                        dts: a,
                        len: s
                    }
                }
                return null
            }
            class Js {
                static getSilentFrame(t, e) {
                    if ("mp4a.40.2" === t) {
                        if (1 === e) return new Uint8Array([0, 200, 0, 128, 35, 128]);
                        if (2 === e) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
                        if (3 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
                        if (4 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
                        if (5 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
                        if (6 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224])
                    } else {
                        if (1 === e) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                        if (2 === e) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                        if (3 === e) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94])
                    }
                }
            }
            const Zs = Math.pow(2, 32) - 1;
            class tr {
                static init() {
                    let t;
                    for (t in tr.types = {
                            avc1: [],
                            avcC: [],
                            hvc1: [],
                            hvcC: [],
                            btrt: [],
                            dinf: [],
                            dref: [],
                            esds: [],
                            ftyp: [],
                            hdlr: [],
                            mdat: [],
                            mdhd: [],
                            mdia: [],
                            mfhd: [],
                            minf: [],
                            moof: [],
                            moov: [],
                            mp4a: [],
                            ".mp3": [],
                            dac3: [],
                            "ac-3": [],
                            mvex: [],
                            mvhd: [],
                            pasp: [],
                            sdtp: [],
                            stbl: [],
                            stco: [],
                            stsc: [],
                            stsd: [],
                            stsz: [],
                            stts: [],
                            tfdt: [],
                            tfhd: [],
                            traf: [],
                            trak: [],
                            trun: [],
                            trex: [],
                            tkhd: [],
                            vmhd: [],
                            smhd: []
                        }, tr.types) tr.types.hasOwnProperty(t) && (tr.types[t] = [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3)]);
                    const e = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),
                        i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
                    tr.HDLR_TYPES = {
                        video: e,
                        audio: i
                    };
                    const s = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),
                        r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
                    tr.STTS = tr.STSC = tr.STCO = r, tr.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), tr.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), tr.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), tr.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
                    const n = new Uint8Array([105, 115, 111, 109]),
                        a = new Uint8Array([97, 118, 99, 49]),
                        o = new Uint8Array([0, 0, 0, 1]);
                    tr.FTYP = tr.box(tr.types.ftyp, n, o, n, a), tr.DINF = tr.box(tr.types.dinf, tr.box(tr.types.dref, s))
                }
                static box(t, ...e) {
                    let i = 8,
                        s = e.length;
                    const r = s;
                    for (; s--;) i += e[s].byteLength;
                    const n = new Uint8Array(i);
                    for (n[0] = i >> 24 & 255, n[1] = i >> 16 & 255, n[2] = i >> 8 & 255, n[3] = 255 & i, n.set(t, 4), s = 0, i = 8; s < r; s++) n.set(e[s], i), i += e[s].byteLength;
                    return n
                }
                static hdlr(t) {
                    return tr.box(tr.types.hdlr, tr.HDLR_TYPES[t])
                }
                static mdat(t) {
                    return tr.box(tr.types.mdat, t)
                }
                static mdhd(t, e) {
                    e *= t;
                    const i = Math.floor(e / (Zs + 1)),
                        s = Math.floor(e % (Zs + 1));
                    return tr.box(tr.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, 85, 196, 0, 0]))
                }
                static mdia(t) {
                    return tr.box(tr.types.mdia, tr.mdhd(t.timescale || 0, t.duration || 0), tr.hdlr(t.type), tr.minf(t))
                }
                static mfhd(t) {
                    return tr.box(tr.types.mfhd, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t]))
                }
                static minf(t) {
                    return "audio" === t.type ? tr.box(tr.types.minf, tr.box(tr.types.smhd, tr.SMHD), tr.DINF, tr.stbl(t)) : tr.box(tr.types.minf, tr.box(tr.types.vmhd, tr.VMHD), tr.DINF, tr.stbl(t))
                }
                static moof(t, e, i) {
                    return tr.box(tr.types.moof, tr.mfhd(t), tr.traf(i, e))
                }
                static moov(t) {
                    let e = t.length;
                    const i = [];
                    for (; e--;) i[e] = tr.trak(t[e]);
                    return tr.box.apply(null, [tr.types.moov, tr.mvhd(t[0].timescale || 0, t[0].duration || 0)].concat(i).concat(tr.mvex(t)))
                }
                static mvex(t) {
                    let e = t.length;
                    const i = [];
                    for (; e--;) i[e] = tr.trex(t[e]);
                    return tr.box.apply(null, [tr.types.mvex, ...i])
                }
                static mvhd(t, e) {
                    e *= t;
                    const i = Math.floor(e / (Zs + 1)),
                        s = Math.floor(e % (Zs + 1)),
                        r = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
                    return tr.box(tr.types.mvhd, r)
                }
                static sdtp(t) {
                    const e = t.samples || [],
                        i = new Uint8Array(4 + e.length);
                    let s, r;
                    for (s = 0; s < e.length; s++) r = e[s].flags, i[s + 4] = r.dependsOn << 4 | r.isDependedOn << 2 | r.hasRedundancy;
                    return tr.box(tr.types.sdtp, i)
                }
                static stbl(t) {
                    return tr.box(tr.types.stbl, tr.stsd(t), tr.box(tr.types.stts, tr.STTS), tr.box(tr.types.stsc, tr.STSC), tr.box(tr.types.stsz, tr.STSZ), tr.box(tr.types.stco, tr.STCO))
                }
                static avc1(t) {
                    let e, i, s, r = [],
                        n = [];
                    for (e = 0; e < t.sps.length; e++) i = t.sps[e], s = i.byteLength, r.push(s >>> 8 & 255), r.push(255 & s), r = r.concat(Array.prototype.slice.call(i));
                    for (e = 0; e < t.pps.length; e++) i = t.pps[e], s = i.byteLength, n.push(s >>> 8 & 255), n.push(255 & s), n = n.concat(Array.prototype.slice.call(i));
                    const a = tr.box(tr.types.avcC, new Uint8Array([1, r[3], r[4], r[5], 255, 224 | t.sps.length].concat(r).concat([t.pps.length]).concat(n))),
                        o = t.width,
                        l = t.height,
                        c = t.pixelRatio[0],
                        u = t.pixelRatio[1];
                    return tr.box(tr.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, o >> 8 & 255, 255 & o, l >> 8 & 255, 255 & l, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), a, tr.box(tr.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), tr.box(tr.types.pasp, new Uint8Array([c >> 24, c >> 16 & 255, c >> 8 & 255, 255 & c, u >> 24, u >> 16 & 255, u >> 8 & 255, 255 & u])))
                }
                static esds(t) {
                    const e = t.config;
                    return new Uint8Array([0, 0, 0, 0, 3, 25, 0, 1, 0, 4, 17, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2, ...e, 6, 1, 2])
                }
                static audioStsd(t) {
                    const e = t.samplerate || 0;
                    return new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t.channelCount || 0, 0, 16, 0, 0, 0, 0, e >> 8 & 255, 255 & e, 0, 0])
                }
                static mp4a(t) {
                    return tr.box(tr.types.mp4a, tr.audioStsd(t), tr.box(tr.types.esds, tr.esds(t)))
                }
                static mp3(t) {
                    return tr.box(tr.types[".mp3"], tr.audioStsd(t))
                }
                static ac3(t) {
                    return tr.box(tr.types["ac-3"], tr.audioStsd(t), tr.box(tr.types.dac3, t.config))
                }
                static stsd(t) {
                    const {
                        segmentCodec: e
                    } = t;
                    if ("audio" === t.type) {
                        if ("aac" === e) return tr.box(tr.types.stsd, tr.STSD, tr.mp4a(t));
                        if ("ac3" === e && t.config) return tr.box(tr.types.stsd, tr.STSD, tr.ac3(t));
                        if ("mp3" === e && "mp3" === t.codec) return tr.box(tr.types.stsd, tr.STSD, tr.mp3(t))
                    } else {
                        if (!t.pps || !t.sps) throw new Error("video track missing pps or sps");
                        if ("avc" === e) return tr.box(tr.types.stsd, tr.STSD, tr.avc1(t));
                        if ("hevc" === e && t.vps) return tr.box(tr.types.stsd, tr.STSD, tr.hvc1(t))
                    }
                    throw new Error(`unsupported ${t.type} segment codec (${e}/${t.codec})`)
                }
                static tkhd(t) {
                    const e = t.id,
                        i = (t.duration || 0) * (t.timescale || 0),
                        s = t.width || 0,
                        r = t.height || 0,
                        n = Math.floor(i / (Zs + 1)),
                        a = Math.floor(i % (Zs + 1));
                    return tr.box(tr.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, 0, 0, 0, 0, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, s >> 8 & 255, 255 & s, 0, 0, r >> 8 & 255, 255 & r, 0, 0]))
                }
                static traf(t, e) {
                    const i = tr.sdtp(t),
                        s = t.id,
                        r = Math.floor(e / (Zs + 1)),
                        n = Math.floor(e % (Zs + 1));
                    return tr.box(tr.types.traf, tr.box(tr.types.tfhd, new Uint8Array([0, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s])), tr.box(tr.types.tfdt, new Uint8Array([1, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n])), tr.trun(t, i.length + 16 + 20 + 8 + 16 + 8 + 8), i)
                }
                static trak(t) {
                    return t.duration = t.duration || 4294967295, tr.box(tr.types.trak, tr.tkhd(t), tr.mdia(t))
                }
                static trex(t) {
                    const e = t.id;
                    return tr.box(tr.types.trex, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
                }
                static trun(t, e) {
                    const i = t.samples || [],
                        s = i.length,
                        r = 12 + 16 * s,
                        n = new Uint8Array(r);
                    let a, o, l, c, u, d;
                    for (e += 8 + r, n.set(["video" === t.type ? 1 : 0, 0, 15, 1, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e], 0), a = 0; a < s; a++) o = i[a], l = o.duration, c = o.size, u = o.flags, d = o.cts, n.set([l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l, c >>> 24 & 255, c >>> 16 & 255, c >>> 8 & 255, 255 & c, u.isLeading << 2 | u.dependsOn, u.isDependedOn << 6 | u.hasRedundancy << 4 | u.paddingValue << 1 | u.isNonSync, 61440 & u.degradPrio, 15 & u.degradPrio, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, 255 & d], 12 + 16 * a);
                    return tr.box(tr.types.trun, n)
                }
                static initSegment(t) {
                    tr.types || tr.init();
                    const e = tr.moov(t);
                    return mt(tr.FTYP, e)
                }
                static hvc1(t) {
                    const e = t.params,
                        i = [t.vps, t.sps, t.pps],
                        s = new Uint8Array([1, e.general_profile_space << 6 | (e.general_tier_flag ? 32 : 0) | e.general_profile_idc, e.general_profile_compatibility_flags[0], e.general_profile_compatibility_flags[1], e.general_profile_compatibility_flags[2], e.general_profile_compatibility_flags[3], e.general_constraint_indicator_flags[0], e.general_constraint_indicator_flags[1], e.general_constraint_indicator_flags[2], e.general_constraint_indicator_flags[3], e.general_constraint_indicator_flags[4], e.general_constraint_indicator_flags[5], e.general_level_idc, 240 | e.min_spatial_segmentation_idc >> 8, 255 & e.min_spatial_segmentation_idc, 252 | e.parallelismType, 252 | e.chroma_format_idc, 248 | e.bit_depth_luma_minus8, 248 | e.bit_depth_chroma_minus8, 0, parseInt(e.frame_rate.fps), 3 | e.temporal_id_nested << 2 | e.num_temporal_layers << 3 | (e.frame_rate.fixed ? 64 : 0), i.length]);
                    let r = s.length;
                    for (let t = 0; t < i.length; t += 1) {
                        r += 3;
                        for (let e = 0; e < i[t].length; e += 1) r += 2 + i[t][e].length
                    }
                    const n = new Uint8Array(r);
                    n.set(s, 0), r = s.length;
                    const a = i.length - 1;
                    for (let t = 0; t < i.length; t += 1) {
                        n.set(new Uint8Array([32 + t | (t === a ? 128 : 0), 0, i[t].length]), r), r += 3;
                        for (let e = 0; e < i[t].length; e += 1) n.set(new Uint8Array([i[t][e].length >> 8, 255 & i[t][e].length]), r), r += 2, n.set(i[t][e], r), r += i[t][e].length
                    }
                    const o = tr.box(tr.types.hvcC, n),
                        l = t.width,
                        c = t.height,
                        u = t.pixelRatio[0],
                        d = t.pixelRatio[1];
                    return tr.box(tr.types.hvc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, 255 & l, c >> 8 & 255, 255 & c, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), o, tr.box(tr.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), tr.box(tr.types.pasp, new Uint8Array([u >> 24, u >> 16 & 255, u >> 8 & 255, 255 & u, d >> 24, d >> 16 & 255, d >> 8 & 255, 255 & d])))
                }
            }
            tr.types = void 0, tr.HDLR_TYPES = void 0, tr.STTS = void 0, tr.STSC = void 0, tr.STCO = void 0, tr.STSZ = void 0, tr.VMHD = void 0, tr.SMHD = void 0, tr.STSD = void 0, tr.FTYP = void 0, tr.DINF = void 0;

            function er(t, e, i = 1, s = !1) {
                const r = t * e * i;
                return s ? Math.round(r) : r
            }

            function ir(t, e = !1) {
                return er(t, 1e3, 1 / 9e4, e)
            }
            let sr, rr = null,
                nr = null;

            function ar(t, e, i, s) {
                return {
                    duration: e,
                    size: i,
                    cts: s,
                    flags: {
                        isLeading: 0,
                        isDependedOn: 0,
                        hasRedundancy: 0,
                        degradPrio: 0,
                        dependsOn: t ? 2 : 1,
                        isNonSync: t ? 0 : 1
                    }
                }
            }
            class or {
                constructor(t, e, i, s) {
                    if (this.logger = void 0, this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextAvcDts = null, this.nextAudioPts = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.videoTrackConfig = void 0, this.observer = t, this.config = e, this.typeSupported = i, this.logger = s, this.ISGenerated = !1, null === rr) {
                        const t = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
                        rr = t ? parseInt(t[1]) : 0
                    }
                    if (null === nr) {
                        const t = navigator.userAgent.match(/Safari\/(\d+)/i);
                        nr = t ? parseInt(t[1]) : 0
                    }
                }
                destroy() {
                    this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null
                }
                resetTimeStamp(t) {
                    this.logger.log("[mp4-remuxer]: initPTS & initDTS reset"), this._initPTS = this._initDTS = t
                }
                resetNextTimestamp() {
                    this.logger.log("[mp4-remuxer]: reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1
                }
                resetInitSegment() {
                    this.logger.log("[mp4-remuxer]: ISGenerated flag reset"), this.ISGenerated = !1, this.videoTrackConfig = void 0
                }
                getVideoStartPts(t) {
                    let e = !1;
                    const i = t[0].pts,
                        s = t.reduce(((t, s) => {
                            let r = s.pts,
                                n = r - t;
                            return n < -4294967296 && (e = !0, r = lr(r, i), n = r - t), n > 0 ? t : r
                        }), i);
                    return e && this.logger.debug("PTS rollover detected"), s
                }
                remux(t, e, i, s, r, n, a, o) {
                    let l, c, u, d, h, f, g = r,
                        m = r;
                    const y = t.pid > -1,
                        v = e.pid > -1,
                        b = e.samples.length,
                        T = t.samples.length > 0,
                        E = a && b > 0 || b > 1;
                    if ((!y || T) && (!v || E) || this.ISGenerated || a) {
                        if (this.ISGenerated) {
                            var S, w, k, A;
                            const t = this.videoTrackConfig;
                            (t && (e.width !== t.width || e.height !== t.height || (null == (S = e.pixelRatio) ? void 0 : S[0]) !== (null == (w = t.pixelRatio) ? void 0 : w[0]) || (null == (k = e.pixelRatio) ? void 0 : k[1]) !== (null == (A = t.pixelRatio) ? void 0 : A[1])) || !t && E || null === this.nextAudioPts && T) && this.resetInitSegment()
                        }
                        this.ISGenerated || (u = this.generateIS(t, e, r, n));
                        const i = this.isVideoContiguous;
                        let s, a = -1;
                        if (E && (a = function(t) {
                                for (let e = 0; e < t.length; e++)
                                    if (t[e].key) return e;
                                return -1
                            }(e.samples), !i && this.config.forceKeyFrameOnDiscontinuity))
                            if (f = !0, a > 0) {
                                this.logger.warn(`[mp4-remuxer]: Dropped ${a} out of ${b} video samples due to a missing keyframe`);
                                const t = this.getVideoStartPts(e.samples);
                                e.samples = e.samples.slice(a), e.dropped += a, m += (e.samples[0].pts - t) / e.inputTimeScale, s = m
                            } else -1 === a && (this.logger.warn(`[mp4-remuxer]: No keyframe found out of ${b} video samples`), f = !1);
                        if (this.ISGenerated) {
                            if (T && E) {
                                const i = this.getVideoStartPts(e.samples),
                                    s = (lr(t.samples[0].pts, i) - i) / e.inputTimeScale;
                                g += Math.max(0, s), m += Math.max(0, -s)
                            }
                            if (T) {
                                if (t.samplerate || (this.logger.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"), u = this.generateIS(t, e, r, n)), c = this.remuxAudio(t, g, this.isAudioContiguous, n, v || E || o === p ? m : void 0), E) {
                                    const s = c ? c.endPTS - c.startPTS : 0;
                                    e.inputTimeScale || (this.logger.warn("[mp4-remuxer]: regenerate InitSegment as video detected"), u = this.generateIS(t, e, r, n)), l = this.remuxVideo(e, m, i, s)
                                }
                            } else E && (l = this.remuxVideo(e, m, i, 0));
                            l && (l.firstKeyFrame = a, l.independent = -1 !== a, l.firstKeyFramePTS = s)
                        }
                    }
                    return this.ISGenerated && this._initPTS && this._initDTS && (i.samples.length && (h = cr(i, r, this._initPTS, this._initDTS)), s.samples.length && (d = ur(s, r, this._initPTS))), {
                        audio: c,
                        video: l,
                        initSegment: u,
                        independent: f,
                        text: d,
                        id3: h
                    }
                }
                generateIS(t, e, i, s) {
                    const r = t.samples,
                        n = e.samples,
                        a = this.typeSupported,
                        o = {},
                        l = this._initPTS;
                    let c, u, d, h = !l || s,
                        f = "audio/mp4";
                    if (h && (c = u = 1 / 0), t.config && r.length) {
                        switch (t.timescale = t.samplerate, t.segmentCodec) {
                            case "mp3":
                                a.mpeg ? (f = "audio/mpeg", t.codec = "") : a.mp3 && (t.codec = "mp3");
                                break;
                            case "ac3":
                                t.codec = "ac-3"
                        }
                        o.audio = {
                            id: "audio",
                            container: f,
                            codec: t.codec,
                            initSegment: "mp3" === t.segmentCodec && a.mpeg ? new Uint8Array(0) : tr.initSegment([t]),
                            metadata: {
                                channelCount: t.channelCount
                            }
                        }, h && (d = t.inputTimeScale, l && d === l.timescale ? h = !1 : c = u = r[0].pts - Math.round(d * i))
                    }
                    if (e.sps && e.pps && n.length) {
                        if (e.timescale = e.inputTimeScale, o.video = {
                                id: "main",
                                container: "video/mp4",
                                codec: e.codec,
                                initSegment: tr.initSegment([e]),
                                metadata: {
                                    width: e.width,
                                    height: e.height
                                }
                            }, h)
                            if (d = e.inputTimeScale, l && d === l.timescale) h = !1;
                            else {
                                const t = this.getVideoStartPts(n),
                                    e = Math.round(d * i);
                                u = Math.min(u, lr(n[0].dts, t) - e), c = Math.min(c, t - e)
                            }
                        this.videoTrackConfig = {
                            width: e.width,
                            height: e.height,
                            pixelRatio: e.pixelRatio
                        }
                    }
                    if (Object.keys(o).length) return this.ISGenerated = !0, h ? (this._initPTS = {
                        baseTime: c,
                        timescale: d
                    }, this._initDTS = {
                        baseTime: u,
                        timescale: d
                    }) : c = d = void 0, {
                        tracks: o,
                        initPTS: c,
                        timescale: d
                    }
                }
                remuxVideo(t, e, i, s) {
                    const r = t.inputTimeScale,
                        n = t.samples,
                        c = [],
                        u = n.length,
                        d = this._initPTS;
                    let h, f, p = this.nextAvcDts,
                        g = 8,
                        m = this.videoSampleDuration,
                        y = Number.POSITIVE_INFINITY,
                        v = Number.NEGATIVE_INFINITY,
                        T = !1;
                    if (!i || null === p) {
                        const t = e * r,
                            s = n[0].pts - lr(n[0].dts, n[0].pts);
                        rr && null !== p && Math.abs(t - s - p) < 15e3 ? i = !0 : p = t - s
                    }
                    const E = d.baseTime * r / d.timescale;
                    for (let t = 0; t < u; t++) {
                        const e = n[t];
                        e.pts = lr(e.pts - E, p), e.dts = lr(e.dts - E, p), e.dts < n[t > 0 ? t - 1 : t].dts && (T = !0)
                    }
                    T && n.sort((function(t, e) {
                        const i = t.dts - e.dts,
                            s = t.pts - e.pts;
                        return i || s
                    })), h = n[0].dts, f = n[n.length - 1].dts;
                    const S = f - h,
                        w = S ? Math.round(S / (u - 1)) : m || t.inputTimeScale / 30;
                    if (i) {
                        const i = h - p,
                            s = i > w,
                            r = i < -1;
                        if ((s || r) && (s ? this.logger.warn(`${(t.segmentCodec||"").toUpperCase()}: ${ir(i,!0)} ms (${i}dts) hole between fragments detected at ${e.toFixed(3)}`) : this.logger.warn(`${(t.segmentCodec||"").toUpperCase()}: ${ir(-i,!0)} ms (${i}dts) overlapping between fragments detected at ${e.toFixed(3)}`), !r || p >= n[0].pts || rr)) {
                            h = p;
                            const t = n[0].pts - i;
                            if (s) n[0].dts = h, n[0].pts = t;
                            else {
                                let e = !0;
                                for (let s = 0; s < n.length && !(n[s].dts > t && e); s++) {
                                    const t = n[s].pts;
                                    if (n[s].dts -= i, n[s].pts -= i, s < n.length - 1) {
                                        const i = n[s + 1].pts;
                                        e = i <= n[s].pts == i <= t
                                    }
                                }
                            }
                            this.logger.log(`Video: Initial PTS/DTS adjusted: ${ir(t,!0)}/${ir(h,!0)}, delta: ${ir(i,!0)} ms`)
                        }
                    }
                    h = Math.max(0, h);
                    let k = 0,
                        A = 0,
                        _ = h;
                    for (let t = 0; t < u; t++) {
                        const e = n[t],
                            i = e.units,
                            s = i.length;
                        let r = 0;
                        for (let t = 0; t < s; t++) r += i[t].data.length;
                        A += r, k += s, e.length = r, e.dts < _ ? (e.dts = _, _ += w / 4 | 0 || 1) : _ = e.dts, y = Math.min(e.pts, y), v = Math.max(e.pts, v)
                    }
                    f = n[u - 1].dts;
                    const L = A + 4 * k + 8;
                    let R;
                    try {
                        R = new Uint8Array(L)
                    } catch (t) {
                        return void this.observer.emit(l.ERROR, l.ERROR, {
                            type: a.MUX_ERROR,
                            details: o.REMUX_ALLOC_ERROR,
                            fatal: !1,
                            error: t,
                            bytes: L,
                            reason: `fail allocating video mdat ${L}`
                        })
                    }
                    const I = new DataView(R.buffer);
                    I.setUint32(0, L), R.set(tr.types.mdat, 4);
                    let C = !1,
                        D = Number.POSITIVE_INFINITY,
                        x = Number.POSITIVE_INFINITY,
                        P = Number.NEGATIVE_INFINITY,
                        O = Number.NEGATIVE_INFINITY;
                    for (let t = 0; t < u; t++) {
                        const e = n[t],
                            i = e.units;
                        let a, o = 0;
                        for (let t = 0, e = i.length; t < e; t++) {
                            const e = i[t],
                                s = e.data,
                                r = e.data.byteLength;
                            I.setUint32(g, r), g += 4, R.set(s, g), g += r, o += 4 + r
                        }
                        if (t < u - 1) m = n[t + 1].dts - e.dts, a = n[t + 1].pts - e.pts;
                        else {
                            const i = this.config,
                                o = t > 0 ? e.dts - n[t - 1].dts : w;
                            if (a = t > 0 ? e.pts - n[t - 1].pts : w, i.stretchShortVideoTrack && null !== this.nextAudioPts) {
                                const t = Math.floor(i.maxBufferHole * r),
                                    n = (s ? y + s * r : this.nextAudioPts) - e.pts;
                                n > t ? (m = n - o, m < 0 ? m = o : C = !0, this.logger.log(`[mp4-remuxer]: It is approximately ${n/90} ms to the next segment; using duration ${m/90} ms for the last video frame.`)) : m = o
                            } else m = o
                        }
                        const l = Math.round(e.pts - e.dts);
                        D = Math.min(D, m), P = Math.max(P, m), x = Math.min(x, a), O = Math.max(O, a), c.push(ar(e.key, m, o, l))
                    }
                    if (c.length)
                        if (rr) {
                            if (rr < 70) {
                                const t = c[0].flags;
                                t.dependsOn = 2, t.isNonSync = 0
                            }
                        } else if (nr && O - x < P - D && w / P < .025 && 0 === c[0].cts) {
                        this.logger.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
                        let t = h;
                        for (let e = 0, i = c.length; e < i; e++) {
                            const s = t + c[e].duration,
                                r = t + c[e].cts;
                            if (e < i - 1) {
                                const t = s + c[e + 1].cts;
                                c[e].duration = t - r
                            } else c[e].duration = e ? c[e - 1].duration : w;
                            c[e].cts = 0, t = s
                        }
                    }
                    m = C || !m ? w : m, this.nextAvcDts = p = f + m, this.videoSampleDuration = m, this.isVideoContiguous = !0;
                    const M = {
                        data1: tr.moof(t.sequenceNumber++, h, b(t, {
                            samples: c
                        })),
                        data2: R,
                        startPTS: y / r,
                        endPTS: (v + m) / r,
                        startDTS: h / r,
                        endDTS: p / r,
                        type: "video",
                        hasAudio: !1,
                        hasVideo: !0,
                        nb: c.length,
                        dropped: t.dropped
                    };
                    return t.samples = [], t.dropped = 0, M
                }
                getSamplesPerFrame(t) {
                    switch (t.segmentCodec) {
                        case "mp3":
                            return 1152;
                        case "ac3":
                            return 1536;
                        default:
                            return 1024
                    }
                }
                remuxAudio(t, e, i, s, r) {
                    const n = t.inputTimeScale,
                        c = n / (t.samplerate ? t.samplerate : n),
                        u = this.getSamplesPerFrame(t),
                        d = u * c,
                        h = this._initPTS,
                        f = "mp3" === t.segmentCodec && this.typeSupported.mpeg,
                        p = [],
                        g = void 0 !== r;
                    let m = t.samples,
                        y = f ? 0 : 8,
                        v = this.nextAudioPts || -1;
                    const T = e * n,
                        E = h.baseTime * n / h.timescale;
                    if (this.isAudioContiguous = i = i || m.length && v > 0 && (s && Math.abs(T - v) < 9e3 || Math.abs(lr(m[0].pts - E, T) - v) < 20 * d), m.forEach((function(t) {
                            t.pts = lr(t.pts - E, T)
                        })), !i || v < 0) {
                        if (m = m.filter((t => t.pts >= 0)), !m.length) return;
                        v = 0 === r ? 0 : s && !g ? Math.max(0, T) : m[0].pts
                    }
                    if ("aac" === t.segmentCodec) {
                        const e = this.config.maxAudioFramesDrift;
                        for (let i = 0, s = v; i < m.length; i++) {
                            const r = m[i],
                                a = r.pts,
                                o = a - s,
                                l = Math.abs(1e3 * o / n);
                            if (o <= -e * d && g) 0 === i && (this.logger.warn(`Audio frame @ ${(a/n).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1e3*o/n)} ms.`), this.nextAudioPts = v = s = a);
                            else if (o >= e * d && l < 1e4 && g) {
                                let e = Math.round(o / d);
                                s = a - e * d, s < 0 && (e--, s += d), 0 === i && (this.nextAudioPts = v = s), this.logger.warn(`[mp4-remuxer]: Injecting ${e} audio frame @ ${(s/n).toFixed(3)}s due to ${Math.round(1e3*o/n)} ms gap.`);
                                for (let n = 0; n < e; n++) {
                                    const e = Math.max(s, 0);
                                    let n = Js.getSilentFrame(t.parsedCodec || t.manifestCodec || t.codec, t.channelCount);
                                    n || (this.logger.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."), n = r.unit.subarray()), m.splice(i, 0, {
                                        unit: n,
                                        pts: e
                                    }), s += d, i++
                                }
                            }
                            r.pts = s, s += d
                        }
                    }
                    let S, w = null,
                        k = null,
                        A = 0,
                        _ = m.length;
                    for (; _--;) A += m[_].unit.byteLength;
                    for (let e = 0, s = m.length; e < s; e++) {
                        const s = m[e],
                            r = s.unit;
                        let n = s.pts;
                        if (null !== k) p[e - 1].duration = Math.round((n - k) / c);
                        else {
                            if (i && "aac" === t.segmentCodec && (n = v), w = n, !(A > 0)) return;
                            A += y;
                            try {
                                S = new Uint8Array(A)
                            } catch (t) {
                                return void this.observer.emit(l.ERROR, l.ERROR, {
                                    type: a.MUX_ERROR,
                                    details: o.REMUX_ALLOC_ERROR,
                                    fatal: !1,
                                    error: t,
                                    bytes: A,
                                    reason: `fail allocating audio mdat ${A}`
                                })
                            }
                            f || (new DataView(S.buffer).setUint32(0, A), S.set(tr.types.mdat, 4))
                        }
                        S.set(r, y);
                        const d = r.byteLength;
                        y += d, p.push(ar(!0, u, d, 0)), k = n
                    }
                    const L = p.length;
                    if (!L) return;
                    const R = p[p.length - 1];
                    this.nextAudioPts = v = k + c * R.duration;
                    const I = f ? new Uint8Array(0) : tr.moof(t.sequenceNumber++, w / c, b({}, t, {
                        samples: p
                    }));
                    t.samples = [];
                    const C = w / n,
                        D = v / n,
                        x = {
                            data1: I,
                            data2: S,
                            startPTS: C,
                            endPTS: D,
                            startDTS: C,
                            endDTS: D,
                            type: "audio",
                            hasAudio: !0,
                            hasVideo: !1,
                            nb: L
                        };
                    return this.isAudioContiguous = !0, x
                }
            }

            function lr(t, e) {
                let i;
                if (null === e) return t;
                for (i = e < t ? -8589934592 : 8589934592; Math.abs(t - e) > 4294967296;) t += i;
                return t
            }

            function cr(t, e, i, s) {
                const r = t.samples.length;
                if (!r) return;
                const n = t.inputTimeScale;
                for (let a = 0; a < r; a++) {
                    const r = t.samples[a];
                    r.pts = lr(r.pts - i.baseTime * n / i.timescale, e * n) / n, r.dts = lr(r.dts - s.baseTime * n / s.timescale, e * n) / n
                }
                const a = t.samples;
                return t.samples = [], {
                    samples: a
                }
            }

            function ur(t, e, i) {
                const s = t.samples.length;
                if (!s) return;
                const r = t.inputTimeScale;
                for (let n = 0; n < s; n++) {
                    const s = t.samples[n];
                    s.pts = lr(s.pts - i.baseTime * r / i.timescale, e * r) / r
                }
                t.samples.sort(((t, e) => t.pts - e.pts));
                const n = t.samples;
                return t.samples = [], {
                    samples: n
                }
            }

            function dr(t, e) {
                const i = null == t ? void 0 : t.codec;
                return i && i.length > 4 ? i : e === V ? "ec-3" === i || "ac-3" === i || "alac" === i ? i : "fLaC" === i || "Opus" === i ? Pt(i, !1) : (R.warn(`Unhandled audio codec "${i}" in mp4 MAP`), i || "mp4a") : (R.warn(`Unhandled video codec "${i}" in mp4 MAP`), i || "avc1")
            }
            try {
                sr = self.performance.now.bind(self.performance)
            } catch (t) {
                sr = Date.now
            }
            const hr = [{
                demux: class {
                    constructor(t, e) {
                        this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = e
                    }
                    resetTimeStamp() {}
                    resetInitSegment(t, e, i, s) {
                        const r = this.videoTrack = Ss("video", 1),
                            n = this.audioTrack = Ss("audio", 1),
                            a = this.txtTrack = Ss("text", 1);
                        if (this.id3Track = Ss("id3", 1), this.timeOffset = 0, null == t || !t.byteLength) return;
                        const o = lt(t);
                        if (o.video) {
                            const {
                                id: t,
                                timescale: e,
                                codec: i,
                                supplemental: s
                            } = o.video;
                            r.id = t, r.timescale = a.timescale = e, r.codec = i, r.supplemental = s
                        }
                        if (o.audio) {
                            const {
                                id: t,
                                timescale: e,
                                codec: i
                            } = o.audio;
                            n.id = t, n.timescale = e, n.codec = i
                        }
                        a.id = Z.text, r.sampleDuration = 0, r.duration = n.duration = s
                    }
                    resetContiguity() {
                        this.remainderData = null
                    }
                    static probe(t) {
                        return function(t) {
                            const e = t.byteLength;
                            for (let i = 0; i < e;) {
                                const s = it(t, i);
                                if (s > 8 && 109 === t[i + 4] && 111 === t[i + 5] && 111 === t[i + 6] && 102 === t[i + 7]) return !0;
                                i = s > 1 ? i + s : e
                            }
                            return !1
                        }(t)
                    }
                    demux(t, e) {
                        this.timeOffset = e;
                        let i = t;
                        const s = this.videoTrack,
                            r = this.txtTrack;
                        if (this.config.progressive) {
                            this.remainderData && (i = mt(this.remainderData, t));
                            const e = function(t) {
                                const e = {
                                        valid: null,
                                        remainder: null
                                    },
                                    i = at(t, ["moof"]);
                                if (i.length < 2) return e.remainder = t, e;
                                const s = i[i.length - 1];
                                return e.valid = t.slice(0, s.byteOffset - 8), e.remainder = t.slice(s.byteOffset - 8), e
                            }(i);
                            this.remainderData = e.remainder, s.samples = e.valid || new Uint8Array
                        } else s.samples = i;
                        const n = this.extractID3Track(s, e);
                        return r.samples = yt(e, s), {
                            videoTrack: s,
                            audioTrack: this.audioTrack,
                            id3Track: n,
                            textTrack: this.txtTrack
                        }
                    }
                    flush() {
                        const t = this.timeOffset,
                            e = this.videoTrack,
                            i = this.txtTrack;
                        e.samples = this.remainderData || new Uint8Array, this.remainderData = null;
                        const s = this.extractID3Track(e, this.timeOffset);
                        return i.samples = yt(t, e), {
                            videoTrack: e,
                            audioTrack: Ss(),
                            id3Track: s,
                            textTrack: Ss()
                        }
                    }
                    extractID3Track(t, e) {
                        const i = this.id3Track;
                        if (t.samples.length) {
                            const s = at(t.samples, ["emsg"]);
                            s && s.forEach((t => {
                                const s = function(t) {
                                    const e = t[0];
                                    let i = "",
                                        s = "",
                                        n = 0,
                                        a = 0,
                                        o = 0,
                                        l = 0,
                                        c = 0,
                                        u = 0;
                                    if (0 === e) {
                                        for (;
                                            "\0" !== tt(t.subarray(u, u + 1));) i += tt(t.subarray(u, u + 1)), u += 1;
                                        for (i += tt(t.subarray(u, u + 1)), u += 1;
                                            "\0" !== tt(t.subarray(u, u + 1));) s += tt(t.subarray(u, u + 1)), u += 1;
                                        s += tt(t.subarray(u, u + 1)), u += 1, n = it(t, 12), a = it(t, 16), l = it(t, 20), c = it(t, 24), u = 28
                                    } else if (1 === e) {
                                        u += 4, n = it(t, u), u += 4;
                                        const e = it(t, u);
                                        u += 4;
                                        const a = it(t, u);
                                        for (u += 4, o = 2 ** 32 * e + a, r(o) || (o = Number.MAX_SAFE_INTEGER, R.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), l = it(t, u), u += 4, c = it(t, u), u += 4;
                                            "\0" !== tt(t.subarray(u, u + 1));) i += tt(t.subarray(u, u + 1)), u += 1;
                                        for (i += tt(t.subarray(u, u + 1)), u += 1;
                                            "\0" !== tt(t.subarray(u, u + 1));) s += tt(t.subarray(u, u + 1)), u += 1;
                                        s += tt(t.subarray(u, u + 1)), u += 1
                                    }
                                    return {
                                        schemeIdUri: i,
                                        value: s,
                                        timeScale: n,
                                        presentationTime: o,
                                        presentationTimeDelta: a,
                                        eventDuration: l,
                                        id: c,
                                        payload: t.subarray(u, t.byteLength)
                                    }
                                }(t);
                                if (Fs.test(s.schemeIdUri)) {
                                    const t = $s(s, e);
                                    let r = 4294967295 === s.eventDuration ? Number.POSITIVE_INFINITY : s.eventDuration / s.timeScale;
                                    r <= .001 && (r = Number.POSITIVE_INFINITY);
                                    const n = s.payload;
                                    i.samples.push({
                                        data: n,
                                        len: n.byteLength,
                                        dts: t,
                                        pts: t,
                                        type: Es.emsg,
                                        duration: r
                                    })
                                } else if (this.config.enableEmsgKLVMetadata && s.schemeIdUri.startsWith("urn:misb:KLV:bin:1910.1")) {
                                    const t = $s(s, e);
                                    i.samples.push({
                                        data: s.payload,
                                        len: s.payload.byteLength,
                                        dts: t,
                                        pts: t,
                                        type: Es.misbklv,
                                        duration: Number.POSITIVE_INFINITY
                                    })
                                }
                            }))
                        }
                        return i
                    }
                    demuxSampleAes(t, e, i) {
                        return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"))
                    }
                    destroy() {
                        this.config = null, this.remainderData = null, this.videoTrack = this.audioTrack = this.id3Track = this.txtTrack = void 0
                    }
                },
                remux: class {
                    constructor(t, e, i, s) {
                        this.logger = void 0, this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null, this.logger = s
                    }
                    destroy() {}
                    resetTimeStamp(t) {
                        this.initPTS = t, this.lastEndTime = null
                    }
                    resetNextTimestamp() {
                        this.lastEndTime = null
                    }
                    resetInitSegment(t, e, i, s) {
                        this.audioCodec = e, this.videoCodec = i, this.generateInitSegment(function(t, e) {
                            if (!t || !e) return t;
                            const i = e.keyId;
                            return i && e.isCommonEncryption && at(t, ["moov", "trak"]).forEach((t => {
                                const e = at(t, ["mdia", "minf", "stbl", "stsd"])[0].subarray(8);
                                let s = at(e, ["enca"]);
                                const r = s.length > 0;
                                r || (s = at(e, ["encv"])), s.forEach((t => {
                                    at(r ? t.subarray(28) : t.subarray(78), ["sinf"]).forEach((t => {
                                        const e = pt(t);
                                        if (e) {
                                            const t = e.subarray(8, 24);
                                            t.some((t => 0 !== t)) || (R.log(`[eme] Patching keyId in 'enc${r?"a":"v"}>sinf>>tenc' box: ${x(t)} -> ${x(i)}`), e.set(i, 8))
                                        }
                                    }))
                                }))
                            })), t
                        }(t, s)), this.emitInitSegment = !0
                    }
                    generateInitSegment(t) {
                        let {
                            audioCodec: e,
                            videoCodec: i
                        } = this;
                        if (null == t || !t.byteLength) return this.initTracks = void 0, void(this.initData = void 0);
                        const s = this.initData = lt(t);
                        s.audio && (e = dr(s.audio, V)), s.video && (i = dr(s.video, H));
                        const r = {};
                        s.audio && s.video ? r.audiovideo = {
                            container: "video/mp4",
                            codec: e + "," + i,
                            supplemental: s.video.supplemental,
                            initSegment: t,
                            id: "main"
                        } : s.audio ? r.audio = {
                            container: "audio/mp4",
                            codec: e,
                            initSegment: t,
                            id: "audio"
                        } : s.video ? r.video = {
                            container: "video/mp4",
                            codec: i,
                            supplemental: s.video.supplemental,
                            initSegment: t,
                            id: "main"
                        } : this.logger.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."), this.initTracks = r
                    }
                    remux(t, e, i, r, n, a) {
                        var o, l;
                        let {
                            initPTS: c,
                            lastEndTime: u
                        } = this;
                        const d = {
                            audio: void 0,
                            video: void 0,
                            text: r,
                            id3: i,
                            initSegment: void 0
                        };
                        s(u) || (u = this.lastEndTime = n || 0);
                        const h = e.samples;
                        if (null == h || !h.length) return d;
                        const f = {
                            initPTS: void 0,
                            timescale: 1
                        };
                        let p = this.initData;
                        if (null != (o = p) && o.length || (this.generateInitSegment(h), p = this.initData), null == (l = p) || !l.length) return this.logger.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."), d;
                        this.emitInitSegment && (f.tracks = this.initTracks, this.emitInitSegment = !1);
                        const g = function(t, e) {
                                let i = 0,
                                    r = 0,
                                    n = 0;
                                const a = at(t, ["moof", "traf"]);
                                for (let t = 0; t < a.length; t++) {
                                    const s = a[t],
                                        o = at(s, ["tfhd"])[0],
                                        l = e[it(o, 4)];
                                    if (!l) continue;
                                    const c = l.default,
                                        u = it(o, 0) | (null == c ? void 0 : c.flags);
                                    let d = null == c ? void 0 : c.duration;
                                    8 & u && (d = it(o, 2 & u ? 12 : 8));
                                    const h = l.timescale || 9e4,
                                        f = at(s, ["trun"]);
                                    for (let t = 0; t < f.length; t++) i = gt(f[t]), !i && d && (i = d * it(f[t], 4)), l.type === H ? r += i / h : l.type === V && (n += i / h)
                                }
                                if (0 === r && 0 === n) {
                                    let e = 1 / 0,
                                        i = 0,
                                        r = 0;
                                    const n = at(t, ["sidx"]);
                                    for (let t = 0; t < n.length; t++) {
                                        const s = ot(n[t]);
                                        if (null != s && s.references) {
                                            e = Math.min(e, s.earliestPresentationTime / s.timescale);
                                            const t = s.references.reduce(((t, e) => t + e.info.duration || 0), 0);
                                            i = Math.max(i, t + s.earliestPresentationTime / s.timescale), r = i - e
                                        }
                                    }
                                    if (r && s(r)) return r
                                }
                                return r || n
                            }(h, p),
                            m = function(t, e) {
                                return at(e, ["moof", "traf"]).reduce(((e, i) => {
                                    const r = at(i, ["tfdt"])[0],
                                        n = r[0],
                                        a = at(i, ["tfhd"]).reduce(((e, i) => {
                                            const a = it(i, 4),
                                                o = t[a];
                                            if (o) {
                                                let t = it(r, 4);
                                                if (1 === n) {
                                                    if (t === Q) return R.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time"), e;
                                                    t *= Q + 1, t += it(r, 8)
                                                }
                                                const i = t / (o.timescale || 9e4);
                                                if (s(i) && (null === e || i < e)) return i
                                            }
                                            return e
                                        }), null);
                                    return null !== a && s(a) && (null === e || a < e) ? a : e
                                }), null)
                            }(p, h),
                            y = null === m ? n : m;
                        !a && c || ! function(t, e, i, s) {
                            if (null === t) return !0;
                            const r = Math.max(s, 1),
                                n = e - t.baseTime / t.timescale;
                            return Math.abs(n - i) > r
                        }(c, y, n, g) && f.timescale === c.timescale || (f.initPTS = y - n, c && 1 === c.timescale && this.logger.warn(`Adjusting initPTS @${n} from ${c.baseTime/c.timescale} to ${f.initPTS}`), this.initPTS = c = {
                            baseTime: f.initPTS,
                            timescale: 1
                        });
                        const v = t ? y - c.baseTime / c.timescale : u,
                            b = v + g;
                        ! function(t, e, i) {
                            at(e, ["moof", "traf"]).forEach((e => {
                                at(e, ["tfhd"]).forEach((s => {
                                    const r = it(s, 4),
                                        n = t[r];
                                    if (!n) return;
                                    const a = n.timescale || 9e4;
                                    at(e, ["tfdt"]).forEach((t => {
                                        const e = t[0],
                                            s = i * a;
                                        if (s) {
                                            let i = it(t, 4);
                                            if (0 === e) i -= s, i = Math.max(i, 0), nt(t, 4, i);
                                            else {
                                                i *= Math.pow(2, 32), i += it(t, 8), i -= s, i = Math.max(i, 0);
                                                const e = Math.floor(i / (Q + 1)),
                                                    r = Math.floor(i % (Q + 1));
                                                nt(t, 4, e), nt(t, 8, r)
                                            }
                                        }
                                    }))
                                }))
                            }))
                        }(p, h, c.baseTime / c.timescale), g > 0 ? this.lastEndTime = b : (this.logger.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp());
                        const T = !!p.audio,
                            E = !!p.video;
                        let S = "";
                        T && (S += "audio"), E && (S += "video");
                        const w = {
                            data1: h,
                            startPTS: v,
                            startDTS: v,
                            endPTS: b,
                            endDTS: b,
                            type: S,
                            hasAudio: T,
                            hasVideo: E,
                            nb: 1,
                            dropped: 0
                        };
                        return d.audio = "audio" === w.type ? w : void 0, d.video = "audio" !== w.type ? w : void 0, d.initSegment = f, d.id3 = cr(i, n, c, c), r.samples.length && (d.text = ur(r, n, c)), d
                    }
                }
            }, {
                demux: Ks,
                remux: or
            }, {
                demux: class extends ws {
                    constructor(t, e) {
                        super(), this.observer = void 0, this.config = void 0, this.observer = t, this.config = e
                    }
                    resetInitSegment(t, e, i, s) {
                        super.resetInitSegment(t, e, i, s), this._audioTrack = {
                            container: "audio/adts",
                            type: "audio",
                            id: 2,
                            pid: -1,
                            sequenceNumber: 0,
                            segmentCodec: "aac",
                            samples: [],
                            manifestCodec: e,
                            duration: s,
                            inputTimeScale: 9e4,
                            dropped: 0
                        }
                    }
                    static probe(t, e) {
                        if (!t) return !1;
                        const i = es(t, 0);
                        let s = (null == i ? void 0 : i.length) || 0;
                        if (Os(t, s)) return !1;
                        for (let i = t.length; s < i; s++)
                            if (as(t, s)) return e.log("ADTS sync word found !"), !0;
                        return !1
                    }
                    canParse(t, e) {
                        return function(t, e) {
                            return function(t, e) {
                                return e + 5 < t.length
                            }(t, e) && is(t, e) && rs(t, e) <= t.length - e
                        }(t, e)
                    }
                    appendFrame(t, e, i) {
                        os(t, this.observer, e, i, t.manifestCodec);
                        const s = cs(t, e, i, this.basePTS, this.frameIndex);
                        if (s && 0 === s.missing) return s
                    }
                },
                remux: or
            }, {
                demux: class extends ws {
                    resetInitSegment(t, e, i, s) {
                        super.resetInitSegment(t, e, i, s), this._audioTrack = {
                            container: "audio/mpeg",
                            type: "audio",
                            id: 2,
                            pid: -1,
                            sequenceNumber: 0,
                            segmentCodec: "mp3",
                            samples: [],
                            manifestCodec: e,
                            duration: s,
                            inputTimeScale: 9e4,
                            dropped: 0
                        }
                    }
                    static probe(t) {
                        if (!t) return !1;
                        const e = es(t, 0);
                        let i = (null == e ? void 0 : e.length) || 0;
                        if (e && 11 === t[i] && 119 === t[i + 1] && void 0 !== Ts(e) && Ms(t, i) <= 16) return !1;
                        for (let e = t.length; i < e; i++)
                            if (Os(t, i)) return R.log("MPEG Audio sync word found !"), !0;
                        return !1
                    }
                    canParse(t, e) {
                        return function(t, e) {
                            return xs(t, e) && 4 <= t.length - e
                        }(t, e)
                    }
                    appendFrame(t, e, i) {
                        if (null !== this.basePTS) return Cs(t, e, i, this.basePTS, this.frameIndex)
                    }
                },
                remux: or
            }];
            hr.splice(2, 0, {
                demux: class extends ws {
                    constructor(t) {
                        super(), this.observer = void 0, this.observer = t
                    }
                    resetInitSegment(t, e, i, s) {
                        super.resetInitSegment(t, e, i, s), this._audioTrack = {
                            container: "audio/ac-3",
                            type: "audio",
                            id: 2,
                            pid: -1,
                            sequenceNumber: 0,
                            segmentCodec: "ac3",
                            samples: [],
                            manifestCodec: e,
                            duration: s,
                            inputTimeScale: 9e4,
                            dropped: 0
                        }
                    }
                    canParse(t, e) {
                        return e + 64 < t.length
                    }
                    appendFrame(t, e, i) {
                        const s = Ns(t, e, i, this.basePTS, this.frameIndex);
                        if (-1 !== s) return {
                            sample: t.samples[t.samples.length - 1],
                            length: s,
                            missing: 0
                        }
                    }
                    static probe(t) {
                        if (!t) return !1;
                        const e = es(t, 0);
                        if (!e) return !1;
                        const i = e.length;
                        return 11 === t[i] && 119 === t[i + 1] && void 0 !== Ts(e) && Ms(t, i) < 16
                    }
                },
                remux: or
            });
            class fr {
                constructor(t, e, i, s, r, n) {
                    this.asyncResult = !1, this.logger = void 0, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = t, this.typeSupported = e, this.config = i, this.id = r, this.logger = n
                }
                configure(t) {
                    this.transmuxConfig = t, this.decrypter && this.decrypter.reset()
                }
                push(t, e, i, s) {
                    const r = i.transmuxing;
                    r.executeStart = sr();
                    let n = new Uint8Array(t);
                    const {
                        currentTransmuxState: c,
                        transmuxConfig: u
                    } = this;
                    s && (this.currentTransmuxState = s);
                    const {
                        contiguous: d,
                        discontinuity: h,
                        trackSwitch: f,
                        accurateTimeOffset: p,
                        timeOffset: g,
                        initSegmentChange: m
                    } = s || c, {
                        audioCodec: y,
                        videoCodec: v,
                        defaultInitPts: b,
                        duration: T,
                        initSegmentData: E
                    } = u, S = function(t, e) {
                        let i = null;
                        return t.byteLength > 0 && null != (null == e ? void 0 : e.key) && null !== e.iv && null != e.method && (i = e), i
                    }(n, e);
                    if (S && ze(S.method)) {
                        const t = this.getDecrypter(),
                            e = qe(S.method);
                        if (!t.isSync()) return this.asyncResult = !0, this.decryptionPromise = t.webCryptoDecrypt(n, S.key.buffer, S.iv.buffer, e).then((t => {
                            const e = this.push(t, null, i);
                            return this.decryptionPromise = null, e
                        })), this.decryptionPromise; {
                            let s = t.softwareDecrypt(n, S.key.buffer, S.iv.buffer, e);
                            if (i.part > -1) {
                                const e = t.flush();
                                s = e ? e.buffer : e
                            }
                            if (!s) return r.executeEnd = sr(), pr(i);
                            n = new Uint8Array(s)
                        }
                    }
                    const w = this.needsProbing(h, f);
                    if (w) {
                        const t = this.configureTransmuxer(n);
                        if (t) return this.logger.warn(`[transmuxer] ${t.message}`), this.observer.emit(l.ERROR, l.ERROR, {
                            type: a.MEDIA_ERROR,
                            details: o.FRAG_PARSING_ERROR,
                            fatal: !1,
                            error: t,
                            reason: t.message
                        }), r.executeEnd = sr(), pr(i)
                    }(h || f || m || w) && this.resetInitSegment(E, y, v, T, e), (h || m || w) && this.resetInitialTimestamp(b), d || this.resetContiguity();
                    const k = this.transmux(n, S, g, p, i);
                    this.asyncResult = gr(k);
                    const A = this.currentTransmuxState;
                    return A.contiguous = !0, A.discontinuity = !1, A.trackSwitch = !1, r.executeEnd = sr(), k
                }
                flush(t) {
                    const e = t.transmuxing;
                    e.executeStart = sr();
                    const {
                        decrypter: i,
                        currentTransmuxState: s,
                        decryptionPromise: r
                    } = this;
                    if (r) return this.asyncResult = !0, r.then((() => this.flush(t)));
                    const n = [],
                        {
                            timeOffset: a
                        } = s;
                    if (i) {
                        const e = i.flush();
                        e && n.push(this.push(e.buffer, null, t))
                    }
                    const {
                        demuxer: o,
                        remuxer: l
                    } = this;
                    if (!o || !l) {
                        e.executeEnd = sr();
                        const i = [pr(t)];
                        return this.asyncResult ? Promise.resolve(i) : i
                    }
                    const c = o.flush(a);
                    return gr(c) ? (this.asyncResult = !0, c.then((e => (this.flushRemux(n, e, t), n)))) : (this.flushRemux(n, c, t), this.asyncResult ? Promise.resolve(n) : n)
                }
                flushRemux(t, e, i) {
                    const {
                        audioTrack: s,
                        videoTrack: r,
                        id3Track: n,
                        textTrack: a
                    } = e, {
                        accurateTimeOffset: o,
                        timeOffset: l
                    } = this.currentTransmuxState;
                    this.logger.log(`[transmuxer.ts]: Flushed ${this.id} sn: ${i.sn}${i.part>-1?" part: "+i.part:""} of ${this.id===f?"level":"track"} ${i.level}`);
                    const c = this.remuxer.remux(s, r, n, a, l, o, !0, this.id);
                    t.push({
                        remuxResult: c,
                        chunkMeta: i
                    }), i.transmuxing.executeEnd = sr()
                }
                resetInitialTimestamp(t) {
                    const {
                        demuxer: e,
                        remuxer: i
                    } = this;
                    e && i && (e.resetTimeStamp(t), i.resetTimeStamp(t))
                }
                resetContiguity() {
                    const {
                        demuxer: t,
                        remuxer: e
                    } = this;
                    t && e && (t.resetContiguity(), e.resetNextTimestamp())
                }
                resetInitSegment(t, e, i, s, r) {
                    const {
                        demuxer: n,
                        remuxer: a
                    } = this;
                    n && a && (n.resetInitSegment(t, e, i, s), a.resetInitSegment(t, e, i, r))
                }
                destroy() {
                    this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0)
                }
                transmux(t, e, i, s, r) {
                    let n;
                    return n = e && "SAMPLE-AES" === e.method ? this.transmuxSampleAes(t, e, i, s, r) : this.transmuxUnencrypted(t, i, s, r), n
                }
                transmuxUnencrypted(t, e, i, s) {
                    const {
                        audioTrack: r,
                        videoTrack: n,
                        id3Track: a,
                        textTrack: o
                    } = this.demuxer.demux(t, e, !1, !this.config.progressive);
                    return {
                        remuxResult: this.remuxer.remux(r, n, a, o, e, i, !1, this.id),
                        chunkMeta: s
                    }
                }
                transmuxSampleAes(t, e, i, s, r) {
                    return this.demuxer.demuxSampleAes(t, e, i).then((t => ({
                        remuxResult: this.remuxer.remux(t.audioTrack, t.videoTrack, t.id3Track, t.textTrack, i, s, !1, this.id),
                        chunkMeta: r
                    })))
                }
                configureTransmuxer(t) {
                    const {
                        config: e,
                        observer: i,
                        typeSupported: s
                    } = this;
                    let r;
                    for (let e = 0, i = hr.length; e < i; e++) {
                        var n;
                        if (null != (n = hr[e].demux) && n.probe(t, this.logger)) {
                            r = hr[e];
                            break
                        }
                    }
                    if (!r) return new Error("Failed to find demuxer by probing fragment data");
                    const a = this.demuxer,
                        o = this.remuxer,
                        l = r.remux,
                        c = r.demux;
                    o && o instanceof l || (this.remuxer = new l(i, e, s, this.logger)), a && a instanceof c || (this.demuxer = new c(i, e, s, this.logger), this.probe = c.probe)
                }
                needsProbing(t, e) {
                    return !this.demuxer || !this.remuxer || t || e
                }
                getDecrypter() {
                    let t = this.decrypter;
                    return t || (t = this.decrypter = new Ae(this.config)), t
                }
            }
            const pr = t => ({
                remuxResult: {},
                chunkMeta: t
            });

            function gr(t) {
                return "then" in t && t.then instanceof Function
            }
            class mr {
                constructor(t, e, i, s, r) {
                    this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = t, this.videoCodec = e, this.initSegmentData = i, this.duration = s, this.defaultInitPts = r || null
                }
            }
            class yr {
                constructor(t, e, i, s, r, n) {
                    this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = t, this.contiguous = e, this.accurateTimeOffset = i, this.trackSwitch = s, this.timeOffset = r, this.initSegmentChange = n
                }
            }
            let vr = 0;
            class br {
                constructor(t, e, i, s) {
                    this.error = null, this.hls = void 0, this.id = void 0, this.instanceNo = vr++, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0, this.onWorkerMessage = t => {
                        const e = t.data,
                            i = this.hls;
                        if (i && null != e && e.event && e.instanceNo === this.instanceNo) switch (e.event) {
                            case "init":
                                {
                                    var s;
                                    const t = null == (s = this.workerContext) ? void 0 : s.objectURL;t && self.URL.revokeObjectURL(t);
                                    break
                                }
                            case "transmuxComplete":
                                this.handleTransmuxComplete(e.data);
                                break;
                            case "flush":
                                this.onFlush(e.data);
                                break;
                            case "workerLog":
                                i.logger[e.data.logType] && i.logger[e.data.logType](e.data.message);
                                break;
                            default:
                                e.data = e.data || {}, e.data.frag = this.frag, e.data.part = this.part, e.data.id = this.id, i.trigger(e.event, e.data)
                        }
                    }, this.onWorkerError = t => {
                        if (!this.hls) return;
                        const e = new Error(`${t.message}  (${t.filename}:${t.lineno})`);
                        this.hls.config.enableWorker = !1, this.hls.logger.warn(`Error in "${this.id}" Web Worker, fallback to inline`), this.hls.trigger(l.ERROR, {
                            type: a.OTHER_ERROR,
                            details: o.INTERNAL_EXCEPTION,
                            fatal: !1,
                            event: "demuxerWorker",
                            error: e
                        })
                    };
                    const r = t.config;
                    this.hls = t, this.id = e, this.useWorker = !!r.enableWorker, this.onTransmuxComplete = i, this.onFlush = s;
                    const n = (t, e) => {
                        (e = e || {}).frag = this.frag || void 0, t === l.ERROR && (e.parent = this.id, e.part = this.part, this.error = e.error), this.hls.trigger(t, e)
                    };
                    this.observer = new Yi, this.observer.on(l.FRAG_DECRYPTED, n), this.observer.on(l.ERROR, n);
                    const c = Nt(r.preferManagedMediaSource);
                    if (this.useWorker && "undefined" != typeof Worker) {
                        const i = this.hls.logger;
                        if (r.workerPath || "function" == typeof __HLS_WORKER_BUNDLE__) {
                            try {
                                r.workerPath ? (i.log(`loading Web Worker ${r.workerPath} for "${e}"`), this.workerContext = function(t) {
                                    const e = Qi[t];
                                    if (e) return e.clientCount++, e;
                                    const i = new self.URL(t, self.location.href).href,
                                        s = {
                                            worker: new self.Worker(i),
                                            scriptURL: i,
                                            clientCount: 1
                                        };
                                    return Qi[t] = s, s
                                }(r.workerPath)) : (i.log(`injecting Web Worker for "${e}"`), this.workerContext = function() {
                                    const t = Qi[Xi];
                                    if (t) return t.clientCount++, t;
                                    const e = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {
                                            type: "text/javascript"
                                        }),
                                        i = self.URL.createObjectURL(e),
                                        s = {
                                            worker: new self.Worker(i),
                                            objectURL: i,
                                            clientCount: 1
                                        };
                                    return Qi[Xi] = s, s
                                }());
                                const {
                                    worker: t
                                } = this.workerContext;
                                t.addEventListener("message", this.onWorkerMessage), t.addEventListener("error", this.onWorkerError), t.postMessage({
                                    instanceNo: this.instanceNo,
                                    cmd: "init",
                                    typeSupported: c,
                                    id: e,
                                    config: Yt(r)
                                })
                            } catch (s) {
                                i.warn(`Error setting up "${e}" Web Worker, fallback to inline`, s), this.terminateWorker(), this.error = null, this.transmuxer = new fr(this.observer, c, r, "", e, t.logger)
                            }
                            return
                        }
                    }
                    this.transmuxer = new fr(this.observer, c, r, "", e, t.logger)
                }
                reset() {
                    if (this.frag = null, this.part = null, this.workerContext) {
                        const t = this.instanceNo;
                        this.instanceNo = vr++;
                        const e = this.hls.config,
                            i = Nt(e.preferManagedMediaSource);
                        this.workerContext.worker.postMessage({
                            instanceNo: this.instanceNo,
                            cmd: "reset",
                            resetNo: t,
                            typeSupported: i,
                            id: this.id,
                            config: Yt(e)
                        })
                    }
                }
                terminateWorker() {
                    if (this.workerContext) {
                        const {
                            worker: t
                        } = this.workerContext;
                        this.workerContext = null, t.removeEventListener("message", this.onWorkerMessage), t.removeEventListener("error", this.onWorkerError),
                            function(t) {
                                const e = Qi[t || Xi];
                                if (e && 1 == e.clientCount--) {
                                    const {
                                        worker: i,
                                        objectURL: s
                                    } = e;
                                    delete Qi[t || Xi], s && self.URL.revokeObjectURL(s), i.terminate()
                                }
                            }(this.hls.config.workerPath)
                    }
                }
                destroy() {
                    if (this.workerContext) this.terminateWorker(), this.onWorkerMessage = this.onWorkerError = null;
                    else {
                        const t = this.transmuxer;
                        t && (t.destroy(), this.transmuxer = null)
                    }
                    const t = this.observer;
                    t && t.removeAllListeners(), this.frag = null, this.part = null, this.observer = null, this.hls = null
                }
                push(t, e, i, s, r, n, a, o, l, c) {
                    var u, d;
                    l.transmuxing.start = self.performance.now();
                    const {
                        instanceNo: h,
                        transmuxer: p
                    } = this, g = n ? n.start : r.start, m = r.decryptdata, y = this.frag, v = !(y && r.cc === y.cc), b = !(y && l.level === y.level), T = y ? l.sn - y.sn : -1, E = this.part ? l.part - this.part.index : -1, S = 0 === T && l.id > 1 && l.id === (null == y ? void 0 : y.stats.chunkCount), w = !b && (1 === T || 0 === T && (1 === E || S && E <= 0)), k = self.performance.now();
                    (b || T || 0 === r.stats.parsing.start) && (r.stats.parsing.start = k), !n || !E && w || (n.stats.parsing.start = k);
                    const A = !(y && (null == (u = r.initSegment) ? void 0 : u.url) === (null == (d = y.initSegment) ? void 0 : d.url)),
                        _ = new yr(v, w, o, b, g, A);
                    if (!w || v || A) {
                        this.hls.logger.log(`[transmuxer-interface]: Starting new transmux session for ${r.type} sn: ${l.sn}${l.part>-1?" part: "+l.part:""} ${this.id===f?"level":"track"}: ${l.level} id: ${l.id}\n        discontinuity: ${v}\n        trackSwitch: ${b}\n        contiguous: ${w}\n        accurateTimeOffset: ${o}\n        timeOffset: ${g}\n        initSegmentChange: ${A}`);
                        const t = new mr(i, s, e, a, c);
                        this.configureTransmuxer(t)
                    }
                    if (this.frag = r, this.part = n, this.workerContext) this.workerContext.worker.postMessage({
                        instanceNo: h,
                        cmd: "demux",
                        data: t,
                        decryptdata: m,
                        chunkMeta: l,
                        state: _
                    }, t instanceof ArrayBuffer ? [t] : []);
                    else if (p) {
                        const e = p.push(t, m, l, _);
                        gr(e) ? e.then((t => {
                            this.handleTransmuxComplete(t)
                        })).catch((t => {
                            this.transmuxerError(t, l, "transmuxer-interface push error")
                        })) : this.handleTransmuxComplete(e)
                    }
                }
                flush(t) {
                    t.transmuxing.start = self.performance.now();
                    const {
                        instanceNo: e,
                        transmuxer: i
                    } = this;
                    if (this.workerContext) this.workerContext.worker.postMessage({
                        instanceNo: e,
                        cmd: "flush",
                        chunkMeta: t
                    });
                    else if (i) {
                        const e = i.flush(t);
                        gr(e) ? e.then((e => {
                            this.handleFlushResult(e, t)
                        })).catch((e => {
                            this.transmuxerError(e, t, "transmuxer-interface flush error")
                        })) : this.handleFlushResult(e, t)
                    }
                }
                transmuxerError(t, e, i) {
                    this.hls && (this.error = t, this.hls.trigger(l.ERROR, {
                        type: a.MEDIA_ERROR,
                        details: o.FRAG_PARSING_ERROR,
                        chunkMeta: e,
                        frag: this.frag || void 0,
                        part: this.part || void 0,
                        fatal: !1,
                        error: t,
                        err: t,
                        reason: i
                    }))
                }
                handleFlushResult(t, e) {
                    t.forEach((t => {
                        this.handleTransmuxComplete(t)
                    })), this.onFlush(e)
                }
                configureTransmuxer(t) {
                    const {
                        instanceNo: e,
                        transmuxer: i
                    } = this;
                    this.workerContext ? this.workerContext.worker.postMessage({
                        instanceNo: e,
                        cmd: "configure",
                        config: t
                    }) : i && i.configure(t)
                }
                handleTransmuxComplete(t) {
                    t.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(t)
                }
            }
            class Tr extends S {
                constructor(t, e) {
                    super(e, t.logger), this.hls = void 0, this.canLoad = !1, this.timer = -1, this.hls = t
                }
                destroy() {
                    this.clearTimer(), this.hls = this.log = this.warn = null
                }
                clearTimer() {
                    -1 !== this.timer && (self.clearTimeout(this.timer), this.timer = -1)
                }
                startLoad() {
                    this.canLoad = !0, this.loadPlaylist()
                }
                stopLoad() {
                    this.canLoad = !1, this.clearTimer()
                }
                switchParams(t, e, i) {
                    const s = null == e ? void 0 : e.renditionReports;
                    if (s) {
                        let r = -1;
                        for (let i = 0; i < s.length; i++) {
                            const n = s[i];
                            let a;
                            try {
                                a = new self.URL(n.URI, e.url).href
                            } catch (t) {
                                this.warn(`Could not construct new URL for Rendition Report: ${t}`), a = n.URI || ""
                            }
                            if (a === t) {
                                r = i;
                                break
                            }
                            a === t.substring(0, a.length) && (r = i)
                        }
                        if (-1 !== r) {
                            const t = s[r],
                                n = parseInt(t["LAST-MSN"]) || (null == e ? void 0 : e.lastPartSn);
                            let a = parseInt(t["LAST-PART"]) || (null == e ? void 0 : e.lastPartIndex);
                            if (this.hls.config.lowLatencyMode) {
                                const t = Math.min(e.age - e.partTarget, e.targetduration);
                                a >= 0 && t > e.partTarget && (a += 1)
                            }
                            const o = i && Kt(i);
                            return new zt(n, a >= 0 ? a : void 0, o)
                        }
                    }
                }
                loadPlaylist(t) {
                    this.clearTimer()
                }
                loadingPlaylist(t, e) {
                    this.clearTimer()
                }
                shouldLoadPlaylist(t) {
                    return this.canLoad && !!t && !!t.url && (!t.details || t.details.live)
                }
                getUrlWithDirectives(t, e) {
                    if (e) try {
                        return e.addDirectives(t)
                    } catch (t) {
                        this.warn(`Could not construct new URL with HLS Delivery Directives: ${t}`)
                    }
                    return t
                }
                playlistLoaded(t, e, i) {
                    const {
                        details: r,
                        stats: n
                    } = e, c = self.performance.now(), u = n.loading.first ? Math.max(0, c - n.loading.first) : 0;
                    r.advancedDateTime = Date.now() - u;
                    const d = this.hls.config.timelineOffset;
                    if (d !== r.appliedTimelineOffset) {
                        const t = Math.max(d || 0, 0);
                        r.appliedTimelineOffset = t, r.fragments.forEach((e => {
                            e.start = e.playlistOffset + t
                        }))
                    }
                    if (r.live || null != i && i.live) {
                        const d = "levelInfo" in e ? e.levelInfo : e.track;
                        if (r.reloaded(i), i && r.fragments.length > 0) {
                            ! function(t, e) {
                                if (t === e) return;
                                let i = null;
                                const r = t.fragments;
                                for (let t = r.length - 1; t >= 0; t--) {
                                    const e = r[t].initSegment;
                                    if (e) {
                                        i = e;
                                        break
                                    }
                                }
                                let n;
                                t.fragmentHint && delete t.fragmentHint.endPTS,
                                    function(t, e, i) {
                                        const s = e.skippedSegments,
                                            r = Math.max(t.startSN, e.startSN) - e.startSN,
                                            n = (t.fragmentHint ? 1 : 0) + (s ? e.endSN : Math.min(t.endSN, e.endSN)) - e.startSN,
                                            a = e.startSN - t.startSN,
                                            o = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments,
                                            l = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments;
                                        for (let c = r; c <= n; c++) {
                                            const r = l[a + c];
                                            let n = o[c];
                                            if (s && !n && r && (n = e.fragments[c] = r), r && n) {
                                                if (i(r, n, c, o), r.url && r.url !== n.url) return void(e.playlistParsingError = Ci(`media sequence mismatch ${n.sn}:`, t, e, 0, n));
                                                if (r.cc !== n.cc) return void(e.playlistParsingError = Ci(`discontinuity sequence mismatch (${r.cc}!=${n.cc})`, t, e, 0, n))
                                            }
                                        }
                                    }(t, e, ((t, r, a, o) => {
                                        if (e.skippedSegments && r.cc !== t.cc) {
                                            const e = t.cc - r.cc;
                                            for (let t = a; t < o.length; t++) o[t].cc += e
                                        }
                                        s(t.startPTS) && s(t.endPTS) && (r.setStart(r.startPTS = t.startPTS), r.startDTS = t.startDTS, r.maxStartPTS = t.maxStartPTS, r.endPTS = t.endPTS, r.endDTS = t.endDTS, r.minEndPTS = t.minEndPTS, r.setDuration(t.endPTS - t.startPTS), r.duration && (n = r), e.PTSKnown = e.alignedSliding = !0), t.hasStreams && (r.elementaryStreams = t.elementaryStreams), r.loader = t.loader, t.hasStats && (r.stats = t.stats), t.initSegment && (r.initSegment = t.initSegment, i = t.initSegment)
                                    }));
                                const a = e.fragments,
                                    o = e.fragmentHint ? a.concat(e.fragmentHint) : a;
                                if (i && o.forEach((t => {
                                        var e;
                                        !t || t.initSegment && t.initSegment.relurl !== (null == (e = i) ? void 0 : e.relurl) || (t.initSegment = i)
                                    })), e.skippedSegments)
                                    if (e.deltaUpdateFailed = a.some((t => !t)), e.deltaUpdateFailed) {
                                        R.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
                                        for (let t = e.skippedSegments; t--;) a.shift();
                                        e.startSN = a[0].sn
                                    } else {
                                        e.endCC = a[a.length - 1].cc, e.canSkipDateRanges && (e.dateRanges = function(t, e) {
                                            const {
                                                dateRanges: i,
                                                recentlyRemovedDateranges: s
                                            } = e, r = b({}, t);
                                            s && s.forEach((t => {
                                                delete r[t]
                                            }));
                                            const n = Object.keys(r).length;
                                            return n && Object.keys(i).forEach((t => {
                                                const e = r[t],
                                                    s = new He(i[t].attr, e);
                                                s.isValid ? (r[t] = s, e || (s.tagOrder += n)) : R.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${Yt(i[t].attr)}"`)
                                            })), r
                                        }(t.dateRanges, e));
                                        const i = t.fragments.filter((t => t.rawProgramDateTime));
                                        if (t.hasProgramDateTime && !e.hasProgramDateTime)
                                            for (let t = 1; t < o.length; t++) null === o[t].programDateTime && wi(o[t], o[t - 1], i);
                                        yi(i, e)
                                    }! function(t, e, i) {
                                    if (t && e) {
                                        let s = 0;
                                        for (let r = 0, n = t.length; r <= n; r++) {
                                            const n = t[r],
                                                a = e[r + s];
                                            n && a && n.index === a.index && n.fragment.sn === a.fragment.sn ? i(n, a) : s--
                                        }
                                    }
                                }(t.partList, e.partList, ((t, e) => {
                                    e.elementaryStreams = t.elementaryStreams, e.stats = t.stats
                                })), n ? Ii(e, n, n.startPTS, n.endPTS, n.startDTS, n.endDTS) : Di(t, e), a.length && (e.totalduration = e.edge - a[0].start), e.driftStartTime = t.driftStartTime, e.driftStart = t.driftStart;
                                const l = e.advancedDateTime;
                                if (e.advanced && l) {
                                    const t = e.edge;
                                    e.driftStart || (e.driftStartTime = l, e.driftStart = t), e.driftEndTime = l, e.driftEnd = t
                                } else e.driftEndTime = t.driftEndTime, e.driftEnd = t.driftEnd, e.advancedDateTime = t.advancedDateTime; - 1 === e.requestScheduled && (e.requestScheduled = t.requestScheduled)
                            }(i, r);
                            const t = r.playlistParsingError;
                            if (t) {
                                this.warn(t);
                                const i = this.hls;
                                if (!i.config.ignorePlaylistParsingErrors) {
                                    var h;
                                    const {
                                        networkDetails: s
                                    } = e;
                                    return void i.trigger(l.ERROR, {
                                        type: a.NETWORK_ERROR,
                                        details: o.LEVEL_PARSING_ERROR,
                                        fatal: !1,
                                        url: r.url,
                                        error: t,
                                        reason: t.message,
                                        level: e.level || void 0,
                                        parent: null == (h = r.fragments[0]) ? void 0 : h.type,
                                        networkDetails: s,
                                        stats: n
                                    })
                                }
                                r.playlistParsingError = null
                            }
                        } - 1 === r.requestScheduled && (r.requestScheduled = n.loading.start);
                        const f = this.hls.mainForwardBufferInfo,
                            p = f ? f.end - f.len : 0,
                            g = Pi(r, 1e3 * (r.edge - p));
                        if (r.requestScheduled + g < c ? r.requestScheduled = c : r.requestScheduled += g, this.log(`live playlist ${t} ${r.advanced?"REFRESHED "+r.lastPartSn+"-"+r.lastPartIndex:r.updated?"UPDATED":"MISSED"}`), !this.canLoad || !r.live) return;
                        let m, y, v;
                        if (r.canBlockReload && r.endSN && r.advanced) {
                            const t = this.hls.config.lowLatencyMode,
                                s = r.lastPartSn,
                                n = r.endSN,
                                a = r.lastPartIndex,
                                o = s === n; - 1 !== a ? o ? (y = n + 1, v = t ? 0 : a) : (y = s, v = t ? a + 1 : r.maxPartIndex) : y = n + 1;
                            const l = r.age,
                                u = l + r.ageHeader;
                            let h = Math.min(u - r.partTarget, 1.5 * r.targetduration);
                            if (h > 0) {
                                if (u > 3 * r.targetduration) this.log(`Playlist last advanced ${l.toFixed(2)}s ago. Omitting segment and part directives.`), y = void 0, v = void 0;
                                else if (null != i && i.tuneInGoal && u - r.partTarget > i.tuneInGoal) this.warn(`CDN Tune-in goal increased from: ${i.tuneInGoal} to: ${h} with playlist age: ${r.age}`), h = 0;
                                else {
                                    const t = Math.floor(h / r.targetduration);
                                    y += t, void 0 !== v && (v += Math.round(h % r.targetduration / r.partTarget)), this.log(`CDN Tune-in age: ${r.ageHeader}s last advanced ${l.toFixed(2)}s goal: ${h} skip sn ${t} to part ${v}`)
                                }
                                r.tuneInGoal = h
                            }
                            if (m = this.getDeliveryDirectives(r, e.deliveryDirectives, y, v), t || !o) return r.requestScheduled = c, void this.loadingPlaylist(d, m)
                        } else(r.canBlockReload || r.canSkipUntil) && (m = this.getDeliveryDirectives(r, e.deliveryDirectives, y, v));
                        m && void 0 !== y && r.canBlockReload && (r.requestScheduled = n.loading.first + Math.max(g - 2 * u, g / 2)), this.scheduleLoading(d, m, r)
                    } else this.clearTimer()
                }
                scheduleLoading(t, e, i) {
                    const s = i || t.details;
                    if (!s) return void this.loadingPlaylist(t, e);
                    const r = self.performance.now(),
                        n = s.requestScheduled;
                    if (r >= n) return void this.loadingPlaylist(t, e);
                    const a = n - r;
                    this.log(`reload live playlist ${t.name||t.bitrate+"bps"} in ${Math.round(a)} ms`), this.clearTimer(), this.timer = self.setTimeout((() => this.loadingPlaylist(t, e)), a)
                }
                getDeliveryDirectives(t, e, i, s) {
                    let r = Kt(t);
                    return null != e && e.skip && t.deltaUpdateFailed && (i = e.msn, s = e.part, r = ""), new zt(i, s, r)
                }
                checkRetry(t) {
                    const e = t.details,
                        i = ce(t),
                        s = t.errorAction,
                        {
                            action: r,
                            retryCount: n = 0,
                            retryConfig: a
                        } = s || {},
                        o = !!s && !!a && (5 === r || !s.resolved && 2 === r);
                    if (o) {
                        var l;
                        if (n >= a.maxNumRetry) return !1;
                        if (i && null != (l = t.context) && l.deliveryDirectives) this.warn(`Retrying playlist loading ${n+1}/${a.maxNumRetry} after "${e}" without delivery-directives`), this.loadPlaylist();
                        else {
                            const t = de(a, n);
                            this.clearTimer(), this.timer = self.setTimeout((() => this.loadPlaylist()), t), this.warn(`Retrying playlist loading ${n+1}/${a.maxNumRetry} after "${e}" in ${t}ms`)
                        }
                        t.levelRetry = !0, s.resolved = !0
                    }
                    return o
                }
            }

            function Er(t, e) {
                if (t.length !== e.length) return !1;
                for (let i = 0; i < t.length; i++)
                    if (!Sr(t[i].attrs, e[i].attrs)) return !1;
                return !0
            }

            function Sr(t, e, i) {
                const s = t["STABLE-RENDITION-ID"];
                return s && !i ? s === e["STABLE-RENDITION-ID"] : !(i || ["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED", "ASSOC-LANGUAGE"]).some((i => t[i] !== e[i]))
            }

            function wr(t, e) {
                return e.label.toLowerCase() === t.name.toLowerCase() && (!e.language || e.language.toLowerCase() === (t.lang || "").toLowerCase())
            }
            class kr {
                constructor(t) {
                    this.tracks = void 0, this.queues = {
                        video: [],
                        audio: [],
                        audiovideo: []
                    }, this.tracks = t
                }
                destroy() {
                    this.tracks = this.queues = null
                }
                append(t, e, i) {
                    if (null === this.queues || null === this.tracks) return;
                    const s = this.queues[e];
                    s.push(t), 1 !== s.length || i || this.executeNext(e)
                }
                appendBlocker(t) {
                    return new Promise((e => {
                        const i = {
                            label: "async-blocker",
                            execute: e,
                            onStart: () => {},
                            onComplete: () => {},
                            onError: () => {}
                        };
                        this.append(i, t)
                    }))
                }
                prependBlocker(t) {
                    return new Promise((e => {
                        if (this.queues) {
                            const i = {
                                label: "async-blocker-prepend",
                                execute: e,
                                onStart: () => {},
                                onComplete: () => {},
                                onError: () => {}
                            };
                            this.queues[t].unshift(i)
                        }
                    }))
                }
                removeBlockers() {
                    null !== this.queues && [this.queues.video, this.queues.audio, this.queues.audiovideo].forEach((t => {
                        var e;
                        const i = null == (e = t[0]) ? void 0 : e.label;
                        "async-blocker" !== i && "async-blocker-prepend" !== i || (t[0].execute(), t.splice(0, 1))
                    }))
                }
                unblockAudio(t) {
                    null !== this.queues && this.queues.audio[0] === t && this.shiftAndExecuteNext("audio")
                }
                executeNext(t) {
                    if (null === this.queues || null === this.tracks) return;
                    const e = this.queues[t];
                    if (e.length) {
                        const s = e[0];
                        try {
                            s.execute()
                        } catch (e) {
                            var i;
                            if (s.onError(e), null === this.queues || null === this.tracks) return;
                            const r = null == (i = this.tracks[t]) ? void 0 : i.buffer;
                            null != r && r.updating || this.shiftAndExecuteNext(t)
                        }
                    }
                }
                shiftAndExecuteNext(t) {
                    null !== this.queues && (this.queues[t].shift(), this.executeNext(t))
                }
                current(t) {
                    var e;
                    return (null == (e = this.queues) ? void 0 : e[t][0]) || null
                }
                toString() {
                    const {
                        queues: t,
                        tracks: e
                    } = this;
                    return null === t || null === e ? "<destroyed>" : `\n${this.list("video")}\n${this.list("audio")}\n${this.list("audiovideo")}}`
                }
                list(t) {
                    var e, i;
                    return null != (e = this.queues) && e[t] || null != (i = this.tracks) && i[t] ? `${t}: (${this.listSbInfo(t)}) ${this.listOps(t)}` : ""
                }
                listSbInfo(t) {
                    var e;
                    const i = null == (e = this.tracks) ? void 0 : e[t],
                        s = null == i ? void 0 : i.buffer;
                    return s ? `SourceBuffer${s.updating?" updating":""}${i.ended?" ended":""}${i.ending?" ending":""}` : "none"
                }
                listOps(t) {
                    var e;
                    return (null == (e = this.queues) ? void 0 : e[t].map((t => t.label)).join(", ")) || ""
                }
            }
            const Ar = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/,
                _r = "HlsJsTrackRemovedError";
            class Lr extends Error {
                constructor(t) {
                    super(t), this.name = _r
                }
            }

            function Rr(t) {
                const e = t.querySelectorAll("source");
                [].slice.call(e).forEach((e => {
                    t.removeChild(e)
                }))
            }

            function Ir(t) {
                return "audio" === t ? 1 : 0
            }
            class Cr {
                constructor(t) {
                    this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = t, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners()
                }
                setStreamController(t) {
                    this.streamController = t
                }
                destroy() {
                    this.hls && this.unregisterListener(), this.timer && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null
                }
                registerListeners() {
                    const {
                        hls: t
                    } = this;
                    t.on(l.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), t.on(l.MEDIA_ATTACHING, this.onMediaAttaching, this), t.on(l.MANIFEST_PARSED, this.onManifestParsed, this), t.on(l.LEVELS_UPDATED, this.onLevelsUpdated, this), t.on(l.BUFFER_CODECS, this.onBufferCodecs, this), t.on(l.MEDIA_DETACHING, this.onMediaDetaching, this)
                }
                unregisterListener() {
                    const {
                        hls: t
                    } = this;
                    t.off(l.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), t.off(l.MEDIA_ATTACHING, this.onMediaAttaching, this), t.off(l.MANIFEST_PARSED, this.onManifestParsed, this), t.off(l.LEVELS_UPDATED, this.onLevelsUpdated, this), t.off(l.BUFFER_CODECS, this.onBufferCodecs, this), t.off(l.MEDIA_DETACHING, this.onMediaDetaching, this)
                }
                onFpsDropLevelCapping(t, e) {
                    const i = this.hls.levels[e.droppedLevel];
                    this.isLevelAllowed(i) && this.restrictedLevels.push({
                        bitrate: i.bitrate,
                        height: i.height,
                        width: i.width
                    })
                }
                onMediaAttaching(t, e) {
                    this.media = e.media instanceof HTMLVideoElement ? e.media : null, this.clientRect = null, this.timer && this.hls.levels.length && this.detectPlayerSize()
                }
                onManifestParsed(t, e) {
                    const i = this.hls;
                    this.restrictedLevels = [], this.firstLevel = e.firstLevel, i.config.capLevelToPlayerSize && e.video && this.startCapping()
                }
                onLevelsUpdated(t, e) {
                    this.timer && s(this.autoLevelCapping) && this.detectPlayerSize()
                }
                onBufferCodecs(t, e) {
                    this.hls.config.capLevelToPlayerSize && e.video && this.startCapping()
                }
                onMediaDetaching() {
                    this.stopCapping(), this.media = null
                }
                detectPlayerSize() {
                    if (this.media) {
                        if (this.mediaHeight <= 0 || this.mediaWidth <= 0) return void(this.clientRect = null);
                        const t = this.hls.levels;
                        if (t.length) {
                            const e = this.hls,
                                i = this.getMaxLevel(t.length - 1);
                            i !== this.autoLevelCapping && e.logger.log(`Setting autoLevelCapping to ${i}: ${t[i].height}p@${t[i].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`), e.autoLevelCapping = i, e.autoLevelEnabled && e.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = e.autoLevelCapping
                        }
                    }
                }
                getMaxLevel(t) {
                    const e = this.hls.levels;
                    if (!e.length) return -1;
                    const i = e.filter(((e, i) => this.isLevelAllowed(e) && i <= t));
                    return this.clientRect = null, Cr.getMaxLevelByMediaSize(i, this.mediaWidth, this.mediaHeight)
                }
                startCapping() {
                    this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize())
                }
                stopCapping() {
                    this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0)
                }
                getDimensions() {
                    if (this.clientRect) return this.clientRect;
                    const t = this.media,
                        e = {
                            width: 0,
                            height: 0
                        };
                    if (t) {
                        const i = t.getBoundingClientRect();
                        e.width = i.width, e.height = i.height, e.width || e.height || (e.width = i.right - i.left || t.width || 0, e.height = i.bottom - i.top || t.height || 0)
                    }
                    return this.clientRect = e, e
                }
                get mediaWidth() {
                    return this.getDimensions().width * this.contentScaleFactor
                }
                get mediaHeight() {
                    return this.getDimensions().height * this.contentScaleFactor
                }
                get contentScaleFactor() {
                    let t = 1;
                    if (!this.hls.config.ignoreDevicePixelRatio) try {
                        t = self.devicePixelRatio
                    } catch (t) {}
                    return Math.min(t, this.hls.config.maxDevicePixelRatio)
                }
                isLevelAllowed(t) {
                    return !this.restrictedLevels.some((e => t.bitrate === e.bitrate && t.width === e.width && t.height === e.height))
                }
                static getMaxLevelByMediaSize(t, e, i) {
                    if (null == t || !t.length) return -1;
                    let s = t.length - 1;
                    const r = Math.max(e, i);
                    for (let e = 0; e < t.length; e += 1) {
                        const i = t[e];
                        if ((i.width >= r || i.height >= r) && (n = i, !(a = t[e + 1]) || n.width !== a.width || n.height !== a.height)) {
                            s = e;
                            break
                        }
                    }
                    var n, a;
                    return s
                }
            }
            const Dr = "m",
                xr = "a",
                Pr = "v",
                Or = "av",
                Mr = "i",
                Nr = "tt",
                Fr = "h",
                $r = "CMCD-Request",
                Ur = {
                    ["CMCD-Object"]: ["br", "d", "ot", "tb"],
                    [$r]: ["bl", "dl", "mtp", "nor", "nrr", "su"],
                    ["CMCD-Session"]: ["cid", "pr", "sf", "sid", "st", "v"],
                    ["CMCD-Status"]: ["bs", "rtp"]
                };
            class Br {
                constructor(t, e) {
                    Array.isArray(t) && (t = t.map((t => t instanceof Br ? t : new Br(t)))), this.value = t, this.params = e
                }
            }
            const jr = "Dict";

            function Gr(t, e, i) {
                return function(t, e, i, s) {
                    return new Error(`failed to ${t} "${r=e,Array.isArray(r)?JSON.stringify(r):r instanceof Map?"Map{}":r instanceof Set?"Set{}":"object"==typeof r?JSON.stringify(r):String(r)}" as ${i}`, {
                        cause: s
                    });
                    var r
                }("serialize", t, e, i)
            }
            class Vr {
                constructor(t) {
                    this.description = t
                }
            }
            const Hr = "Bare Item",
                Kr = "Boolean",
                zr = "Byte Sequence";
            const qr = "Integer";

            function Wr(t) {
                if (function(t) {
                        return t < -999999999999999 || 999999999999999 < t
                    }(t)) throw Gr(t, qr);
                return t.toString()
            }
            const Yr = "Decimal";

            function Xr(t) {
                const e = ds(t, 3);
                if (Math.floor(Math.abs(e)).toString().length > 12) throw Gr(t, Yr);
                const i = e.toString();
                return i.includes(".") ? i : `${i}.0`
            }
            const Qr = "String",
                Jr = /[\x00-\x1f\x7f]+/,
                Zr = "Token";

            function tn(t) {
                const e = (i = t).description || i.toString().slice(7, -1);
                var i;
                if (!1 === /^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(e)) throw Gr(e, Zr);
                return e
            }

            function en(t) {
                switch (typeof t) {
                    case "number":
                        if (!s(t)) throw Gr(t, Hr);
                        return Number.isInteger(t) ? Wr(t) : Xr(t);
                    case "string":
                        return function(t) {
                            if (Jr.test(t)) throw Gr(t, Qr);
                            return `"${t.replace(/\\/g,"\\\\").replace(/"/g,'\\"')}"`
                        }(t);
                    case "symbol":
                        return tn(t);
                    case "boolean":
                        return function(t) {
                            if ("boolean" != typeof t) throw Gr(t, Kr);
                            return t ? "?1" : "?0"
                        }(t);
                    case "object":
                        if (t instanceof Date) return function(t) {
                            return `@${Wr(t.getTime()/1e3)}`
                        }(t);
                        if (t instanceof Uint8Array) return function(t) {
                            if (!1 === ArrayBuffer.isView(t)) throw Gr(t, zr);
                            return `:${e=t,btoa(String.fromCharCode(...e))}:`;
                            var e
                        }(t);
                        if (t instanceof Vr) return tn(t);
                    default:
                        throw Gr(t, Hr)
                }
            }
            const sn = "Key";

            function rn(t) {
                if (!1 === /^[a-z*][a-z0-9\-_.*]*$/.test(t)) throw Gr(t, sn);
                return t
            }

            function nn(t) {
                return null == t ? "" : Object.entries(t).map((([t, e]) => !0 === e ? `;${rn(t)}` : `;${rn(t)}=${en(e)}`)).join("")
            }

            function an(t) {
                return t instanceof Br ? `${en(t.value)}${nn(t.params)}` : en(t)
            }
            const on = t => Math.round(t),
                ln = t => 100 * on(t / 100),
                cn = {
                    br: on,
                    d: on,
                    bl: ln,
                    dl: ln,
                    mtp: ln,
                    nor: (t, e) => ((null == e ? void 0 : e.baseUrl) && (t = function(t, e) {
                        const i = new URL(t),
                            s = new URL(e);
                        if (i.origin !== s.origin) return t;
                        const r = i.pathname.split("/").slice(1),
                            n = s.pathname.split("/").slice(1, -1);
                        for (; r[0] === n[0];) r.shift(), n.shift();
                        for (; n.length;) n.shift(), r.unshift("..");
                        return r.join("/")
                    }(t, e.baseUrl)), encodeURIComponent(t)),
                    rtp: ln,
                    tb: on
                };

            function un(t, e = {}) {
                return t ? function(t, e) {
                    return function(t, e = {
                        whitespace: !0
                    }) {
                        if ("object" != typeof t) throw Gr(t, jr);
                        const i = t instanceof Map ? t.entries() : Object.entries(t),
                            s = (null == e ? void 0 : e.whitespace) ? " " : "";
                        return Array.from(i).map((([t, e]) => {
                            e instanceof Br == 0 && (e = new Br(e));
                            let i = rn(t);
                            var s;
                            return !0 === e.value ? i += nn(e.params) : (i += "=", Array.isArray(e.value) ? i += `(${(s=e).value.map(an).join(" ")})${nn(s.params)}` : i += an(e)), i
                        })).join(`,${s}`)
                    }(t, e)
                }(function(t, e) {
                    const i = {};
                    if (null == t || "object" != typeof t) return i;
                    const r = Object.keys(t).sort(),
                        n = b({}, cn, null == e ? void 0 : e.formatters),
                        a = null == e ? void 0 : e.filter;
                    return r.forEach((r => {
                        if (null == a ? void 0 : a(r)) return;
                        let o = t[r];
                        const l = n[r];
                        l && (o = l(o, e)), "v" === r && 1 === o || "pr" == r && 1 === o || function(t) {
                            return "number" == typeof t ? s(t) : null != t && "" !== t && !1 !== t
                        }(o) && (function(t) {
                            return "ot" === t || "sf" === t || "st" === t
                        }(r) && "string" == typeof o && (o = new Vr(o)), i[r] = o)
                    })), i
                }(t, e), b({
                    whitespace: !1
                }, e)) : ""
            }
            const dn = /CMCD=[^&#]+/;

            function hn(t, e, i, s) {
                t && Object.keys(e).forEach((r => {
                    const n = t.filter((t => t.groupId === r)).map((t => {
                        const n = b({}, t);
                        return n.details = void 0, n.attrs = new Ge(n.attrs), n.url = n.attrs.URI = fn(t.url, t.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", i), n.groupId = n.attrs["GROUP-ID"] = e[r], n.attrs["PATHWAY-ID"] = s, n
                    }));
                    t.push(...n)
                }))
            }

            function fn(t, e, i, s) {
                const {
                    HOST: r,
                    PARAMS: n,
                    [i]: a
                } = s;
                let o;
                e && (o = null == a ? void 0 : a[e], o && (t = o));
                const l = new self.URL(t);
                return r && !o && (l.host = r), n && Object.keys(n).sort().forEach((t => {
                    t && l.searchParams.set(t, n[t])
                })), l.href
            }
            class pn extends S {
                constructor(t) {
                    super("eme", t.logger), this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.setMediaKeysQueue = pn.CDMCleanupPromise ? [pn.CDMCleanupPromise] : [], this.onMediaEncrypted = t => {
                        const {
                            initDataType: e,
                            initData: i
                        } = t, s = `"${t.type}" event: init data type: "${e}"`;
                        if (this.debug(s), null !== i) {
                            if (!this.keyFormatPromise) {
                                let t = Object.keys(this.keySystemAccessPromises);
                                t.length || (t = ni(this.config));
                                const e = t.map(ri).filter((t => !!t));
                                this.keyFormatPromise = this.getKeyFormatPromise(e)
                            }
                            this.keyFormatPromise.then((r => {
                                const n = ii(r);
                                let a, o;
                                if ("sinf" === e) {
                                    if (n !== Qe.FAIRPLAY) return void this.warn(`Ignoring unexpected "${t.type}" event with init data type: "${e}" for selected key-system ${n}`);
                                    const r = tt(new Uint8Array(i));
                                    try {
                                        const t = pt(We(JSON.parse(r).sinf));
                                        if (!t) throw new Error("'schm' box missing or not cbcs/cenc with schi > tenc");
                                        a = new Uint8Array(t.subarray(8, 24)), o = Qe.FAIRPLAY
                                    } catch (t) {
                                        return void this.warn(`${s} Failed to parse sinf: ${t}`)
                                    }
                                } else {
                                    if (n !== Qe.WIDEVINE && n !== Qe.PLAYREADY) return void this.warn(`Ignoring unexpected "${t.type}" event with init data type: "${e}" for selected key-system ${n}`);
                                    const r = function(t) {
                                            const e = [];
                                            if (t instanceof ArrayBuffer) {
                                                const i = t.byteLength;
                                                let s = 0;
                                                for (; s + 32 < i;) {
                                                    const i = St(new DataView(t, s));
                                                    e.push(i), s += i.size
                                                }
                                            }
                                            return e
                                        }(i),
                                        l = r.filter((t => !!t.systemId && si(t.systemId) === n));
                                    l.length > 1 && this.warn(`${s} Using first of ${l.length} pssh found for selected key-system ${n}`);
                                    const c = l[0];
                                    if (!c) return void(0 === r.length || r.some((t => !t.systemId)) ? this.warn(`${s} contains incomplete or invalid pssh data`) : this.log(`ignoring ${s} for ${r.map((t=>si(t.systemId))).join(",")} pssh data in favor of playlist keys`));
                                    if (o = si(c.systemId), 0 === c.version && c.data)
                                        if (o === Qe.WIDEVINE) {
                                            const t = c.data.length - 22;
                                            a = new Uint8Array(c.data.subarray(t, t + 16))
                                        } else o === Qe.PLAYREADY && (a = li(c.data))
                                }
                                if (!o || !a) return;
                                const l = x(a),
                                    {
                                        keyIdToKeySessionPromise: c,
                                        mediaKeySessions: u
                                    } = this;
                                let d = c[l];
                                for (let t = 0; t < u.length; t++) {
                                    const s = u[t],
                                        r = s.decryptdata;
                                    if (!r.keyId) continue;
                                    const n = x(r.keyId);
                                    if (l === n || -1 !== r.uri.replace(/-/g, "").indexOf(l)) {
                                        if (d = c[n], r.pssh) break;
                                        delete c[n], r.pssh = new Uint8Array(i), r.keyId = a, d = c[l] = d.then((() => this.generateRequestWithPreferredKeySession(s, e, i, "encrypted-event-key-match"))), d.catch((t => this.handleError(t)));
                                        break
                                    }
                                }
                                if (!d) {
                                    if (o !== n) return void this.log(`Ignoring "${t.type}" event with ${o} init data for selected key-system ${n}`);
                                    d = c[l] = this.getKeySystemSelectionPromise([o]).then((({
                                        keySystem: t,
                                        mediaKeys: s
                                    }) => {
                                        var r;
                                        this.throwIfDestroyed();
                                        const n = new ui("ISO-23001-7", l, null != (r = ri(t)) ? r : "");
                                        return n.pssh = new Uint8Array(i), n.keyId = a, this.attemptSetMediaKeys(t, s).then((() => {
                                            this.throwIfDestroyed();
                                            const r = this.createMediaKeySessionContext({
                                                decryptdata: n,
                                                keySystem: t,
                                                mediaKeys: s
                                            });
                                            return this.generateRequestWithPreferredKeySession(r, e, i, "encrypted-event-no-match")
                                        }))
                                    })), d.catch((t => this.handleError(t)))
                                }
                            }))
                        }
                    }, this.onWaitingForKey = t => {
                        this.log(`"${t.type}" event`)
                    }, this.hls = t, this.config = t.config, this.registerListeners()
                }
                destroy() {
                    const t = this.media;
                    this.unregisterListeners(), this.onMediaDetached(), this._clear(t);
                    const e = this.config;
                    e.requestMediaKeySystemAccessFunc = null, e.licenseXhrSetup = e.licenseResponseCallback = void 0, e.drmSystems = e.drmSystemOptions = {}, this.hls = this.config = this.keyIdToKeySessionPromise = null, this.onMediaEncrypted = this.onWaitingForKey = null
                }
                registerListeners() {
                    this.hls.on(l.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(l.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(l.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(l.MANIFEST_LOADED, this.onManifestLoaded, this)
                }
                unregisterListeners() {
                    this.hls.off(l.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(l.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(l.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(l.MANIFEST_LOADED, this.onManifestLoaded, this)
                }
                getLicenseServerUrl(t) {
                    const {
                        drmSystems: e,
                        widevineLicenseUrl: i
                    } = this.config, s = e[t];
                    return s ? s.licenseUrl : t === Qe.WIDEVINE && i ? i : void 0
                }
                getLicenseServerUrlOrThrow(t) {
                    const e = this.getLicenseServerUrl(t);
                    if (void 0 === e) throw new Error(`no license server URL configured for key-system "${t}"`);
                    return e
                }
                getServerCertificateUrl(t) {
                    const {
                        drmSystems: e
                    } = this.config, i = e[t];
                    if (i) return i.serverCertificateUrl;
                    this.log(`No Server Certificate in config.drmSystems["${t}"]`)
                }
                attemptKeySystemAccess(t) {
                    const e = this.hls.levels,
                        i = (t, e, i) => !!t && i.indexOf(t) === e,
                        s = e.map((t => t.audioCodec)).filter(i),
                        r = e.map((t => t.videoCodec)).filter(i);
                    return s.length + r.length === 0 && r.push("avc1.42e01e"), new Promise(((e, i) => {
                        const n = t => {
                            const l = t.shift();
                            this.getMediaKeysPromise(l, s, r).then((t => e({
                                keySystem: l,
                                mediaKeys: t
                            }))).catch((e => {
                                t.length ? n(t) : i(e instanceof gn ? e : new gn({
                                    type: a.KEY_SYSTEM_ERROR,
                                    details: o.KEY_SYSTEM_NO_ACCESS,
                                    error: e,
                                    fatal: !0
                                }, e.message))
                            }))
                        };
                        n(t)
                    }))
                }
                requestMediaKeySystemAccess(t, e) {
                    const {
                        requestMediaKeySystemAccessFunc: i
                    } = this.config;
                    if ("function" != typeof i) {
                        let t = `Configured requestMediaKeySystemAccess is not a function ${i}`;
                        return null === ai && "http:" === self.location.protocol && (t = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`), Promise.reject(new Error(t))
                    }
                    return i(t, e)
                }
                getMediaKeysPromise(t, e, i) {
                    const s = function(t, e, i, s) {
                            let r;
                            switch (t) {
                                case Qe.FAIRPLAY:
                                    r = ["cenc", "sinf"];
                                    break;
                                case Qe.WIDEVINE:
                                case Qe.PLAYREADY:
                                    r = ["cenc"];
                                    break;
                                case Qe.CLEARKEY:
                                    r = ["cenc", "keyids"];
                                    break;
                                default:
                                    throw new Error(`Unknown key-system: ${t}`)
                            }
                            return function(t, e, i, s) {
                                return [{
                                    initDataTypes: t,
                                    persistentState: s.persistentState || "optional",
                                    distinctiveIdentifier: s.distinctiveIdentifier || "optional",
                                    sessionTypes: s.sessionTypes || [s.sessionType || "temporary"],
                                    audioCapabilities: e.map((t => ({
                                        contentType: `audio/mp4; codecs=${t}`,
                                        robustness: s.audioRobustness || "",
                                        encryptionScheme: s.audioEncryptionScheme || null
                                    }))),
                                    videoCapabilities: i.map((t => ({
                                        contentType: `video/mp4; codecs=${t}`,
                                        robustness: s.videoRobustness || "",
                                        encryptionScheme: s.videoEncryptionScheme || null
                                    })))
                                }]
                            }(r, e, i, s)
                        }(t, e, i, this.config.drmSystemOptions),
                        r = this.keySystemAccessPromises[t];
                    let n = null == r ? void 0 : r.keySystemAccess;
                    if (!n) {
                        this.log(`Requesting encrypted media "${t}" key-system access with config: ${Yt(s)}`), n = this.requestMediaKeySystemAccess(t, s);
                        const e = this.keySystemAccessPromises[t] = {
                            keySystemAccess: n
                        };
                        return n.catch((e => {
                            this.log(`Failed to obtain access to key-system "${t}": ${e}`)
                        })), n.then((i => {
                            this.log(`Access for key-system "${i.keySystem}" obtained`);
                            const s = this.fetchServerCertificate(t);
                            return this.log(`Create media-keys for "${t}"`), e.mediaKeys = i.createMediaKeys().then((e => (this.log(`Media-keys created for "${t}"`), s.then((i => i ? this.setMediaKeysServerCertificate(e, t, i) : e))))), e.mediaKeys.catch((e => {
                                this.error(`Failed to create media-keys for "${t}"}: ${e}`)
                            })), e.mediaKeys
                        }))
                    }
                    return n.then((() => r.mediaKeys))
                }
                createMediaKeySessionContext({
                    decryptdata: t,
                    keySystem: e,
                    mediaKeys: i
                }) {
                    this.log(`Creating key-system session "${e}" keyId: ${x(t.keyId||[])}`);
                    const s = i.createSession(),
                        r = {
                            decryptdata: t,
                            keySystem: e,
                            mediaKeys: i,
                            mediaKeysSession: s,
                            keyStatus: "status-pending"
                        };
                    return this.mediaKeySessions.push(r), r
                }
                renewKeySession(t) {
                    const e = t.decryptdata;
                    if (e.pssh) {
                        const i = this.createMediaKeySessionContext(t),
                            s = this.getKeyIdString(e),
                            r = "cenc";
                        this.keyIdToKeySessionPromise[s] = this.generateRequestWithPreferredKeySession(i, r, e.pssh.buffer, "expired")
                    } else this.warn("Could not renew expired session. Missing pssh initData.");
                    this.removeSession(t)
                }
                getKeyIdString(t) {
                    if (!t) throw new Error("Could not read keyId of undefined decryptdata");
                    if (null === t.keyId) throw new Error("keyId is null");
                    return x(t.keyId)
                }
                updateKeySession(t, e) {
                    var i;
                    const s = t.mediaKeysSession;
                    return this.log(`Updating key-session "${s.sessionId}" for keyID ${x((null==(i=t.decryptdata)?void 0:i.keyId)||[])}\n      } (data length: ${e?e.byteLength:e})`), s.update(e)
                }
                selectKeySystemFormat(t) {
                    const e = Object.keys(t.levelkeys || {});
                    return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${t.sn} ${t.type}: ${t.level}) key formats ${e.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(e)), this.keyFormatPromise
                }
                getKeyFormatPromise(t) {
                    return new Promise(((e, i) => {
                        const s = ni(this.config),
                            r = t.map(ii).filter((t => !!t && -1 !== s.indexOf(t)));
                        return this.getKeySystemSelectionPromise(r).then((({
                            keySystem: t
                        }) => {
                            const s = ri(t);
                            s ? e(s) : i(new Error(`Unable to find format for key-system "${t}"`))
                        })).catch(i)
                    }))
                }
                loadKey(t) {
                    const e = t.keyInfo.decryptdata,
                        i = this.getKeyIdString(e),
                        s = `(keyId: ${i} format: "${e.keyFormat}" method: ${e.method} uri: ${e.uri})`;
                    this.log(`Starting session for key ${s}`);
                    let r = this.keyIdToKeySessionPromise[i];
                    return r || (r = this.getKeySystemForKeyPromise(e).then((({
                        keySystem: i,
                        mediaKeys: r
                    }) => (this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${t.frag.sn} ${t.frag.type}: ${t.frag.level} using key ${s}`), this.attemptSetMediaKeys(i, r).then((() => (this.throwIfDestroyed(), this.createMediaKeySessionContext({
                        keySystem: i,
                        mediaKeys: r,
                        decryptdata: e
                    }))))))), (this.keyIdToKeySessionPromise[i] = r.then((t => {
                        const i = e.pssh ? e.pssh.buffer : null;
                        return this.generateRequestWithPreferredKeySession(t, "cenc", i, "playlist-key")
                    }))).catch((t => this.handleError(t)))), r
                }
                throwIfDestroyed(t = "Invalid state") {
                    if (!this.hls) throw new Error("invalid state")
                }
                handleError(t) {
                    this.hls && (this.error(t.message), t instanceof gn ? this.hls.trigger(l.ERROR, t.data) : this.hls.trigger(l.ERROR, {
                        type: a.KEY_SYSTEM_ERROR,
                        details: o.KEY_SYSTEM_NO_KEYS,
                        error: t,
                        fatal: !0
                    }))
                }
                getKeySystemForKeyPromise(t) {
                    const e = this.getKeyIdString(t),
                        i = this.keyIdToKeySessionPromise[e];
                    if (!i) {
                        const e = ii(t.keyFormat),
                            i = e ? [e] : ni(this.config);
                        return this.attemptKeySystemAccess(i)
                    }
                    return i
                }
                getKeySystemSelectionPromise(t) {
                    if (t.length || (t = ni(this.config)), 0 === t.length) throw new gn({
                        type: a.KEY_SYSTEM_ERROR,
                        details: o.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
                        fatal: !0
                    }, `Missing key-system license configuration options ${Yt({drmSystems:this.config.drmSystems})}`);
                    return this.attemptKeySystemAccess(t)
                }
                attemptSetMediaKeys(t, e) {
                    const i = this.setMediaKeysQueue.slice();
                    this.log(`Setting media-keys for "${t}"`);
                    const s = Promise.all(i).then((() => {
                        if (!this.media) throw new Error("Attempted to set mediaKeys without media element attached");
                        return this.media.setMediaKeys(e)
                    }));
                    return this.setMediaKeysQueue.push(s), s.then((() => {
                        this.log(`Media-keys set for "${t}"`), i.push(s), this.setMediaKeysQueue = this.setMediaKeysQueue.filter((t => -1 === i.indexOf(t)))
                    }))
                }
                generateRequestWithPreferredKeySession(t, e, i, s) {
                    var r, n;
                    const l = null == (r = this.config.drmSystems) || null == (n = r[t.keySystem]) ? void 0 : n.generateRequest;
                    if (l) try {
                        const s = l.call(this.hls, e, i, t);
                        if (!s) throw new Error("Invalid response from configured generateRequest filter");
                        e = s.initDataType, i = s.initData ? s.initData : null, t.decryptdata.pssh = i ? new Uint8Array(i) : null
                    } catch (t) {
                        var c;
                        if (this.warn(t.message), null != (c = this.hls) && c.config.debug) throw t
                    }
                    if (null === i) return this.log(`Skipping key-session request for "${s}" (no initData)`), Promise.resolve(t);
                    const u = this.getKeyIdString(t.decryptdata);
                    this.log(`Generating key-session request for "${s}": ${u} (init data type: ${e} length: ${i?i.byteLength:null})`);
                    const d = new Yi,
                        h = t._onmessage = e => {
                            const i = t.mediaKeysSession;
                            if (!i) return void d.emit("error", new Error("invalid state"));
                            const {
                                messageType: s,
                                message: r
                            } = e;
                            this.log(`"${s}" message event for session "${i.sessionId}" message size: ${r.byteLength}`), "license-request" === s || "license-renewal" === s ? this.renewLicense(t, r).catch((t => {
                                d.eventNames().length ? d.emit("error", t) : this.handleError(t)
                            })) : "license-release" === s ? t.keySystem === Qe.FAIRPLAY && (this.updateKeySession(t, Ye("acknowledged")), this.removeSession(t)) : this.warn(`unhandled media key message type "${s}"`)
                        },
                        f = t._onkeystatuseschange = e => {
                            if (!t.mediaKeysSession) return void d.emit("error", new Error("invalid state"));
                            this.onKeyStatusChange(t);
                            const i = t.keyStatus;
                            d.emit("keyStatus", i), "expired" === i && (this.warn(`${t.keySystem} expired for key ${u}`), this.renewKeySession(t))
                        };
                    t.mediaKeysSession.addEventListener("message", h), t.mediaKeysSession.addEventListener("keystatuseschange", f);
                    const p = new Promise(((t, e) => {
                        d.on("error", e), d.on("keyStatus", (i => {
                            i.startsWith("usable") ? t() : "output-restricted" === i ? e(new gn({
                                type: a.KEY_SYSTEM_ERROR,
                                details: o.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
                                fatal: !1
                            }, "HDCP level output restricted")) : "internal-error" === i ? e(new gn({
                                type: a.KEY_SYSTEM_ERROR,
                                details: o.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
                                fatal: !0
                            }, `key status changed to "${i}"`)) : "expired" === i ? e(new Error("key expired while generating request")) : this.warn(`unhandled key status change "${i}"`)
                        }))
                    }));
                    return t.mediaKeysSession.generateRequest(e, i).then((() => {
                        var e;
                        this.log(`Request generated for key-session "${null==(e=t.mediaKeysSession)?void 0:e.sessionId}" keyId: ${u}`)
                    })).catch((t => {
                        throw new gn({
                            type: a.KEY_SYSTEM_ERROR,
                            details: o.KEY_SYSTEM_NO_SESSION,
                            error: t,
                            fatal: !1
                        }, `Error generating key-session request: ${t}`)
                    })).then((() => p)).catch((e => {
                        throw d.removeAllListeners(), this.removeSession(t), e
                    })).then((() => (d.removeAllListeners(), t)))
                }
                onKeyStatusChange(t) {
                    t.mediaKeysSession.keyStatuses.forEach(((e, i) => {
                        if ("string" == typeof i && "object" == typeof e) {
                            const t = i;
                            i = e, e = t
                        }
                        this.log(`key status change "${e}" for keyStatuses keyId: ${x("buffer"in i?new Uint8Array(i.buffer,i.byteOffset,i.byteLength):new Uint8Array(i))} session keyId: ${x(new Uint8Array(t.decryptdata.keyId||[]))} uri: ${t.decryptdata.uri}`), t.keyStatus = e
                    }))
                }
                fetchServerCertificate(t) {
                    const e = this.config,
                        i = new(0, e.loader)(e),
                        s = this.getServerCertificateUrl(t);
                    return s ? (this.log(`Fetching server certificate for "${t}"`), new Promise(((r, n) => {
                        const l = {
                                responseType: "arraybuffer",
                                url: s
                            },
                            c = e.certLoadPolicy.default,
                            u = {
                                loadPolicy: c,
                                timeout: c.maxLoadTimeMs,
                                maxRetry: 0,
                                retryDelay: 0,
                                maxRetryDelay: 0
                            },
                            d = {
                                onSuccess: (t, e, i, s) => {
                                    r(t.data)
                                },
                                onError: (e, i, r, c) => {
                                    n(new gn({
                                        type: a.KEY_SYSTEM_ERROR,
                                        details: o.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                                        fatal: !0,
                                        networkDetails: r,
                                        response: E({
                                            url: l.url,
                                            data: void 0
                                        }, e)
                                    }, `"${t}" certificate request failed (${s}). Status: ${e.code} (${e.text})`))
                                },
                                onTimeout: (e, i, r) => {
                                    n(new gn({
                                        type: a.KEY_SYSTEM_ERROR,
                                        details: o.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                                        fatal: !0,
                                        networkDetails: r,
                                        response: {
                                            url: l.url,
                                            data: void 0
                                        }
                                    }, `"${t}" certificate request timed out (${s})`))
                                },
                                onAbort: (t, e, i) => {
                                    n(new Error("aborted"))
                                }
                            };
                        i.load(l, u, d)
                    }))) : Promise.resolve()
                }
                setMediaKeysServerCertificate(t, e, i) {
                    return new Promise(((s, r) => {
                        t.setServerCertificate(i).then((r => {
                            this.log(`setServerCertificate ${r?"success":"not supported by CDM"} (${null==i?void 0:i.byteLength}) on "${e}"`), s(t)
                        })).catch((t => {
                            r(new gn({
                                type: a.KEY_SYSTEM_ERROR,
                                details: o.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
                                error: t,
                                fatal: !0
                            }, t.message))
                        }))
                    }))
                }
                renewLicense(t, e) {
                    return this.requestLicense(t, new Uint8Array(e)).then((e => this.updateKeySession(t, new Uint8Array(e)).catch((t => {
                        throw new gn({
                            type: a.KEY_SYSTEM_ERROR,
                            details: o.KEY_SYSTEM_SESSION_UPDATE_FAILED,
                            error: t,
                            fatal: !0
                        }, t.message)
                    }))))
                }
                unpackPlayReadyKeyMessage(t, e) {
                    const i = String.fromCharCode.apply(null, new Uint16Array(e.buffer));
                    if (!i.includes("PlayReadyKeyMessage")) return t.setRequestHeader("Content-Type", "text/xml; charset=utf-8"), e;
                    const s = (new DOMParser).parseFromString(i, "application/xml"),
                        r = s.querySelectorAll("HttpHeader");
                    if (r.length > 0) {
                        let e;
                        for (let i = 0, s = r.length; i < s; i++) {
                            var n, a;
                            e = r[i];
                            const s = null == (n = e.querySelector("name")) ? void 0 : n.textContent,
                                o = null == (a = e.querySelector("value")) ? void 0 : a.textContent;
                            s && o && t.setRequestHeader(s, o)
                        }
                    }
                    const o = s.querySelector("Challenge"),
                        l = null == o ? void 0 : o.textContent;
                    if (!l) throw new Error("Cannot find <Challenge> in key message");
                    return Ye(atob(l))
                }
                setupLicenseXHR(t, e, i, s) {
                    const r = this.config.licenseXhrSetup;
                    return r ? Promise.resolve().then((() => {
                        if (!i.decryptdata) throw new Error("Key removed");
                        return r.call(this.hls, t, e, i, s)
                    })).catch((n => {
                        if (!i.decryptdata) throw n;
                        return t.open("POST", e, !0), r.call(this.hls, t, e, i, s)
                    })).then((i => (t.readyState || t.open("POST", e, !0), {
                        xhr: t,
                        licenseChallenge: i || s
                    }))) : (t.open("POST", e, !0), Promise.resolve({
                        xhr: t,
                        licenseChallenge: s
                    }))
                }
                requestLicense(t, e) {
                    const i = this.config.keyLoadPolicy.default;
                    return new Promise(((s, r) => {
                        const n = this.getLicenseServerUrlOrThrow(t.keySystem);
                        this.log(`Sending license request to URL: ${n}`);
                        const l = new XMLHttpRequest;
                        l.responseType = "arraybuffer", l.onreadystatechange = () => {
                            if (!this.hls || !t.mediaKeysSession) return r(new Error("invalid state"));
                            if (4 === l.readyState)
                                if (200 === l.status) {
                                    this._requestLicenseFailureCount = 0;
                                    let e = l.response;
                                    this.log(`License received ${e instanceof ArrayBuffer?e.byteLength:e}`);
                                    const i = this.config.licenseResponseCallback;
                                    if (i) try {
                                        e = i.call(this.hls, l, n, t)
                                    } catch (t) {
                                        this.error(t)
                                    }
                                    s(e)
                                } else {
                                    const c = i.errorRetry,
                                        u = c ? c.maxNumRetry : 0;
                                    if (this._requestLicenseFailureCount++, this._requestLicenseFailureCount > u || l.status >= 400 && l.status < 500) r(new gn({
                                        type: a.KEY_SYSTEM_ERROR,
                                        details: o.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                                        fatal: !0,
                                        networkDetails: l,
                                        response: {
                                            url: n,
                                            data: void 0,
                                            code: l.status,
                                            text: l.statusText
                                        }
                                    }, `License Request XHR failed (${n}). Status: ${l.status} (${l.statusText})`));
                                    else {
                                        const i = u - this._requestLicenseFailureCount + 1;
                                        this.warn(`Retrying license request, ${i} attempts left`), this.requestLicense(t, e).then(s, r)
                                    }
                                }
                        }, t.licenseXhr && t.licenseXhr.readyState !== XMLHttpRequest.DONE && t.licenseXhr.abort(), t.licenseXhr = l, this.setupLicenseXHR(l, n, t, e).then((({
                            xhr: e,
                            licenseChallenge: i
                        }) => {
                            t.keySystem == Qe.PLAYREADY && (i = this.unpackPlayReadyKeyMessage(e, i)), e.send(i)
                        }))
                    }))
                }
                onMediaAttached(t, e) {
                    if (!this.config.emeEnabled) return;
                    const i = e.media;
                    this.media = i, i.removeEventListener("encrypted", this.onMediaEncrypted), i.removeEventListener("waitingforkey", this.onWaitingForKey), i.addEventListener("encrypted", this.onMediaEncrypted), i.addEventListener("waitingforkey", this.onWaitingForKey)
                }
                onMediaDetached() {
                    const t = this.media;
                    t && (t.removeEventListener("encrypted", this.onMediaEncrypted), t.removeEventListener("waitingforkey", this.onWaitingForKey), this.media = null)
                }
                _clear(t) {
                    var e;
                    const i = this.mediaKeySessions;
                    this._requestLicenseFailureCount = 0, this.setMediaKeysQueue = [], this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, ui.clearKeyUriToKeyIdMap();
                    const s = i.length;
                    pn.CDMCleanupPromise = Promise.all(i.map((t => this.removeSession(t))).concat(null == t || null == (e = t.setMediaKeys(null)) ? void 0 : e.catch((t => {
                        var e;
                        this.log(`Could not clear media keys: ${t}`), null == (e = this.hls) || e.trigger(l.ERROR, {
                            type: a.OTHER_ERROR,
                            details: o.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR,
                            fatal: !1,
                            error: new Error(`Could not clear media keys: ${t}`)
                        })
                    })))).then((() => {
                        s && (this.log("finished closing key sessions and clearing media keys"), i.length = 0)
                    })).catch((t => {
                        var e;
                        this.log(`Could not close sessions and clear media keys: ${t}`), null == (e = this.hls) || e.trigger(l.ERROR, {
                            type: a.OTHER_ERROR,
                            details: o.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
                            fatal: !1,
                            error: new Error(`Could not close sessions and clear media keys: ${t}`)
                        })
                    }))
                }
                onManifestLoading() {
                    this.keyFormatPromise = null
                }
                onManifestLoaded(t, {
                    sessionKeys: e
                }) {
                    if (e && this.config.emeEnabled && !this.keyFormatPromise) {
                        const t = e.reduce(((t, e) => (-1 === t.indexOf(e.keyFormat) && t.push(e.keyFormat), t)), []);
                        this.log(`Selecting key-system from session-keys ${t.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(t)
                    }
                }
                removeSession(t) {
                    const {
                        mediaKeysSession: e,
                        licenseXhr: i
                    } = t;
                    if (e) {
                        this.log(`Remove licenses and keys and close session ${e.sessionId}`), t._onmessage && (e.removeEventListener("message", t._onmessage), t._onmessage = void 0), t._onkeystatuseschange && (e.removeEventListener("keystatuseschange", t._onkeystatuseschange), t._onkeystatuseschange = void 0), i && i.readyState !== XMLHttpRequest.DONE && i.abort(), t.mediaKeysSession = t.decryptdata = t.licenseXhr = void 0;
                        const s = this.mediaKeySessions.indexOf(t);
                        s > -1 && this.mediaKeySessions.splice(s, 1);
                        const {
                            drmSystemOptions: r
                        } = this.config, n = function(t) {
                            var e;
                            return "persistent-license" === t.sessionType || !(null == (e = t.sessionTypes) || !e.some((t => "persistent-license" === t)))
                        }(r) ? new Promise(((t, i) => {
                            self.setTimeout((() => i(new Error("MediaKeySession.remove() timeout"))), 8e3), e.remove().then(t)
                        })) : Promise.resolve();
                        return n.catch((t => {
                            var e;
                            this.log(`Could not remove session: ${t}`), null == (e = this.hls) || e.trigger(l.ERROR, {
                                type: a.OTHER_ERROR,
                                details: o.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR,
                                fatal: !1,
                                error: new Error(`Could not remove session: ${t}`)
                            })
                        })).then((() => e.close())).catch((t => {
                            var e;
                            this.log(`Could not close session: ${t}`), null == (e = this.hls) || e.trigger(l.ERROR, {
                                type: a.OTHER_ERROR,
                                details: o.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
                                fatal: !1,
                                error: new Error(`Could not close session: ${t}`)
                            })
                        }))
                    }
                }
            }
            pn.CDMCleanupPromise = void 0;
            class gn extends Error {
                constructor(t, e) {
                    super(e), this.data = void 0, t.error || (t.error = new Error(e)), this.data = t, t.err = t.error
                }
            }

            function mn(t, e) {
                let i;
                try {
                    i = new Event("addtrack")
                } catch (t) {
                    i = document.createEvent("Event"), i.initEvent("addtrack", !1, !1)
                }
                i.track = t, e.dispatchEvent(i)
            }

            function yn(t, e) {
                const i = t.mode;
                if ("disabled" === i && (t.mode = "hidden"), t.cues && !t.cues.getCueById(e.id)) try {
                    if (t.addCue(e), !t.cues.getCueById(e.id)) throw new Error(`addCue is failed for: ${e}`)
                } catch (i) {
                    R.debug(`[texttrack-utils]: ${i}`);
                    try {
                        const i = new self.TextTrackCue(e.startTime, e.endTime, e.text);
                        i.id = e.id, t.addCue(i)
                    } catch (t) {
                        R.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${t}`)
                    }
                }
                "disabled" === i && (t.mode = i)
            }

            function vn(t, e) {
                const i = t.mode;
                if ("disabled" === i && (t.mode = "hidden"), t.cues)
                    for (let i = t.cues.length; i--;) e && t.cues[i].removeEventListener("enter", e), t.removeCue(t.cues[i]);
                "disabled" === i && (t.mode = i)
            }

            function bn(t, e, i, s) {
                const r = t.mode;
                if ("disabled" === r && (t.mode = "hidden"), t.cues && t.cues.length > 0) {
                    const r = function(t, e, i) {
                        const s = [],
                            r = function(t, e) {
                                if (e <= t[0].startTime) return 0;
                                const i = t.length - 1;
                                if (e > t[i].endTime) return -1;
                                let s, r = 0,
                                    n = i;
                                for (; r <= n;)
                                    if (s = Math.floor((n + r) / 2), e < t[s].startTime) n = s - 1;
                                    else {
                                        if (!(e > t[s].startTime && r < i)) return s;
                                        r = s + 1
                                    }
                                return t[r].startTime - e < e - t[n].startTime ? r : n
                            }(t, e);
                        if (r > -1)
                            for (let n = r, a = t.length; n < a; n++) {
                                const r = t[n];
                                if (r.startTime >= e && r.endTime <= i) s.push(r);
                                else if (r.startTime > i) return s
                            }
                        return s
                    }(t.cues, e, i);
                    for (let e = 0; e < r.length; e++) s && !s(r[e]) || t.removeCue(r[e])
                }
                "disabled" === r && (t.mode = r)
            }

            function Tn(t) {
                const e = [];
                for (let i = 0; i < t.length; i++) {
                    const s = t[i];
                    "subtitles" !== s.kind && "captions" !== s.kind || !s.label || e.push(t[i])
                }
                return e
            }

            function En(t) {
                let e = 5381,
                    i = t.length;
                for (; i;) e = 33 * e ^ t.charCodeAt(--i);
                return (e >>> 0).toString()
            }
            const Sn = .025;
            let wn = function(t) {
                return t[t.Point = 0] = "Point", t[t.Range = 1] = "Range", t
            }({});

            function kn(t, e, i) {
                return `${t.identifier}-${i+1}-${En(e)}`
            }
            class An {
                constructor(t, e) {
                    this.base = void 0, this._duration = null, this._timelineStart = null, this.appendInPlaceDisabled = void 0, this.appendInPlaceStarted = void 0, this.dateRange = void 0, this.hasPlayed = !1, this.cumulativeDuration = 0, this.resumeOffset = NaN, this.playoutLimit = NaN, this.restrictions = {
                        skip: !1,
                        jump: !1
                    }, this.snapOptions = {
                        out: !1,
                        in: !1
                    }, this.assetList = [], this.assetListLoader = void 0, this.assetListResponse = null, this.resumeAnchor = void 0, this.error = void 0, this.resetOnResume = void 0, this.base = e, this.dateRange = t, this.setDateRange(t)
                }
                setDateRange(t) {
                    this.dateRange = t, this.resumeOffset = t.attr.optionalFloat("X-RESUME-OFFSET", this.resumeOffset), this.playoutLimit = t.attr.optionalFloat("X-PLAYOUT-LIMIT", this.playoutLimit), this.restrictions = t.attr.enumeratedStringList("X-RESTRICT", this.restrictions), this.snapOptions = t.attr.enumeratedStringList("X-SNAP", this.snapOptions)
                }
                reset() {
                    var t;
                    this.appendInPlaceStarted = !1, null == (t = this.assetListLoader) || t.destroy(), this.assetListLoader = void 0, this.supplementsPrimary || (this.assetListResponse = null, this.assetList = [], this._duration = null)
                }
                isAssetPastPlayoutLimit(t) {
                    if (t >= this.assetList.length) return !0;
                    const e = this.playoutLimit;
                    return !(t <= 0 || isNaN(e)) && this.assetList[t].startOffset > e
                }
                findAssetIndex(t) {
                    return this.assetList.indexOf(t)
                }
                get identifier() {
                    return this.dateRange.id
                }
                get startDate() {
                    return this.dateRange.startDate
                }
                get startTime() {
                    const t = this.dateRange.startTime;
                    if (this.snapOptions.out) {
                        const e = this.dateRange.tagAnchor;
                        if (e) return _n(t, e)
                    }
                    return t
                }
                get startOffset() {
                    return this.cue.pre ? 0 : this.startTime
                }
                get startIsAligned() {
                    if (0 === this.startTime || this.snapOptions.out) return !0;
                    const t = this.dateRange.tagAnchor;
                    if (t) {
                        const e = this.dateRange.startTime;
                        return e - _n(e, t) < .1
                    }
                    return !1
                }
                get resumptionOffset() {
                    const t = this.resumeOffset,
                        e = s(t) ? t : this.duration;
                    return this.cumulativeDuration + e
                }
                get resumeTime() {
                    const t = this.startOffset + this.resumptionOffset;
                    if (this.snapOptions.in) {
                        const e = this.resumeAnchor;
                        if (e) return _n(t, e)
                    }
                    return t
                }
                get appendInPlace() {
                    return !!this.appendInPlaceStarted || !this.appendInPlaceDisabled && !(this.cue.once || this.cue.pre || !this.startIsAligned || !(isNaN(this.playoutLimit) && isNaN(this.resumeOffset) || this.resumeOffset && this.duration && Math.abs(this.resumeOffset - this.duration) < Sn))
                }
                set appendInPlace(t) {
                    this.appendInPlaceStarted ? this.resetOnResume = !t : this.appendInPlaceDisabled = !t
                }
                get timelineStart() {
                    return null !== this._timelineStart ? this._timelineStart : this.startTime
                }
                set timelineStart(t) {
                    this._timelineStart = t
                }
                get duration() {
                    const t = this.playoutLimit;
                    let e;
                    return e = null !== this._duration ? this._duration : this.dateRange.duration ? this.dateRange.duration : this.dateRange.plannedDuration || 0, !isNaN(t) && t < e && (e = t), e
                }
                set duration(t) {
                    this._duration = t
                }
                get cue() {
                    return this.dateRange.cue
                }
                get timelineOccupancy() {
                    return "RANGE" === this.dateRange.attr["X-TIMELINE-OCCUPIES"] ? wn.Range : wn.Point
                }
                get supplementsPrimary() {
                    return "PRIMARY" === this.dateRange.attr["X-TIMELINE-STYLE"]
                }
                get contentMayVary() {
                    return "NO" !== this.dateRange.attr["X-CONTENT-MAY-VARY"]
                }
                get assetUrl() {
                    return this.dateRange.attr["X-ASSET-URI"]
                }
                get assetListUrl() {
                    return this.dateRange.attr["X-ASSET-LIST"]
                }
                get baseUrl() {
                    return this.base.url
                }
                get assetListLoaded() {
                    return this.assetList.length > 0 || null !== this.assetListResponse
                }
                toString() {
                    return `["${(t=this).identifier}" ${t.cue.pre?"<pre>":t.cue.post?"<post>":""}${t.timelineStart.toFixed(2)}-${t.resumeTime.toFixed(2)}]`;
                    var t
                }
            }

            function _n(t, e) {
                return t - e.start < e.duration / 2 && !(Math.abs(t - (e.start + e.duration)) < Sn) ? e.start : e.start + e.duration
            }

            function Ln(t, e, i) {
                const s = new self.URL(t, i);
                return "data:" !== s.protocol && s.searchParams.set("_HLS_primary_id", e), s
            }

            function Rn(t) {
                const e = t.timelineStart,
                    i = t.duration || 0;
                return `["${t.identifier}" ${e.toFixed(2)}-${(e+i).toFixed(2)}]`
            }
            class In {
                constructor(t, e, i, s) {
                    this.hls = void 0, this.interstitial = void 0, this.assetItem = void 0, this.tracks = null, this.hasDetails = !1, this.mediaAttached = null, this._currentTime = void 0, this._bufferedEosTime = void 0, this.checkPlayout = () => {
                        const t = this.interstitial.playoutLimit,
                            e = this.currentTime;
                        this.startOffset + e >= t && this.hls.trigger(l.PLAYOUT_LIMIT_REACHED, {})
                    };
                    const r = this.hls = new t(e);
                    this.interstitial = i, this.assetItem = s;
                    let n = s.uri;
                    try {
                        n = Ln(n, r.sessionId).href
                    } catch (t) {}
                    r.loadSource(n);
                    const a = () => {
                        this.hasDetails = !0
                    };
                    r.once(l.LEVEL_LOADED, a), r.once(l.AUDIO_TRACK_LOADED, a), r.once(l.SUBTITLE_TRACK_LOADED, a), r.on(l.MEDIA_ATTACHING, ((t, {
                        media: e
                    }) => {
                        this.removeMediaListeners(), this.mediaAttached = e, this.interstitial.playoutLimit && e.addEventListener("timeupdate", this.checkPlayout)
                    }))
                }
                bufferedInPlaceToEnd(t) {
                    var e;
                    if (!this.interstitial.appendInPlace) return !1;
                    if (null != (e = this.hls) && e.bufferedToEnd) return !0;
                    if (!t || !this._bufferedEosTime) return !1;
                    const i = this.timelineOffset,
                        s = Oe.bufferInfo(t, i, 0);
                    return this.getAssetTime(s.end) >= this._bufferedEosTime - .02
                }
                get destroyed() {
                    var t;
                    return !(null != (t = this.hls) && t.userConfig)
                }
                get assetId() {
                    return this.assetItem.identifier
                }
                get interstitialId() {
                    return this.assetItem.parentIdentifier
                }
                get media() {
                    var t;
                    return (null == (t = this.hls) ? void 0 : t.media) || null
                }
                get bufferedEnd() {
                    const t = this.media || this.mediaAttached;
                    if (!t) return this._bufferedEosTime ? this._bufferedEosTime : this.currentTime;
                    const e = Oe.bufferInfo(t, t.currentTime, .001);
                    return this.getAssetTime(e.end)
                }
                get currentTime() {
                    const t = this.media || this.mediaAttached;
                    return t ? this.getAssetTime(t.currentTime) : this._currentTime || 0
                }
                get duration() {
                    return this.assetItem.duration || 0
                }
                get remaining() {
                    const t = this.duration;
                    return t ? Math.max(0, t - this.currentTime) : 0
                }
                get startOffset() {
                    return this.assetItem.startOffset
                }
                get timelineOffset() {
                    var t;
                    return (null == (t = this.hls) ? void 0 : t.config.timelineOffset) || 0
                }
                set timelineOffset(t) {
                    const e = this.timelineOffset;
                    if (t !== e) {
                        const i = t - e;
                        if (Math.abs(i) > 1 / 9e4) {
                            if (this.hasDetails) throw new Error("Cannot set timelineOffset after playlists are loaded");
                            this.hls.config.timelineOffset = t
                        }
                    }
                }
                getAssetTime(t) {
                    const e = this.timelineOffset,
                        i = this.duration;
                    return Math.min(Math.max(0, t - e), i)
                }
                removeMediaListeners() {
                    const t = this.mediaAttached;
                    t && (this._currentTime = t.currentTime, this.bufferSnapShot(), t.removeEventListener("timeupdate", this.checkPlayout))
                }
                bufferSnapShot() {
                    var t;
                    this.mediaAttached && null != (t = this.hls) && t.bufferedToEnd && (this._bufferedEosTime = this.bufferedEnd)
                }
                destroy() {
                    this.removeMediaListeners(), this.hls.destroy(), this.hls = this.interstitial = null, this.tracks = this.mediaAttached = this.checkPlayout = null
                }
                attachMedia(t) {
                    this.hls.attachMedia(t)
                }
                detachMedia() {
                    this.removeMediaListeners(), this.mediaAttached = null, this.hls.detachMedia()
                }
                resumeBuffering() {
                    this.hls.resumeBuffering()
                }
                pauseBuffering() {
                    this.hls.pauseBuffering()
                }
                transferMedia() {
                    return this.bufferSnapShot(), this.hls.transferMedia()
                }
                on(t, e, i) {
                    this.hls.on(t, e)
                }
                once(t, e, i) {
                    this.hls.once(t, e)
                }
                off(t, e, i) {
                    this.hls.off(t, e)
                }
                toString() {
                    var t, e;
                    return `HlsAssetPlayer: ${Rn(this.assetItem)} ${null==(t=this.hls)?void 0:t.sessionId} ${null!=(e=this.interstitial)&&e.appendInPlace?"append-in-place":""}`
                }
            }
            class Cn extends S {
                constructor(t, e) {
                    super("interstitials-sched", e), this.onScheduleUpdate = void 0, this.eventMap = {}, this.events = null, this.items = null, this.durations = {
                        primary: 0,
                        playout: 0,
                        integrated: 0
                    }, this.onScheduleUpdate = t
                }
                destroy() {
                    this.reset(), this.onScheduleUpdate = null
                }
                reset() {
                    this.eventMap = {}, this.setDurations(0, 0, 0), this.events && this.events.forEach((t => t.reset())), this.events = this.items = null
                }
                resetErrorsInRange(t, e) {
                    return this.events ? this.events.reduce(((i, s) => t <= s.startOffset && e > s.startOffset ? (delete s.error, i + 1) : i), 0) : 0
                }
                get duration() {
                    const t = this.items;
                    return t ? t[t.length - 1].end : 0
                }
                get length() {
                    return this.items ? this.items.length : 0
                }
                getEvent(t) {
                    return t && this.eventMap[t] || null
                }
                hasEvent(t) {
                    return t in this.eventMap
                }
                findItemIndex(t, e) {
                    if (t.event) return this.findEventIndex(t.event.identifier);
                    let i = -1;
                    t.nextEvent ? i = this.findEventIndex(t.nextEvent.identifier) - 1 : t.previousEvent && (i = this.findEventIndex(t.previousEvent.identifier) + 1);
                    const s = this.items;
                    if (s)
                        for (s[i] || (void 0 === e && (e = t.start), i = this.findItemIndexAtTime(e)); i >= 0 && null != (r = s[i]) && r.event;) {
                            var r;
                            i--
                        }
                    return i
                }
                findItemIndexAtTime(t, e) {
                    const i = this.items;
                    if (i)
                        for (let s = 0; s < i.length; s++) {
                            let r = i[s];
                            if (e && "primary" !== e && (r = r[e]), t === r.start || t > r.start && t < r.end) return s
                        }
                    return -1
                }
                findJumpRestrictedIndex(t, e) {
                    const i = this.items;
                    if (i)
                        for (let s = t; s <= e && i[s]; s++) {
                            const t = i[s].event;
                            if (null != t && t.restrictions.jump && !t.appendInPlace) return s
                        }
                    return -1
                }
                findEventIndex(t) {
                    const e = this.items;
                    if (e)
                        for (let s = e.length; s--;) {
                            var i;
                            if ((null == (i = e[s].event) ? void 0 : i.identifier) === t) return s
                        }
                    return -1
                }
                findAssetIndex(t, e) {
                    const i = t.assetList,
                        s = i.length;
                    if (s > 1)
                        for (let t = 0; t < s; t++) {
                            const s = i[t];
                            if (!s.error) {
                                const i = s.timelineStart;
                                if (e === i || e > i && e < i + (s.duration || 0)) return t
                            }
                        }
                    return 0
                }
                get assetIdAtEnd() {
                    var t, e;
                    const i = null == (t = this.items) || null == (e = t[this.length - 1]) ? void 0 : e.event;
                    if (i) {
                        const t = i.assetList,
                            e = t[t.length - 1];
                        if (e) return e.identifier
                    }
                    return null
                }
                parseInterstitialDateRanges(t, e) {
                    const i = t.main.details,
                        {
                            dateRanges: s
                        } = i,
                        r = this.events,
                        n = this.parseDateRanges(s, {
                            url: i.url
                        }, e),
                        a = Object.keys(s),
                        o = r ? r.filter((t => !a.includes(t.identifier))) : [];
                    n.length && n.sort(((t, e) => {
                        const i = t.cue.pre,
                            s = t.cue.post,
                            r = e.cue.pre,
                            n = e.cue.post;
                        if (i && !r) return -1;
                        if (r && !i) return 1;
                        if (s && !n) return 1;
                        if (n && !s) return -1;
                        if (!(i || r || s || n)) {
                            const i = t.startTime,
                                s = e.startTime;
                            if (i !== s) return i - s
                        }
                        return t.dateRange.tagOrder - e.dateRange.tagOrder
                    })), this.events = n, o.forEach((t => {
                        this.removeEvent(t)
                    })), this.updateSchedule(t, o)
                }
                updateSchedule(t, e = []) {
                    const i = this.events || [];
                    if (i.length || e.length || this.length < 2) {
                        const s = this.items,
                            r = this.parseSchedule(i, t);
                        (e.length || (null == s ? void 0 : s.length) !== r.length || r.some(((t, e) => Math.abs(t.playout.start - s[e].playout.start) > .005 || Math.abs(t.playout.end - s[e].playout.end) > .005))) && (this.items = r, this.onScheduleUpdate(e, s))
                    }
                }
                parseDateRanges(t, e, i) {
                    const s = [],
                        r = Object.keys(t);
                    for (let n = 0; n < r.length; n++) {
                        const a = r[n],
                            o = t[a];
                        if (o.isInterstitial) {
                            let t = this.eventMap[a];
                            t ? t.setDateRange(o) : (t = new An(o, e), this.eventMap[a] = t, !1 === i && (t.appendInPlace = i)), s.push(t)
                        }
                    }
                    return s
                }
                parseSchedule(t, e) {
                    const i = [],
                        s = e.main.details,
                        r = s.live ? 1 / 0 : s.edge;
                    let n = 0;
                    if ((t = t.filter((t => !(t.error || t.cue.once && t.hasPlayed)))).length) {
                        this.resolveOffsets(t, e);
                        let s = 0,
                            o = 0;
                        if (t.forEach(((e, a) => {
                                const l = e.cue.pre,
                                    c = e.cue.post,
                                    u = t[a - 1] || null,
                                    d = e.appendInPlace,
                                    h = c ? r : e.startOffset,
                                    f = e.duration,
                                    p = e.timelineOccupancy === wn.Range ? f : 0,
                                    g = e.resumptionOffset,
                                    m = (null == u ? void 0 : u.startTime) === h,
                                    y = h + e.cumulativeDuration;
                                let v = d ? y + f : h + g;
                                if (l || !c && h <= 0) {
                                    const t = o;
                                    o += p, e.timelineStart = y;
                                    const s = n;
                                    n += f, i.push({
                                        event: e,
                                        start: y,
                                        end: v,
                                        playout: {
                                            start: s,
                                            end: n
                                        },
                                        integrated: {
                                            start: t,
                                            end: o
                                        }
                                    })
                                } else {
                                    if (!(h <= r)) return; {
                                        if (!m) {
                                            const r = h - s;
                                            if (r > .033) {
                                                const l = s,
                                                    c = o;
                                                o += r;
                                                const u = n;
                                                n += r;
                                                const d = {
                                                    previousEvent: t[a - 1] || null,
                                                    nextEvent: e,
                                                    start: l,
                                                    end: l + r,
                                                    playout: {
                                                        start: u,
                                                        end: n
                                                    },
                                                    integrated: {
                                                        start: c,
                                                        end: o
                                                    }
                                                };
                                                i.push(d)
                                            } else r > 0 && u && (u.cumulativeDuration += r, i[i.length - 1].end = h)
                                        }
                                        c && (v = y), e.timelineStart = y;
                                        const r = o;
                                        o += p;
                                        const l = n;
                                        n += f, i.push({
                                            event: e,
                                            start: y,
                                            end: v,
                                            playout: {
                                                start: l,
                                                end: n
                                            },
                                            integrated: {
                                                start: r,
                                                end: o
                                            }
                                        })
                                    }
                                }
                                const b = e.resumeTime;
                                s = c || b > r ? r : b
                            })), s < r) {
                            var a;
                            const t = s,
                                e = o,
                                l = r - s;
                            o += l;
                            const c = n;
                            n += l, i.push({
                                previousEvent: (null == (a = i[i.length - 1]) ? void 0 : a.event) || null,
                                nextEvent: null,
                                start: s,
                                end: t + l,
                                playout: {
                                    start: c,
                                    end: n
                                },
                                integrated: {
                                    start: e,
                                    end: o
                                }
                            })
                        }
                        this.setDurations(r, n, o)
                    } else {
                        const t = 0;
                        i.push({
                            previousEvent: null,
                            nextEvent: null,
                            start: t,
                            end: r,
                            playout: {
                                start: t,
                                end: r
                            },
                            integrated: {
                                start: t,
                                end: r
                            }
                        }), this.setDurations(r, r, r)
                    }
                    return i
                }
                setDurations(t, e, i) {
                    this.durations = {
                        primary: t,
                        playout: e,
                        integrated: i
                    }
                }
                resolveOffsets(t, e) {
                    const i = e.main.details,
                        r = i.live ? 1 / 0 : i.edge;
                    let n = 0,
                        a = -1;
                    t.forEach(((o, l) => {
                        const c = o.cue.pre,
                            u = o.cue.post,
                            d = c ? 0 : u ? r : o.startTime;
                        this.updateAssetDurations(o), a === d ? o.cumulativeDuration = n : (n = 0, a = d), !u && o.snapOptions.in && (o.resumeAnchor = ne(null, i.fragments, o.startOffset + o.resumptionOffset, 0, 0) || void 0), o.appendInPlace && !o.appendInPlaceStarted && (this.primaryCanResumeInPlaceAt(o, e) || (o.appendInPlace = !1)), !o.appendInPlace && l + 1 < t.length && t[l + 1].startTime - t[l].resumeTime < .033 && (t[l + 1].appendInPlace = !1, t[l + 1].appendInPlace && this.warn(`Could not change append strategy for abutting event ${o}`));
                        const h = s(o.resumeOffset) ? o.resumeOffset : o.duration;
                        n += h
                    }))
                }
                primaryCanResumeInPlaceAt(t, e) {
                    const i = t.resumeTime,
                        s = t.startTime + t.resumptionOffset;
                    return Math.abs(i - s) > Sn ? (this.log(`"${t.identifier}" resumption ${i} not aligned with estimated timeline end ${s}`), !1) : e ? !Object.keys(e).some((s => {
                        const r = e[s].details,
                            n = r.edge;
                        if (i >= n) return this.log(`"${t.identifier}" resumption ${i} past ${s} playlist end ${n}`), !1;
                        const a = ne(null, r.fragments, i);
                        if (!a) return this.log(`"${t.identifier}" resumption ${i} does not align with any fragments in ${s} playlist (${r.fragStart}-${r.fragmentEnd})`), !0;
                        const o = "audio" === s ? .175 : 0;
                        return !(Math.abs(a.start - i) < Sn + o || Math.abs(a.end - i) < Sn + o || (this.log(`"${t.identifier}" resumption ${i} not aligned with ${s} fragment bounds (${a.start}-${a.end} sn: ${a.sn} cc: ${a.cc})`), 0))
                    })) : (this.log(`"${t.identifier}" resumption ${i} can not be aligned with media (none selected)`), !1)
                }
                updateAssetDurations(t) {
                    if (!t.assetListLoaded) return;
                    const e = t.timelineStart;
                    let i = 0,
                        s = !1,
                        r = !1;
                    t.assetList.forEach(((t, n) => {
                        const a = e + i;
                        t.startOffset = i, t.timelineStart = a, s || (s = null === t.duration), r || (r = !!t.error);
                        const o = t.error ? 0 : t.duration || 0;
                        i += o
                    })), t.duration = s && !r ? Math.max(i, t.duration) : i
                }
                removeEvent(t) {
                    t.reset(), delete this.eventMap[t.identifier]
                }
            }

            function Dn(t) {
                return `[${t.event?'"'+t.event.identifier+'"':"primary"}: ${t.start.toFixed(2)}-${t.end.toFixed(2)}]`
            }
            class xn {
                constructor(t) {
                    this.hls = void 0, this.hls = t
                }
                destroy() {
                    this.hls = null
                }
                loadAssetList(t, e) {
                    const i = t.assetListUrl;
                    let s;
                    try {
                        s = Ln(i, this.hls.sessionId, t.baseUrl)
                    } catch (e) {
                        const s = this.assignAssetListError(t, o.ASSET_LIST_LOAD_ERROR, e, i);
                        return void this.hls.trigger(l.ERROR, s)
                    }
                    e && "data:" !== s.protocol && s.searchParams.set("_HLS_start_offset", "" + e);
                    const r = this.hls.config,
                        n = new(0, r.loader)(r),
                        a = {
                            responseType: "json",
                            url: s.href
                        },
                        c = r.interstitialAssetListLoadPolicy.default,
                        u = {
                            loadPolicy: c,
                            timeout: c.maxLoadTimeMs,
                            maxRetry: 0,
                            retryDelay: 0,
                            maxRetryDelay: 0
                        },
                        d = {
                            onSuccess: (e, i, s, r) => {
                                const n = e.data,
                                    a = null == n ? void 0 : n.ASSETS;
                                if (Array.isArray(a)) t.assetListResponse = n, this.hls.trigger(l.ASSET_LIST_LOADED, {
                                    event: t,
                                    assetListResponse: n,
                                    networkDetails: r
                                });
                                else {
                                    const e = this.assignAssetListError(t, o.ASSET_LIST_PARSING_ERROR, new Error("Invalid interstitial asset list"), s.url, i, r);
                                    this.hls.trigger(l.ERROR, e)
                                }
                            },
                            onError: (e, i, s, r) => {
                                const n = this.assignAssetListError(t, o.ASSET_LIST_LOAD_ERROR, new Error(`Error loading X-ASSET-LIST: HTTP status ${e.code} ${e.text} (${i.url})`), i.url, r, s);
                                this.hls.trigger(l.ERROR, n)
                            },
                            onTimeout: (e, i, s) => {
                                const r = this.assignAssetListError(t, o.ASSET_LIST_LOAD_TIMEOUT, new Error(`Timeout loading X-ASSET-LIST (${i.url})`), i.url, e, s);
                                this.hls.trigger(l.ERROR, r)
                            }
                        };
                    return n.load(a, u, d), this.hls.trigger(l.ASSET_LIST_LOADING, {
                        event: t
                    }), n
                }
                assignAssetListError(t, e, i, s, r, n) {
                    return t.error = i, {
                        type: a.NETWORK_ERROR,
                        details: e,
                        fatal: !1,
                        interstitial: t,
                        url: s,
                        error: i,
                        networkDetails: n,
                        stats: r
                    }
                }
            }

            function Pn(t, e, i) {
                On(t, e, i), t.addEventListener(e, i)
            }

            function On(t, e, i) {
                t.removeEventListener(e, i)
            }

            function Mn(t) {
                null == t || t.play().catch((() => {}))
            }
            class Nn {
                constructor(t) {
                    this.buffered = void 0;
                    const e = (e, i, s) => {
                        if ((i >>>= 0) > s - 1) throw new DOMException(`Failed to execute '${e}' on 'TimeRanges': The index provided (${i}) is greater than the maximum bound (${s})`);
                        return t[i][e]
                    };
                    this.buffered = {
                        get length() {
                            return t.length
                        },
                        end: i => e("end", i, t.length),
                        start: i => e("start", i, t.length)
                    }
                }
            }
            const Fn = {
                    42: 225,
                    92: 233,
                    94: 237,
                    95: 243,
                    96: 250,
                    123: 231,
                    124: 247,
                    125: 209,
                    126: 241,
                    127: 9608,
                    128: 174,
                    129: 176,
                    130: 189,
                    131: 191,
                    132: 8482,
                    133: 162,
                    134: 163,
                    135: 9834,
                    136: 224,
                    137: 32,
                    138: 232,
                    139: 226,
                    140: 234,
                    141: 238,
                    142: 244,
                    143: 251,
                    144: 193,
                    145: 201,
                    146: 211,
                    147: 218,
                    148: 220,
                    149: 252,
                    150: 8216,
                    151: 161,
                    152: 42,
                    153: 8217,
                    154: 9473,
                    155: 169,
                    156: 8480,
                    157: 8226,
                    158: 8220,
                    159: 8221,
                    160: 192,
                    161: 194,
                    162: 199,
                    163: 200,
                    164: 202,
                    165: 203,
                    166: 235,
                    167: 206,
                    168: 207,
                    169: 239,
                    170: 212,
                    171: 217,
                    172: 249,
                    173: 219,
                    174: 171,
                    175: 187,
                    176: 195,
                    177: 227,
                    178: 205,
                    179: 204,
                    180: 236,
                    181: 210,
                    182: 242,
                    183: 213,
                    184: 245,
                    185: 123,
                    186: 125,
                    187: 92,
                    188: 94,
                    189: 95,
                    190: 124,
                    191: 8764,
                    192: 196,
                    193: 228,
                    194: 214,
                    195: 246,
                    196: 223,
                    197: 165,
                    198: 164,
                    199: 9475,
                    200: 197,
                    201: 229,
                    202: 216,
                    203: 248,
                    204: 9487,
                    205: 9491,
                    206: 9495,
                    207: 9499
                },
                $n = t => String.fromCharCode(Fn[t] || t),
                Un = 15,
                Bn = 100,
                jn = {
                    17: 1,
                    18: 3,
                    21: 5,
                    22: 7,
                    23: 9,
                    16: 11,
                    19: 12,
                    20: 14
                },
                Gn = {
                    17: 2,
                    18: 4,
                    21: 6,
                    22: 8,
                    23: 10,
                    19: 13,
                    20: 15
                },
                Vn = {
                    25: 1,
                    26: 3,
                    29: 5,
                    30: 7,
                    31: 9,
                    24: 11,
                    27: 12,
                    28: 14
                },
                Hn = {
                    25: 2,
                    26: 4,
                    29: 6,
                    30: 8,
                    31: 10,
                    27: 13,
                    28: 15
                },
                Kn = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
            class zn {
                constructor() {
                    this.time = null, this.verboseLevel = 0
                }
                log(t, e) {
                    if (this.verboseLevel >= t) {
                        const i = "function" == typeof e ? e() : e;
                        R.log(`${this.time} [${t}] ${i}`)
                    }
                }
            }
            const qn = function(t) {
                const e = [];
                for (let i = 0; i < t.length; i++) e.push(t[i].toString(16));
                return e
            };
            class Wn {
                constructor() {
                    this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1
                }
                reset() {
                    this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1
                }
                setStyles(t) {
                    const e = ["foreground", "underline", "italics", "background", "flash"];
                    for (let i = 0; i < e.length; i++) {
                        const s = e[i];
                        t.hasOwnProperty(s) && (this[s] = t[s])
                    }
                }
                isDefault() {
                    return "white" === this.foreground && !this.underline && !this.italics && "black" === this.background && !this.flash
                }
                equals(t) {
                    return this.foreground === t.foreground && this.underline === t.underline && this.italics === t.italics && this.background === t.background && this.flash === t.flash
                }
                copy(t) {
                    this.foreground = t.foreground, this.underline = t.underline, this.italics = t.italics, this.background = t.background, this.flash = t.flash
                }
                toString() {
                    return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash
                }
            }
            class Yn {
                constructor() {
                    this.uchar = " ", this.penState = new Wn
                }
                reset() {
                    this.uchar = " ", this.penState.reset()
                }
                setChar(t, e) {
                    this.uchar = t, this.penState.copy(e)
                }
                setPenState(t) {
                    this.penState.copy(t)
                }
                equals(t) {
                    return this.uchar === t.uchar && this.penState.equals(t.penState)
                }
                copy(t) {
                    this.uchar = t.uchar, this.penState.copy(t.penState)
                }
                isEmpty() {
                    return " " === this.uchar && this.penState.isDefault()
                }
            }
            class Xn {
                constructor(t) {
                    this.chars = [], this.pos = 0, this.currPenState = new Wn, this.cueStartTime = null, this.logger = void 0;
                    for (let t = 0; t < Bn; t++) this.chars.push(new Yn);
                    this.logger = t
                }
                equals(t) {
                    for (let e = 0; e < Bn; e++)
                        if (!this.chars[e].equals(t.chars[e])) return !1;
                    return !0
                }
                copy(t) {
                    for (let e = 0; e < Bn; e++) this.chars[e].copy(t.chars[e])
                }
                isEmpty() {
                    let t = !0;
                    for (let e = 0; e < Bn; e++)
                        if (!this.chars[e].isEmpty()) {
                            t = !1;
                            break
                        }
                    return t
                }
                setCursor(t) {
                    this.pos !== t && (this.pos = t), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > Bn && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = Bn)
                }
                moveCursor(t) {
                    const e = this.pos + t;
                    if (t > 1)
                        for (let t = this.pos + 1; t < e + 1; t++) this.chars[t].setPenState(this.currPenState);
                    this.setCursor(e)
                }
                backSpace() {
                    this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState)
                }
                insertChar(t) {
                    t >= 144 && this.backSpace();
                    const e = $n(t);
                    this.pos >= Bn ? this.logger.log(0, (() => "Cannot insert " + t.toString(16) + " (" + e + ") at position " + this.pos + ". Skipping it!")) : (this.chars[this.pos].setChar(e, this.currPenState), this.moveCursor(1))
                }
                clearFromPos(t) {
                    let e;
                    for (e = t; e < Bn; e++) this.chars[e].reset()
                }
                clear() {
                    this.clearFromPos(0), this.pos = 0, this.currPenState.reset()
                }
                clearToEndOfRow() {
                    this.clearFromPos(this.pos)
                }
                getTextString() {
                    const t = [];
                    let e = !0;
                    for (let i = 0; i < Bn; i++) {
                        const s = this.chars[i].uchar;
                        " " !== s && (e = !1), t.push(s)
                    }
                    return e ? "" : t.join("")
                }
                setPenStyles(t) {
                    this.currPenState.setStyles(t), this.chars[this.pos].setPenState(this.currPenState)
                }
            }
            class Qn {
                constructor(t) {
                    this.rows = [], this.currRow = 14, this.nrRollUpRows = null, this.lastOutputScreen = null, this.logger = void 0;
                    for (let e = 0; e < Un; e++) this.rows.push(new Xn(t));
                    this.logger = t
                }
                reset() {
                    for (let t = 0; t < Un; t++) this.rows[t].clear();
                    this.currRow = 14
                }
                equals(t) {
                    let e = !0;
                    for (let i = 0; i < Un; i++)
                        if (!this.rows[i].equals(t.rows[i])) {
                            e = !1;
                            break
                        }
                    return e
                }
                copy(t) {
                    for (let e = 0; e < Un; e++) this.rows[e].copy(t.rows[e])
                }
                isEmpty() {
                    let t = !0;
                    for (let e = 0; e < Un; e++)
                        if (!this.rows[e].isEmpty()) {
                            t = !1;
                            break
                        }
                    return t
                }
                backSpace() {
                    this.rows[this.currRow].backSpace()
                }
                clearToEndOfRow() {
                    this.rows[this.currRow].clearToEndOfRow()
                }
                insertChar(t) {
                    this.rows[this.currRow].insertChar(t)
                }
                setPen(t) {
                    this.rows[this.currRow].setPenStyles(t)
                }
                moveCursor(t) {
                    this.rows[this.currRow].moveCursor(t)
                }
                setCursor(t) {
                    this.logger.log(2, "setCursor: " + t), this.rows[this.currRow].setCursor(t)
                }
                setPAC(t) {
                    this.logger.log(2, (() => "pacData = " + Yt(t)));
                    let e = t.row - 1;
                    if (this.nrRollUpRows && e < this.nrRollUpRows - 1 && (e = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== e) {
                        for (let t = 0; t < Un; t++) this.rows[t].clear();
                        const t = this.currRow + 1 - this.nrRollUpRows,
                            i = this.lastOutputScreen;
                        if (i) {
                            const s = i.rows[t].cueStartTime,
                                r = this.logger.time;
                            if (null !== s && null !== r && s < r)
                                for (let s = 0; s < this.nrRollUpRows; s++) this.rows[e - this.nrRollUpRows + s + 1].copy(i.rows[t + s])
                        }
                    }
                    this.currRow = e;
                    const i = this.rows[this.currRow];
                    if (null !== t.indent) {
                        const e = t.indent,
                            s = Math.max(e - 1, 0);
                        i.setCursor(t.indent), t.color = i.chars[s].penState.foreground
                    }
                    const s = {
                        foreground: t.color,
                        underline: t.underline,
                        italics: t.italics,
                        background: "black",
                        flash: !1
                    };
                    this.setPen(s)
                }
                setBkgData(t) {
                    this.logger.log(2, (() => "bkgData = " + Yt(t))), this.backSpace(), this.setPen(t), this.insertChar(32)
                }
                setRollUpRows(t) {
                    this.nrRollUpRows = t
                }
                rollUp() {
                    if (null === this.nrRollUpRows) return void this.logger.log(3, "roll_up but nrRollUpRows not set yet");
                    this.logger.log(1, (() => this.getDisplayText()));
                    const t = this.currRow + 1 - this.nrRollUpRows,
                        e = this.rows.splice(t, 1)[0];
                    e.clear(), this.rows.splice(this.currRow, 0, e), this.logger.log(2, "Rolling up")
                }
                getDisplayText(t) {
                    t = t || !1;
                    const e = [];
                    let i = "",
                        s = -1;
                    for (let i = 0; i < Un; i++) {
                        const r = this.rows[i].getTextString();
                        r && (s = i + 1, t ? e.push("Row " + s + ": '" + r + "'") : e.push(r.trim()))
                    }
                    return e.length > 0 && (i = t ? "[" + e.join(" | ") + "]" : e.join("\n")), i
                }
                getTextAndFormat() {
                    return this.rows
                }
            }
            class Jn {
                constructor(t, e, i) {
                    this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = t, this.outputFilter = e, this.mode = null, this.verbose = 0, this.displayedMemory = new Qn(i), this.nonDisplayedMemory = new Qn(i), this.lastOutputScreen = new Qn(i), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = i
                }
                reset() {
                    this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null
                }
                getHandler() {
                    return this.outputFilter
                }
                setHandler(t) {
                    this.outputFilter = t
                }
                setPAC(t) {
                    this.writeScreen.setPAC(t)
                }
                setBkgData(t) {
                    this.writeScreen.setBkgData(t)
                }
                setMode(t) {
                    t !== this.mode && (this.mode = t, this.logger.log(2, (() => "MODE=" + t)), "MODE_POP-ON" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), "MODE_ROLL-UP" !== this.mode && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = t)
                }
                insertChars(t) {
                    for (let e = 0; e < t.length; e++) this.writeScreen.insertChar(t[e]);
                    const e = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
                    this.logger.log(2, (() => e + ": " + this.writeScreen.getDisplayText(!0))), "MODE_PAINT-ON" !== this.mode && "MODE_ROLL-UP" !== this.mode || (this.logger.log(1, (() => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0))), this.outputDataUpdate())
                }
                ccRCL() {
                    this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON")
                }
                ccBS() {
                    this.logger.log(2, "BS - BackSpace"), "MODE_TEXT" !== this.mode && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate())
                }
                ccAOF() {}
                ccAON() {}
                ccDER() {
                    this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate()
                }
                ccRU(t) {
                    this.logger.log(2, "RU(" + t + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(t)
                }
                ccFON() {
                    this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({
                        flash: !0
                    })
                }
                ccRDC() {
                    this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON")
                }
                ccTR() {
                    this.logger.log(2, "TR"), this.setMode("MODE_TEXT")
                }
                ccRTD() {
                    this.logger.log(2, "RTD"), this.setMode("MODE_TEXT")
                }
                ccEDM() {
                    this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0)
                }
                ccCR() {
                    this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0)
                }
                ccENM() {
                    this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset()
                }
                ccEOC() {
                    if (this.logger.log(2, "EOC - End Of Caption"), "MODE_POP-ON" === this.mode) {
                        const t = this.displayedMemory;
                        this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = t, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, (() => "DISP: " + this.displayedMemory.getDisplayText()))
                    }
                    this.outputDataUpdate(!0)
                }
                ccTO(t) {
                    this.logger.log(2, "TO(" + t + ") - Tab Offset"), this.writeScreen.moveCursor(t)
                }
                ccMIDROW(t) {
                    const e = {
                        flash: !1
                    };
                    if (e.underline = t % 2 == 1, e.italics = t >= 46, e.italics) e.foreground = "white";
                    else {
                        const i = Math.floor(t / 2) - 16,
                            s = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
                        e.foreground = s[i]
                    }
                    this.logger.log(2, "MIDROW: " + Yt(e)), this.writeScreen.setPen(e)
                }
                outputDataUpdate(t = !1) {
                    const e = this.logger.time;
                    null !== e && this.outputFilter && (null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, e, this.lastOutputScreen), t && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : e) : this.cueStartTime = e, this.lastOutputScreen.copy(this.displayedMemory))
                }
                cueSplitAtTime(t) {
                    this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory), this.cueStartTime = t))
                }
            }
            class Zn {
                constructor(t, e, i) {
                    this.channels = void 0, this.currentChannel = 0, this.cmdHistory = {
                        a: null,
                        b: null
                    }, this.logger = void 0;
                    const s = this.logger = new zn;
                    this.channels = [null, new Jn(t, e, s), new Jn(t + 1, i, s)]
                }
                getHandler(t) {
                    return this.channels[t].getHandler()
                }
                setHandler(t, e) {
                    this.channels[t].setHandler(e)
                }
                addData(t, e) {
                    this.logger.time = t;
                    for (let t = 0; t < e.length; t += 2) {
                        const i = 127 & e[t],
                            s = 127 & e[t + 1];
                        let r = !1,
                            n = null;
                        if (0 === i && 0 === s) continue;
                        this.logger.log(3, (() => "[" + qn([e[t], e[t + 1]]) + "] -> (" + qn([i, s]) + ")"));
                        const a = this.cmdHistory;
                        if (i >= 16 && i <= 31) {
                            if (ea(i, s, a)) {
                                ta(null, null, a), this.logger.log(3, (() => "Repeated command (" + qn([i, s]) + ") is dropped"));
                                continue
                            }
                            ta(i, s, this.cmdHistory), r = this.parseCmd(i, s), r || (r = this.parseMidrow(i, s)), r || (r = this.parsePAC(i, s)), r || (r = this.parseBackgroundAttributes(i, s))
                        } else ta(null, null, a);
                        if (!r && (n = this.parseChars(i, s), n)) {
                            const t = this.currentChannel;
                            t && t > 0 ? this.channels[t].insertChars(n) : this.logger.log(2, "No channel found yet. TEXT-MODE?")
                        }
                        r || n || this.logger.log(2, (() => "Couldn't parse cleaned data " + qn([i, s]) + " orig: " + qn([e[t], e[t + 1]])))
                    }
                }
                parseCmd(t, e) {
                    if (!((20 === t || 28 === t || 21 === t || 29 === t) && e >= 32 && e <= 47 || (23 === t || 31 === t) && e >= 33 && e <= 35)) return !1;
                    const i = 20 === t || 21 === t || 23 === t ? 1 : 2,
                        s = this.channels[i];
                    return 20 === t || 21 === t || 28 === t || 29 === t ? 32 === e ? s.ccRCL() : 33 === e ? s.ccBS() : 34 === e ? s.ccAOF() : 35 === e ? s.ccAON() : 36 === e ? s.ccDER() : 37 === e ? s.ccRU(2) : 38 === e ? s.ccRU(3) : 39 === e ? s.ccRU(4) : 40 === e ? s.ccFON() : 41 === e ? s.ccRDC() : 42 === e ? s.ccTR() : 43 === e ? s.ccRTD() : 44 === e ? s.ccEDM() : 45 === e ? s.ccCR() : 46 === e ? s.ccENM() : 47 === e && s.ccEOC() : s.ccTO(e - 32), this.currentChannel = i, !0
                }
                parseMidrow(t, e) {
                    let i = 0;
                    if ((17 === t || 25 === t) && e >= 32 && e <= 47) {
                        if (i = 17 === t ? 1 : 2, i !== this.currentChannel) return this.logger.log(0, "Mismatch channel in midrow parsing"), !1;
                        const s = this.channels[i];
                        return !!s && (s.ccMIDROW(e), this.logger.log(3, (() => "MIDROW (" + qn([t, e]) + ")")), !0)
                    }
                    return !1
                }
                parsePAC(t, e) {
                    let i;
                    if (!((t >= 17 && t <= 23 || t >= 25 && t <= 31) && e >= 64 && e <= 127 || (16 === t || 24 === t) && e >= 64 && e <= 95)) return !1;
                    const s = t <= 23 ? 1 : 2;
                    i = e >= 64 && e <= 95 ? 1 === s ? jn[t] : Vn[t] : 1 === s ? Gn[t] : Hn[t];
                    const r = this.channels[s];
                    return !!r && (r.setPAC(this.interpretPAC(i, e)), this.currentChannel = s, !0)
                }
                interpretPAC(t, e) {
                    let i;
                    const s = {
                        color: null,
                        italics: !1,
                        indent: null,
                        underline: !1,
                        row: t
                    };
                    return i = e > 95 ? e - 96 : e - 64, s.underline = 1 == (1 & i), i <= 13 ? s.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(i / 2)] : i <= 15 ? (s.italics = !0, s.color = "white") : s.indent = 4 * Math.floor((i - 16) / 2), s
                }
                parseChars(t, e) {
                    let i, s = null,
                        r = null;
                    if (t >= 25 ? (i = 2, r = t - 8) : (i = 1, r = t), r >= 17 && r <= 19) {
                        let t;
                        t = 17 === r ? e + 80 : 18 === r ? e + 112 : e + 144, this.logger.log(2, (() => "Special char '" + $n(t) + "' in channel " + i)), s = [t]
                    } else t >= 32 && t <= 127 && (s = 0 === e ? [t] : [t, e]);
                    return s && this.logger.log(3, (() => "Char codes =  " + qn(s).join(","))), s
                }
                parseBackgroundAttributes(t, e) {
                    if (!((16 === t || 24 === t) && e >= 32 && e <= 47 || (23 === t || 31 === t) && e >= 45 && e <= 47)) return !1;
                    let i;
                    const s = {};
                    16 === t || 24 === t ? (i = Math.floor((e - 32) / 2), s.background = Kn[i], e % 2 == 1 && (s.background = s.background + "_semi")) : 45 === e ? s.background = "transparent" : (s.foreground = "black", 47 === e && (s.underline = !0));
                    const r = t <= 23 ? 1 : 2;
                    return this.channels[r].setBkgData(s), !0
                }
                reset() {
                    for (let t = 0; t < Object.keys(this.channels).length; t++) {
                        const e = this.channels[t];
                        e && e.reset()
                    }
                    ta(null, null, this.cmdHistory)
                }
                cueSplitAtTime(t) {
                    for (let e = 0; e < this.channels.length; e++) {
                        const i = this.channels[e];
                        i && i.cueSplitAtTime(t)
                    }
                }
            }

            function ta(t, e, i) {
                i.a = t, i.b = e
            }

            function ea(t, e, i) {
                return i.a === t && i.b === e
            }
            var ia = function() {
                if (null != Xe && Xe.VTTCue) return self.VTTCue;
                const t = ["", "lr", "rl"],
                    e = ["start", "middle", "end", "left", "right"];

                function i(t, e) {
                    if ("string" != typeof e) return !1;
                    if (!Array.isArray(t)) return !1;
                    const i = e.toLowerCase();
                    return !!~t.indexOf(i) && i
                }

                function s(t) {
                    return i(e, t)
                }

                function r(t, ...e) {
                    let i = 1;
                    for (; i < arguments.length; i++) {
                        const e = arguments[i];
                        for (const i in e) t[i] = e[i]
                    }
                    return t
                }

                function n(e, n, a) {
                    const o = this,
                        l = {
                            enumerable: !0
                        };
                    o.hasBeenReset = !1;
                    let c = "",
                        u = !1,
                        d = e,
                        h = n,
                        f = a,
                        p = null,
                        g = "",
                        m = !0,
                        y = "auto",
                        v = "start",
                        b = 50,
                        T = "middle",
                        E = 50,
                        S = "middle";
                    Object.defineProperty(o, "id", r({}, l, {
                        get: function() {
                            return c
                        },
                        set: function(t) {
                            c = "" + t
                        }
                    })), Object.defineProperty(o, "pauseOnExit", r({}, l, {
                        get: function() {
                            return u
                        },
                        set: function(t) {
                            u = !!t
                        }
                    })), Object.defineProperty(o, "startTime", r({}, l, {
                        get: function() {
                            return d
                        },
                        set: function(t) {
                            if ("number" != typeof t) throw new TypeError("Start time must be set to a number.");
                            d = t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "endTime", r({}, l, {
                        get: function() {
                            return h
                        },
                        set: function(t) {
                            if ("number" != typeof t) throw new TypeError("End time must be set to a number.");
                            h = t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "text", r({}, l, {
                        get: function() {
                            return f
                        },
                        set: function(t) {
                            f = "" + t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "region", r({}, l, {
                        get: function() {
                            return p
                        },
                        set: function(t) {
                            p = t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "vertical", r({}, l, {
                        get: function() {
                            return g
                        },
                        set: function(e) {
                            const s = function(e) {
                                return i(t, e)
                            }(e);
                            if (!1 === s) throw new SyntaxError("An invalid or illegal string was specified.");
                            g = s, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "snapToLines", r({}, l, {
                        get: function() {
                            return m
                        },
                        set: function(t) {
                            m = !!t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "line", r({}, l, {
                        get: function() {
                            return y
                        },
                        set: function(t) {
                            if ("number" != typeof t && "auto" !== t) throw new SyntaxError("An invalid number or illegal string was specified.");
                            y = t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "lineAlign", r({}, l, {
                        get: function() {
                            return v
                        },
                        set: function(t) {
                            const e = s(t);
                            if (!e) throw new SyntaxError("An invalid or illegal string was specified.");
                            v = e, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "position", r({}, l, {
                        get: function() {
                            return b
                        },
                        set: function(t) {
                            if (t < 0 || t > 100) throw new Error("Position must be between 0 and 100.");
                            b = t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "positionAlign", r({}, l, {
                        get: function() {
                            return T
                        },
                        set: function(t) {
                            const e = s(t);
                            if (!e) throw new SyntaxError("An invalid or illegal string was specified.");
                            T = e, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "size", r({}, l, {
                        get: function() {
                            return E
                        },
                        set: function(t) {
                            if (t < 0 || t > 100) throw new Error("Size must be between 0 and 100.");
                            E = t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "align", r({}, l, {
                        get: function() {
                            return S
                        },
                        set: function(t) {
                            const e = s(t);
                            if (!e) throw new SyntaxError("An invalid or illegal string was specified.");
                            S = e, this.hasBeenReset = !0
                        }
                    })), o.displayState = void 0
                }
                return n.prototype.getCueAsHTML = function() {
                    return self.WebVTT.convertCueToDOMTree(self, this.text)
                }, n
            }();
            class sa {
                decode(t, e) {
                    if (!t) return "";
                    if ("string" != typeof t) throw new Error("Error - expected string data.");
                    return decodeURIComponent(encodeURIComponent(t))
                }
            }

            function ra(t) {
                function e(t, e, i, s) {
                    return 3600 * (0 | t) + 60 * (0 | e) + (0 | i) + parseFloat(s || 0)
                }
                const i = t.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
                return i ? parseFloat(i[2]) > 59 ? e(i[2], i[3], 0, i[4]) : e(i[1], i[2], i[3], i[4]) : null
            }
            class na {
                constructor() {
                    this.values = Object.create(null)
                }
                set(t, e) {
                    this.get(t) || "" === e || (this.values[t] = e)
                }
                get(t, e, i) {
                    return i ? this.has(t) ? this.values[t] : e[i] : this.has(t) ? this.values[t] : e
                }
                has(t) {
                    return t in this.values
                }
                alt(t, e, i) {
                    for (let s = 0; s < i.length; ++s)
                        if (e === i[s]) {
                            this.set(t, e);
                            break
                        }
                }
                integer(t, e) {
                    /^-?\d+$/.test(e) && this.set(t, parseInt(e, 10))
                }
                percent(t, e) {
                    if (/^([\d]{1,3})(\.[\d]*)?%$/.test(e)) {
                        const i = parseFloat(e);
                        if (i >= 0 && i <= 100) return this.set(t, i), !0
                    }
                    return !1
                }
            }

            function aa(t, e, i, s) {
                const r = s ? t.split(s) : [t];
                for (const t in r) {
                    if ("string" != typeof r[t]) continue;
                    const s = r[t].split(i);
                    2 === s.length && e(s[0], s[1])
                }
            }
            const oa = new ia(0, 0, ""),
                la = "middle" === oa.align ? "middle" : "center";

            function ca(t, e, i) {
                const s = t;

                function r() {
                    const e = ra(t);
                    if (null === e) throw new Error("Malformed timestamp: " + s);
                    return t = t.replace(/^[^\sa-zA-Z-]+/, ""), e
                }

                function n() {
                    t = t.replace(/^\s+/, "")
                }
                if (n(), e.startTime = r(), n(), "--\x3e" !== t.slice(0, 3)) throw new Error("Malformed time stamp (time stamps must be separated by '--\x3e'): " + s);
                t = t.slice(3), n(), e.endTime = r(), n(),
                    function(t, e) {
                        const s = new na;
                        aa(t, (function(t, e) {
                            let r;
                            switch (t) {
                                case "region":
                                    for (let r = i.length - 1; r >= 0; r--)
                                        if (i[r].id === e) {
                                            s.set(t, i[r].region);
                                            break
                                        }
                                    break;
                                case "vertical":
                                    s.alt(t, e, ["rl", "lr"]);
                                    break;
                                case "line":
                                    r = e.split(","), s.integer(t, r[0]), s.percent(t, r[0]) && s.set("snapToLines", !1), s.alt(t, r[0], ["auto"]), 2 === r.length && s.alt("lineAlign", r[1], ["start", la, "end"]);
                                    break;
                                case "position":
                                    r = e.split(","), s.percent(t, r[0]), 2 === r.length && s.alt("positionAlign", r[1], ["start", la, "end", "line-left", "line-right", "auto"]);
                                    break;
                                case "size":
                                    s.percent(t, e);
                                    break;
                                case "align":
                                    s.alt(t, e, ["start", la, "end", "left", "right"])
                            }
                        }), /:/, /\s/), e.region = s.get("region", null), e.vertical = s.get("vertical", "");
                        let r = s.get("line", "auto");
                        "auto" === r && -1 === oa.line && (r = -1), e.line = r, e.lineAlign = s.get("lineAlign", "start"), e.snapToLines = s.get("snapToLines", !0), e.size = s.get("size", 100), e.align = s.get("align", la);
                        let n = s.get("position", "auto");
                        "auto" === n && 50 === oa.position && (n = "start" === e.align || "left" === e.align ? 0 : "end" === e.align || "right" === e.align ? 100 : 50), e.position = n
                    }(t, e)
            }

            function ua(t) {
                return t.replace(/<br(?: \/)?>/gi, "\n")
            }
            class da {
                constructor() {
                    this.state = "INITIAL", this.buffer = "", this.decoder = new sa, this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0
                }
                parse(t) {
                    const e = this;

                    function i() {
                        let t = e.buffer,
                            i = 0;
                        for (t = ua(t); i < t.length && "\r" !== t[i] && "\n" !== t[i];) ++i;
                        const s = t.slice(0, i);
                        return "\r" === t[i] && ++i, "\n" === t[i] && ++i, e.buffer = t.slice(i), s
                    }
                    t && (e.buffer += e.decoder.decode(t, {
                        stream: !0
                    }));
                    try {
                        let t = "";
                        if ("INITIAL" === e.state) {
                            if (!/\r\n|\n/.test(e.buffer)) return this;
                            t = i();
                            const s = t.match(/^()?WEBVTT([ \t].*)?$/);
                            if (null == s || !s[0]) throw new Error("Malformed WebVTT signature.");
                            e.state = "HEADER"
                        }
                        let s = !1;
                        for (; e.buffer;) {
                            if (!/\r\n|\n/.test(e.buffer)) return this;
                            switch (s ? s = !1 : t = i(), e.state) {
                                case "HEADER":
                                    /:/.test(t) ? aa(t, (function(t, e) {}), /:/) : t || (e.state = "ID");
                                    continue;
                                case "NOTE":
                                    t || (e.state = "ID");
                                    continue;
                                case "ID":
                                    if (/^NOTE($|[ \t])/.test(t)) {
                                        e.state = "NOTE";
                                        break
                                    }
                                    if (!t) continue;
                                    if (e.cue = new ia(0, 0, ""), e.state = "CUE", -1 === t.indexOf("--\x3e")) {
                                        e.cue.id = t;
                                        continue
                                    }
                                case "CUE":
                                    if (!e.cue) {
                                        e.state = "BADCUE";
                                        continue
                                    }
                                    try {
                                        ca(t, e.cue, e.regionList)
                                    } catch (t) {
                                        e.cue = null, e.state = "BADCUE";
                                        continue
                                    }
                                    e.state = "CUETEXT";
                                    continue;
                                case "CUETEXT":
                                    {
                                        const i = -1 !== t.indexOf("--\x3e");
                                        if (!t || i && (s = !0)) {
                                            e.oncue && e.cue && e.oncue(e.cue), e.cue = null, e.state = "ID";
                                            continue
                                        }
                                        if (null === e.cue) continue;e.cue.text && (e.cue.text += "\n"),
                                        e.cue.text += t
                                    }
                                    continue;
                                case "BADCUE":
                                    t || (e.state = "ID")
                            }
                        }
                    } catch (t) {
                        "CUETEXT" === e.state && e.cue && e.oncue && e.oncue(e.cue), e.cue = null, e.state = "INITIAL" === e.state ? "BADWEBVTT" : "BADCUE"
                    }
                    return this
                }
                flush() {
                    const t = this;
                    try {
                        if ((t.cue || "HEADER" === t.state) && (t.buffer += "\n\n", t.parse()), "INITIAL" === t.state || "BADWEBVTT" === t.state) throw new Error("Malformed WebVTT signature.")
                    } catch (e) {
                        t.onparsingerror && t.onparsingerror(e)
                    }
                    return t.onflush && t.onflush(), this
                }
            }
            const ha = /\r\n|\n\r|\n|\r/g,
                fa = function(t, e, i = 0) {
                    return t.slice(i, i + e.length) === e
                };

            function pa(t, e, i) {
                return En(t.toString()) + En(e.toString()) + En(i)
            }
            const ga = "stpp.ttml.im1t",
                ma = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/,
                ya = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/,
                va = {
                    left: "start",
                    center: "center",
                    right: "end",
                    start: "start",
                    end: "end"
                };

            function ba(t, e, i, s) {
                const r = at(new Uint8Array(t), ["mdat"]);
                if (0 === r.length) return void s(new Error("Could not parse IMSC1 mdat"));
                const n = r.map((t => D(t))),
                    a = function(t, e, i = 1, s = !1) {
                        return er(t, e, 1 / i, s)
                    }(e.baseTime, 1, e.timescale);
                try {
                    n.forEach((t => i(function(t, e) {
                        const i = (new DOMParser).parseFromString(t, "text/xml").getElementsByTagName("tt")[0];
                        if (!i) throw new Error("Invalid ttml");
                        const s = {
                                frameRate: 30,
                                subFrameRate: 1,
                                frameRateMultiplier: 0,
                                tickRate: 0
                            },
                            r = Object.keys(s).reduce(((t, e) => (t[e] = i.getAttribute(`ttp:${e}`) || s[e], t)), {}),
                            n = "preserve" !== i.getAttribute("xml:space"),
                            a = Ea(Ta(i, "styling", "style")),
                            o = Ea(Ta(i, "layout", "region")),
                            l = Ta(i, "body", "[begin]");
                        return [].map.call(l, (t => {
                            const i = Sa(t, n);
                            if (!i || !t.hasAttribute("begin")) return null;
                            const s = Aa(t.getAttribute("begin"), r),
                                l = Aa(t.getAttribute("dur"), r);
                            let c = Aa(t.getAttribute("end"), r);
                            if (null === s) throw ka(t);
                            if (null === c) {
                                if (null === l) throw ka(t);
                                c = s + l
                            }
                            const u = new ia(s - e, c - e, i);
                            u.id = pa(u.startTime, u.endTime, u.text);
                            const d = function(t, e, i) {
                                    const s = "http://www.w3.org/ns/ttml#styling";
                                    let r = null;
                                    const n = null != t && t.hasAttribute("style") ? t.getAttribute("style") : null;
                                    return n && i.hasOwnProperty(n) && (r = i[n]), ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"].reduce(((i, n) => {
                                        const a = wa(e, s, n) || wa(t, s, n) || wa(r, s, n);
                                        return a && (i[n] = a), i
                                    }), {})
                                }(o[t.getAttribute("region")], a[t.getAttribute("style")], a),
                                {
                                    textAlign: h
                                } = d;
                            if (h) {
                                const t = va[h];
                                t && (u.lineAlign = t), u.align = h
                            }
                            return b(u, d), u
                        })).filter((t => null !== t))
                    }(t, a))))
                } catch (t) {
                    s(t)
                }
            }

            function Ta(t, e, i) {
                const s = t.getElementsByTagName(e)[0];
                return s ? [].slice.call(s.querySelectorAll(i)) : []
            }

            function Ea(t) {
                return t.reduce(((t, e) => {
                    const i = e.getAttribute("xml:id");
                    return i && (t[i] = e), t
                }), {})
            }

            function Sa(t, e) {
                return [].slice.call(t.childNodes).reduce(((t, i, s) => {
                    var r;
                    return "br" === i.nodeName && s ? t + "\n" : null != (r = i.childNodes) && r.length ? Sa(i, e) : e ? t + i.textContent.trim().replace(/\s+/g, " ") : t + i.textContent
                }), "")
            }

            function wa(t, e, i) {
                return t && t.hasAttributeNS(e, i) ? t.getAttributeNS(e, i) : null
            }

            function ka(t) {
                return new Error(`Could not parse ttml timestamp ${t}`)
            }

            function Aa(t, e) {
                if (!t) return null;
                let i = ra(t);
                return null === i && (ma.test(t) ? i = function(t, e) {
                    const i = ma.exec(t),
                        s = (0 | i[4]) + (0 | i[5]) / e.subFrameRate;
                    return 3600 * (0 | i[1]) + 60 * (0 | i[2]) + (0 | i[3]) + s / e.frameRate
                }(t, e) : ya.test(t) && (i = function(t, e) {
                    const i = ya.exec(t),
                        s = Number(i[1]);
                    switch (i[2]) {
                        case "h":
                            return 3600 * s;
                        case "m":
                            return 60 * s;
                        case "ms":
                            return 1e3 * s;
                        case "f":
                            return s / e.frameRate;
                        case "t":
                            return s / e.tickRate
                    }
                    return s
                }(t, e))), i
            }
            class _a {
                constructor(t, e) {
                    this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = t, this.trackName = e
                }
                dispatchCue() {
                    null !== this.startTime && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null)
                }
                newCue(t, e, i) {
                    (null === this.startTime || this.startTime > t) && (this.startTime = t), this.endTime = e, this.screen = i, this.timelineController.createCaptionsTrack(this.trackName)
                }
                reset() {
                    this.cueRanges = [], this.startTime = null
                }
            }

            function La(t) {
                return t.characteristics && /transcribes-spoken-dialog/gi.test(t.characteristics) && /describes-music-and-sound/gi.test(t.characteristics) ? "captions" : "subtitles"
            }

            function Ra(t, e) {
                return !!t && t.kind === La(e) && wr(e, t)
            }
            const Ia = /\s/,
                Ca = {
                    newCue(t, e, i, s) {
                        const r = [];
                        let n, a, o, l, c;
                        const u = self.VTTCue || self.TextTrackCue;
                        for (let h = 0; h < s.rows.length; h++)
                            if (n = s.rows[h], o = !0, l = 0, c = "", !n.isEmpty()) {
                                var d;
                                for (let t = 0; t < n.chars.length; t++) Ia.test(n.chars[t].uchar) && o ? l++ : (c += n.chars[t].uchar, o = !1);
                                n.cueStartTime = e, e === i && (i += 1e-4), l >= 16 ? l-- : l++;
                                const s = ua(c.trim()),
                                    f = pa(e, i, s);
                                null != t && null != (d = t.cues) && d.getCueById(f) || (a = new u(e, i, s), a.id = f, a.line = h + 1, a.align = "left", a.position = 10 + Math.min(80, 10 * Math.floor(8 * l / 32)), r.push(a))
                            }
                        return t && r.length && (r.sort(((t, e) => "auto" === t.line || "auto" === e.line ? 0 : t.line > 8 && e.line > 8 ? e.line - t.line : t.line - e.line)), r.forEach((e => yn(t, e)))), r
                    }
                },
                Da = /(\d+)-(\d+)\/(\d+)/;
            class xa {
                constructor(t) {
                    this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = null, this.response = null, this.controller = void 0, this.context = null, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = t.fetchSetup || Pa, this.controller = new self.AbortController, this.stats = new G
                }
                destroy() {
                    this.loader = this.callbacks = this.context = this.config = this.request = null, this.abortInternal(), this.response = null, this.fetchSetup = this.controller = this.stats = null
                }
                abortInternal() {
                    this.controller && !this.stats.loading.end && (this.stats.aborted = !0, this.controller.abort())
                }
                abort() {
                    var t;
                    this.abortInternal(), null != (t = this.callbacks) && t.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response)
                }
                load(t, e, i) {
                    const r = this.stats;
                    if (r.loading.start) throw new Error("Loader can only be used once.");
                    r.loading.start = self.performance.now();
                    const n = function(t, e) {
                            const i = {
                                method: "GET",
                                mode: "cors",
                                credentials: "same-origin",
                                signal: e,
                                headers: new self.Headers(b({}, t.headers))
                            };
                            return t.rangeEnd && i.headers.set("Range", "bytes=" + t.rangeStart + "-" + String(t.rangeEnd - 1)), i
                        }(t, this.controller.signal),
                        a = "arraybuffer" === t.responseType,
                        o = a ? "byteLength" : "length",
                        {
                            maxTimeToFirstByteMs: l,
                            maxLoadTimeMs: c
                        } = e.loadPolicy;
                    this.context = t, this.config = e, this.callbacks = i, this.request = this.fetchSetup(t, n), self.clearTimeout(this.requestTimeout), e.timeout = l && s(l) ? l : c, this.requestTimeout = self.setTimeout((() => {
                        this.callbacks && (this.abortInternal(), this.callbacks.onTimeout(r, t, this.response))
                    }), e.timeout), (gr(this.request) ? this.request.then(self.fetch) : self.fetch(this.request)).then((i => {
                        var n;
                        this.response = this.loader = i;
                        const o = Math.max(self.performance.now(), r.loading.start);
                        if (self.clearTimeout(this.requestTimeout), e.timeout = c, this.requestTimeout = self.setTimeout((() => {
                                this.callbacks && (this.abortInternal(), this.callbacks.onTimeout(r, t, this.response))
                            }), c - (o - r.loading.start)), !i.ok) {
                            const {
                                status: t,
                                statusText: e
                            } = i;
                            throw new Oa(e || "fetch, bad network response", t, i)
                        }
                        r.loading.first = o, r.total = function(t) {
                            const e = t.get("Content-Range");
                            if (e) {
                                const t = function(t) {
                                    const e = Da.exec(t);
                                    if (e) return parseInt(e[2]) - parseInt(e[1]) + 1
                                }(e);
                                if (s(t)) return t
                            }
                            const i = t.get("Content-Length");
                            if (i) return parseInt(i)
                        }(i.headers) || r.total;
                        const l = null == (n = this.callbacks) ? void 0 : n.onProgress;
                        return l && s(e.highWaterMark) ? this.loadProgressively(i, r, t, e.highWaterMark, l) : a ? i.arrayBuffer() : "json" === t.responseType ? i.json() : i.text()
                    })).then((i => {
                        var n, a;
                        const l = this.response;
                        if (!l) throw new Error("loader destroyed");
                        self.clearTimeout(this.requestTimeout), r.loading.end = Math.max(self.performance.now(), r.loading.first);
                        const c = i[o];
                        c && (r.loaded = r.total = c);
                        const u = {
                                url: l.url,
                                data: i,
                                code: l.status
                            },
                            d = null == (n = this.callbacks) ? void 0 : n.onProgress;
                        d && !s(e.highWaterMark) && d(r, t, i, l), null == (a = this.callbacks) || a.onSuccess(u, r, t, l)
                    })).catch((e => {
                        var i;
                        if (self.clearTimeout(this.requestTimeout), r.aborted) return;
                        const s = e && e.code || 0,
                            n = e ? e.message : null;
                        null == (i = this.callbacks) || i.onError({
                            code: s,
                            text: n
                        }, t, e ? e.details : null, r)
                    }))
                }
                getCacheAge() {
                    let t = null;
                    if (this.response) {
                        const e = this.response.headers.get("age");
                        t = e ? parseFloat(e) : null
                    }
                    return t
                }
                getResponseHeader(t) {
                    return this.response ? this.response.headers.get(t) : null
                }
                loadProgressively(t, e, i, s = 0, r) {
                    const n = new Ki,
                        a = t.body.getReader(),
                        o = () => a.read().then((a => {
                            if (a.done) return n.dataLength && r(e, i, n.flush().buffer, t), Promise.resolve(new ArrayBuffer(0));
                            const l = a.value,
                                c = l.length;
                            return e.loaded += c, c < s || n.dataLength ? (n.push(l), n.dataLength >= s && r(e, i, n.flush().buffer, t)) : r(e, i, l.buffer, t), o()
                        })).catch((() => Promise.reject()));
                    return o()
                }
            }

            function Pa(t, e) {
                return new self.Request(t.url, e)
            }
            class Oa extends Error {
                constructor(t, e, i) {
                    super(t), this.code = void 0, this.details = void 0, this.code = e, this.details = i
                }
            }
            const Ma = /^age:\s*[\d.]+\s*$/im;
            class Na {
                constructor(t) {
                    this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = null, this.loader = null, this.stats = void 0, this.xhrSetup = t && t.xhrSetup || null, this.stats = new G, this.retryDelay = 0
                }
                destroy() {
                    this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null, this.context = null, this.xhrSetup = null
                }
                abortInternal() {
                    const t = this.loader;
                    self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), t && (t.onreadystatechange = null, t.onprogress = null, 4 !== t.readyState && (this.stats.aborted = !0, t.abort()))
                }
                abort() {
                    var t;
                    this.abortInternal(), null != (t = this.callbacks) && t.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader)
                }
                load(t, e, i) {
                    if (this.stats.loading.start) throw new Error("Loader can only be used once.");
                    this.stats.loading.start = self.performance.now(), this.context = t, this.config = e, this.callbacks = i, this.loadInternal()
                }
                loadInternal() {
                    const {
                        config: t,
                        context: e
                    } = this;
                    if (!t || !e) return;
                    const i = this.loader = new self.XMLHttpRequest,
                        s = this.stats;
                    s.loading.first = 0, s.loaded = 0, s.aborted = !1;
                    const r = this.xhrSetup;
                    r ? Promise.resolve().then((() => {
                        if (this.loader === i && !this.stats.aborted) return r(i, e.url)
                    })).catch((t => {
                        if (this.loader === i && !this.stats.aborted) return i.open("GET", e.url, !0), r(i, e.url)
                    })).then((() => {
                        this.loader !== i || this.stats.aborted || this.openAndSendXhr(i, e, t)
                    })).catch((t => {
                        var r;
                        null == (r = this.callbacks) || r.onError({
                            code: i.status,
                            text: t.message
                        }, e, i, s)
                    })) : this.openAndSendXhr(i, e, t)
                }
                openAndSendXhr(t, e, i) {
                    t.readyState || t.open("GET", e.url, !0);
                    const r = e.headers,
                        {
                            maxTimeToFirstByteMs: n,
                            maxLoadTimeMs: a
                        } = i.loadPolicy;
                    if (r)
                        for (const e in r) t.setRequestHeader(e, r[e]);
                    e.rangeEnd && t.setRequestHeader("Range", "bytes=" + e.rangeStart + "-" + (e.rangeEnd - 1)), t.onreadystatechange = this.readystatechange.bind(this), t.onprogress = this.loadprogress.bind(this), t.responseType = e.responseType, self.clearTimeout(this.requestTimeout), i.timeout = n && s(n) ? n : a, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), i.timeout), t.send()
                }
                readystatechange() {
                    const {
                        context: t,
                        loader: e,
                        stats: i
                    } = this;
                    if (!t || !e) return;
                    const s = e.readyState,
                        r = this.config;
                    if (!i.aborted && s >= 2 && (0 === i.loading.first && (i.loading.first = Math.max(self.performance.now(), i.loading.start), r.timeout !== r.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout), r.timeout = r.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), r.loadPolicy.maxLoadTimeMs - (i.loading.first - i.loading.start)))), 4 === s)) {
                        self.clearTimeout(this.requestTimeout), e.onreadystatechange = null, e.onprogress = null;
                        const s = e.status,
                            l = "text" === e.responseType ? e.responseText : null;
                        if (s >= 200 && s < 300) {
                            const r = null != l ? l : e.response;
                            if (null != r) {
                                var n, a;
                                i.loading.end = Math.max(self.performance.now(), i.loading.first);
                                const o = "arraybuffer" === e.responseType ? r.byteLength : r.length;
                                i.loaded = i.total = o, i.bwEstimate = 8e3 * i.total / (i.loading.end - i.loading.first);
                                const l = null == (n = this.callbacks) ? void 0 : n.onProgress;
                                l && l(i, t, r, e);
                                const c = {
                                    url: e.responseURL,
                                    data: r,
                                    code: s
                                };
                                return void(null == (a = this.callbacks) || a.onSuccess(c, i, t, e))
                            }
                        }
                        const c = r.loadPolicy.errorRetry;
                        var o;
                        fe(c, i.retry, !1, {
                            url: t.url,
                            data: void 0,
                            code: s
                        }) ? this.retry(c) : (R.error(`${s} while loading ${t.url}`), null == (o = this.callbacks) || o.onError({
                            code: s,
                            text: e.statusText
                        }, t, e, i))
                    }
                }
                loadtimeout() {
                    if (!this.config) return;
                    const t = this.config.loadPolicy.timeoutRetry;
                    if (fe(t, this.stats.retry, !0)) this.retry(t);
                    else {
                        var e;
                        R.warn(`timeout while loading ${null==(e=this.context)?void 0:e.url}`);
                        const t = this.callbacks;
                        t && (this.abortInternal(), t.onTimeout(this.stats, this.context, this.loader))
                    }
                }
                retry(t) {
                    const {
                        context: e,
                        stats: i
                    } = this;
                    this.retryDelay = de(t, i.retry), i.retry++, R.warn(`${status?"HTTP Status "+status:"Timeout"} while loading ${null==e?void 0:e.url}, retrying ${i.retry}/${t.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay)
                }
                loadprogress(t) {
                    const e = this.stats;
                    e.loaded = t.loaded, t.lengthComputable && (e.total = t.total)
                }
                getCacheAge() {
                    let t = null;
                    if (this.loader && Ma.test(this.loader.getAllResponseHeaders())) {
                        const e = this.loader.getResponseHeader("age");
                        t = e ? parseFloat(e) : null
                    }
                    return t
                }
                getResponseHeader(t) {
                    return this.loader && new RegExp(`^${t}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(t) : null
                }
            }
            const Fa = E(E({
                autoStartLoad: !0,
                startPosition: -1,
                defaultAudioCodec: void 0,
                debug: !1,
                capLevelOnFPSDrop: !1,
                capLevelToPlayerSize: !1,
                ignoreDevicePixelRatio: !1,
                maxDevicePixelRatio: Number.POSITIVE_INFINITY,
                preferManagedMediaSource: !0,
                initialLiveManifestSize: 1,
                maxBufferLength: 30,
                backBufferLength: 1 / 0,
                frontBufferFlushThreshold: 1 / 0,
                maxBufferSize: 6e7,
                maxFragLookUpTolerance: .25,
                maxBufferHole: .1,
                detectStallWithCurrentTimeMs: 1250,
                highBufferWatchdogPeriod: 2,
                nudgeOffset: .1,
                nudgeMaxRetry: 3,
                nudgeOnVideoHole: !0,
                liveSyncDurationCount: 3,
                liveSyncOnStallIncrease: 1,
                liveMaxLatencyDurationCount: 1 / 0,
                liveSyncDuration: void 0,
                liveMaxLatencyDuration: void 0,
                maxLiveSyncPlaybackRate: 1,
                liveDurationInfinity: !1,
                liveBackBufferLength: null,
                maxMaxBufferLength: 600,
                enableWorker: !0,
                workerPath: null,
                enableSoftwareAES: !0,
                startLevel: void 0,
                startFragPrefetch: !1,
                fpsDroppedMonitoringPeriod: 5e3,
                fpsDroppedMonitoringThreshold: .2,
                appendErrorMaxRetry: 3,
                ignorePlaylistParsingErrors: !1,
                loader: Na,
                fLoader: void 0,
                pLoader: void 0,
                xhrSetup: void 0,
                licenseXhrSetup: void 0,
                licenseResponseCallback: void 0,
                abrController: class extends S {
                    constructor(t) {
                        super("abr", t.logger), this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = -1, this.firstSelection = -1, this._nextAutoLevel = -1, this.nextAutoLevelKey = "", this.audioTracksByGroup = null, this.codecTiers = null, this.timer = -1, this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.rebufferNotice = -1, this.bwEstimator = void 0, this._abandonRulesCheck = t => {
                            var e;
                            const {
                                fragCurrent: i,
                                partCurrent: r,
                                hls: n
                            } = this, {
                                autoLevelEnabled: a,
                                media: o
                            } = n;
                            if (!i || !o) return;
                            const c = performance.now(),
                                u = r ? r.stats : i.stats,
                                d = r ? r.duration : i.duration,
                                h = c - u.loading.start,
                                f = n.minAutoLevel,
                                p = i.level,
                                g = this._nextAutoLevel;
                            if (u.aborted || u.loaded && u.loaded === u.total || p <= f) return this.clearTimer(), void(this._nextAutoLevel = -1);
                            if (!a) return;
                            const m = g > -1 && g !== p,
                                y = !!t || m;
                            if (!y && (o.paused || !o.playbackRate || !o.readyState)) return;
                            const v = n.mainForwardBufferInfo;
                            if (!y && null === v) return;
                            const b = this.bwEstimator.getEstimateTTFB(),
                                T = Math.abs(o.playbackRate);
                            if (h <= Math.max(b, d / (2 * T) * 1e3)) return;
                            const E = v ? v.len / T : 0,
                                S = u.loading.first ? u.loading.first - u.loading.start : -1,
                                w = u.loaded && S > -1,
                                k = this.getBwEstimate(),
                                A = n.levels,
                                _ = A[p],
                                L = Math.max(u.loaded, Math.round(d * (i.bitrate || _.averageBitrate) / 8));
                            let R = w ? h - S : h;
                            R < 1 && w && (R = Math.min(h, 8 * u.loaded / k));
                            const I = w ? 1e3 * u.loaded / R : 0,
                                C = b / 1e3,
                                D = I ? (L - u.loaded) / I : 8 * L / k + C;
                            if (D <= E) return;
                            const x = I ? 8 * I : k,
                                P = !0 === (null == (e = (null == t ? void 0 : t.details) || this.hls.latestLevelDetails) ? void 0 : e.live),
                                O = this.hls.config.abrBandWidthUpFactor;
                            let M, N = Number.POSITIVE_INFINITY;
                            for (M = p - 1; M > f; M--) {
                                const t = A[M].maxBitrate,
                                    e = !A[M].details || P;
                                if (N = this.getTimeToLoadFrag(C, x, d * t, e), N < Math.min(E, d + C)) break
                            }
                            if (N >= D) return;
                            if (N > 10 * d) return;
                            w ? this.bwEstimator.sample(h - Math.min(b, S), u.loaded) : this.bwEstimator.sampleTTFB(h);
                            const F = A[M].maxBitrate;
                            this.getBwEstimate() * O > F && this.resetEstimator(F);
                            const $ = this.findBestLevel(F, f, M, 0, E, 1, 1);
                            $ > -1 && (M = $), this.warn(`Fragment ${i.sn}${r?" part "+r.index:""} of level ${p} is loading too slowly;\n      Fragment duration: ${i.duration.toFixed(3)}\n      Time to underbuffer: ${E.toFixed(3)} s\n      Estimated load time for current fragment: ${D.toFixed(3)} s\n      Estimated load time for down switch fragment: ${N.toFixed(3)} s\n      TTFB estimate: ${0|S} ms\n      Current BW estimate: ${s(k)?0|k:"Unknown"} bps\n      New BW estimate: ${0|this.getBwEstimate()} bps\n      Switching to level ${M} @ ${0|F} bps`), n.nextLoadLevel = n.nextAutoLevel = M, this.clearTimer();
                            const U = () => {
                                if (this.clearTimer(), this.fragCurrent === i && this.hls.loadLevel === M && M > 0) {
                                    const t = this.getStarvationDelay();
                                    if (this.warn(`Aborting inflight request ${M>0?"and switching down":""}\n      Fragment duration: ${i.duration.toFixed(3)} s\n      Time to underbuffer: ${t.toFixed(3)} s`), i.abortRequests(), this.fragCurrent = this.partCurrent = null, M > f) {
                                        let e = this.findBestLevel(this.hls.levels[f].bitrate, f, M, 0, t, 1, 1); - 1 === e && (e = f), this.hls.nextLoadLevel = this.hls.nextAutoLevel = e, this.resetEstimator(this.hls.levels[e].bitrate)
                                    }
                                }
                            };
                            m || D > 2 * N ? U() : this.timer = self.setInterval(U, 1e3 * N), n.trigger(l.FRAG_LOAD_EMERGENCY_ABORTED, {
                                frag: i,
                                part: r,
                                stats: u
                            })
                        }, this.hls = t, this.bwEstimator = this.initEstimator(), this.registerListeners()
                    }
                    resetEstimator(t) {
                        t && (this.log(`setting initial bwe to ${t}`), this.hls.config.abrEwmaDefaultEstimate = t), this.firstSelection = -1, this.bwEstimator = this.initEstimator()
                    }
                    initEstimator() {
                        const t = this.hls.config;
                        return new y(t.abrEwmaSlowVoD, t.abrEwmaFastVoD, t.abrEwmaDefaultEstimate)
                    }
                    registerListeners() {
                        const {
                            hls: t
                        } = this;
                        t.on(l.MANIFEST_LOADING, this.onManifestLoading, this), t.on(l.FRAG_LOADING, this.onFragLoading, this), t.on(l.FRAG_LOADED, this.onFragLoaded, this), t.on(l.FRAG_BUFFERED, this.onFragBuffered, this), t.on(l.LEVEL_SWITCHING, this.onLevelSwitching, this), t.on(l.LEVEL_LOADED, this.onLevelLoaded, this), t.on(l.LEVELS_UPDATED, this.onLevelsUpdated, this), t.on(l.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), t.on(l.ERROR, this.onError, this)
                    }
                    unregisterListeners() {
                        const {
                            hls: t
                        } = this;
                        t && (t.off(l.MANIFEST_LOADING, this.onManifestLoading, this), t.off(l.FRAG_LOADING, this.onFragLoading, this), t.off(l.FRAG_LOADED, this.onFragLoaded, this), t.off(l.FRAG_BUFFERED, this.onFragBuffered, this), t.off(l.LEVEL_SWITCHING, this.onLevelSwitching, this), t.off(l.LEVEL_LOADED, this.onLevelLoaded, this), t.off(l.LEVELS_UPDATED, this.onLevelsUpdated, this), t.off(l.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), t.off(l.ERROR, this.onError, this))
                    }
                    destroy() {
                        this.unregisterListeners(), this.clearTimer(), this.hls = this._abandonRulesCheck = null, this.fragCurrent = this.partCurrent = null
                    }
                    onManifestLoading(t, e) {
                        this.lastLoadedFragLevel = -1, this.firstSelection = -1, this.lastLevelLoadSec = 0, this.fragCurrent = this.partCurrent = null, this.onLevelsUpdated(), this.clearTimer()
                    }
                    onLevelsUpdated() {
                        this.lastLoadedFragLevel > -1 && this.fragCurrent && (this.lastLoadedFragLevel = this.fragCurrent.level), this._nextAutoLevel = -1, this.onMaxAutoLevelUpdated(), this.codecTiers = null, this.audioTracksByGroup = null
                    }
                    onMaxAutoLevelUpdated() {
                        this.firstSelection = -1, this.nextAutoLevelKey = ""
                    }
                    onFragLoading(t, e) {
                        const i = e.frag;
                        var s;
                        this.ignoreFragment(i) || (i.bitrateTest || (this.fragCurrent = i, this.partCurrent = null != (s = e.part) ? s : null), this.clearTimer(), this.timer = self.setInterval(this._abandonRulesCheck, 100))
                    }
                    onLevelSwitching(t, e) {
                        this.clearTimer()
                    }
                    onError(t, e) {
                        if (!e.fatal) switch (e.details) {
                            case o.BUFFER_ADD_CODEC_ERROR:
                            case o.BUFFER_APPEND_ERROR:
                                this.lastLoadedFragLevel = -1, this.firstSelection = -1;
                                break;
                            case o.FRAG_LOAD_TIMEOUT:
                                {
                                    const t = e.frag,
                                        {
                                            fragCurrent: i,
                                            partCurrent: s
                                        } = this;
                                    if (t && i && t.sn === i.sn && t.level === i.level) {
                                        const e = performance.now(),
                                            i = s ? s.stats : t.stats,
                                            r = e - i.loading.start,
                                            n = i.loading.first ? i.loading.first - i.loading.start : -1;
                                        if (i.loaded && n > -1) {
                                            const t = this.bwEstimator.getEstimateTTFB();
                                            this.bwEstimator.sample(r - Math.min(t, n), i.loaded)
                                        } else this.bwEstimator.sampleTTFB(r)
                                    }
                                    break
                                }
                        }
                    }
                    getTimeToLoadFrag(t, e, i, s) {
                        return t + i / e + (s ? t + this.lastLevelLoadSec : 0)
                    }
                    onLevelLoaded(t, e) {
                        const i = this.hls.config,
                            {
                                loading: r
                            } = e.stats,
                            n = r.end - r.first;
                        s(n) && (this.lastLevelLoadSec = n / 1e3), e.details.live ? this.bwEstimator.update(i.abrEwmaSlowLive, i.abrEwmaFastLive) : this.bwEstimator.update(i.abrEwmaSlowVoD, i.abrEwmaFastVoD), this.timer > -1 && this._abandonRulesCheck(e.levelInfo)
                    }
                    onFragLoaded(t, {
                        frag: e,
                        part: i
                    }) {
                        const s = i ? i.stats : e.stats;
                        if (e.type === f && this.bwEstimator.sampleTTFB(s.loading.first - s.loading.start), !this.ignoreFragment(e)) {
                            if (this.clearTimer(), e.level === this._nextAutoLevel && (this._nextAutoLevel = -1), this.firstSelection = -1, this.hls.config.abrMaxWithRealBitrate) {
                                const t = i ? i.duration : e.duration,
                                    r = this.hls.levels[e.level],
                                    n = (r.loaded ? r.loaded.bytes : 0) + s.loaded,
                                    a = (r.loaded ? r.loaded.duration : 0) + t;
                                r.loaded = {
                                    bytes: n,
                                    duration: a
                                }, r.realBitrate = Math.round(8 * n / a)
                            }
                            if (e.bitrateTest) {
                                const t = {
                                    stats: s,
                                    frag: e,
                                    part: i,
                                    id: e.type
                                };
                                this.onFragBuffered(l.FRAG_BUFFERED, t), e.bitrateTest = !1
                            } else this.lastLoadedFragLevel = e.level
                        }
                    }
                    onFragBuffered(t, e) {
                        const {
                            frag: i,
                            part: s
                        } = e, r = null != s && s.stats.loaded ? s.stats : i.stats;
                        if (r.aborted) return;
                        if (this.ignoreFragment(i)) return;
                        const n = r.parsing.end - r.loading.start - Math.min(r.loading.first - r.loading.start, this.bwEstimator.getEstimateTTFB());
                        this.bwEstimator.sample(n, r.loaded), r.bwEstimate = this.getBwEstimate(), i.bitrateTest ? this.bitrateTestDelay = n / 1e3 : this.bitrateTestDelay = 0
                    }
                    ignoreFragment(t) {
                        return t.type !== f || "initSegment" === t.sn
                    }
                    clearTimer() {
                        this.timer > -1 && (self.clearInterval(this.timer), this.timer = -1)
                    }
                    get firstAutoLevel() {
                        const {
                            maxAutoLevel: t,
                            minAutoLevel: e
                        } = this.hls, i = this.getBwEstimate(), s = this.hls.config.maxStarvationDelay, r = this.findBestLevel(i, e, t, 0, s, 1, 1);
                        if (r > -1) return r;
                        const n = this.hls.firstLevel,
                            a = Math.min(Math.max(n, e), t);
                        return this.warn(`Could not find best starting auto level. Defaulting to first in playlist ${n} clamped to ${a}`), a
                    }
                    get forcedAutoLevel() {
                        return this.nextAutoLevelKey ? -1 : this._nextAutoLevel
                    }
                    get nextAutoLevel() {
                        const t = this.forcedAutoLevel,
                            e = this.bwEstimator.canEstimate(),
                            i = this.lastLoadedFragLevel > -1;
                        if (!(-1 === t || e && i && this.nextAutoLevelKey !== this.getAutoLevelKey())) return t;
                        const s = e && i ? this.getNextABRAutoLevel() : this.firstAutoLevel;
                        if (-1 !== t) {
                            const e = this.hls.levels;
                            if (e.length > Math.max(t, s) && e[t].loadError <= e[s].loadError) return t
                        }
                        return this._nextAutoLevel = s, this.nextAutoLevelKey = this.getAutoLevelKey(), s
                    }
                    getAutoLevelKey() {
                        return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`
                    }
                    getNextABRAutoLevel() {
                        const {
                            fragCurrent: t,
                            partCurrent: e,
                            hls: i
                        } = this;
                        if (i.levels.length <= 1) return i.loadLevel;
                        const {
                            maxAutoLevel: s,
                            config: r,
                            minAutoLevel: n
                        } = i, a = e ? e.duration : t ? t.duration : 0, o = this.getBwEstimate(), l = this.getStarvationDelay();
                        let c = r.abrBandWidthFactor,
                            u = r.abrBandWidthUpFactor;
                        if (l) {
                            const t = this.findBestLevel(o, n, s, l, 0, c, u);
                            if (t >= 0) return this.rebufferNotice = -1, t
                        }
                        let d = a ? Math.min(a, r.maxStarvationDelay) : r.maxStarvationDelay;
                        if (!l) {
                            const t = this.bitrateTestDelay;
                            t && (d = (a ? Math.min(a, r.maxLoadingDelay) : r.maxLoadingDelay) - t, this.info(`bitrate test took ${Math.round(1e3*t)}ms, set first fragment max fetchDuration to ${Math.round(1e3*d)} ms`), c = u = 1)
                        }
                        const h = this.findBestLevel(o, n, s, l, d, c, u);
                        if (this.rebufferNotice !== h && (this.rebufferNotice = h, this.info(`${l?"rebuffering expected":"buffer is empty"}, optimal quality level ${h}`)), h > -1) return h;
                        const f = i.levels[n],
                            p = i.loadLevelObj;
                        return p && (null == f ? void 0 : f.bitrate) < p.bitrate ? n : i.loadLevel
                    }
                    getStarvationDelay() {
                        const t = this.hls,
                            e = t.media;
                        if (!e) return 1 / 0;
                        const i = e && 0 !== e.playbackRate ? Math.abs(e.playbackRate) : 1,
                            s = t.mainForwardBufferInfo;
                        return (s ? s.len : 0) / i
                    }
                    getBwEstimate() {
                        return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate
                    }
                    findBestLevel(t, e, i, r, n, a, o) {
                        var l;
                        const c = r + n,
                            u = this.lastLoadedFragLevel,
                            d = -1 === u ? this.hls.firstLevel : u,
                            {
                                fragCurrent: h,
                                partCurrent: f
                            } = this,
                            {
                                levels: p,
                                allAudioTracks: g,
                                loadLevel: m,
                                config: y
                            } = this.hls;
                        if (1 === p.length) return 0;
                        const v = p[d],
                            b = !(null == (l = this.hls.latestLevelDetails) || !l.live),
                            T = -1 === m || -1 === u;
                        let E, S = "SDR",
                            w = (null == v ? void 0 : v.frameRate) || 0;
                        const {
                            audioPreference: k,
                            videoPreference: A
                        } = y, _ = this.audioTracksByGroup || (this.audioTracksByGroup = Qt(g));
                        let L = -1;
                        if (T) {
                            if (-1 !== this.firstSelection) return this.firstSelection;
                            const r = this.codecTiers || (this.codecTiers = function(t, e, i, s) {
                                    return t.slice(i, s + 1).reduce(((t, i, s) => {
                                        if (!i.codecSet) return t;
                                        const r = i.audioGroups;
                                        let n = t[i.codecSet];
                                        n || (t[i.codecSet] = n = {
                                            minBitrate: 1 / 0,
                                            minHeight: 1 / 0,
                                            minFramerate: 1 / 0,
                                            minIndex: s,
                                            maxScore: 0,
                                            videoRanges: {
                                                SDR: 0
                                            },
                                            channels: {
                                                2: 0
                                            },
                                            hasDefaultAudio: !r,
                                            fragmentError: 0
                                        }), n.minBitrate = Math.min(n.minBitrate, i.bitrate);
                                        const a = Math.min(i.height, i.width);
                                        return n.minHeight = Math.min(n.minHeight, a), n.minFramerate = Math.min(n.minFramerate, i.frameRate), n.minIndex = Math.min(n.minIndex, s), n.maxScore = Math.max(n.maxScore, i.score), n.fragmentError += i.fragmentError, n.videoRanges[i.videoRange] = (n.videoRanges[i.videoRange] || 0) + 1, r && r.forEach((t => {
                                            if (!t) return;
                                            const i = e.groups[t];
                                            i && (n.hasDefaultAudio = n.hasDefaultAudio || e.hasDefaultAudio ? i.hasDefault : i.hasAutoSelect || !e.hasDefaultAudio && !e.hasAutoSelectAudio, Object.keys(i.channels).forEach((t => {
                                                n.channels[t] = (n.channels[t] || 0) + i.channels[t]
                                            })))
                                        })), t
                                    }), {})
                                }(p, _, e, i)),
                                n = function(t, e, i, r, n) {
                                    const a = Object.keys(t),
                                        o = null == r ? void 0 : r.channels,
                                        l = null == r ? void 0 : r.audioCodec,
                                        c = null == n ? void 0 : n.videoCodec,
                                        u = o && 2 === parseInt(o);
                                    let d = !1,
                                        h = !1,
                                        f = 1 / 0,
                                        p = 1 / 0,
                                        g = 1 / 0,
                                        m = 1 / 0,
                                        y = 0,
                                        v = [];
                                    const {
                                        preferHDR: b,
                                        allowedVideoRanges: T
                                    } = function(t, e) {
                                        let i = !1,
                                            s = [];
                                        if (t && (i = "SDR" !== t, s = [t]), e) {
                                            s = e.allowedVideoRanges || Ht.slice(0);
                                            const t = "SDR" !== s.join("") && !e.videoCodec;
                                            i = void 0 !== e.preferHDR ? e.preferHDR : t && function() {
                                                if ("function" == typeof matchMedia) {
                                                    const t = matchMedia("(dynamic-range: high)"),
                                                        e = matchMedia("bad query");
                                                    if (t.media !== e.media) return !0 === t.matches
                                                }
                                                return !1
                                            }(), i || (s = ["SDR"])
                                        }
                                        return {
                                            preferHDR: i,
                                            allowedVideoRanges: s
                                        }
                                    }(e, n);
                                    for (let e = a.length; e--;) {
                                        const i = t[a[e]];
                                        d || (d = i.channels[2] > 0), f = Math.min(f, i.minHeight), p = Math.min(p, i.minFramerate), g = Math.min(g, i.minBitrate), T.filter((t => i.videoRanges[t] > 0)).length > 0 && (h = !0)
                                    }
                                    f = s(f) ? f : 0, p = s(p) ? p : 0;
                                    const E = Math.max(1080, f),
                                        S = Math.max(30, p);
                                    g = s(g) ? g : i, i = Math.max(g, i), h || (e = void 0);
                                    const w = a.length > 1;
                                    return {
                                        codecSet: a.reduce(((e, s) => {
                                            const r = t[s];
                                            if (s === e) return e;
                                            if (v = h ? T.filter((t => r.videoRanges[t] > 0)) : [], w) {
                                                if (r.minBitrate > i) return Xt(s, `min bitrate of ${r.minBitrate} > current estimate of ${i}`), e;
                                                if (!r.hasDefaultAudio) return Xt(s, "no renditions with default or auto-select sound found"), e;
                                                if (l && s.indexOf(l.substring(0, 4)) % 5 != 0) return Xt(s, `audio codec preference "${l}" not found`), e;
                                                if (o && !u) {
                                                    if (!r.channels[o]) return Xt(s, `no renditions with ${o} channel sound found (channels options: ${Object.keys(r.channels)})`), e
                                                } else if ((!l || u) && d && 0 === r.channels[2]) return Xt(s, "no renditions with stereo sound found"), e;
                                                if (r.minHeight > E) return Xt(s, `min resolution of ${r.minHeight} > maximum of ${E}`), e;
                                                if (r.minFramerate > S) return Xt(s, `min framerate of ${r.minFramerate} > maximum of ${S}`), e;
                                                if (!v.some((t => r.videoRanges[t] > 0))) return Xt(s, `no variants with VIDEO-RANGE of ${Yt(v)} found`), e;
                                                if (c && s.indexOf(c.substring(0, 4)) % 5 != 0) return Xt(s, `video codec preference "${c}" not found`), e;
                                                if (r.maxScore < y) return Xt(s, `max score of ${r.maxScore} < selected max of ${y}`), e
                                            }
                                            return e && (Ct(s) >= Ct(e) || r.fragmentError > t[e].fragmentError) ? e : (m = r.minIndex, y = r.maxScore, s)
                                        }), void 0),
                                        videoRanges: v,
                                        preferHDR: b,
                                        minFramerate: p,
                                        minBitrate: g,
                                        minIndex: m
                                    }
                                }(r, S, t, k, A),
                                {
                                    codecSet: a,
                                    videoRanges: o,
                                    minFramerate: l,
                                    minBitrate: c,
                                    minIndex: u,
                                    preferHDR: d
                                } = n;
                            L = u, E = a, S = d ? o[o.length - 1] : o[0], w = l, t = Math.max(t, c), this.log(`picked start tier ${Yt(n)}`)
                        } else E = null == v ? void 0 : v.codecSet, S = null == v ? void 0 : v.videoRange;
                        const R = f ? f.duration : h ? h.duration : 0,
                            I = this.bwEstimator.getEstimateTTFB() / 1e3,
                            C = [];
                        for (let l = i; l >= e; l--) {
                            var D;
                            const e = p[l],
                                h = l > d;
                            if (!e) continue;
                            if (y.useMediaCapabilities && !e.supportedResult && !e.supportedPromise) {
                                const i = navigator.mediaCapabilities;
                                "function" == typeof(null == i ? void 0 : i.decodingInfo) && (jt(e, _, S, w, t, k) || vt(e.videoCodec)) ? (e.supportedPromise = Gt(e, _, i), e.supportedPromise.then((t => {
                                    if (!this.hls) return;
                                    e.supportedResult = t;
                                    const i = this.hls.levels,
                                        s = i.indexOf(e);
                                    t.error ? this.warn(`MediaCapabilities decodingInfo error: "${t.error}" for level ${s} ${Yt(t)}`) : t.supported || (this.warn(`Unsupported MediaCapabilities decodingInfo result for level ${s} ${Yt(t)}`), s > -1 && i.length > 1 && (this.log(`Removing unsupported level ${s}`), this.hls.removeLevel(s), -1 === this.hls.loadLevel && (this.hls.nextLoadLevel = 0)))
                                }))) : e.supportedResult = $t
                            }
                            if ((E && e.codecSet !== E || S && e.videoRange !== S || h && w > e.frameRate || !h && w > 0 && w < e.frameRate || e.supportedResult && (null == (D = e.supportedResult.decodingInfoResults) || !D[0].smooth)) && (!T || l !== L)) {
                                C.push(l);
                                continue
                            }
                            const g = e.details,
                                v = (f ? null == g ? void 0 : g.partTarget : null == g ? void 0 : g.averagetargetduration) || R;
                            let A;
                            A = h ? o * t : a * t;
                            const x = R && r >= 2 * R && 0 === n ? e.averageBitrate : e.maxBitrate,
                                P = this.getTimeToLoadFrag(I, A, x * v, void 0 === g);
                            if (A >= x && (l === u || 0 === e.loadError && 0 === e.fragmentError) && (P <= I || !s(P) || b && !this.bitrateTestDelay || P < c)) {
                                const t = this.forcedAutoLevel;
                                return l === m || -1 !== t && t === m || (C.length && this.trace(`Skipped level(s) ${C.join(",")} of ${i} max with CODECS and VIDEO-RANGE:"${p[C[0]].codecs}" ${p[C[0]].videoRange}; not compatible with "${E}" ${S}`), this.info(`switch candidate:${d}->${l} adjustedbw(${Math.round(A)})-bitrate=${Math.round(A-x)} ttfb:${I.toFixed(1)} avgDuration:${v.toFixed(1)} maxFetchDuration:${c.toFixed(1)} fetchDuration:${P.toFixed(1)} firstSelection:${T} codecSet:${e.codecSet} videoRange:${e.videoRange} hls.loadLevel:${m}`)), T && (this.firstSelection = l), l
                            }
                        }
                        return -1
                    }
                    set nextAutoLevel(t) {
                        const e = this.deriveNextAutoLevel(t);
                        this._nextAutoLevel !== e && (this.nextAutoLevelKey = "", this._nextAutoLevel = e)
                    }
                    deriveNextAutoLevel(t) {
                        const {
                            maxAutoLevel: e,
                            minAutoLevel: i
                        } = this.hls;
                        return Math.min(Math.max(t, i), e)
                    }
                },
                bufferController: class extends S {
                    constructor(t, e) {
                        var i;
                        super("buffer-controller", t.logger), this.hls = void 0, this.fragmentTracker = void 0, this.details = null, this._objectUrl = null, this.operationQueue = null, this.bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.blockedAudioAppend = null, this.lastVideoAppendEnd = 0, this.appendSource = void 0, this.transferData = void 0, this.overrides = void 0, this.appendErrors = {
                            audio: 0,
                            video: 0,
                            audiovideo: 0
                        }, this.tracks = {}, this.sourceBuffers = [
                            [null, null],
                            [null, null]
                        ], this._onEndStreaming = t => {
                            var e;
                            this.hls && "open" === (null == (e = this.mediaSource) ? void 0 : e.readyState) && this.hls.pauseBuffering()
                        }, this._onStartStreaming = t => {
                            this.hls && this.hls.resumeBuffering()
                        }, this._onMediaSourceOpen = t => {
                            const {
                                media: e,
                                mediaSource: i
                            } = this;
                            t && this.log("Media source opened"), e && i && (i.removeEventListener("sourceopen", this._onMediaSourceOpen), e.removeEventListener("emptied", this._onMediaEmptied), this.updateDuration(), this.hls.trigger(l.MEDIA_ATTACHED, {
                                media: e,
                                mediaSource: i
                            }), null !== this.mediaSource && this.checkPendingTracks())
                        }, this._onMediaSourceClose = () => {
                            this.log("Media source closed")
                        }, this._onMediaSourceEnded = () => {
                            this.log("Media source ended")
                        }, this._onMediaEmptied = () => {
                            const {
                                mediaSrc: t,
                                _objectUrl: e
                            } = this;
                            t !== e && this.error(`Media element src was set while attaching MediaSource (${e} > ${t})`)
                        }, this.hls = t, this.fragmentTracker = e, this.appendSource = (i = I(t.config.preferManagedMediaSource), "undefined" != typeof self && i === self.ManagedMediaSource), this.initTracks(), this.registerListeners()
                    }
                    hasSourceTypes() {
                        return Object.keys(this.tracks).length > 0
                    }
                    destroy() {
                        this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = this.blockedAudioAppend = null, this.transferData = this.overrides = void 0, this.operationQueue && (this.operationQueue.destroy(), this.operationQueue = null), this.hls = this.fragmentTracker = null, this._onMediaSourceOpen = this._onMediaSourceClose = null, this._onMediaSourceEnded = null, this._onStartStreaming = this._onEndStreaming = null
                    }
                    registerListeners() {
                        const {
                            hls: t
                        } = this;
                        t.on(l.MEDIA_ATTACHING, this.onMediaAttaching, this), t.on(l.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(l.MANIFEST_LOADING, this.onManifestLoading, this), t.on(l.MANIFEST_PARSED, this.onManifestParsed, this), t.on(l.BUFFER_RESET, this.onBufferReset, this), t.on(l.BUFFER_APPENDING, this.onBufferAppending, this), t.on(l.BUFFER_CODECS, this.onBufferCodecs, this), t.on(l.BUFFER_EOS, this.onBufferEos, this), t.on(l.BUFFER_FLUSHING, this.onBufferFlushing, this), t.on(l.LEVEL_UPDATED, this.onLevelUpdated, this), t.on(l.FRAG_PARSED, this.onFragParsed, this), t.on(l.FRAG_CHANGED, this.onFragChanged, this), t.on(l.ERROR, this.onError, this)
                    }
                    unregisterListeners() {
                        const {
                            hls: t
                        } = this;
                        t.off(l.MEDIA_ATTACHING, this.onMediaAttaching, this), t.off(l.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(l.MANIFEST_LOADING, this.onManifestLoading, this), t.off(l.MANIFEST_PARSED, this.onManifestParsed, this), t.off(l.BUFFER_RESET, this.onBufferReset, this), t.off(l.BUFFER_APPENDING, this.onBufferAppending, this), t.off(l.BUFFER_CODECS, this.onBufferCodecs, this), t.off(l.BUFFER_EOS, this.onBufferEos, this), t.off(l.BUFFER_FLUSHING, this.onBufferFlushing, this), t.off(l.LEVEL_UPDATED, this.onLevelUpdated, this), t.off(l.FRAG_PARSED, this.onFragParsed, this), t.off(l.FRAG_CHANGED, this.onFragChanged, this), t.off(l.ERROR, this.onError, this)
                    }
                    transferMedia() {
                        const {
                            media: t,
                            mediaSource: e
                        } = this;
                        if (!t) return null;
                        const i = {};
                        if (this.operationQueue) {
                            const t = this.isUpdating();
                            t || this.operationQueue.removeBlockers();
                            const e = this.isQueued();
                            (t || e) && this.warn(`Transfering MediaSource with${e?" operations in queue":""}${t?" updating SourceBuffer(s)":""} ${this.operationQueue}`), this.operationQueue.destroy()
                        }
                        const s = this.transferData;
                        return !this.sourceBufferCount && s && s.mediaSource === e ? b(i, s.tracks) : this.sourceBuffers.forEach((t => {
                            const [e] = t;
                            e && (i[e] = b({}, this.tracks[e]), this.removeBuffer(e)), t[0] = t[1] = null
                        })), {
                            media: t,
                            mediaSource: e,
                            tracks: i
                        }
                    }
                    initTracks() {
                        this.sourceBuffers = [
                            [null, null],
                            [null, null]
                        ], this.tracks = {}, this.resetQueue(), this.resetAppendErrors(), this.lastMpegAudioChunk = this.blockedAudioAppend = null, this.lastVideoAppendEnd = 0
                    }
                    onManifestLoading() {
                        this.bufferCodecEventsTotal = 0, this.details = null
                    }
                    onManifestParsed(t, e) {
                        var i;
                        let s = 2;
                        (e.audio && !e.video || !e.altAudio) && (s = 1), this.bufferCodecEventsTotal = s, this.log(`${s} bufferCodec event(s) expected.`), null != (i = this.transferData) && i.mediaSource && this.sourceBufferCount && s && this.bufferCreated()
                    }
                    onMediaAttaching(t, e) {
                        const i = this.media = e.media,
                            s = I(this.appendSource);
                        if (this.transferData = this.overrides = void 0, i && s) {
                            const t = !!e.mediaSource;
                            (t || e.overrides) && (this.transferData = e, this.overrides = e.overrides);
                            const r = this.mediaSource = e.mediaSource || new s;
                            if (this.assignMediaSource(r), t) this._objectUrl = i.src, this.attachTransferred();
                            else {
                                const t = this._objectUrl = self.URL.createObjectURL(r);
                                if (this.appendSource) try {
                                    i.removeAttribute("src");
                                    const e = self.ManagedMediaSource;
                                    i.disableRemotePlayback = i.disableRemotePlayback || e && r instanceof e, Rr(i),
                                        function(t, e) {
                                            const i = self.document.createElement("source");
                                            i.type = "video/mp4", i.src = e, t.appendChild(i)
                                        }(i, t), i.load()
                                } catch (e) {
                                    i.src = t
                                } else i.src = t
                            }
                            i.addEventListener("emptied", this._onMediaEmptied)
                        }
                    }
                    assignMediaSource(t) {
                        var e, i;
                        this.log(`${(null==(e=this.transferData)?void 0:e.mediaSource)===t?"transferred":"created"} media source: ${null==(i=t.constructor)?void 0:i.name}`), t.addEventListener("sourceopen", this._onMediaSourceOpen), t.addEventListener("sourceended", this._onMediaSourceEnded), t.addEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (t.addEventListener("startstreaming", this._onStartStreaming), t.addEventListener("endstreaming", this._onEndStreaming))
                    }
                    attachTransferred() {
                        const t = this.media,
                            e = this.transferData;
                        if (!e || !t) return;
                        const i = this.tracks,
                            s = e.tracks,
                            r = s ? Object.keys(s) : null,
                            n = r ? r.length : 0,
                            a = () => {
                                this.media && this.mediaSourceOpenOrEnded && this._onMediaSourceOpen()
                            };
                        if (s && r && n) {
                            if (!this.tracksReady) return this.hls.config.startFragPrefetch = !0, void this.log("attachTransferred: waiting for SourceBuffer track info");
                            if (this.log(`attachTransferred: (bufferCodecEventsTotal ${this.bufferCodecEventsTotal})\nrequired tracks: ${Yt(i,((t,e)=>"initSegment"===t?void 0:e))};\ntransfer tracks: ${Yt(s,((t,e)=>"initSegment"===t?void 0:e))}}`), !C(s, i)) {
                                e.mediaSource = null, e.tracks = void 0;
                                const r = t.currentTime,
                                    n = this.details,
                                    a = Math.max(r, (null == n ? void 0 : n.fragments[0].start) || 0);
                                return a - r > 1 ? void this.log(`attachTransferred: waiting for playback to reach new tracks start time ${r} -> ${a}`) : (this.warn(`attachTransferred: resetting MediaSource for incompatible tracks ("${Object.keys(s)}"->"${Object.keys(i)}") start time: ${a} currentTime: ${r}`), this.onMediaDetaching(l.MEDIA_DETACHING, {}), this.onMediaAttaching(l.MEDIA_ATTACHING, e), void(t.currentTime = a))
                            }
                            this.transferData = void 0, r.forEach((t => {
                                const e = t,
                                    i = s[e];
                                if (i) {
                                    const t = i.buffer;
                                    if (t) {
                                        const s = this.fragmentTracker,
                                            r = i.id;
                                        if (s.hasFragments(r) || s.hasParts(r)) {
                                            const i = Oe.getBuffered(t);
                                            s.detectEvictedFragments(e, i, r, null, !0)
                                        }
                                        const n = Ir(e),
                                            a = [e, t];
                                        this.sourceBuffers[n] = a, t.updating && this.operationQueue && this.operationQueue.prependBlocker(e), this.trackSourceBuffer(e, i)
                                    }
                                }
                            })), a(), this.bufferCreated()
                        } else this.log("attachTransferred: MediaSource w/o SourceBuffers"), a()
                    }
                    get mediaSourceOpenOrEnded() {
                        var t;
                        const e = null == (t = this.mediaSource) ? void 0 : t.readyState;
                        return "open" === e || "ended" === e
                    }
                    onMediaDetaching(t, e) {
                        const i = !!e.transferMedia;
                        this.transferData = this.overrides = void 0;
                        const {
                            media: s,
                            mediaSource: r,
                            _objectUrl: n
                        } = this;
                        if (r) {
                            if (this.log("media source " + (i ? "transferring" : "detaching")), i) this.sourceBuffers.forEach((([t]) => {
                                t && this.removeBuffer(t)
                            })), this.resetQueue();
                            else {
                                if (this.mediaSourceOpenOrEnded) {
                                    const t = "open" === r.readyState;
                                    try {
                                        const e = r.sourceBuffers;
                                        for (let i = e.length; i--;) t && e[i].abort(), r.removeSourceBuffer(e[i]);
                                        t && r.endOfStream()
                                    } catch (t) {
                                        this.warn(`onMediaDetaching: ${t.message} while calling endOfStream`)
                                    }
                                }
                                this.sourceBufferCount && this.onBufferReset()
                            }
                            r.removeEventListener("sourceopen", this._onMediaSourceOpen), r.removeEventListener("sourceended", this._onMediaSourceEnded), r.removeEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (r.removeEventListener("startstreaming", this._onStartStreaming), r.removeEventListener("endstreaming", this._onEndStreaming)), this.mediaSource = null, this._objectUrl = null
                        }
                        s && (s.removeEventListener("emptied", this._onMediaEmptied), i || (n && self.URL.revokeObjectURL(n), this.mediaSrc === n ? (s.removeAttribute("src"), this.appendSource && Rr(s), s.load()) : this.warn("media|source.src was changed by a third party - skip cleanup")), this.media = null), this.hls.trigger(l.MEDIA_DETACHED, e)
                    }
                    onBufferReset() {
                        this.sourceBuffers.forEach((([t]) => {
                            t && this.resetBuffer(t)
                        })), this.initTracks()
                    }
                    resetBuffer(t) {
                        var e;
                        const i = null == (e = this.tracks[t]) ? void 0 : e.buffer;
                        if (this.removeBuffer(t), i) try {
                            var s;
                            null != (s = this.mediaSource) && s.sourceBuffers.length && this.mediaSource.removeSourceBuffer(i)
                        } catch (e) {
                            this.warn(`onBufferReset ${t}`, e)
                        }
                        delete this.tracks[t]
                    }
                    removeBuffer(t) {
                        this.removeBufferListeners(t), this.sourceBuffers[Ir(t)] = [null, null];
                        const e = this.tracks[t];
                        e && (e.buffer = void 0)
                    }
                    resetQueue() {
                        this.operationQueue && this.operationQueue.destroy(), this.operationQueue = new kr(this.tracks)
                    }
                    onBufferCodecs(t, e) {
                        const i = this.tracks,
                            s = Object.keys(e);
                        this.log(`BUFFER_CODECS: "${s}" (current SB count ${this.sourceBufferCount})`);
                        const r = "audiovideo" in e && (i.audio || i.video) || i.audiovideo && ("audio" in e || "video" in e),
                            n = !r && this.sourceBufferCount && this.media && s.some((t => !i[t]));
                        r || n ? this.warn(`Unsupported transition between "${Object.keys(i)}" and "${s}" SourceBuffers`) : (s.forEach((t => {
                            var s, r, n;
                            const a = e[t],
                                {
                                    id: o,
                                    codec: l,
                                    levelCodec: c,
                                    container: u,
                                    metadata: d,
                                    supplemental: h
                                } = a;
                            let f = i[t];
                            const p = null == (s = this.transferData) || null == (r = s.tracks) ? void 0 : r[t],
                                g = null != p && p.buffer ? p : f,
                                m = (null == g ? void 0 : g.pendingCodec) || (null == g ? void 0 : g.codec),
                                y = null == g ? void 0 : g.levelCodec;
                            f || (f = i[t] = {
                                buffer: void 0,
                                listeners: [],
                                codec: l,
                                supplemental: h,
                                container: u,
                                levelCodec: c,
                                metadata: d,
                                id: o
                            });
                            const v = Ot(m, y),
                                b = null == v ? void 0 : v.replace(Ar, "$1");
                            let T = Ot(l, c);
                            const E = null == (n = T) ? void 0 : n.replace(Ar, "$1");
                            T && v && b !== E && ("audio" === t.slice(0, 5) && (T = Pt(T, this.appendSource)), this.log(`switching codec ${m} to ${T}`), T !== (f.pendingCodec || f.codec) && (f.pendingCodec = T), f.container = u, this.appendChangeType(t, u, T))
                        })), (this.tracksReady || this.sourceBufferCount) && (e.tracks = this.sourceBufferTracks), this.sourceBufferCount || this.mediaSourceOpenOrEnded && this.checkPendingTracks())
                    }
                    get sourceBufferTracks() {
                        return Object.keys(this.tracks).reduce(((t, e) => {
                            const i = this.tracks[e];
                            return t[e] = {
                                id: i.id,
                                container: i.container,
                                codec: i.codec,
                                levelCodec: i.levelCodec
                            }, t
                        }), {})
                    }
                    appendChangeType(t, e, i) {
                        const s = `${e};codecs=${i}`,
                            r = {
                                label: `change-type=${s}`,
                                execute: () => {
                                    const r = this.tracks[t];
                                    if (r) {
                                        const n = r.buffer;
                                        null != n && n.changeType && (this.log(`changing ${t} sourceBuffer type to ${s}`), n.changeType(s), r.codec = i, r.container = e)
                                    }
                                    this.shiftAndExecuteNext(t)
                                },
                                onStart: () => {},
                                onComplete: () => {},
                                onError: e => {
                                    this.warn(`Failed to change ${t} SourceBuffer type`, e)
                                }
                            };
                        this.append(r, t, this.isPending(this.tracks[t]))
                    }
                    blockAudio(t) {
                        var e;
                        const i = t.start,
                            s = i + .05 * t.duration;
                        if (!0 === (null == (e = this.fragmentTracker.getAppendedFrag(i, f)) ? void 0 : e.gap)) return;
                        const r = {
                            label: "block-audio",
                            execute: () => {
                                var t;
                                const e = this.tracks.video;
                                (this.lastVideoAppendEnd > s || null != e && e.buffer && Oe.isBuffered(e.buffer, s) || !0 === (null == (t = this.fragmentTracker.getAppendedFrag(s, f)) ? void 0 : t.gap)) && (this.blockedAudioAppend = null, this.shiftAndExecuteNext("audio"))
                            },
                            onStart: () => {},
                            onComplete: () => {},
                            onError: t => {
                                this.warn("Error executing block-audio operation", t)
                            }
                        };
                        this.blockedAudioAppend = {
                            op: r,
                            frag: t
                        }, this.append(r, "audio", !0)
                    }
                    unblockAudio() {
                        const {
                            blockedAudioAppend: t,
                            operationQueue: e
                        } = this;
                        t && e && (this.blockedAudioAppend = null, e.unblockAudio(t.op))
                    }
                    onBufferAppending(t, e) {
                        const {
                            tracks: i
                        } = this, {
                            data: s,
                            type: r,
                            parent: n,
                            frag: c,
                            part: u,
                            chunkMeta: d
                        } = e, h = d.buffering[r], f = c.sn, p = self.performance.now();
                        h.start = p;
                        const g = c.stats.buffering,
                            m = u ? u.stats.buffering : null;
                        0 === g.start && (g.start = p), m && 0 === m.start && (m.start = p);
                        const y = i.audio;
                        let v = !1;
                        "audio" === r && "audio/mpeg" === (null == y ? void 0 : y.container) && (v = !this.lastMpegAudioChunk || 1 === d.id || this.lastMpegAudioChunk.sn !== d.sn, this.lastMpegAudioChunk = d);
                        const b = this.tracks.video,
                            T = null == b ? void 0 : b.buffer;
                        if (T && "initSegment" !== f) {
                            const t = u || c,
                                e = this.blockedAudioAppend;
                            if ("audio" !== r || "main" === n || this.blockedAudioAppend) {
                                if ("video" === r) {
                                    const i = t.end;
                                    if (e) {
                                        const t = e.frag.start;
                                        (i > t || i < this.lastVideoAppendEnd || Oe.isBuffered(T, t)) && this.unblockAudio()
                                    }
                                    this.lastVideoAppendEnd = i
                                }
                            } else {
                                const e = t.start + .05 * t.duration,
                                    i = T.buffered,
                                    s = this.currentOp("video");
                                i.length || s ? !s && !Oe.isBuffered(T, e) && this.lastVideoAppendEnd < e && this.blockAudio(t) : this.blockAudio(t)
                            }
                        }
                        const E = (u || c).start,
                            S = {
                                label: `append-${r}`,
                                execute: () => {
                                    if (h.executeStart = self.performance.now(), v) {
                                        const t = this.tracks[r];
                                        if (t) {
                                            const e = t.buffer;
                                            if (e) {
                                                const t = E - e.timestampOffset;
                                                Math.abs(t) >= .1 && (this.log(`Updating audio SourceBuffer timestampOffset to ${E} (delta: ${t}) sn: ${f})`), e.timestampOffset = E)
                                            }
                                        }
                                    }
                                    this.appendExecutor(s, r)
                                },
                                onStart: () => {},
                                onComplete: () => {
                                    const t = self.performance.now();
                                    h.executeEnd = h.end = t, 0 === g.first && (g.first = t), m && 0 === m.first && (m.first = t);
                                    const e = {};
                                    this.sourceBuffers.forEach((([t, i]) => {
                                        t && (e[t] = Oe.getBuffered(i))
                                    })), this.appendErrors[r] = 0, "audio" === r || "video" === r ? this.appendErrors.audiovideo = 0 : (this.appendErrors.audio = 0, this.appendErrors.video = 0), this.hls.trigger(l.BUFFER_APPENDED, {
                                        type: r,
                                        frag: c,
                                        part: u,
                                        chunkMeta: d,
                                        parent: c.type,
                                        timeRanges: e
                                    })
                                },
                                onError: t => {
                                    var e;
                                    const i = {
                                            type: a.MEDIA_ERROR,
                                            parent: c.type,
                                            details: o.BUFFER_APPEND_ERROR,
                                            sourceBufferName: r,
                                            frag: c,
                                            part: u,
                                            chunkMeta: d,
                                            error: t,
                                            err: t,
                                            fatal: !1
                                        },
                                        s = null == (e = this.media) ? void 0 : e.error;
                                    if (t.code === DOMException.QUOTA_EXCEEDED_ERR) i.details = o.BUFFER_FULL_ERROR;
                                    else if (t.code === DOMException.INVALID_STATE_ERR && this.mediaSourceOpenOrEnded && !s) i.errorAction = pe(!0);
                                    else if (t.name === _r && 0 === this.sourceBufferCount) i.errorAction = pe(!0);
                                    else {
                                        const t = ++this.appendErrors[r];
                                        this.warn(`Failed ${t}/${this.hls.config.appendErrorMaxRetry} times to append segment in "${r}" sourceBuffer (${s||"no media error"})`), (t >= this.hls.config.appendErrorMaxRetry || s) && (i.fatal = !0)
                                    }
                                    this.hls.trigger(l.ERROR, i)
                                }
                            };
                        this.append(S, r, this.isPending(this.tracks[r]))
                    }
                    getFlushOp(t, e, i) {
                        return this.log(`queuing "${t}" remove ${e}-${i}`), {
                            label: "remove",
                            execute: () => {
                                this.removeExecutor(t, e, i)
                            },
                            onStart: () => {},
                            onComplete: () => {
                                this.hls.trigger(l.BUFFER_FLUSHED, {
                                    type: t
                                })
                            },
                            onError: s => {
                                this.warn(`Failed to remove ${e}-${i} from "${t}" SourceBuffer`, s)
                            }
                        }
                    }
                    onBufferFlushing(t, e) {
                        const {
                            type: i,
                            startOffset: s,
                            endOffset: r
                        } = e;
                        i ? this.append(this.getFlushOp(i, s, r), i) : this.sourceBuffers.forEach((([t]) => {
                            t && this.append(this.getFlushOp(t, s, r), t)
                        }))
                    }
                    onFragParsed(t, e) {
                        const {
                            frag: i,
                            part: s
                        } = e, r = [], n = s ? s.elementaryStreams : i.elementaryStreams;
                        n[K] ? r.push("audiovideo") : (n[V] && r.push("audio"), n[H] && r.push("video")), 0 === r.length && this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${i.type} level: ${i.level} sn: ${i.sn}`), this.blockBuffers((() => {
                            const t = self.performance.now();
                            i.stats.buffering.end = t, s && (s.stats.buffering.end = t);
                            const e = s ? s.stats : i.stats;
                            this.hls.trigger(l.FRAG_BUFFERED, {
                                frag: i,
                                part: s,
                                stats: e,
                                id: i.type
                            })
                        }), r).catch((t => {
                            this.warn(`Fragment buffered callback ${t}`), this.stepOperationQueue(this.sourceBufferTypes)
                        }))
                    }
                    onFragChanged(t, e) {
                        this.trimBuffers()
                    }
                    get bufferedToEnd() {
                        return this.sourceBufferCount > 0 && !this.sourceBuffers.some((([t]) => {
                            var e, i;
                            return t && (!(null != (e = this.tracks[t]) && e.ended) || (null == (i = this.tracks[t]) ? void 0 : i.ending))
                        }))
                    }
                    onBufferEos(t, e) {
                        var i;
                        this.sourceBuffers.forEach((([t]) => {
                            if (t) {
                                const i = this.tracks[t];
                                e.type && e.type !== t || (i.ending = !0, i.ended || (i.ended = !0, this.log(`${t} buffer reached EOS`)))
                            }
                        }));
                        const s = !1 !== (null == (i = this.overrides) ? void 0 : i.endOfStream);
                        this.sourceBufferCount > 0 && !this.sourceBuffers.some((([t]) => {
                            var e;
                            return t && !(null != (e = this.tracks[t]) && e.ended)
                        })) && (s ? (this.log("Queueing EOS"), this.blockUntilOpen((() => {
                            this.tracksEnded();
                            const {
                                mediaSource: t
                            } = this;
                            t && "open" === t.readyState ? (this.log("Calling mediaSource.endOfStream()"), t.endOfStream(), this.hls.trigger(l.BUFFERED_TO_END, void 0)) : t && this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${t.readyState}`)
                        }))) : (this.tracksEnded(), this.hls.trigger(l.BUFFERED_TO_END, void 0)))
                    }
                    tracksEnded() {
                        this.sourceBuffers.forEach((([t]) => {
                            if (null !== t) {
                                const e = this.tracks[t];
                                e && (e.ending = !1)
                            }
                        }))
                    }
                    onLevelUpdated(t, {
                        details: e
                    }) {
                        e.fragments.length && (this.details = e, this.updateDuration())
                    }
                    updateDuration() {
                        const t = this.getDurationAndRange();
                        t && this.blockUntilOpen((() => this.updateMediaSource(t)))
                    }
                    onError(t, e) {
                        if (e.details === o.BUFFER_APPEND_ERROR && e.frag) {
                            var i;
                            const t = null == (i = e.errorAction) ? void 0 : i.nextAutoLevel;
                            s(t) && t !== e.frag.level && this.resetAppendErrors()
                        }
                    }
                    resetAppendErrors() {
                        this.appendErrors = {
                            audio: 0,
                            video: 0,
                            audiovideo: 0
                        }
                    }
                    trimBuffers() {
                        const {
                            hls: t,
                            details: e,
                            media: i
                        } = this;
                        if (!i || null === e) return;
                        if (!this.sourceBufferCount) return;
                        const r = t.config,
                            n = i.currentTime,
                            a = e.levelTargetDuration,
                            o = e.live && null !== r.liveBackBufferLength ? r.liveBackBufferLength : r.backBufferLength;
                        if (s(o) && o >= 0) {
                            const t = Math.max(o, a),
                                e = Math.floor(n / a) * a - t;
                            this.flushBackBuffer(n, a, e)
                        }
                        if (s(r.frontBufferFlushThreshold) && r.frontBufferFlushThreshold > 0) {
                            const t = Math.max(r.maxBufferLength, r.frontBufferFlushThreshold),
                                e = Math.max(t, a),
                                i = Math.floor(n / a) * a + e;
                            this.flushFrontBuffer(n, a, i)
                        }
                    }
                    flushBackBuffer(t, e, i) {
                        this.sourceBuffers.forEach((([t, e]) => {
                            if (e) {
                                const r = Oe.getBuffered(e);
                                if (r.length > 0 && i > r.start(0)) {
                                    var s;
                                    this.hls.trigger(l.BACK_BUFFER_REACHED, {
                                        bufferEnd: i
                                    });
                                    const e = this.tracks[t];
                                    if (null != (s = this.details) && s.live) this.hls.trigger(l.LIVE_BACK_BUFFER_REACHED, {
                                        bufferEnd: i
                                    });
                                    else if (null != e && e.ended) return void this.log(`Cannot flush ${t} back buffer while SourceBuffer is in ended state`);
                                    this.hls.trigger(l.BUFFER_FLUSHING, {
                                        startOffset: 0,
                                        endOffset: i,
                                        type: t
                                    })
                                }
                            }
                        }))
                    }
                    flushFrontBuffer(t, e, i) {
                        this.sourceBuffers.forEach((([e, s]) => {
                            if (s) {
                                const r = Oe.getBuffered(s),
                                    n = r.length;
                                if (n < 2) return;
                                const a = r.start(n - 1),
                                    o = r.end(n - 1);
                                if (i > a || t >= a && t <= o) return;
                                this.hls.trigger(l.BUFFER_FLUSHING, {
                                    startOffset: a,
                                    endOffset: 1 / 0,
                                    type: e
                                })
                            }
                        }))
                    }
                    getDurationAndRange() {
                        var t;
                        const {
                            details: e,
                            mediaSource: i
                        } = this;
                        if (!e || !this.media || "open" !== (null == i ? void 0 : i.readyState)) return null;
                        const r = e.edge;
                        if (e.live && this.hls.config.liveDurationInfinity) {
                            if (e.fragments.length && e.live && i.setLiveSeekableRange) {
                                const t = Math.max(0, e.fragmentStart);
                                return {
                                    duration: 1 / 0,
                                    start: t,
                                    end: Math.max(t, r)
                                }
                            }
                            return {
                                duration: 1 / 0
                            }
                        }
                        const n = null == (t = this.overrides) ? void 0 : t.duration;
                        if (n) return s(n) ? {
                            duration: n
                        } : null;
                        const a = this.media.duration;
                        return r > (s(i.duration) ? i.duration : 0) && r > a || !s(a) ? {
                            duration: r
                        } : null
                    }
                    updateMediaSource({
                        duration: t,
                        start: e,
                        end: i
                    }) {
                        const r = this.mediaSource;
                        this.media && r && "open" === r.readyState && (r.duration !== t && (s(t) && this.log(`Updating MediaSource duration to ${t.toFixed(3)}`), r.duration = t), void 0 !== e && void 0 !== i && (this.log(`MediaSource duration is set to ${r.duration}. Setting seekable range to ${e}-${i}.`), r.setLiveSeekableRange(e, i)))
                    }
                    get tracksReady() {
                        const t = this.pendingTrackCount;
                        return t > 0 && (t >= this.bufferCodecEventsTotal || this.isPending(this.tracks.audiovideo))
                    }
                    checkPendingTracks() {
                        const {
                            bufferCodecEventsTotal: t,
                            pendingTrackCount: e,
                            tracks: i
                        } = this;
                        if (this.log(`checkPendingTracks (pending: ${e} codec events expected: ${t}) ${Yt(i)}`), this.tracksReady) {
                            var s;
                            const t = null == (s = this.transferData) ? void 0 : s.tracks;
                            t && Object.keys(t).length ? this.attachTransferred() : this.createSourceBuffers()
                        }
                    }
                    bufferCreated() {
                        if (this.sourceBufferCount) {
                            const t = {};
                            this.sourceBuffers.forEach((([e, i]) => {
                                if (e) {
                                    const s = this.tracks[e];
                                    t[e] = {
                                        buffer: i,
                                        container: s.container,
                                        codec: s.codec,
                                        supplemental: s.supplemental,
                                        levelCodec: s.levelCodec,
                                        id: s.id,
                                        metadata: s.metadata
                                    }
                                }
                            })), this.hls.trigger(l.BUFFER_CREATED, {
                                tracks: t
                            }), this.log(`SourceBuffers created. Running queue: ${this.operationQueue}`), this.sourceBuffers.forEach((([t]) => {
                                this.executeNext(t)
                            }))
                        } else {
                            const t = new Error("could not create source buffer for media codec(s)");
                            this.hls.trigger(l.ERROR, {
                                type: a.MEDIA_ERROR,
                                details: o.BUFFER_INCOMPATIBLE_CODECS_ERROR,
                                fatal: !0,
                                error: t,
                                reason: t.message
                            })
                        }
                    }
                    createSourceBuffers() {
                        const {
                            tracks: t,
                            sourceBuffers: e,
                            mediaSource: i
                        } = this;
                        if (!i) throw new Error("createSourceBuffers called when mediaSource was null");
                        for (const r in t) {
                            const n = r,
                                c = t[n];
                            if (this.isPending(c)) {
                                const t = this.getTrackCodec(c, n),
                                    r = `${c.container};codecs=${t}`;
                                c.codec = t, this.log(`creating sourceBuffer(${r})${this.currentOp(n)?" Queued":""} ${Yt(c)}`);
                                try {
                                    const t = i.addSourceBuffer(r),
                                        s = Ir(n),
                                        a = [n, t];
                                    e[s] = a, c.buffer = t
                                } catch (t) {
                                    var s;
                                    return this.error(`error while trying to add sourceBuffer: ${t.message}`), this.shiftAndExecuteNext(n), null == (s = this.operationQueue) || s.removeBlockers(), delete this.tracks[n], void this.hls.trigger(l.ERROR, {
                                        type: a.MEDIA_ERROR,
                                        details: o.BUFFER_ADD_CODEC_ERROR,
                                        fatal: !1,
                                        error: t,
                                        sourceBufferName: n,
                                        mimeType: r,
                                        parent: c.id
                                    })
                                }
                                this.trackSourceBuffer(n, c)
                            }
                        }
                        this.bufferCreated()
                    }
                    getTrackCodec(t, e) {
                        const i = t.supplemental;
                        let s = t.codec;
                        i && ("video" === e || "audiovideo" === e) && _t(i, "video") && (s = function(t, e) {
                            const i = [];
                            if (t) {
                                const e = t.split(",");
                                for (let t = 0; t < e.length; t++) At(e[t], "video") || i.push(e[t])
                            }
                            return e && i.push(e), i.join(",")
                        }(s, i));
                        const r = Ot(s, t.levelCodec);
                        return r ? "audio" === e.slice(0, 5) ? Pt(r, this.appendSource) : r : ""
                    }
                    trackSourceBuffer(t, e) {
                        const i = e.buffer;
                        if (!i) return;
                        const s = this.getTrackCodec(e, t);
                        this.tracks[t] = {
                            buffer: i,
                            codec: s,
                            container: e.container,
                            levelCodec: e.levelCodec,
                            supplemental: e.supplemental,
                            metadata: e.metadata,
                            id: e.id,
                            listeners: []
                        }, this.removeBufferListeners(t), this.addBufferListener(t, "updatestart", this.onSBUpdateStart), this.addBufferListener(t, "updateend", this.onSBUpdateEnd), this.addBufferListener(t, "error", this.onSBUpdateError), this.appendSource && this.addBufferListener(t, "bufferedchange", ((t, e) => {
                            const i = e.removedRanges;
                            null != i && i.length && this.hls.trigger(l.BUFFER_FLUSHED, {
                                type: t
                            })
                        }))
                    }
                    get mediaSrc() {
                        var t, e;
                        const i = (null == (t = this.media) || null == (e = t.querySelector) ? void 0 : e.call(t, "source")) || this.media;
                        return null == i ? void 0 : i.src
                    }
                    onSBUpdateStart(t) {
                        const e = this.currentOp(t);
                        e && e.onStart()
                    }
                    onSBUpdateEnd(t) {
                        var e;
                        if ("closed" === (null == (e = this.mediaSource) ? void 0 : e.readyState)) return void this.resetBuffer(t);
                        const i = this.currentOp(t);
                        i && (i.onComplete(), this.shiftAndExecuteNext(t))
                    }
                    onSBUpdateError(t, e) {
                        var i;
                        const s = new Error(`${t} SourceBuffer error. MediaSource readyState: ${null==(i=this.mediaSource)?void 0:i.readyState}`);
                        this.error(`${s}`, e), this.hls.trigger(l.ERROR, {
                            type: a.MEDIA_ERROR,
                            details: o.BUFFER_APPENDING_ERROR,
                            sourceBufferName: t,
                            error: s,
                            fatal: !1
                        });
                        const r = this.currentOp(t);
                        r && r.onError(s)
                    }
                    removeExecutor(t, e, i) {
                        const {
                            media: r,
                            mediaSource: n
                        } = this, a = this.tracks[t], o = null == a ? void 0 : a.buffer;
                        if (!r || !n || !o) return this.warn(`Attempting to remove from the ${t} SourceBuffer, but it does not exist`), void this.shiftAndExecuteNext(t);
                        const l = s(r.duration) ? r.duration : 1 / 0,
                            c = s(n.duration) ? n.duration : 1 / 0,
                            u = Math.max(0, e),
                            d = Math.min(i, l, c);
                        d > u && (!a.ending || a.ended) ? (a.ended = !1, this.log(`Removing [${u},${d}] from the ${t} SourceBuffer`), o.remove(u, d)) : this.shiftAndExecuteNext(t)
                    }
                    appendExecutor(t, e) {
                        const i = this.tracks[e],
                            s = null == i ? void 0 : i.buffer;
                        if (!s) throw new Lr(`Attempting to append to the ${e} SourceBuffer, but it does not exist`);
                        i.ending = !1, i.ended = !1, s.appendBuffer(t)
                    }
                    blockUntilOpen(t) {
                        if (this.isUpdating() || this.isQueued()) this.blockBuffers(t).catch((t => {
                            this.warn(`SourceBuffer blocked callback ${t}`), this.stepOperationQueue(this.sourceBufferTypes)
                        }));
                        else try {
                            t()
                        } catch (t) {
                            this.warn(`Callback run without blocking ${this.operationQueue} ${t}`)
                        }
                    }
                    isUpdating() {
                        return this.sourceBuffers.some((([t, e]) => t && e.updating))
                    }
                    isQueued() {
                        return this.sourceBuffers.some((([t]) => t && !!this.currentOp(t)))
                    }
                    isPending(t) {
                        return !!t && !t.buffer
                    }
                    blockBuffers(t, e = this.sourceBufferTypes) {
                        if (!e.length) return this.log("Blocking operation requested, but no SourceBuffers exist"), Promise.resolve().then(t);
                        const {
                            operationQueue: i
                        } = this, s = e.map((t => this.appendBlocker(t)));
                        return e.length > 1 && !!this.blockedAudioAppend && this.unblockAudio(), Promise.all(s).then((e => {
                            i === this.operationQueue && (t(), this.stepOperationQueue(this.sourceBufferTypes))
                        }))
                    }
                    stepOperationQueue(t) {
                        t.forEach((t => {
                            var e;
                            const i = null == (e = this.tracks[t]) ? void 0 : e.buffer;
                            i && !i.updating && this.shiftAndExecuteNext(t)
                        }))
                    }
                    append(t, e, i) {
                        this.operationQueue && this.operationQueue.append(t, e, i)
                    }
                    appendBlocker(t) {
                        if (this.operationQueue) return this.operationQueue.appendBlocker(t)
                    }
                    currentOp(t) {
                        return this.operationQueue ? this.operationQueue.current(t) : null
                    }
                    executeNext(t) {
                        t && this.operationQueue && this.operationQueue.executeNext(t)
                    }
                    shiftAndExecuteNext(t) {
                        this.operationQueue && this.operationQueue.shiftAndExecuteNext(t)
                    }
                    get pendingTrackCount() {
                        return Object.keys(this.tracks).reduce(((t, e) => t + (this.isPending(this.tracks[e]) ? 1 : 0)), 0)
                    }
                    get sourceBufferCount() {
                        return this.sourceBuffers.reduce(((t, [e]) => t + (e ? 1 : 0)), 0)
                    }
                    get sourceBufferTypes() {
                        return this.sourceBuffers.map((([t]) => t)).filter((t => !!t))
                    }
                    addBufferListener(t, e, i) {
                        const s = this.tracks[t];
                        if (!s) return;
                        const r = s.buffer;
                        if (!r) return;
                        const n = i.bind(this, t);
                        s.listeners.push({
                            event: e,
                            listener: n
                        }), r.addEventListener(e, n)
                    }
                    removeBufferListeners(t) {
                        const e = this.tracks[t];
                        if (!e) return;
                        const i = e.buffer;
                        i && (e.listeners.forEach((t => {
                            i.removeEventListener(t.event, t.listener)
                        })), e.listeners.length = 0)
                    }
                },
                capLevelController: Cr,
                errorController: class extends S {
                    constructor(t) {
                        super("error-controller", t.logger), this.hls = void 0, this.playlistError = 0, this.penalizedRenditions = {}, this.hls = t, this.registerListeners()
                    }
                    registerListeners() {
                        const t = this.hls;
                        t.on(l.ERROR, this.onError, this), t.on(l.MANIFEST_LOADING, this.onManifestLoading, this), t.on(l.LEVEL_UPDATED, this.onLevelUpdated, this)
                    }
                    unregisterListeners() {
                        const t = this.hls;
                        t && (t.off(l.ERROR, this.onError, this), t.off(l.ERROR, this.onErrorOut, this), t.off(l.MANIFEST_LOADING, this.onManifestLoading, this), t.off(l.LEVEL_UPDATED, this.onLevelUpdated, this))
                    }
                    destroy() {
                        this.unregisterListeners(), this.hls = null, this.penalizedRenditions = {}
                    }
                    startLoad(t) {}
                    stopLoad() {
                        this.playlistError = 0
                    }
                    getVariantLevelIndex(t) {
                        return (null == t ? void 0 : t.type) === f ? t.level : this.hls.loadLevel
                    }
                    onManifestLoading() {
                        this.playlistError = 0, this.penalizedRenditions = {}
                    }
                    onLevelUpdated() {
                        this.playlistError = 0
                    }
                    onError(t, e) {
                        var i;
                        if (e.fatal) return;
                        const s = this.hls,
                            r = e.context;
                        switch (e.details) {
                            case o.FRAG_LOAD_ERROR:
                            case o.FRAG_LOAD_TIMEOUT:
                            case o.KEY_LOAD_ERROR:
                            case o.KEY_LOAD_TIMEOUT:
                                return void(e.errorAction = this.getFragRetryOrSwitchAction(e));
                            case o.FRAG_PARSING_ERROR:
                                if (null != (i = e.frag) && i.gap) return void(e.errorAction = pe());
                            case o.FRAG_GAP:
                            case o.FRAG_DECRYPT_ERROR:
                                return e.errorAction = this.getFragRetryOrSwitchAction(e), void(e.errorAction.action = 2);
                            case o.LEVEL_EMPTY_ERROR:
                            case o.LEVEL_PARSING_ERROR:
                                {
                                    var n, l;
                                    const t = e.parent === f ? e.level : s.loadLevel;e.details === o.LEVEL_EMPTY_ERROR && null != (n = e.context) && null != (l = n.levelDetails) && l.live ? e.errorAction = this.getPlaylistRetryOrSwitchAction(e, t) : (e.levelRetry = !1, e.errorAction = this.getLevelSwitchAction(e, t))
                                }
                                return;
                            case o.LEVEL_LOAD_ERROR:
                            case o.LEVEL_LOAD_TIMEOUT:
                                return void("number" == typeof(null == r ? void 0 : r.level) && (e.errorAction = this.getPlaylistRetryOrSwitchAction(e, r.level)));
                            case o.AUDIO_TRACK_LOAD_ERROR:
                            case o.AUDIO_TRACK_LOAD_TIMEOUT:
                            case o.SUBTITLE_LOAD_ERROR:
                            case o.SUBTITLE_TRACK_LOAD_TIMEOUT:
                                if (r) {
                                    const t = s.loadLevelObj;
                                    if (t && (r.type === d && t.hasAudioGroup(r.groupId) || r.type === h && t.hasSubtitleGroup(r.groupId))) return e.errorAction = this.getPlaylistRetryOrSwitchAction(e, s.loadLevel), e.errorAction.action = 2, void(e.errorAction.flags = 1)
                                }
                                return;
                            case o.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
                                {
                                    const t = s.loadLevelObj,
                                        i = null == t ? void 0 : t.attrs["HDCP-LEVEL"];i ? e.errorAction = {
                                        action: 2,
                                        flags: 2,
                                        hdcpLevel: i
                                    } : this.keySystemError(e)
                                }
                                return;
                            case o.BUFFER_ADD_CODEC_ERROR:
                            case o.REMUX_ALLOC_ERROR:
                            case o.BUFFER_APPEND_ERROR:
                                var c;
                                return void(e.errorAction || (e.errorAction = this.getLevelSwitchAction(e, null != (c = e.level) ? c : s.loadLevel)));
                            case o.INTERNAL_EXCEPTION:
                            case o.BUFFER_APPENDING_ERROR:
                            case o.BUFFER_FULL_ERROR:
                            case o.LEVEL_SWITCH_ERROR:
                            case o.BUFFER_STALLED_ERROR:
                            case o.BUFFER_SEEK_OVER_HOLE:
                            case o.BUFFER_NUDGE_ON_STALL:
                                return void(e.errorAction = pe())
                        }
                        e.type === a.KEY_SYSTEM_ERROR && this.keySystemError(e)
                    }
                    keySystemError(t) {
                        const e = this.getVariantLevelIndex(t.frag);
                        t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, e)
                    }
                    getPlaylistRetryOrSwitchAction(t, e) {
                        const i = ue(this.hls.config.playlistLoadPolicy, t),
                            s = this.playlistError++;
                        if (fe(i, s, ce(t), t.response)) return {
                            action: 5,
                            flags: 0,
                            retryConfig: i,
                            retryCount: s
                        };
                        const r = this.getLevelSwitchAction(t, e);
                        return i && (r.retryConfig = i, r.retryCount = s), r
                    }
                    getFragRetryOrSwitchAction(t) {
                        const e = this.hls,
                            i = this.getVariantLevelIndex(t.frag),
                            s = e.levels[i],
                            {
                                fragLoadPolicy: r,
                                keyLoadPolicy: n
                            } = e.config,
                            a = ue(t.details.startsWith("key") ? n : r, t),
                            l = e.levels.reduce(((t, e) => t + e.fragmentError), 0);
                        if (s && (t.details !== o.FRAG_GAP && s.fragmentError++, fe(a, l, ce(t), t.response))) return {
                            action: 5,
                            flags: 0,
                            retryConfig: a,
                            retryCount: l
                        };
                        const c = this.getLevelSwitchAction(t, i);
                        return a && (c.retryConfig = a, c.retryCount = l), c
                    }
                    getLevelSwitchAction(t, e) {
                        const i = this.hls;
                        null == e && (e = i.loadLevel);
                        const s = this.hls.levels[e];
                        if (s) {
                            var r, n;
                            const e = t.details;
                            s.loadError++, e === o.BUFFER_APPEND_ERROR && s.fragmentError++;
                            let c = -1;
                            const {
                                levels: u,
                                loadLevel: m,
                                minAutoLevel: y,
                                maxAutoLevel: v
                            } = i;
                            i.autoLevelEnabled || (i.loadLevel = -1);
                            const b = null == (r = t.frag) ? void 0 : r.type,
                                T = (b === p && e === o.FRAG_PARSING_ERROR || "audio" === t.sourceBufferName && (e === o.BUFFER_ADD_CODEC_ERROR || e === o.BUFFER_APPEND_ERROR)) && u.some((({
                                    audioCodec: t
                                }) => s.audioCodec !== t)),
                                E = "video" === t.sourceBufferName && (e === o.BUFFER_ADD_CODEC_ERROR || e === o.BUFFER_APPEND_ERROR) && u.some((({
                                    codecSet: t,
                                    audioCodec: e
                                }) => s.codecSet !== t && s.audioCodec === e)),
                                {
                                    type: S,
                                    groupId: w
                                } = null != (n = t.context) ? n : {};
                            for (let i = u.length; i--;) {
                                const r = (i + m) % u.length;
                                if (r !== m && r >= y && r <= v && 0 === u[r].loadError) {
                                    var a, l;
                                    const i = u[r];
                                    if (e === o.FRAG_GAP && b === f && t.frag) {
                                        const e = u[r].details;
                                        if (e) {
                                            const i = ne(t.frag, e.fragments, t.frag.start);
                                            if (null != i && i.gap) continue
                                        }
                                    } else {
                                        if (S === d && i.hasAudioGroup(w) || S === h && i.hasSubtitleGroup(w)) continue;
                                        if (b === p && null != (a = s.audioGroups) && a.some((t => i.hasAudioGroup(t))) || b === g && null != (l = s.subtitleGroups) && l.some((t => i.hasSubtitleGroup(t))) || T && s.audioCodec === i.audioCodec || !T && s.audioCodec !== i.audioCodec || E && s.codecSet === i.codecSet) continue
                                    }
                                    c = r;
                                    break
                                }
                            }
                            if (c > -1 && i.loadLevel !== c) return t.levelRetry = !0, this.playlistError = 0, {
                                action: 2,
                                flags: 0,
                                nextAutoLevel: c
                            }
                        }
                        return {
                            action: 2,
                            flags: 1
                        }
                    }
                    onErrorOut(t, e) {
                        var i;
                        switch (null == (i = e.errorAction) ? void 0 : i.action) {
                            case 0:
                                break;
                            case 2:
                                this.sendAlternateToPenaltyBox(e), e.errorAction.resolved || e.details === o.FRAG_GAP ? /MediaSource readyState: ended/.test(e.error.message) && (this.warn(`MediaSource ended after "${e.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`), this.hls.recoverMediaError()) : e.fatal = !0
                        }
                        e.fatal && this.hls.stopLoad()
                    }
                    sendAlternateToPenaltyBox(t) {
                        const e = this.hls,
                            i = t.errorAction;
                        if (!i) return;
                        const {
                            flags: s,
                            hdcpLevel: r,
                            nextAutoLevel: n
                        } = i;
                        switch (s) {
                            case 0:
                                this.switchLevel(t, n);
                                break;
                            case 2:
                                r && (e.maxHdcpLevel = Vt[Vt.indexOf(r) - 1], i.resolved = !0), this.warn(`Restricting playback to HDCP-LEVEL of "${e.maxHdcpLevel}" or lower`)
                        }
                        i.resolved || this.switchLevel(t, n)
                    }
                    switchLevel(t, e) {
                        if (void 0 !== e && t.errorAction && (this.warn(`switching to level ${e} after ${t.details}`), this.hls.nextAutoLevel = e, t.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel, t.details === o.BUFFER_ADD_CODEC_ERROR && t.mimeType && "audiovideo" !== t.sourceBufferName)) {
                            const e = Ft(t.mimeType),
                                i = this.hls.levels;
                            for (let s = i.length; s--;) i[s][`${t.sourceBufferName}Codec`] === e && this.hls.removeLevel(s)
                        }
                    }
                },
                fpsController: class {
                    constructor(t) {
                        this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = t, this.registerListeners()
                    }
                    setStreamController(t) {
                        this.streamController = t
                    }
                    registerListeners() {
                        this.hls.on(l.MEDIA_ATTACHING, this.onMediaAttaching, this), this.hls.on(l.MEDIA_DETACHING, this.onMediaDetaching, this)
                    }
                    unregisterListeners() {
                        this.hls.off(l.MEDIA_ATTACHING, this.onMediaAttaching, this), this.hls.off(l.MEDIA_DETACHING, this.onMediaDetaching, this)
                    }
                    destroy() {
                        this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null
                    }
                    onMediaAttaching(t, e) {
                        const i = this.hls.config;
                        if (i.capLevelOnFPSDrop) {
                            const t = e.media instanceof self.HTMLVideoElement ? e.media : null;
                            this.media = t, t && "function" == typeof t.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), i.fpsDroppedMonitoringPeriod)
                        }
                    }
                    onMediaDetaching() {
                        this.media = null
                    }
                    checkFPS(t, e, i) {
                        const s = performance.now();
                        if (e) {
                            if (this.lastTime) {
                                const t = s - this.lastTime,
                                    r = i - this.lastDroppedFrames,
                                    n = e - this.lastDecodedFrames,
                                    a = 1e3 * r / t,
                                    o = this.hls;
                                if (o.trigger(l.FPS_DROP, {
                                        currentDropped: r,
                                        currentDecoded: n,
                                        totalDroppedFrames: i
                                    }), a > 0 && r > o.config.fpsDroppedMonitoringThreshold * n) {
                                    let t = o.currentLevel;
                                    o.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + t), t > 0 && (-1 === o.autoLevelCapping || o.autoLevelCapping >= t) && (t -= 1, o.trigger(l.FPS_DROP_LEVEL_CAPPING, {
                                        level: t,
                                        droppedLevel: o.currentLevel
                                    }), o.autoLevelCapping = t, this.streamController.nextLevelSwitch())
                                }
                            }
                            this.lastTime = s, this.lastDroppedFrames = i, this.lastDecodedFrames = e
                        }
                    }
                    checkFPSInterval() {
                        const t = this.media;
                        if (t)
                            if (this.isVideoPlaybackQualityAvailable) {
                                const e = t.getVideoPlaybackQuality();
                                this.checkFPS(t, e.totalVideoFrames, e.droppedVideoFrames)
                            } else this.checkFPS(t, t.webkitDecodedFrameCount, t.webkitDroppedFrameCount)
                    }
                },
                stretchShortVideoTrack: !1,
                maxAudioFramesDrift: 1,
                forceKeyFrameOnDiscontinuity: !0,
                abrEwmaFastLive: 3,
                abrEwmaSlowLive: 9,
                abrEwmaFastVoD: 3,
                abrEwmaSlowVoD: 9,
                abrEwmaDefaultEstimate: 5e5,
                abrEwmaDefaultEstimateMax: 5e6,
                abrBandWidthFactor: .95,
                abrBandWidthUpFactor: .7,
                abrMaxWithRealBitrate: !1,
                maxStarvationDelay: 4,
                maxLoadingDelay: 4,
                minAutoBitrate: 0,
                emeEnabled: !1,
                widevineLicenseUrl: void 0,
                drmSystems: {},
                drmSystemOptions: {},
                requestMediaKeySystemAccessFunc: ai,
                testBandwidth: !0,
                progressive: !1,
                lowLatencyMode: !0,
                cmcd: void 0,
                enableDateRangeMetadataCues: !0,
                enableEmsgMetadataCues: !0,
                enableEmsgKLVMetadata: !1,
                enableID3MetadataCues: !0,
                enableInterstitialPlayback: !0,
                interstitialAppendInPlace: !0,
                interstitialLiveLookAhead: 10,
                useMediaCapabilities: !0,
                certLoadPolicy: {
                    default: {
                        maxTimeToFirstByteMs: 8e3,
                        maxLoadTimeMs: 2e4,
                        timeoutRetry: null,
                        errorRetry: null
                    }
                },
                keyLoadPolicy: {
                    default: {
                        maxTimeToFirstByteMs: 8e3,
                        maxLoadTimeMs: 2e4,
                        timeoutRetry: {
                            maxNumRetry: 1,
                            retryDelayMs: 1e3,
                            maxRetryDelayMs: 2e4,
                            backoff: "linear"
                        },
                        errorRetry: {
                            maxNumRetry: 8,
                            retryDelayMs: 1e3,
                            maxRetryDelayMs: 2e4,
                            backoff: "linear"
                        }
                    }
                },
                manifestLoadPolicy: {
                    default: {
                        maxTimeToFirstByteMs: 1 / 0,
                        maxLoadTimeMs: 2e4,
                        timeoutRetry: {
                            maxNumRetry: 2,
                            retryDelayMs: 0,
                            maxRetryDelayMs: 0
                        },
                        errorRetry: {
                            maxNumRetry: 1,
                            retryDelayMs: 1e3,
                            maxRetryDelayMs: 8e3
                        }
                    }
                },
                playlistLoadPolicy: {
                    default: {
                        maxTimeToFirstByteMs: 1e4,
                        maxLoadTimeMs: 2e4,
                        timeoutRetry: {
                            maxNumRetry: 2,
                            retryDelayMs: 0,
                            maxRetryDelayMs: 0
                        },
                        errorRetry: {
                            maxNumRetry: 2,
                            retryDelayMs: 1e3,
                            maxRetryDelayMs: 8e3
                        }
                    }
                },
                fragLoadPolicy: {
                    default: {
                        maxTimeToFirstByteMs: 1e4,
                        maxLoadTimeMs: 12e4,
                        timeoutRetry: {
                            maxNumRetry: 4,
                            retryDelayMs: 0,
                            maxRetryDelayMs: 0
                        },
                        errorRetry: {
                            maxNumRetry: 6,
                            retryDelayMs: 1e3,
                            maxRetryDelayMs: 8e3
                        }
                    }
                },
                steeringManifestLoadPolicy: {
                    default: {
                        maxTimeToFirstByteMs: 1e4,
                        maxLoadTimeMs: 2e4,
                        timeoutRetry: {
                            maxNumRetry: 2,
                            retryDelayMs: 0,
                            maxRetryDelayMs: 0
                        },
                        errorRetry: {
                            maxNumRetry: 1,
                            retryDelayMs: 1e3,
                            maxRetryDelayMs: 8e3
                        }
                    }
                },
                interstitialAssetListLoadPolicy: {
                    default: {
                        maxTimeToFirstByteMs: 1e4,
                        maxLoadTimeMs: 3e4,
                        timeoutRetry: {
                            maxNumRetry: 0,
                            retryDelayMs: 0,
                            maxRetryDelayMs: 0
                        },
                        errorRetry: {
                            maxNumRetry: 0,
                            retryDelayMs: 1e3,
                            maxRetryDelayMs: 8e3
                        }
                    }
                },
                manifestLoadingTimeOut: 1e4,
                manifestLoadingMaxRetry: 1,
                manifestLoadingRetryDelay: 1e3,
                manifestLoadingMaxRetryTimeout: 64e3,
                levelLoadingTimeOut: 1e4,
                levelLoadingMaxRetry: 4,
                levelLoadingRetryDelay: 1e3,
                levelLoadingMaxRetryTimeout: 64e3,
                fragLoadingTimeOut: 2e4,
                fragLoadingMaxRetry: 6,
                fragLoadingRetryDelay: 1e3,
                fragLoadingMaxRetryTimeout: 64e3
            }, {
                cueHandler: Ca,
                enableWebVTT: !0,
                enableIMSC1: !0,
                enableCEA708Captions: !0,
                captionsTextTrack1Label: "English",
                captionsTextTrack1LanguageCode: "en",
                captionsTextTrack2Label: "Spanish",
                captionsTextTrack2LanguageCode: "es",
                captionsTextTrack3Label: "Unknown CC",
                captionsTextTrack3LanguageCode: "",
                captionsTextTrack4Label: "Unknown CC",
                captionsTextTrack4LanguageCode: "",
                renderTextTracksNatively: !0
            }), {}, {
                subtitleStreamController: class extends Vi {
                    constructor(t, e, i) {
                        super(t, e, i, "subtitle-stream-controller", g), this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this.registerListeners()
                    }
                    onHandlerDestroying() {
                        this.unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null
                    }
                    registerListeners() {
                        super.registerListeners();
                        const {
                            hls: t
                        } = this;
                        t.on(l.LEVEL_LOADED, this.onLevelLoaded, this), t.on(l.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), t.on(l.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), t.on(l.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), t.on(l.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), t.on(l.BUFFER_FLUSHING, this.onBufferFlushing, this)
                    }
                    unregisterListeners() {
                        super.unregisterListeners();
                        const {
                            hls: t
                        } = this;
                        t.off(l.LEVEL_LOADED, this.onLevelLoaded, this), t.off(l.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), t.off(l.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), t.off(l.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), t.off(l.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), t.off(l.BUFFER_FLUSHING, this.onBufferFlushing, this)
                    }
                    startLoad(t, e) {
                        this.stopLoad(), this.state = Gi.IDLE, this.setInterval(500), this.nextLoadPosition = this.lastCurrentTime = t + this.timelineOffset, this.startPosition = e ? -1 : t, this.tick()
                    }
                    onManifestLoading() {
                        super.onManifestLoading(), this.mainDetails = null
                    }
                    onMediaDetaching(t, e) {
                        this.tracksBuffered = [], super.onMediaDetaching(t, e)
                    }
                    onLevelLoaded(t, e) {
                        this.mainDetails = e.details
                    }
                    onSubtitleFragProcessed(t, e) {
                        const {
                            frag: i,
                            success: s
                        } = e;
                        if (q(i) && (this.fragPrevious = i), this.state = Gi.IDLE, !s) return;
                        const r = this.tracksBuffered[this.currentTrackId];
                        if (!r) return;
                        let n;
                        const a = i.start;
                        for (let t = 0; t < r.length; t++)
                            if (a >= r[t].start && a <= r[t].end) {
                                n = r[t];
                                break
                            }
                        const o = i.start + i.duration;
                        n ? n.end = o : (n = {
                            start: a,
                            end: o
                        }, r.push(n)), this.fragmentTracker.fragBuffered(i), this.fragBufferedComplete(i, null), this.media && this.tick()
                    }
                    onBufferFlushing(t, e) {
                        const {
                            startOffset: i,
                            endOffset: s
                        } = e;
                        if (0 === i && s !== Number.POSITIVE_INFINITY) {
                            const t = s - 1;
                            if (t <= 0) return;
                            e.endOffsetSubtitles = Math.max(0, t), this.tracksBuffered.forEach((e => {
                                for (let i = 0; i < e.length;)
                                    if (e[i].end <= t) e.shift();
                                    else {
                                        if (!(e[i].start < t)) break;
                                        e[i].start = t, i++
                                    }
                            })), this.fragmentTracker.removeFragmentsInRange(i, t, g)
                        }
                    }
                    onError(t, e) {
                        const i = e.frag;
                        (null == i ? void 0 : i.type) === g && (e.details === o.FRAG_GAP && this.fragmentTracker.fragBuffered(i, !0), this.fragCurrent && this.fragCurrent.abortRequests(), this.state !== Gi.STOPPED && (this.state = Gi.IDLE))
                    }
                    onSubtitleTracksUpdated(t, {
                        subtitleTracks: e
                    }) {
                        this.levels && Er(this.levels, e) ? this.levels = e.map((t => new qt(t))) : (this.tracksBuffered = [], this.levels = e.map((t => {
                            const e = new qt(t);
                            return this.tracksBuffered[e.id] = [], e
                        })), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, g), this.fragPrevious = null, this.mediaBuffer = null)
                    }
                    onSubtitleTrackSwitch(t, e) {
                        var i;
                        if (this.currentTrackId = e.id, null == (i = this.levels) || !i.length || -1 === this.currentTrackId) return void this.clearInterval();
                        const s = this.levels[this.currentTrackId];
                        null != s && s.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, s && this.state !== Gi.STOPPED && this.setInterval(500)
                    }
                    onSubtitleTrackLoaded(t, e) {
                        var i;
                        const {
                            currentTrackId: s,
                            levels: r
                        } = this, {
                            details: n,
                            id: a
                        } = e;
                        if (!r) return void this.warn(`Subtitle tracks were reset while loading level ${a}`);
                        const o = r[a];
                        if (a >= r.length || !o) return;
                        this.log(`Subtitle track ${a} loaded [${n.startSN},${n.endSN}]${n.lastPartSn?`[part-${n.lastPartSn}-${n.lastPartIndex}]`:""},duration:${n.totalduration}`), this.mediaBuffer = this.mediaBufferTimeRanges;
                        let c = 0;
                        if (n.live || null != (i = o.details) && i.live) {
                            const t = this.mainDetails;
                            if (n.deltaUpdateFailed || !t) return;
                            const e = t.fragments[0];
                            var u;
                            o.details ? (c = this.alignPlaylists(n, o.details, null == (u = this.levelLastLoaded) ? void 0 : u.details), 0 === c && e && (c = e.start, xi(n, c))) : n.hasProgramDateTime && t.hasProgramDateTime ? (ji(n, t), c = n.fragmentStart) : e && (c = e.start, xi(n, c))
                        }
                        o.details = n, this.levelLastLoaded = o, a === s && (this.hls.trigger(l.SUBTITLE_TRACK_UPDATED, {
                            details: n,
                            id: a,
                            groupId: e.groupId
                        }), this.tick(), n.live && !this.fragCurrent && this.media && this.state === Gi.IDLE) && (ne(null, n.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), o.details = void 0))
                    }
                    _handleFragmentLoadComplete(t) {
                        const {
                            frag: e,
                            payload: i
                        } = t, s = e.decryptdata, r = this.hls;
                        if (!this.fragContextChanged(e) && i && i.byteLength > 0 && null != s && s.key && s.iv && ze(s.method)) {
                            const t = performance.now();
                            this.decrypter.decrypt(new Uint8Array(i), s.key.buffer, s.iv.buffer, qe(s.method)).catch((t => {
                                throw r.trigger(l.ERROR, {
                                    type: a.MEDIA_ERROR,
                                    details: o.FRAG_DECRYPT_ERROR,
                                    fatal: !1,
                                    error: t,
                                    reason: t.message,
                                    frag: e
                                }), t
                            })).then((i => {
                                const s = performance.now();
                                r.trigger(l.FRAG_DECRYPTED, {
                                    frag: e,
                                    payload: i,
                                    stats: {
                                        tstart: t,
                                        tdecrypt: s
                                    }
                                })
                            })).catch((t => {
                                this.warn(`${t.name}: ${t.message}`), this.state = Gi.IDLE
                            }))
                        }
                    }
                    doTick() {
                        if (this.media) {
                            if (this.state === Gi.IDLE) {
                                const {
                                    currentTrackId: t,
                                    levels: e
                                } = this, i = null == e ? void 0 : e[t];
                                if (!i || !e.length || !i.details) return;
                                if (this.waitForLive(i)) return;
                                const {
                                    config: s
                                } = this, r = this.getLoadPosition(), n = Oe.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], r, s.maxBufferHole), {
                                    end: a,
                                    len: o
                                } = n, l = i.details;
                                if (o > this.hls.maxBufferLength + l.levelTargetDuration) return;
                                const c = l.fragments,
                                    u = c.length,
                                    d = l.edge;
                                let h = null;
                                const f = this.fragPrevious;
                                if (a < d) {
                                    const t = s.maxFragLookUpTolerance,
                                        e = a > d - t ? 0 : t;
                                    h = ne(f, c, Math.max(c[0].start, a), e), !h && f && f.start < c[0].start && (h = c[0])
                                } else h = c[u - 1];
                                if (h = this.filterReplacedPrimary(h, i.details), !h) return;
                                const p = c[h.sn - l.startSN - 1];
                                if (p && p.cc === h.cc && this.fragmentTracker.getState(p) === ge && (h = p), this.fragmentTracker.getState(h) === ge) {
                                    const t = this.mapToInitFragWhenRequired(h);
                                    t && this.loadFragment(t, i, a)
                                }
                            }
                        } else this.state = Gi.IDLE
                    }
                    loadFragment(t, e, i) {
                        q(t) ? super.loadFragment(t, e, i) : this._loadInitSegment(t, e)
                    }
                    get mediaBufferTimeRanges() {
                        return new Nn(this.tracksBuffered[this.currentTrackId] || [])
                    }
                },
                subtitleTrackController: class extends Tr {
                    constructor(t) {
                        super(t, "subtitle-track-controller"), this.media = null, this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.asyncPollTrackChange = () => this.pollTrackChange(0), this.onTextTracksChanged = () => {
                            if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !this.media || !this.hls.config.renderTextTracksNatively) return;
                            let t = null;
                            const e = Tn(this.media.textTracks);
                            for (let i = 0; i < e.length; i++)
                                if ("hidden" === e[i].mode) t = e[i];
                                else if ("showing" === e[i].mode) {
                                t = e[i];
                                break
                            }
                            const i = this.findTrackForTextTrack(t);
                            this.subtitleTrack !== i && this.setSubtitleTrack(i)
                        }, this.registerListeners()
                    }
                    destroy() {
                        this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, this.onTextTracksChanged = this.asyncPollTrackChange = null, super.destroy()
                    }
                    get subtitleDisplay() {
                        return this._subtitleDisplay
                    }
                    set subtitleDisplay(t) {
                        this._subtitleDisplay = t, this.trackId > -1 && this.toggleTrackModes()
                    }
                    registerListeners() {
                        const {
                            hls: t
                        } = this;
                        t.on(l.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(l.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(l.MANIFEST_LOADING, this.onManifestLoading, this), t.on(l.MANIFEST_PARSED, this.onManifestParsed, this), t.on(l.LEVEL_LOADING, this.onLevelLoading, this), t.on(l.LEVEL_SWITCHING, this.onLevelSwitching, this), t.on(l.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), t.on(l.ERROR, this.onError, this)
                    }
                    unregisterListeners() {
                        const {
                            hls: t
                        } = this;
                        t.off(l.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(l.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(l.MANIFEST_LOADING, this.onManifestLoading, this), t.off(l.MANIFEST_PARSED, this.onManifestParsed, this), t.off(l.LEVEL_LOADING, this.onLevelLoading, this), t.off(l.LEVEL_SWITCHING, this.onLevelSwitching, this), t.off(l.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), t.off(l.ERROR, this.onError, this)
                    }
                    onMediaAttached(t, e) {
                        this.media = e.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange))
                    }
                    pollTrackChange(t) {
                        self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, t)
                    }
                    onMediaDetaching(t, e) {
                        const i = this.media;
                        if (!i) return;
                        const s = !!e.transferMedia;
                        self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || i.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId), this.subtitleTrack = -1, this.media = null, s || Tn(i.textTracks).forEach((t => {
                            vn(t)
                        }))
                    }
                    onManifestLoading() {
                        this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0
                    }
                    onManifestParsed(t, e) {
                        this.tracks = e.subtitleTracks
                    }
                    onSubtitleTrackLoaded(t, e) {
                        const {
                            id: i,
                            groupId: s,
                            details: r
                        } = e, n = this.tracksInGroup[i];
                        if (!n || n.groupId !== s) return void this.warn(`Subtitle track with id:${i} and group:${s} not found in active group ${null==n?void 0:n.groupId}`);
                        const a = n.details;
                        n.details = e.details, this.log(`Subtitle track ${i} "${n.name}" lang:${n.lang} group:${s} loaded [${r.startSN}-${r.endSN}]`), i === this.trackId && this.playlistLoaded(i, e, a)
                    }
                    onLevelLoading(t, e) {
                        this.switchLevel(e.level)
                    }
                    onLevelSwitching(t, e) {
                        this.switchLevel(e.level)
                    }
                    switchLevel(t) {
                        const e = this.hls.levels[t];
                        if (!e) return;
                        const i = e.subtitleGroups || null,
                            s = this.groupIds;
                        let r = this.currentTrack;
                        if (!i || (null == s ? void 0 : s.length) !== (null == i ? void 0 : i.length) || null != i && i.some((t => -1 === (null == s ? void 0 : s.indexOf(t))))) {
                            this.groupIds = i, this.trackId = -1, this.currentTrack = null;
                            const t = this.tracks.filter((t => !i || -1 !== i.indexOf(t.groupId)));
                            if (t.length) this.selectDefaultTrack && !t.some((t => t.default)) && (this.selectDefaultTrack = !1), t.forEach(((t, e) => {
                                t.id = e
                            }));
                            else if (!r && !this.tracksInGroup.length) return;
                            this.tracksInGroup = t;
                            const e = this.hls.config.subtitlePreference;
                            if (!r && e) {
                                this.selectDefaultTrack = !1;
                                const i = Zt(e, t);
                                if (i > -1) r = t[i];
                                else {
                                    const t = Zt(e, this.tracks);
                                    r = this.tracks[t]
                                }
                            }
                            let s = this.findTrackId(r); - 1 === s && r && (s = this.findTrackId(null));
                            const n = {
                                subtitleTracks: t
                            };
                            this.log(`Updating subtitle tracks, ${t.length} track(s) found in "${null==i?void 0:i.join(",")}" group-id`), this.hls.trigger(l.SUBTITLE_TRACKS_UPDATED, n), -1 !== s && -1 === this.trackId && this.setSubtitleTrack(s)
                        }
                    }
                    findTrackId(t) {
                        const e = this.tracksInGroup,
                            i = this.selectDefaultTrack;
                        for (let s = 0; s < e.length; s++) {
                            const r = e[s];
                            if ((!i || r.default) && (i || t) && (!t || te(r, t))) return s
                        }
                        if (t) {
                            for (let i = 0; i < e.length; i++) {
                                const s = e[i];
                                if (Sr(t.attrs, s.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) return i
                            }
                            for (let i = 0; i < e.length; i++) {
                                const s = e[i];
                                if (Sr(t.attrs, s.attrs, ["LANGUAGE"])) return i
                            }
                        }
                        return -1
                    }
                    findTrackForTextTrack(t) {
                        if (t) {
                            const e = this.tracksInGroup;
                            for (let i = 0; i < e.length; i++)
                                if (wr(e[i], t)) return i
                        }
                        return -1
                    }
                    onError(t, e) {
                        !e.fatal && e.context && (e.context.type !== h || e.context.id !== this.trackId || this.groupIds && -1 === this.groupIds.indexOf(e.context.groupId) || this.checkRetry(e))
                    }
                    get allSubtitleTracks() {
                        return this.tracks
                    }
                    get subtitleTracks() {
                        return this.tracksInGroup
                    }
                    get subtitleTrack() {
                        return this.trackId
                    }
                    set subtitleTrack(t) {
                        this.selectDefaultTrack = !1, this.setSubtitleTrack(t)
                    }
                    setSubtitleOption(t) {
                        if (this.hls.config.subtitlePreference = t, t) {
                            if (-1 === t.id) return this.setSubtitleTrack(-1), null;
                            const e = this.allSubtitleTracks;
                            if (this.selectDefaultTrack = !1, e.length) {
                                const i = this.currentTrack;
                                if (i && te(t, i)) return i;
                                const s = Zt(t, this.tracksInGroup);
                                if (s > -1) {
                                    const t = this.tracksInGroup[s];
                                    return this.setSubtitleTrack(s), t
                                }
                                if (i) return null; {
                                    const i = Zt(t, e);
                                    if (i > -1) return e[i]
                                }
                            }
                        }
                        return null
                    }
                    loadPlaylist(t) {
                        super.loadPlaylist(), this.shouldLoadPlaylist(this.currentTrack) && this.scheduleLoading(this.currentTrack, t)
                    }
                    loadingPlaylist(t, e) {
                        super.loadingPlaylist(t, e);
                        const i = t.id,
                            s = t.groupId,
                            r = this.getUrlWithDirectives(t.url, e),
                            n = t.details,
                            a = null == n ? void 0 : n.age;
                        this.log(`Loading subtitle ${i} "${t.name}" lang:${t.lang} group:${s}${void 0!==(null==e?void 0:e.msn)?" at sn "+e.msn+" part "+e.part:""}${a&&n.live?" age "+a.toFixed(1)+(n.type?" "+n.type||0:""):""} ${r}`), this.hls.trigger(l.SUBTITLE_TRACK_LOADING, {
                            url: r,
                            id: i,
                            groupId: s,
                            deliveryDirectives: e || null,
                            track: t
                        })
                    }
                    toggleTrackModes() {
                        const {
                            media: t
                        } = this;
                        if (!t) return;
                        const e = Tn(t.textTracks),
                            i = this.currentTrack;
                        let s;
                        if (i && (s = e.filter((t => wr(i, t)))[0], s || this.warn(`Unable to find subtitle TextTrack with name "${i.name}" and language "${i.lang}"`)), [].slice.call(e).forEach((t => {
                                "disabled" !== t.mode && t !== s && (t.mode = "disabled")
                            })), s) {
                            const t = this.subtitleDisplay ? "showing" : "hidden";
                            s.mode !== t && (s.mode = t)
                        }
                    }
                    setSubtitleTrack(t) {
                        const e = this.tracksInGroup;
                        if (!this.media) return void(this.queuedDefaultTrack = t);
                        if (t < -1 || t >= e.length || !s(t)) return void this.warn(`Invalid subtitle track id: ${t}`);
                        this.selectDefaultTrack = !1;
                        const i = this.currentTrack,
                            r = e[t] || null;
                        if (this.trackId = t, this.currentTrack = r, this.toggleTrackModes(), !r) return void this.hls.trigger(l.SUBTITLE_TRACK_SWITCH, {
                            id: t
                        });
                        const n = !!r.details && !r.details.live;
                        if (t === this.trackId && r === i && n) return;
                        this.log(`Switching to subtitle-track ${t}` + (r ? ` "${r.name}" lang:${r.lang} group:${r.groupId}` : ""));
                        const {
                            id: a,
                            groupId: o = "",
                            name: c,
                            type: u,
                            url: d
                        } = r;
                        this.hls.trigger(l.SUBTITLE_TRACK_SWITCH, {
                            id: a,
                            groupId: o,
                            name: c,
                            type: u,
                            url: d
                        });
                        const h = this.switchParams(r.url, null == i ? void 0 : i.details, r.details);
                        this.loadPlaylist(h)
                    }
                },
                timelineController: class {
                    constructor(t) {
                        this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = {
                            ccOffset: 0,
                            presentationOffset: 0,
                            0: {
                                start: 0,
                                prevCC: -1,
                                new: !0
                            }
                        }, this.captionsProperties = void 0, this.hls = t, this.config = t.config, this.Cues = t.config.cueHandler, this.captionsProperties = {
                            textTrack1: {
                                label: this.config.captionsTextTrack1Label,
                                languageCode: this.config.captionsTextTrack1LanguageCode
                            },
                            textTrack2: {
                                label: this.config.captionsTextTrack2Label,
                                languageCode: this.config.captionsTextTrack2LanguageCode
                            },
                            textTrack3: {
                                label: this.config.captionsTextTrack3Label,
                                languageCode: this.config.captionsTextTrack3LanguageCode
                            },
                            textTrack4: {
                                label: this.config.captionsTextTrack4Label,
                                languageCode: this.config.captionsTextTrack4LanguageCode
                            }
                        }, t.on(l.MEDIA_ATTACHING, this.onMediaAttaching, this), t.on(l.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(l.MANIFEST_LOADING, this.onManifestLoading, this), t.on(l.MANIFEST_LOADED, this.onManifestLoaded, this), t.on(l.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), t.on(l.FRAG_LOADING, this.onFragLoading, this), t.on(l.FRAG_LOADED, this.onFragLoaded, this), t.on(l.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), t.on(l.FRAG_DECRYPTED, this.onFragDecrypted, this), t.on(l.INIT_PTS_FOUND, this.onInitPtsFound, this), t.on(l.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), t.on(l.BUFFER_FLUSHING, this.onBufferFlushing, this)
                    }
                    destroy() {
                        const {
                            hls: t
                        } = this;
                        t.off(l.MEDIA_ATTACHING, this.onMediaAttaching, this), t.off(l.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(l.MANIFEST_LOADING, this.onManifestLoading, this), t.off(l.MANIFEST_LOADED, this.onManifestLoaded, this), t.off(l.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), t.off(l.FRAG_LOADING, this.onFragLoading, this), t.off(l.FRAG_LOADED, this.onFragLoaded, this), t.off(l.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), t.off(l.FRAG_DECRYPTED, this.onFragDecrypted, this), t.off(l.INIT_PTS_FOUND, this.onInitPtsFound, this), t.off(l.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), t.off(l.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.media = null, this.cea608Parser1 = this.cea608Parser2 = void 0
                    }
                    initCea608Parsers() {
                        const t = new _a(this, "textTrack1"),
                            e = new _a(this, "textTrack2"),
                            i = new _a(this, "textTrack3"),
                            s = new _a(this, "textTrack4");
                        this.cea608Parser1 = new Zn(1, t, e), this.cea608Parser2 = new Zn(3, i, s)
                    }
                    addCues(t, e, i, s, r) {
                        let n = !1;
                        for (let t = r.length; t--;) {
                            const s = r[t],
                                l = (a = s[0], o = s[1], c = e, u = i, Math.min(o, u) - Math.max(a, c));
                            if (l >= 0 && (s[0] = Math.min(s[0], e), s[1] = Math.max(s[1], i), n = !0, l / (i - e) > .5)) return
                        }
                        var a, o, c, u;
                        if (n || r.push([e, i]), this.config.renderTextTracksNatively) {
                            const r = this.captionsTracks[t];
                            this.Cues.newCue(r, e, i, s)
                        } else {
                            const r = this.Cues.newCue(null, e, i, s);
                            this.hls.trigger(l.CUES_PARSED, {
                                type: "captions",
                                cues: r,
                                track: t
                            })
                        }
                    }
                    onInitPtsFound(t, {
                        frag: e,
                        id: i,
                        initPTS: s,
                        timescale: r
                    }) {
                        const {
                            unparsedVttFrags: n
                        } = this;
                        i === f && (this.initPTS[e.cc] = {
                            baseTime: s,
                            timescale: r
                        }), n.length && (this.unparsedVttFrags = [], n.forEach((t => {
                            this.onFragLoaded(l.FRAG_LOADED, t)
                        })))
                    }
                    getExistingTrack(t, e) {
                        const {
                            media: i
                        } = this;
                        if (i)
                            for (let s = 0; s < i.textTracks.length; s++) {
                                const r = i.textTracks[s];
                                if (Ra(r, {
                                        name: t,
                                        lang: e,
                                        characteristics: "transcribes-spoken-dialog,describes-music-and-sound"
                                    })) return r
                            }
                        return null
                    }
                    createCaptionsTrack(t) {
                        this.config.renderTextTracksNatively ? this.createNativeTrack(t) : this.createNonNativeTrack(t)
                    }
                    createNativeTrack(t) {
                        if (this.captionsTracks[t]) return;
                        const {
                            captionsProperties: e,
                            captionsTracks: i,
                            media: s
                        } = this, {
                            label: r,
                            languageCode: n
                        } = e[t], a = this.getExistingTrack(r, n);
                        if (a) i[t] = a, vn(i[t]), mn(i[t], s);
                        else {
                            const e = this.createTextTrack("captions", r, n);
                            e && (e[t] = !0, i[t] = e)
                        }
                    }
                    createNonNativeTrack(t) {
                        if (this.nonNativeCaptionsTracks[t]) return;
                        const e = this.captionsProperties[t];
                        if (!e) return;
                        const i = {
                            _id: t,
                            label: e.label,
                            kind: "captions",
                            default: !!e.media && !!e.media.default,
                            closedCaptions: e.media
                        };
                        this.nonNativeCaptionsTracks[t] = i, this.hls.trigger(l.NON_NATIVE_TEXT_TRACKS_FOUND, {
                            tracks: [i]
                        })
                    }
                    createTextTrack(t, e, i) {
                        const s = this.media;
                        if (s) return s.addTextTrack(t, e, i)
                    }
                    onMediaAttaching(t, e) {
                        this.media = e.media, e.mediaSource || this._cleanTracks()
                    }
                    onMediaDetaching(t, e) {
                        const i = !!e.transferMedia;
                        if (this.media = null, i) return;
                        const {
                            captionsTracks: s
                        } = this;
                        Object.keys(s).forEach((t => {
                            vn(s[t]), delete s[t]
                        })), this.nonNativeCaptionsTracks = {}
                    }
                    onManifestLoading() {
                        this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = {
                            ccOffset: 0,
                            presentationOffset: 0,
                            0: {
                                start: 0,
                                prevCC: -1,
                                new: !0
                            }
                        }, this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = [], this.initPTS = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset())
                    }
                    _cleanTracks() {
                        const {
                            media: t
                        } = this;
                        if (!t) return;
                        const e = t.textTracks;
                        if (e)
                            for (let t = 0; t < e.length; t++) vn(e[t])
                    }
                    onSubtitleTracksUpdated(t, e) {
                        const i = e.subtitleTracks || [],
                            s = i.some((t => t.textCodec === ga));
                        if (this.config.enableWebVTT || s && this.config.enableIMSC1) {
                            if (Er(this.tracks, i)) return void(this.tracks = i);
                            if (this.textTracks = [], this.tracks = i, this.config.renderTextTracksNatively) {
                                const t = this.media,
                                    e = t ? Tn(t.textTracks) : null;
                                if (this.tracks.forEach(((t, i) => {
                                        let s;
                                        if (e) {
                                            let i = null;
                                            for (let s = 0; s < e.length; s++)
                                                if (e[s] && Ra(e[s], t)) {
                                                    i = e[s], e[s] = null;
                                                    break
                                                }
                                            i && (s = i)
                                        }
                                        if (s) vn(s);
                                        else {
                                            const e = La(t);
                                            s = this.createTextTrack(e, t.name, t.lang), s && (s.mode = "disabled")
                                        }
                                        s && this.textTracks.push(s)
                                    })), null != e && e.length) {
                                    const t = e.filter((t => null !== t)).map((t => t.label));
                                    t.length && this.hls.logger.warn(`Media element contains unused subtitle tracks: ${t.join(", ")}. Replace media element for each source to clear TextTracks and captions menu.`)
                                }
                            } else if (this.tracks.length) {
                                const t = this.tracks.map((t => ({
                                    label: t.name,
                                    kind: t.type.toLowerCase(),
                                    default: t.default,
                                    subtitleTrack: t
                                })));
                                this.hls.trigger(l.NON_NATIVE_TEXT_TRACKS_FOUND, {
                                    tracks: t
                                })
                            }
                        }
                    }
                    onManifestLoaded(t, e) {
                        this.config.enableCEA708Captions && e.captions && e.captions.forEach((t => {
                            const e = /(?:CC|SERVICE)([1-4])/.exec(t.instreamId);
                            if (!e) return;
                            const i = `textTrack${e[1]}`,
                                s = this.captionsProperties[i];
                            s && (s.label = t.name, t.lang && (s.languageCode = t.lang), s.media = t)
                        }))
                    }
                    closedCaptionsForLevel(t) {
                        const e = this.hls.levels[t.level];
                        return null == e ? void 0 : e.attrs["CLOSED-CAPTIONS"]
                    }
                    onFragLoading(t, e) {
                        if (this.enabled && e.frag.type === f) {
                            var i, s;
                            const {
                                cea608Parser1: t,
                                cea608Parser2: r,
                                lastSn: n
                            } = this, {
                                cc: a,
                                sn: o
                            } = e.frag, l = null != (i = null == (s = e.part) ? void 0 : s.index) ? i : -1;
                            t && r && (o !== n + 1 || o === n && l !== this.lastPartIndex + 1 || a !== this.lastCc) && (t.reset(), r.reset()), this.lastCc = a, this.lastSn = o, this.lastPartIndex = l
                        }
                    }
                    onFragLoaded(t, e) {
                        const {
                            frag: i,
                            payload: s
                        } = e;
                        if (i.type === g)
                            if (s.byteLength) {
                                const t = i.decryptdata,
                                    r = "stats" in e;
                                if (null == t || !t.encrypted || r) {
                                    const t = this.tracks[i.level],
                                        r = this.vttCCs;
                                    r[i.cc] || (r[i.cc] = {
                                        start: i.start,
                                        prevCC: this.prevCC,
                                        new: !0
                                    }, this.prevCC = i.cc), t && t.textCodec === ga ? this._parseIMSC1(i, s) : this._parseVTTs(e)
                                }
                            } else this.hls.trigger(l.SUBTITLE_FRAG_PROCESSED, {
                                success: !1,
                                frag: i,
                                error: new Error("Empty subtitle payload")
                            })
                    }
                    _parseIMSC1(t, e) {
                        const i = this.hls;
                        ba(e, this.initPTS[t.cc], (e => {
                            this._appendCues(e, t.level), i.trigger(l.SUBTITLE_FRAG_PROCESSED, {
                                success: !0,
                                frag: t
                            })
                        }), (e => {
                            i.logger.log(`Failed to parse IMSC1: ${e}`), i.trigger(l.SUBTITLE_FRAG_PROCESSED, {
                                success: !1,
                                frag: t,
                                error: e
                            })
                        }))
                    }
                    _parseVTTs(t) {
                        var e;
                        const {
                            frag: i,
                            payload: r
                        } = t, {
                            initPTS: n,
                            unparsedVttFrags: a
                        } = this, o = n.length - 1;
                        if (!n[i.cc] && -1 === o) return void a.push(t);
                        const c = this.hls;
                        ! function(t, e, i, r, n, a, o) {
                            const l = new da,
                                c = D(new Uint8Array(t)).trim().replace(ha, "\n").split("\n"),
                                u = [],
                                d = e ? function(t, e = 1) {
                                    return er(t, 9e4, 1 / e)
                                }(e.baseTime, e.timescale) : 0;
                            let h, f = "00:00.000",
                                p = 0,
                                g = 0,
                                m = !0;
                            l.oncue = function(t) {
                                const s = i[r];
                                let a = i.ccOffset;
                                const o = (p - d) / 9e4;
                                if (null != s && s.new && (void 0 !== g ? a = i.ccOffset = s.start : function(t, e, i) {
                                        let s = t[e],
                                            r = t[s.prevCC];
                                        if (!r || !r.new && s.new) return t.ccOffset = t.presentationOffset = s.start, void(s.new = !1);
                                        for (; null != (n = r) && n.new;) {
                                            var n;
                                            t.ccOffset += s.start - r.start, s.new = !1, s = r, r = t[s.prevCC]
                                        }
                                        t.presentationOffset = i
                                    }(i, r, o)), o) {
                                    if (!e) return void(h = new Error("Missing initPTS for VTT MPEGTS"));
                                    a = o - i.presentationOffset
                                }
                                const l = t.endTime - t.startTime,
                                    c = lr(9e4 * (t.startTime + a - g), 9e4 * n) / 9e4;
                                t.startTime = Math.max(c, 0), t.endTime = Math.max(c + l, 0);
                                const f = t.text.trim();
                                t.text = decodeURIComponent(encodeURIComponent(f)), t.id || (t.id = pa(t.startTime, t.endTime, f)), t.endTime > 0 && u.push(t)
                            }, l.onparsingerror = function(t) {
                                h = t
                            }, l.onflush = function() {
                                h ? o(h) : a(u)
                            }, c.forEach((t => {
                                if (m) {
                                    if (fa(t, "X-TIMESTAMP-MAP=")) {
                                        m = !1, t.slice(16).split(",").forEach((t => {
                                            fa(t, "LOCAL:") ? f = t.slice(6) : fa(t, "MPEGTS:") && (p = parseInt(t.slice(7)))
                                        }));
                                        try {
                                            g = function(t) {
                                                let e = parseInt(t.slice(-3));
                                                const i = parseInt(t.slice(-6, -4)),
                                                    r = parseInt(t.slice(-9, -7)),
                                                    n = t.length > 9 ? parseInt(t.substring(0, t.indexOf(":"))) : 0;
                                                if (!(s(e) && s(i) && s(r) && s(n))) throw Error(`Malformed X-TIMESTAMP-MAP: Local:${t}`);
                                                return e += 1e3 * i, e += 6e4 * r, e += 36e5 * n, e
                                            }(f) / 1e3
                                        } catch (t) {
                                            h = t
                                        }
                                        return
                                    }
                                    "" === t && (m = !1)
                                }
                                l.parse(t + "\n")
                            })), l.flush()
                        }(null != (e = i.initSegment) && e.data ? mt(i.initSegment.data, new Uint8Array(r)).buffer : r, this.initPTS[i.cc], this.vttCCs, i.cc, i.start, (t => {
                            this._appendCues(t, i.level), c.trigger(l.SUBTITLE_FRAG_PROCESSED, {
                                success: !0,
                                frag: i
                            })
                        }), (e => {
                            const s = "Missing initPTS for VTT MPEGTS" === e.message;
                            s ? a.push(t) : this._fallbackToIMSC1(i, r), c.logger.log(`Failed to parse VTT cue: ${e}`), s && o > i.cc || c.trigger(l.SUBTITLE_FRAG_PROCESSED, {
                                success: !1,
                                frag: i,
                                error: e
                            })
                        }))
                    }
                    _fallbackToIMSC1(t, e) {
                        const i = this.tracks[t.level];
                        i.textCodec || ba(e, this.initPTS[t.cc], (() => {
                            i.textCodec = ga, this._parseIMSC1(t, e)
                        }), (() => {
                            i.textCodec = "wvtt"
                        }))
                    }
                    _appendCues(t, e) {
                        const i = this.hls;
                        if (this.config.renderTextTracksNatively) {
                            const i = this.textTracks[e];
                            if (!i || "disabled" === i.mode) return;
                            t.forEach((t => yn(i, t)))
                        } else {
                            const s = this.tracks[e];
                            if (!s) return;
                            const r = s.default ? "default" : "subtitles" + e;
                            i.trigger(l.CUES_PARSED, {
                                type: "subtitles",
                                cues: t,
                                track: r
                            })
                        }
                    }
                    onFragDecrypted(t, e) {
                        const {
                            frag: i
                        } = e;
                        i.type === g && this.onFragLoaded(l.FRAG_LOADED, e)
                    }
                    onSubtitleTracksCleared() {
                        this.tracks = [], this.captionsTracks = {}
                    }
                    onFragParsingUserdata(t, e) {
                        if (!this.enabled || !this.config.enableCEA708Captions) return;
                        const {
                            frag: i,
                            samples: s
                        } = e;
                        if (i.type !== f || "NONE" !== this.closedCaptionsForLevel(i))
                            for (let t = 0; t < s.length; t++) {
                                const e = s[t].bytes;
                                if (e) {
                                    this.cea608Parser1 || this.initCea608Parsers();
                                    const i = this.extractCea608Data(e);
                                    this.cea608Parser1.addData(s[t].pts, i[0]), this.cea608Parser2.addData(s[t].pts, i[1])
                                }
                            }
                    }
                    onBufferFlushing(t, {
                        startOffset: e,
                        endOffset: i,
                        endOffsetSubtitles: s,
                        type: r
                    }) {
                        const {
                            media: n
                        } = this;
                        if (n && !(n.currentTime < i)) {
                            if (!r || "video" === r) {
                                const {
                                    captionsTracks: t
                                } = this;
                                Object.keys(t).forEach((s => bn(t[s], e, i)))
                            }
                            if (this.config.renderTextTracksNatively && 0 === e && void 0 !== s) {
                                const {
                                    textTracks: t
                                } = this;
                                Object.keys(t).forEach((i => bn(t[i], e, s)))
                            }
                        }
                    }
                    extractCea608Data(t) {
                        const e = [
                                [],
                                []
                            ],
                            i = 31 & t[0];
                        let s = 2;
                        for (let r = 0; r < i; r++) {
                            const i = t[s++],
                                r = 127 & t[s++],
                                n = 127 & t[s++];
                            if ((0 !== r || 0 !== n) && 0 != (4 & i)) {
                                const t = 3 & i;
                                0 !== t && 1 !== t || (e[t].push(r), e[t].push(n))
                            }
                        }
                        return e
                    }
                },
                audioStreamController: class extends Vi {
                    constructor(t, e, i) {
                        super(t, e, i, "audio-stream-controller", p), this.mainAnchor = null, this.mainFragLoading = null, this.audioOnly = !1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.flushing = !1, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this.registerListeners()
                    }
                    onHandlerDestroying() {
                        this.unregisterListeners(), super.onHandlerDestroying(), this.resetItem()
                    }
                    resetItem() {
                        this.mainDetails = this.mainAnchor = this.mainFragLoading = this.bufferedTrack = this.switchingTrack = this.waitingData = this.cachedTrackLoadedData = null
                    }
                    registerListeners() {
                        super.registerListeners();
                        const {
                            hls: t
                        } = this;
                        t.on(l.LEVEL_LOADED, this.onLevelLoaded, this), t.on(l.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), t.on(l.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.on(l.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), t.on(l.BUFFER_RESET, this.onBufferReset, this), t.on(l.BUFFER_CREATED, this.onBufferCreated, this), t.on(l.BUFFER_FLUSHING, this.onBufferFlushing, this), t.on(l.BUFFER_FLUSHED, this.onBufferFlushed, this), t.on(l.INIT_PTS_FOUND, this.onInitPtsFound, this), t.on(l.FRAG_LOADING, this.onFragLoading, this), t.on(l.FRAG_BUFFERED, this.onFragBuffered, this)
                    }
                    unregisterListeners() {
                        const {
                            hls: t
                        } = this;
                        t && (super.unregisterListeners(), t.off(l.LEVEL_LOADED, this.onLevelLoaded, this), t.off(l.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), t.off(l.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.off(l.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), t.off(l.BUFFER_RESET, this.onBufferReset, this), t.off(l.BUFFER_CREATED, this.onBufferCreated, this), t.off(l.BUFFER_FLUSHING, this.onBufferFlushing, this), t.off(l.BUFFER_FLUSHED, this.onBufferFlushed, this), t.off(l.INIT_PTS_FOUND, this.onInitPtsFound, this), t.off(l.FRAG_LOADING, this.onFragLoading, this), t.off(l.FRAG_BUFFERED, this.onFragBuffered, this))
                    }
                    onInitPtsFound(t, {
                        frag: e,
                        id: i,
                        initPTS: s,
                        timescale: r
                    }) {
                        if (i === f) {
                            const t = e.cc,
                                i = this.fragCurrent;
                            if (this.initPTS[t] = {
                                    baseTime: s,
                                    timescale: r
                                }, this.log(`InitPTS for cc: ${t} found from main: ${s}/${r}`), this.mainAnchor = e, this.state === Gi.WAITING_INIT_PTS) {
                                const i = this.waitingData;
                                (!i && !this.loadingParts || i && i.frag.cc !== t) && (this.nextLoadPosition = this.findSyncFrag(e).start), this.tick()
                            } else !this.hls.hasEnoughToStart && i && i.cc !== t ? (this.startFragRequested = !1, this.nextLoadPosition = this.findSyncFrag(e).start, i.abortRequests(), this.resetLoadingState()) : this.state === Gi.IDLE && this.tick()
                        }
                    }
                    findSyncFrag(t) {
                        const e = this.getLevelDetails(),
                            i = t.cc;
                        return function(t, e, i) {
                            if (t && t.startCC <= e && t.endCC >= e) {
                                const s = i.start,
                                    r = i.end;
                                let n = t.fragments;
                                if (!i.relurl) {
                                    const {
                                        fragmentHint: e
                                    } = t;
                                    e && (n = n.concat(e))
                                }
                                return re(n, (t => t.cc < e || t.end <= s ? 1 : t.cc > e || t.start >= r ? -1 : 0))
                            }
                            return null
                        }(e, i, t) || e && le(e.fragments, i) || t
                    }
                    startLoad(t, e) {
                        if (!this.levels) return this.startPosition = t, void(this.state = Gi.STOPPED);
                        const i = this.lastCurrentTime;
                        this.stopLoad(), this.setInterval(100), i > 0 && -1 === t ? (this.log(`Override startPosition with lastCurrentTime @${i.toFixed(3)}`), t = i, this.state = Gi.IDLE) : this.state = Gi.WAITING_TRACK, this.nextLoadPosition = this.lastCurrentTime = t + this.timelineOffset, this.startPosition = e ? -1 : t, this.tick()
                    }
                    doTick() {
                        switch (this.state) {
                            case Gi.IDLE:
                                this.doTickIdle();
                                break;
                            case Gi.WAITING_TRACK:
                                {
                                    const {
                                        levels: t,
                                        trackId: e
                                    } = this,
                                    i = null == t ? void 0 : t[e],
                                    s = null == i ? void 0 : i.details;
                                    if (s && !this.waitForLive(i)) {
                                        if (this.waitForCdnTuneIn(s)) break;
                                        this.state = Gi.WAITING_INIT_PTS
                                    }
                                    break
                                }
                            case Gi.FRAG_LOADING_WAITING_RETRY:
                                {
                                    var t;
                                    const e = performance.now(),
                                        i = this.retryDate;
                                    if (!i || e >= i || null != (t = this.media) && t.seeking) {
                                        const {
                                            levels: t,
                                            trackId: e
                                        } = this;
                                        this.log("RetryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded((null == t ? void 0 : t[e]) || null), this.state = Gi.IDLE
                                    }
                                    break
                                }
                            case Gi.WAITING_INIT_PTS:
                                {
                                    const t = this.waitingData;
                                    if (t) {
                                        const {
                                            frag: e,
                                            part: i,
                                            cache: s,
                                            complete: r
                                        } = t, n = this.mainAnchor;
                                        if (void 0 !== this.initPTS[e.cc]) {
                                            this.waitingData = null, this.state = Gi.FRAG_LOADING;
                                            const t = {
                                                frag: e,
                                                part: i,
                                                payload: s.flush().buffer,
                                                networkDetails: null
                                            };
                                            this._handleFragmentLoadProgress(t), r && super._handleFragmentLoadComplete(t)
                                        } else n && n.cc !== t.frag.cc && (this.log(`Waiting fragment cc (${e.cc}) cancelled because video is at cc ${n.cc}`), this.nextLoadPosition = this.findSyncFrag(n).start, this.clearWaitingFragment())
                                    } else this.state = Gi.IDLE
                                }
                        }
                        this.onTickEnd()
                    }
                    clearWaitingFragment() {
                        const t = this.waitingData;
                        t && (this.hls.hasEnoughToStart || (this.startFragRequested = !1), this.fragmentTracker.removeFragment(t.frag), this.waitingData = null, this.state !== Gi.STOPPED && (this.state = Gi.IDLE))
                    }
                    resetLoadingState() {
                        this.clearWaitingFragment(), super.resetLoadingState()
                    }
                    onTickEnd() {
                        const {
                            media: t
                        } = this;
                        null != t && t.readyState && (this.lastCurrentTime = t.currentTime)
                    }
                    doTickIdle() {
                        var t;
                        const {
                            hls: e,
                            levels: i,
                            media: s,
                            trackId: r
                        } = this, n = e.config;
                        if (!this.buffering || !s && !this.primaryPrefetch && (this.startFragRequested || !n.startFragPrefetch) || null == i || !i[r]) return;
                        const a = i[r],
                            o = a.details;
                        if (!o || this.waitForLive(a) || this.waitForCdnTuneIn(o)) return this.state = Gi.WAITING_TRACK, void(this.startFragRequested = !1);
                        const c = this.mediaBuffer ? this.mediaBuffer : this.media;
                        this.bufferFlushed && c && (this.bufferFlushed = !1, this.afterBufferFlushed(c, V, p));
                        const u = this.getFwdBufferInfo(c, p);
                        if (null === u) return;
                        if (!this.switchingTrack && this._streamEnded(u, o)) return e.trigger(l.BUFFER_EOS, {
                            type: "audio"
                        }), void(this.state = Gi.ENDED);
                        const d = u.len,
                            h = e.maxBufferLength,
                            g = o.fragments,
                            m = g[0].start,
                            y = this.getLoadPosition(),
                            v = this.flushing ? y : u.end;
                        if (this.switchingTrack && s) {
                            const t = y;
                            o.PTSKnown && t < m && (u.end > m || u.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), s.currentTime = m + .05)
                        }
                        if (d >= h && !this.switchingTrack && v < g[g.length - 1].start) return;
                        let b = this.getNextFragment(v, o);
                        if (b && this.isLoopLoading(b, v) && (b = this.getNextFragmentLoopLoading(b, o, u, f, h)), !b) return void(this.bufferFlushed = !0);
                        let T = (null == (t = this.mainFragLoading) ? void 0 : t.frag) || null;
                        if (!this.audioOnly && this.startFragRequested && T && q(b) && !b.endList && (!o.live || !this.loadingParts && v < this.hls.liveSyncPosition) && (this.fragmentTracker.getState(T) === ve && (this.mainFragLoading = T = null), T && q(T))) {
                            if (b.start > T.end) {
                                const t = this.fragmentTracker.getFragAtPos(v, f);
                                t && t.end > T.end && (T = t, this.mainFragLoading = {
                                    frag: t,
                                    targetBufferTime: null
                                })
                            }
                            if (b.start > T.end) return
                        }
                        this.loadFragment(b, a, v)
                    }
                    onMediaDetaching(t, e) {
                        this.bufferFlushed = this.flushing = !1, super.onMediaDetaching(t, e)
                    }
                    onAudioTracksUpdated(t, {
                        audioTracks: e
                    }) {
                        this.resetTransmuxer(), this.levels = e.map((t => new qt(t)))
                    }
                    onAudioTrackSwitching(t, e) {
                        const i = !!e.url;
                        this.trackId = e.id;
                        const {
                            fragCurrent: s
                        } = this;
                        s && (s.abortRequests(), this.removeUnbufferedFrags(s.start)), this.resetLoadingState(), i ? (this.switchingTrack = e, this.flushAudioIfNeeded(e), this.state !== Gi.STOPPED && (this.setInterval(100), this.state = Gi.IDLE, this.tick())) : (this.resetTransmuxer(), this.switchingTrack = null, this.bufferedTrack = e, this.clearInterval())
                    }
                    onManifestLoading() {
                        super.onManifestLoading(), this.bufferFlushed = this.flushing = this.audioOnly = !1, this.resetItem(), this.trackId = -1
                    }
                    onLevelLoaded(t, e) {
                        this.mainDetails = e.details;
                        const i = this.cachedTrackLoadedData;
                        i && (this.cachedTrackLoadedData = null, this.onAudioTrackLoaded(l.AUDIO_TRACK_LOADED, i))
                    }
                    onAudioTrackLoaded(t, e) {
                        var i;
                        const {
                            levels: s
                        } = this, {
                            details: r,
                            id: n,
                            groupId: a,
                            track: o
                        } = e;
                        if (!s) return void this.warn(`Audio tracks reset while loading track ${n} "${o.name}" of "${a}"`);
                        const c = this.mainDetails;
                        if (!c || r.endCC > c.endCC || c.expired) return this.cachedTrackLoadedData = e, void(this.state !== Gi.STOPPED && (this.state = Gi.WAITING_TRACK));
                        this.cachedTrackLoadedData = null, this.log(`Audio track ${n} "${o.name}" of "${a}" loaded [${r.startSN},${r.endSN}]${r.lastPartSn?`[part-${r.lastPartSn}-${r.lastPartIndex}]`:""},duration:${r.totalduration}`);
                        const u = s[n];
                        let d = 0;
                        if (r.live || null != (i = u.details) && i.live) {
                            if (this.checkLiveUpdate(r), r.deltaUpdateFailed) return;
                            var h;
                            u.details && (d = this.alignPlaylists(r, u.details, null == (h = this.levelLastLoaded) ? void 0 : h.details)), r.alignedSliding || (Bi(r, c), r.alignedSliding || ji(r, c), d = r.fragmentStart)
                        }
                        u.details = r, this.levelLastLoaded = u, this.startFragRequested || this.setStartPosition(c, d), this.hls.trigger(l.AUDIO_TRACK_UPDATED, {
                            details: r,
                            id: n,
                            groupId: e.groupId
                        }), this.state !== Gi.WAITING_TRACK || this.waitForCdnTuneIn(r) || (this.state = Gi.IDLE), this.tick()
                    }
                    _handleFragmentLoadProgress(t) {
                        var e;
                        const i = t.frag,
                            {
                                part: s,
                                payload: r
                            } = t,
                            {
                                config: n,
                                trackId: a,
                                levels: o
                            } = this;
                        if (!o) return void this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${i.sn} of level ${i.level} will not be buffered`);
                        const l = o[a];
                        if (!l) return void this.warn("Audio track is undefined on fragment load progress");
                        const c = l.details;
                        if (!c) return this.warn("Audio track details undefined on fragment load progress"), void this.removeUnbufferedFrags(i.start);
                        const u = n.defaultAudioCodec || l.audioCodec || "mp4a.40.2";
                        let d = this.transmuxer;
                        d || (d = this.transmuxer = new br(this.hls, p, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)));
                        const h = this.initPTS[i.cc],
                            f = null == (e = i.initSegment) ? void 0 : e.data;
                        if (void 0 !== h) {
                            const t = !1,
                                e = s ? s.index : -1,
                                n = -1 !== e,
                                a = new xe(i.level, i.sn, i.stats.chunkCount, r.byteLength, e, n);
                            d.push(r, f, u, "", i, s, c.totalduration, t, a, h)
                        } else {
                            this.log(`Unknown video PTS for cc ${i.cc}, waiting for video PTS before demuxing audio frag ${i.sn} of [${c.startSN} ,${c.endSN}],track ${a}`);
                            const {
                                cache: t
                            } = this.waitingData = this.waitingData || {
                                frag: i,
                                part: s,
                                cache: new Ki,
                                complete: !1
                            };
                            t.push(new Uint8Array(r)), this.state !== Gi.STOPPED && (this.state = Gi.WAITING_INIT_PTS)
                        }
                    }
                    _handleFragmentLoadComplete(t) {
                        this.waitingData ? this.waitingData.complete = !0 : super._handleFragmentLoadComplete(t)
                    }
                    onBufferReset() {
                        this.mediaBuffer = null
                    }
                    onBufferCreated(t, e) {
                        this.bufferFlushed = this.flushing = !1;
                        const i = e.tracks.audio;
                        i && (this.mediaBuffer = i.buffer || null)
                    }
                    onFragLoading(t, e) {
                        !this.audioOnly && e.frag.type === f && q(e.frag) && (this.mainFragLoading = e, this.state === Gi.IDLE && this.tick())
                    }
                    onFragBuffered(t, e) {
                        const {
                            frag: i,
                            part: s
                        } = e;
                        if (i.type === p)
                            if (this.fragContextChanged(i)) this.warn(`Fragment ${i.sn}${s?" p: "+s.index:""} of level ${i.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack?this.switchingTrack.name:"false"}`);
                            else {
                                if (q(i)) {
                                    this.fragPrevious = i;
                                    const t = this.switchingTrack;
                                    t && (this.bufferedTrack = t, this.switchingTrack = null, this.hls.trigger(l.AUDIO_TRACK_SWITCHED, E({}, t)))
                                }
                                this.fragBufferedComplete(i, s), this.media && this.tick()
                            }
                        else this.audioOnly || i.type !== f || i.elementaryStreams.video || i.elementaryStreams.audiovideo || (this.audioOnly = !0, this.mainFragLoading = null)
                    }
                    onError(t, e) {
                        var i;
                        if (e.fatal) this.state = Gi.ERROR;
                        else switch (e.details) {
                            case o.FRAG_GAP:
                            case o.FRAG_PARSING_ERROR:
                            case o.FRAG_DECRYPT_ERROR:
                            case o.FRAG_LOAD_ERROR:
                            case o.FRAG_LOAD_TIMEOUT:
                            case o.KEY_LOAD_ERROR:
                            case o.KEY_LOAD_TIMEOUT:
                                this.onFragmentOrKeyLoadError(p, e);
                                break;
                            case o.AUDIO_TRACK_LOAD_ERROR:
                            case o.AUDIO_TRACK_LOAD_TIMEOUT:
                            case o.LEVEL_PARSING_ERROR:
                                e.levelRetry || this.state !== Gi.WAITING_TRACK || (null == (i = e.context) ? void 0 : i.type) !== d || (this.state = Gi.IDLE);
                                break;
                            case o.BUFFER_ADD_CODEC_ERROR:
                            case o.BUFFER_APPEND_ERROR:
                                if ("audio" !== e.parent) return;
                                this.resetLoadingState();
                                break;
                            case o.BUFFER_FULL_ERROR:
                                if ("audio" !== e.parent) return;
                                this.reduceLengthAndFlushBuffer(e) && (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"));
                                break;
                            case o.INTERNAL_EXCEPTION:
                                this.recoverWorkerError(e)
                        }
                    }
                    onBufferFlushing(t, {
                        type: e
                    }) {
                        e !== H && (this.flushing = !0)
                    }
                    onBufferFlushed(t, {
                        type: e
                    }) {
                        if (e !== H) {
                            this.flushing = !1, this.bufferFlushed = !0, this.state === Gi.ENDED && (this.state = Gi.IDLE);
                            const t = this.mediaBuffer || this.media;
                            t && (this.afterBufferFlushed(t, e, p), this.tick())
                        }
                    }
                    _handleTransmuxComplete(t) {
                        var e;
                        const i = "audio",
                            {
                                hls: s
                            } = this,
                            {
                                remuxResult: r,
                                chunkMeta: n
                            } = t,
                            a = this.getCurrentContext(n);
                        if (!a) return void this.resetWhenMissingContext(n);
                        const {
                            frag: o,
                            part: c,
                            level: u
                        } = a, {
                            details: d
                        } = u, {
                            audio: h,
                            text: f,
                            id3: p,
                            initSegment: g
                        } = r;
                        if (!this.fragContextChanged(o) && d) {
                            if (this.state = Gi.PARSING, this.switchingTrack && h && this.completeAudioSwitch(this.switchingTrack), null != g && g.tracks) {
                                const t = o.initSegment || o;
                                this._bufferInitSegment(u, g.tracks, t, n), s.trigger(l.FRAG_PARSING_INIT_SEGMENT, {
                                    frag: t,
                                    id: i,
                                    tracks: g.tracks
                                })
                            }
                            if (h) {
                                const {
                                    startPTS: t,
                                    endPTS: e,
                                    startDTS: i,
                                    endDTS: s
                                } = h;
                                c && (c.elementaryStreams[V] = {
                                    startPTS: t,
                                    endPTS: e,
                                    startDTS: i,
                                    endDTS: s
                                }), o.setElementaryStreamInfo(V, t, e, i, s), this.bufferFragmentData(h, o, c, n)
                            }
                            if (null != p && null != (e = p.samples) && e.length) {
                                const t = b({
                                    id: i,
                                    frag: o,
                                    details: d
                                }, p);
                                s.trigger(l.FRAG_PARSING_METADATA, t)
                            }
                            if (f) {
                                const t = b({
                                    id: i,
                                    frag: o,
                                    details: d
                                }, f);
                                s.trigger(l.FRAG_PARSING_USERDATA, t)
                            }
                        } else this.fragmentTracker.removeFragment(o)
                    }
                    _bufferInitSegment(t, e, i, s) {
                        if (this.state !== Gi.PARSING) return;
                        if (e.video && delete e.video, e.audiovideo && delete e.audiovideo, !e.audio) return;
                        const r = e.audio;
                        r.id = p;
                        const n = t.audioCodec;
                        this.log(`Init audio buffer, container:${r.container}, codecs[level/parsed]=[${n}/${r.codec}]`), n && 1 === n.split(",").length && (r.levelCodec = n), this.hls.trigger(l.BUFFER_CODECS, e);
                        const a = r.initSegment;
                        if (null != a && a.byteLength) {
                            const t = {
                                type: "audio",
                                frag: i,
                                part: null,
                                chunkMeta: s,
                                parent: i.type,
                                data: a
                            };
                            this.hls.trigger(l.BUFFER_APPENDING, t)
                        }
                        this.tickImmediate()
                    }
                    loadFragment(t, e, i) {
                        const s = this.fragmentTracker.getState(t);
                        var r;
                        if (this.switchingTrack || s === ge || s === ye)
                            if (q(t))
                                if (null != (r = e.details) && r.live && !this.initPTS[t.cc]) {
                                    this.log(`Waiting for video PTS in continuity counter ${t.cc} of live stream before loading audio fragment ${t.sn} of level ${this.trackId}`), this.state = Gi.WAITING_INIT_PTS;
                                    const i = this.mainDetails;
                                    i && i.fragmentStart !== e.details.fragmentStart && ji(e.details, i)
                                } else super.loadFragment(t, e, i);
                        else this._loadInitSegment(t, e);
                        else this.clearTrackerIfNeeded(t)
                    }
                    flushAudioIfNeeded(t) {
                        if (this.media && this.bufferedTrack) {
                            const {
                                name: e,
                                lang: i,
                                assocLang: s,
                                characteristics: r,
                                audioCodec: n,
                                channels: a
                            } = this.bufferedTrack;
                            te({
                                name: e,
                                lang: i,
                                assocLang: s,
                                characteristics: r,
                                audioCodec: n,
                                channels: a
                            }, t, ee) || (se(t.url, this.hls) ? (this.log("Switching audio track : flushing all audio"), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"), this.bufferedTrack = null) : this.bufferedTrack = t)
                        }
                    }
                    completeAudioSwitch(t) {
                        const {
                            hls: e
                        } = this;
                        this.flushAudioIfNeeded(t), this.bufferedTrack = t, this.switchingTrack = null, e.trigger(l.AUDIO_TRACK_SWITCHED, E({}, t))
                    }
                },
                audioTrackController: class extends Tr {
                    constructor(t) {
                        super(t, "audio-track-controller"), this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners()
                    }
                    registerListeners() {
                        const {
                            hls: t
                        } = this;
                        t.on(l.MANIFEST_LOADING, this.onManifestLoading, this), t.on(l.MANIFEST_PARSED, this.onManifestParsed, this), t.on(l.LEVEL_LOADING, this.onLevelLoading, this), t.on(l.LEVEL_SWITCHING, this.onLevelSwitching, this), t.on(l.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), t.on(l.ERROR, this.onError, this)
                    }
                    unregisterListeners() {
                        const {
                            hls: t
                        } = this;
                        t.off(l.MANIFEST_LOADING, this.onManifestLoading, this), t.off(l.MANIFEST_PARSED, this.onManifestParsed, this), t.off(l.LEVEL_LOADING, this.onLevelLoading, this), t.off(l.LEVEL_SWITCHING, this.onLevelSwitching, this), t.off(l.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), t.off(l.ERROR, this.onError, this)
                    }
                    destroy() {
                        this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy()
                    }
                    onManifestLoading() {
                        this.tracks = [], this.tracksInGroup = [], this.groupIds = null, this.currentTrack = null, this.trackId = -1, this.selectDefaultTrack = !0
                    }
                    onManifestParsed(t, e) {
                        this.tracks = e.audioTracks || []
                    }
                    onAudioTrackLoaded(t, e) {
                        const {
                            id: i,
                            groupId: s,
                            details: r
                        } = e, n = this.tracksInGroup[i];
                        if (!n || n.groupId !== s) return void this.warn(`Audio track with id:${i} and group:${s} not found in active group ${null==n?void 0:n.groupId}`);
                        const a = n.details;
                        n.details = e.details, this.log(`Audio track ${i} "${n.name}" lang:${n.lang} group:${s} loaded [${r.startSN}-${r.endSN}]`), i === this.trackId && this.playlistLoaded(i, e, a)
                    }
                    onLevelLoading(t, e) {
                        this.switchLevel(e.level)
                    }
                    onLevelSwitching(t, e) {
                        this.switchLevel(e.level)
                    }
                    switchLevel(t) {
                        const e = this.hls.levels[t];
                        if (!e) return;
                        const i = e.audioGroups || null,
                            s = this.groupIds;
                        let r = this.currentTrack;
                        if (!i || (null == s ? void 0 : s.length) !== (null == i ? void 0 : i.length) || null != i && i.some((t => -1 === (null == s ? void 0 : s.indexOf(t))))) {
                            this.groupIds = i, this.trackId = -1, this.currentTrack = null;
                            const t = this.tracks.filter((t => !i || -1 !== i.indexOf(t.groupId)));
                            if (t.length) this.selectDefaultTrack && !t.some((t => t.default)) && (this.selectDefaultTrack = !1), t.forEach(((t, e) => {
                                t.id = e
                            }));
                            else if (!r && !this.tracksInGroup.length) return;
                            this.tracksInGroup = t;
                            const e = this.hls.config.audioPreference;
                            if (!r && e) {
                                const i = Zt(e, t, ee);
                                if (i > -1) r = t[i];
                                else {
                                    const t = Zt(e, this.tracks);
                                    r = this.tracks[t]
                                }
                            }
                            let s = this.findTrackId(r); - 1 === s && r && (s = this.findTrackId(null));
                            const c = {
                                audioTracks: t
                            };
                            this.log(`Updating audio tracks, ${t.length} track(s) found in group(s): ${null==i?void 0:i.join(",")}`), this.hls.trigger(l.AUDIO_TRACKS_UPDATED, c);
                            const u = this.trackId;
                            if (-1 !== s && -1 === u) this.setAudioTrack(s);
                            else if (t.length && -1 === u) {
                                var n;
                                const e = new Error(`No audio track selected for current audio group-ID(s): ${null==(n=this.groupIds)?void 0:n.join(",")} track count: ${t.length}`);
                                this.warn(e.message), this.hls.trigger(l.ERROR, {
                                    type: a.MEDIA_ERROR,
                                    details: o.AUDIO_TRACK_LOAD_ERROR,
                                    fatal: !0,
                                    error: e
                                })
                            }
                        }
                    }
                    onError(t, e) {
                        !e.fatal && e.context && (e.context.type !== d || e.context.id !== this.trackId || this.groupIds && -1 === this.groupIds.indexOf(e.context.groupId) || this.checkRetry(e))
                    }
                    get allAudioTracks() {
                        return this.tracks
                    }
                    get audioTracks() {
                        return this.tracksInGroup
                    }
                    get audioTrack() {
                        return this.trackId
                    }
                    set audioTrack(t) {
                        this.selectDefaultTrack = !1, this.setAudioTrack(t)
                    }
                    setAudioOption(t) {
                        const e = this.hls;
                        if (e.config.audioPreference = t, t) {
                            const i = this.allAudioTracks;
                            if (this.selectDefaultTrack = !1, i.length) {
                                const s = this.currentTrack;
                                if (s && te(t, s, ee)) return s;
                                const r = Zt(t, this.tracksInGroup, ee);
                                if (r > -1) {
                                    const t = this.tracksInGroup[r];
                                    return this.setAudioTrack(r), t
                                }
                                if (s) {
                                    let s = e.loadLevel; - 1 === s && (s = e.firstAutoLevel);
                                    const r = function(t, e, i, s, r) {
                                        const n = e[s],
                                            a = e.reduce(((t, e, i) => {
                                                const s = e.uri;
                                                return (t[s] || (t[s] = [])).push(i), t
                                            }), {})[n.uri];
                                        a.length > 1 && (s = Math.max.apply(Math, a));
                                        const o = n.videoRange,
                                            l = n.frameRate,
                                            c = n.codecSet.substring(0, 4),
                                            u = ie(e, s, (e => {
                                                if (e.videoRange !== o || e.frameRate !== l || e.codecSet.substring(0, 4) !== c) return !1;
                                                const s = e.audioGroups,
                                                    n = i.filter((t => !s || -1 !== s.indexOf(t.groupId)));
                                                return Zt(t, n, r) > -1
                                            }));
                                        return u > -1 ? u : ie(e, s, (e => {
                                            const s = e.audioGroups,
                                                n = i.filter((t => !s || -1 !== s.indexOf(t.groupId)));
                                            return Zt(t, n, r) > -1
                                        }))
                                    }(t, e.levels, i, s, ee);
                                    if (-1 === r) return null;
                                    e.nextLoadLevel = r
                                }
                                if (t.channels || t.audioCodec) {
                                    const e = Zt(t, i);
                                    if (e > -1) return i[e]
                                }
                            }
                        }
                        return null
                    }
                    setAudioTrack(t) {
                        const e = this.tracksInGroup;
                        if (t < 0 || t >= e.length) return void this.warn(`Invalid audio track id: ${t}`);
                        this.selectDefaultTrack = !1;
                        const i = this.currentTrack,
                            s = e[t],
                            r = s.details && !s.details.live;
                        if (t === this.trackId && s === i && r) return;
                        if (this.log(`Switching to audio-track ${t} "${s.name}" lang:${s.lang} group:${s.groupId} channels:${s.channels}`), this.trackId = t, this.currentTrack = s, this.hls.trigger(l.AUDIO_TRACK_SWITCHING, E({}, s)), r) return;
                        const n = this.switchParams(s.url, null == i ? void 0 : i.details, s.details);
                        this.loadPlaylist(n)
                    }
                    findTrackId(t) {
                        const e = this.tracksInGroup;
                        for (let i = 0; i < e.length; i++) {
                            const s = e[i];
                            if ((!this.selectDefaultTrack || s.default) && (!t || te(t, s, ee))) return i
                        }
                        if (t) {
                            const {
                                name: i,
                                lang: s,
                                assocLang: r,
                                characteristics: n,
                                audioCodec: a,
                                channels: o
                            } = t;
                            for (let t = 0; t < e.length; t++)
                                if (te({
                                        name: i,
                                        lang: s,
                                        assocLang: r,
                                        characteristics: n,
                                        audioCodec: a,
                                        channels: o
                                    }, e[t], ee)) return t;
                            for (let i = 0; i < e.length; i++) {
                                const s = e[i];
                                if (Sr(t.attrs, s.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) return i
                            }
                            for (let i = 0; i < e.length; i++) {
                                const s = e[i];
                                if (Sr(t.attrs, s.attrs, ["LANGUAGE"])) return i
                            }
                        }
                        return -1
                    }
                    loadPlaylist(t) {
                        super.loadPlaylist();
                        const e = this.currentTrack;
                        this.shouldLoadPlaylist(e) && se(e.url, this.hls) && this.scheduleLoading(e, t)
                    }
                    loadingPlaylist(t, e) {
                        super.loadingPlaylist(t, e);
                        const i = t.id,
                            s = t.groupId,
                            r = this.getUrlWithDirectives(t.url, e),
                            n = t.details,
                            a = null == n ? void 0 : n.age;
                        this.log(`Loading audio-track ${i} "${t.name}" lang:${t.lang} group:${s}${void 0!==(null==e?void 0:e.msn)?" at sn "+e.msn+" part "+e.part:""}${a&&n.live?" age "+a.toFixed(1)+(n.type?" "+n.type||0:""):""} ${r}`), this.hls.trigger(l.AUDIO_TRACK_LOADING, {
                            url: r,
                            id: i,
                            groupId: s,
                            deliveryDirectives: e || null,
                            track: t
                        })
                    }
                },
                emeController: pn,
                cmcdController: class {
                    constructor(t) {
                        this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.includeKeys = void 0, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = () => {
                            this.initialized && (this.starved = !0), this.buffering = !0
                        }, this.onPlaying = () => {
                            this.initialized || (this.initialized = !0), this.buffering = !1
                        }, this.applyPlaylistData = t => {
                            try {
                                this.apply(t, {
                                    ot: Dr,
                                    su: !this.initialized
                                })
                            } catch (t) {
                                this.hls.logger.warn("Could not generate manifest CMCD data.", t)
                            }
                        }, this.applyFragmentData = t => {
                            try {
                                const {
                                    frag: e,
                                    part: i
                                } = t, s = this.hls.levels[e.level], r = this.getObjectType(e), n = {
                                    d: 1e3 * (i || e).duration,
                                    ot: r
                                };
                                r !== Pr && r !== xr && r != Or || (n.br = s.bitrate / 1e3, n.tb = this.getTopBandwidth(r) / 1e3, n.bl = this.getBufferLength(r));
                                const a = i ? this.getNextPart(i) : this.getNextFrag(e);
                                null != a && a.url && a.url !== e.url && (n.nor = a.url), this.apply(t, n)
                            } catch (t) {
                                this.hls.logger.warn("Could not generate segment CMCD data.", t)
                            }
                        }, this.hls = t;
                        const e = this.config = t.config,
                            {
                                cmcd: i
                            } = e;
                        null != i && (e.pLoader = this.createPlaylistLoader(), e.fLoader = this.createFragmentLoader(), this.sid = i.sessionId || t.sessionId, this.cid = i.contentId, this.useHeaders = !0 === i.useHeaders, this.includeKeys = i.includeKeys, this.registerListeners())
                    }
                    registerListeners() {
                        const t = this.hls;
                        t.on(l.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(l.MEDIA_DETACHED, this.onMediaDetached, this), t.on(l.BUFFER_CREATED, this.onBufferCreated, this)
                    }
                    unregisterListeners() {
                        const t = this.hls;
                        t.off(l.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(l.MEDIA_DETACHED, this.onMediaDetached, this), t.off(l.BUFFER_CREATED, this.onBufferCreated, this)
                    }
                    destroy() {
                        this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null, this.onWaiting = this.onPlaying = this.media = null
                    }
                    onMediaAttached(t, e) {
                        this.media = e.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying)
                    }
                    onMediaDetached() {
                        this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null)
                    }
                    onBufferCreated(t, e) {
                        var i, s;
                        this.audioBuffer = null == (i = e.tracks.audio) ? void 0 : i.buffer, this.videoBuffer = null == (s = e.tracks.video) ? void 0 : s.buffer
                    }
                    createData() {
                        var t;
                        return {
                            v: 1,
                            sf: Fr,
                            sid: this.sid,
                            cid: this.cid,
                            pr: null == (t = this.media) ? void 0 : t.playbackRate,
                            mtp: this.hls.bandwidthEstimate / 1e3
                        }
                    }
                    apply(t, e = {}) {
                        b(e, this.createData());
                        const i = e.ot === Mr || e.ot === Pr || e.ot === Or;
                        this.starved && i && (e.bs = !0, e.su = !0, this.starved = !1), null == e.su && (e.su = this.buffering);
                        const {
                            includeKeys: s
                        } = this;
                        s && (e = Object.keys(e).reduce(((t, i) => (s.includes(i) && (t[i] = e[i]), t)), {}));
                        const r = {
                            baseUrl: t.url
                        };
                        this.useHeaders ? (t.headers || (t.headers = {}), function(t, e, i) {
                            b(t, function(t, e = {}) {
                                const i = {};
                                if (!t) return i;
                                const s = Object.entries(t),
                                    r = Object.entries(Ur).concat(Object.entries((null == e ? void 0 : e.customHeaderMap) || {})),
                                    n = s.reduce(((t, e) => {
                                        var i, s;
                                        const [n, a] = e, o = (null === (i = r.find((t => t[1].includes(n)))) || void 0 === i ? void 0 : i[0]) || $r;
                                        return null !== (s = t[o]) && void 0 !== s || (t[o] = {}), t[o][n] = a, t
                                    }), {});
                                return Object.entries(n).reduce(((t, [i, s]) => (t[i] = un(s, e), t)), i)
                            }(e, i))
                        }(t.headers, e, r)) : t.url = function(t, e, i) {
                            const s = function(t, e = {}) {
                                if (!t) return "";
                                const i = un(t, e);
                                return `CMCD=${encodeURIComponent(i)}`
                            }(e, i);
                            if (!s) return t;
                            if (dn.test(t)) return t.replace(dn, s);
                            const r = t.includes("?") ? "&" : "?";
                            return `${t}${r}${s}`
                        }(t.url, e, r)
                    }
                    getNextFrag(t) {
                        var e;
                        const i = null == (e = this.hls.levels[t.level]) ? void 0 : e.details;
                        if (i) {
                            const e = t.sn - i.startSN;
                            return i.fragments[e + 1]
                        }
                    }
                    getNextPart(t) {
                        var e, i;
                        const {
                            index: s,
                            fragment: r
                        } = t, n = null == (e = this.hls.levels[r.level]) || null == (i = e.details) ? void 0 : i.partList;
                        if (n) {
                            const {
                                sn: t
                            } = r;
                            for (let e = n.length - 1; e >= 0; e--) {
                                const i = n[e];
                                if (i.index === s && i.fragment.sn === t) return n[e + 1]
                            }
                        }
                    }
                    getObjectType(t) {
                        const {
                            type: e
                        } = t;
                        return "subtitle" === e ? Nr : "initSegment" === t.sn ? Mr : "audio" === e ? xr : "main" === e ? this.hls.audioTracks.length ? Pr : Or : void 0
                    }
                    getTopBandwidth(t) {
                        let e, i = 0;
                        const s = this.hls;
                        if (t === xr) e = s.audioTracks;
                        else {
                            const t = s.maxAutoLevel,
                                i = t > -1 ? t + 1 : s.levels.length;
                            e = s.levels.slice(0, i)
                        }
                        for (const t of e) t.bitrate > i && (i = t.bitrate);
                        return i > 0 ? i : NaN
                    }
                    getBufferLength(t) {
                        const e = this.media,
                            i = t === xr ? this.audioBuffer : this.videoBuffer;
                        return i && e ? 1e3 * Oe.bufferInfo(i, e.currentTime, this.config.maxBufferHole).len : NaN
                    }
                    createPlaylistLoader() {
                        const {
                            pLoader: t
                        } = this.config, e = this.applyPlaylistData, i = t || this.config.loader;
                        return class {
                            constructor(t) {
                                this.loader = void 0, this.loader = new i(t)
                            }
                            get stats() {
                                return this.loader.stats
                            }
                            get context() {
                                return this.loader.context
                            }
                            destroy() {
                                this.loader.destroy()
                            }
                            abort() {
                                this.loader.abort()
                            }
                            load(t, i, s) {
                                e(t), this.loader.load(t, i, s)
                            }
                        }
                    }
                    createFragmentLoader() {
                        const {
                            fLoader: t
                        } = this.config, e = this.applyFragmentData, i = t || this.config.loader;
                        return class {
                            constructor(t) {
                                this.loader = void 0, this.loader = new i(t)
                            }
                            get stats() {
                                return this.loader.stats
                            }
                            get context() {
                                return this.loader.context
                            }
                            destroy() {
                                this.loader.destroy()
                            }
                            abort() {
                                this.loader.abort()
                            }
                            load(t, i, s) {
                                e(t), this.loader.load(t, i, s)
                            }
                        }
                    }
                },
                contentSteeringController: class extends S {
                    constructor(t) {
                        super("content-steering", t.logger), this.hls = void 0, this.loader = null, this.uri = null, this.pathwayId = ".", this._pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = t, this.registerListeners()
                    }
                    registerListeners() {
                        const t = this.hls;
                        t.on(l.MANIFEST_LOADING, this.onManifestLoading, this), t.on(l.MANIFEST_LOADED, this.onManifestLoaded, this), t.on(l.MANIFEST_PARSED, this.onManifestParsed, this), t.on(l.ERROR, this.onError, this)
                    }
                    unregisterListeners() {
                        const t = this.hls;
                        t && (t.off(l.MANIFEST_LOADING, this.onManifestLoading, this), t.off(l.MANIFEST_LOADED, this.onManifestLoaded, this), t.off(l.MANIFEST_PARSED, this.onManifestParsed, this), t.off(l.ERROR, this.onError, this))
                    }
                    pathways() {
                        return (this.levels || []).reduce(((t, e) => (-1 === t.indexOf(e.pathwayId) && t.push(e.pathwayId), t)), [])
                    }
                    get pathwayPriority() {
                        return this._pathwayPriority
                    }
                    set pathwayPriority(t) {
                        this.updatePathwayPriority(t)
                    }
                    startLoad() {
                        if (this.started = !0, this.clearTimeout(), this.enabled && this.uri) {
                            if (this.updated) {
                                const t = 1e3 * this.timeToLoad - (performance.now() - this.updated);
                                if (t > 0) return void this.scheduleRefresh(this.uri, t)
                            }
                            this.loadSteeringManifest(this.uri)
                        }
                    }
                    stopLoad() {
                        this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), this.clearTimeout()
                    }
                    clearTimeout() {
                        -1 !== this.reloadTimer && (self.clearTimeout(this.reloadTimer), this.reloadTimer = -1)
                    }
                    destroy() {
                        this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null
                    }
                    removeLevel(t) {
                        const e = this.levels;
                        e && (this.levels = e.filter((e => e !== t)))
                    }
                    onManifestLoading() {
                        this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = ".", this.levels = this.audioTracks = this.subtitleTracks = null
                    }
                    onManifestLoaded(t, e) {
                        const {
                            contentSteering: i
                        } = e;
                        null !== i && (this.pathwayId = i.pathwayId, this.uri = i.uri, this.started && this.startLoad())
                    }
                    onManifestParsed(t, e) {
                        this.audioTracks = e.audioTracks, this.subtitleTracks = e.subtitleTracks
                    }
                    onError(t, e) {
                        const {
                            errorAction: i
                        } = e;
                        if (2 === (null == i ? void 0 : i.action) && 1 === i.flags) {
                            const t = this.levels;
                            let s = this._pathwayPriority,
                                r = this.pathwayId;
                            if (e.context) {
                                const {
                                    groupId: i,
                                    pathwayId: s,
                                    type: n
                                } = e.context;
                                i && t ? r = this.getPathwayForGroupId(i, n, r) : s && (r = s)
                            }
                            r in this.penalizedPathways || (this.penalizedPathways[r] = performance.now()), !s && t && (s = this.pathways()), s && s.length > 1 && (this.updatePathwayPriority(s), i.resolved = this.pathwayId !== r), i.resolved || this.warn(`Could not resolve ${e.details} ("${e.error.message}") with content-steering for Pathway: ${r} levels: ${t?t.length:t} priorities: ${Yt(s)} penalized: ${Yt(this.penalizedPathways)}`)
                        }
                    }
                    filterParsedLevels(t) {
                        this.levels = t;
                        let e = this.getLevelsForPathway(this.pathwayId);
                        if (0 === e.length) {
                            const i = t[0].pathwayId;
                            this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${i}"`), e = this.getLevelsForPathway(i), this.pathwayId = i
                        }
                        return e.length !== t.length && this.log(`Found ${e.length}/${t.length} levels in Pathway "${this.pathwayId}"`), e
                    }
                    getLevelsForPathway(t) {
                        return null === this.levels ? [] : this.levels.filter((e => t === e.pathwayId))
                    }
                    updatePathwayPriority(t) {
                        let e;
                        this._pathwayPriority = t;
                        const i = this.penalizedPathways,
                            s = performance.now();
                        Object.keys(i).forEach((t => {
                            s - i[t] > 3e5 && delete i[t]
                        }));
                        for (let s = 0; s < t.length; s++) {
                            const r = t[s];
                            if (r in i) continue;
                            if (r === this.pathwayId) return;
                            const n = this.hls.nextLoadLevel,
                                a = this.hls.levels[n];
                            if (e = this.getLevelsForPathway(r), e.length > 0) {
                                this.log(`Setting Pathway to "${r}"`), this.pathwayId = r, Ni(e), this.hls.trigger(l.LEVELS_UPDATED, {
                                    levels: e
                                });
                                const t = this.hls.levels[n];
                                a && t && this.levels && (t.attrs["STABLE-VARIANT-ID"] !== a.attrs["STABLE-VARIANT-ID"] && t.bitrate !== a.bitrate && this.log(`Unstable Pathways change from bitrate ${a.bitrate} to ${t.bitrate}`), this.hls.nextLoadLevel = n);
                                break
                            }
                        }
                    }
                    getPathwayForGroupId(t, e, i) {
                        const s = this.getLevelsForPathway(i).concat(this.levels || []);
                        for (let i = 0; i < s.length; i++)
                            if (e === d && s[i].hasAudioGroup(t) || e === h && s[i].hasSubtitleGroup(t)) return s[i].pathwayId;
                        return i
                    }
                    clonePathways(t) {
                        const e = this.levels;
                        if (!e) return;
                        const i = {},
                            s = {};
                        t.forEach((t => {
                            const {
                                ID: r,
                                "BASE-ID": n,
                                "URI-REPLACEMENT": a
                            } = t;
                            if (e.some((t => t.pathwayId === r))) return;
                            const o = this.getLevelsForPathway(n).map((t => {
                                const e = new Ge(t.attrs);
                                e["PATHWAY-ID"] = r;
                                const n = e.AUDIO && `${e.AUDIO}_clone_${r}`,
                                    o = e.SUBTITLES && `${e.SUBTITLES}_clone_${r}`;
                                n && (i[e.AUDIO] = n, e.AUDIO = n), o && (s[e.SUBTITLES] = o, e.SUBTITLES = o);
                                const l = fn(t.uri, e["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", a),
                                    c = new qt({
                                        attrs: e,
                                        audioCodec: t.audioCodec,
                                        bitrate: t.bitrate,
                                        height: t.height,
                                        name: t.name,
                                        url: l,
                                        videoCodec: t.videoCodec,
                                        width: t.width
                                    });
                                if (t.audioGroups)
                                    for (let e = 1; e < t.audioGroups.length; e++) c.addGroupId("audio", `${t.audioGroups[e]}_clone_${r}`);
                                if (t.subtitleGroups)
                                    for (let e = 1; e < t.subtitleGroups.length; e++) c.addGroupId("text", `${t.subtitleGroups[e]}_clone_${r}`);
                                return c
                            }));
                            e.push(...o), hn(this.audioTracks, i, a, r), hn(this.subtitleTracks, s, a, r)
                        }))
                    }
                    loadSteeringManifest(t) {
                        const e = this.hls.config,
                            i = e.loader;
                        let s;
                        this.loader && this.loader.destroy(), this.loader = new i(e);
                        try {
                            s = new self.URL(t)
                        } catch (e) {
                            return this.enabled = !1, void this.log(`Failed to parse Steering Manifest URI: ${t}`)
                        }
                        if ("data:" !== s.protocol) {
                            const t = 0 | (this.hls.bandwidthEstimate || e.abrEwmaDefaultEstimate);
                            s.searchParams.set("_HLS_pathway", this.pathwayId), s.searchParams.set("_HLS_throughput", "" + t)
                        }
                        const r = {
                                responseType: "json",
                                url: s.href
                            },
                            n = e.steeringManifestLoadPolicy.default,
                            a = n.errorRetry || n.timeoutRetry || {},
                            o = {
                                loadPolicy: n,
                                timeout: n.maxLoadTimeMs,
                                maxRetry: a.maxNumRetry || 0,
                                retryDelay: a.retryDelayMs || 0,
                                maxRetryDelay: a.maxRetryDelayMs || 0
                            },
                            c = {
                                onSuccess: (t, e, i, r) => {
                                    this.log(`Loaded steering manifest: "${s}"`);
                                    const n = t.data;
                                    if (1 !== (null == n ? void 0 : n.VERSION)) return void this.log(`Steering VERSION ${n.VERSION} not supported!`);
                                    this.updated = performance.now(), this.timeToLoad = n.TTL;
                                    const {
                                        "RELOAD-URI": a,
                                        "PATHWAY-CLONES": o,
                                        "PATHWAY-PRIORITY": c
                                    } = n;
                                    if (a) try {
                                        this.uri = new self.URL(a, s).href
                                    } catch (t) {
                                        return this.enabled = !1, void this.log(`Failed to parse Steering Manifest RELOAD-URI: ${a}`)
                                    }
                                    this.scheduleRefresh(this.uri || i.url), o && this.clonePathways(o);
                                    const u = {
                                        steeringManifest: n,
                                        url: s.toString()
                                    };
                                    this.hls.trigger(l.STEERING_MANIFEST_LOADED, u), c && this.updatePathwayPriority(c)
                                },
                                onError: (t, e, i, s) => {
                                    if (this.log(`Error loading steering manifest: ${t.code} ${t.text} (${e.url})`), this.stopLoad(), 410 === t.code) return this.enabled = !1, void this.log(`Steering manifest ${e.url} no longer available`);
                                    let r = 1e3 * this.timeToLoad;
                                    if (429 !== t.code) this.scheduleRefresh(this.uri || e.url, r);
                                    else {
                                        const t = this.loader;
                                        if ("function" == typeof(null == t ? void 0 : t.getResponseHeader)) {
                                            const e = t.getResponseHeader("Retry-After");
                                            e && (r = 1e3 * parseFloat(e))
                                        }
                                        this.log(`Steering manifest ${e.url} rate limited`)
                                    }
                                },
                                onTimeout: (t, e, i) => {
                                    this.log(`Timeout loading steering manifest (${e.url})`), this.scheduleRefresh(this.uri || e.url)
                                }
                            };
                        this.log(`Requesting steering manifest: ${s}`), this.loader.load(r, o, c)
                    }
                    scheduleRefresh(t, e = 1e3 * this.timeToLoad) {
                        this.clearTimeout(), this.reloadTimer = self.setTimeout((() => {
                            var e;
                            const i = null == (e = this.hls) ? void 0 : e.media;
                            !i || i.ended ? this.scheduleRefresh(t, 1e3 * this.timeToLoad) : this.loadSteeringManifest(t)
                        }), e)
                    }
                },
                interstitialsController: class extends S {
                    constructor(t, e) {
                        super("interstitials", t.logger), this.HlsPlayerClass = void 0, this.hls = void 0, this.assetListLoader = void 0, this.mediaSelection = null, this.altSelection = null, this.media = null, this.detachedData = null, this.requiredTracks = null, this.manager = null, this.playerQueue = [], this.bufferedPos = -1, this.timelinePos = -1, this.schedule = void 0, this.playingItem = null, this.bufferingItem = null, this.waitingItem = null, this.endedItem = null, this.playingAsset = null, this.endedAsset = null, this.bufferingAsset = null, this.shouldPlay = !1, this.onPlay = () => {
                            this.shouldPlay = !0
                        }, this.onPause = () => {
                            this.shouldPlay = !1
                        }, this.onSeeking = () => {
                            const t = this.currentTime;
                            if (void 0 === t || this.playbackDisabled) return;
                            const e = t - this.timelinePos;
                            if (Math.abs(e) < 1 / 7056e5) return;
                            const i = e <= -.01;
                            this.timelinePos = t, this.bufferedPos = t;
                            const s = this.playingItem;
                            if (!s) return void this.checkBuffer();
                            if (i && this.schedule.resetErrorsInRange(t, t - e) && this.updateSchedule(), this.checkBuffer(), i && t < s.start || t >= s.end) {
                                var r;
                                const t = this.schedule.findItemIndexAtTime(this.timelinePos);
                                if (!this.isInterstitial(s) && null != (r = this.media) && r.paused && (this.shouldPlay = !1), !i) {
                                    const e = this.findItemIndex(s);
                                    if (t > e) {
                                        const i = this.schedule.findJumpRestrictedIndex(e + 1, t);
                                        if (i > e) return void this.setSchedulePosition(i)
                                    }
                                }
                                return void this.setSchedulePosition(t)
                            }
                            const n = this.playingAsset;
                            if (!n) {
                                if (this.playingLastItem && this.isInterstitial(s)) {
                                    const e = s.event.assetList[0];
                                    e && (this.endedItem = this.playingItem, this.playingItem = null, this.setScheduleToAssetAtTime(t, e))
                                }
                                return
                            }
                            const a = n.timelineStart,
                                o = n.duration || 0;
                            (i && t < a || t >= a + o) && this.setScheduleToAssetAtTime(t, n)
                        }, this.onTimeupdate = () => {
                            const t = this.currentTime;
                            if (void 0 === t || this.playbackDisabled) return;
                            if (!(t > this.timelinePos)) return;
                            this.timelinePos = t, t > this.bufferedPos && this.checkBuffer();
                            const e = this.playingItem;
                            if (!e || this.playingLastItem) return;
                            if (t >= e.end) {
                                this.timelinePos = e.end;
                                const t = this.findItemIndex(e);
                                this.setSchedulePosition(t + 1)
                            }
                            const i = this.playingAsset;
                            i && t >= i.timelineStart + (i.duration || 0) && this.setScheduleToAssetAtTime(t, i)
                        }, this.onScheduleUpdate = (t, e) => {
                            const i = this.schedule,
                                s = this.playingItem,
                                r = i.events || [],
                                n = i.items || [],
                                a = i.durations,
                                o = t.map((t => t.identifier)),
                                c = !(!r.length && !o.length);
                            if (c && this.log(`INTERSTITIALS_UPDATED (${r.length}): ${r}\nSchedule: ${n.map((t=>Dn(t)))}`), o.length && this.log(`Removed events ${o}`), this.playerQueue.forEach((t => {
                                    if (t.interstitial.appendInPlace) {
                                        const e = t.assetItem.timelineStart,
                                            i = t.timelineOffset - e;
                                        if (i) try {
                                            t.timelineOffset = e
                                        } catch (s) {
                                            Math.abs(i) > Sn && this.warn(`${s} ("${t.assetId}" ${t.timelineOffset}->${e})`)
                                        }
                                    }
                                })), s) {
                                const t = this.updateItem(s, this.timelinePos);
                                this.itemsMatch(s, t) && (this.playingItem = t, this.waitingItem = this.endedItem = null)
                            } else this.waitingItem = this.updateItem(this.waitingItem), this.endedItem = this.updateItem(this.endedItem);
                            const u = this.bufferingItem;
                            if (u) {
                                const t = this.updateItem(u, this.bufferedPos);
                                this.itemsMatch(u, t) ? this.bufferingItem = t : u.event && (this.bufferingItem = this.playingItem, this.clearInterstitial(u.event, null))
                            }
                            if (t.forEach((t => {
                                    t.assetList.forEach((t => {
                                        this.clearAssetPlayer(t.identifier, null)
                                    }))
                                })), c || e) {
                                if (this.hls.trigger(l.INTERSTITIALS_UPDATED, {
                                        events: r.slice(0),
                                        schedule: n.slice(0),
                                        durations: a,
                                        removedIds: o
                                    }), this.isInterstitial(s) && o.includes(s.event.identifier)) return this.warn(`Interstitial "${s.event.identifier}" removed while playing`), void this.primaryFallback(s.event);
                                this.checkBuffer()
                            }
                        }, this.hls = t, this.HlsPlayerClass = e, this.assetListLoader = new xn(t), this.schedule = new Cn(this.onScheduleUpdate, t.logger), this.registerListeners()
                    }
                    registerListeners() {
                        const t = this.hls;
                        t.on(l.MEDIA_ATTACHING, this.onMediaAttaching, this), t.on(l.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(l.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(l.MANIFEST_LOADING, this.onManifestLoading, this), t.on(l.LEVEL_UPDATED, this.onLevelUpdated, this), t.on(l.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.on(l.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this), t.on(l.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), t.on(l.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this), t.on(l.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this), t.on(l.ASSET_LIST_LOADED, this.onAssetListLoaded, this), t.on(l.BUFFER_APPENDED, this.onBufferAppended, this), t.on(l.BUFFER_FLUSHED, this.onBufferFlushed, this), t.on(l.BUFFERED_TO_END, this.onBufferedToEnd, this), t.on(l.MEDIA_ENDED, this.onMediaEnded, this), t.on(l.ERROR, this.onError, this), t.on(l.DESTROYING, this.onDestroying, this)
                    }
                    unregisterListeners() {
                        const t = this.hls;
                        t && (t.off(l.MEDIA_ATTACHING, this.onMediaAttaching, this), t.off(l.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(l.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(l.MANIFEST_LOADING, this.onManifestLoading, this), t.off(l.LEVEL_UPDATED, this.onLevelUpdated, this), t.off(l.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.off(l.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this), t.off(l.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), t.off(l.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this), t.off(l.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this), t.off(l.ASSET_LIST_LOADED, this.onAssetListLoaded, this), t.off(l.BUFFER_CODECS, this.onBufferCodecs, this), t.off(l.BUFFER_APPENDED, this.onBufferAppended, this), t.off(l.BUFFER_FLUSHED, this.onBufferFlushed, this), t.off(l.BUFFERED_TO_END, this.onBufferedToEnd, this), t.off(l.MEDIA_ENDED, this.onMediaEnded, this), t.off(l.ERROR, this.onError, this), t.off(l.DESTROYING, this.onDestroying, this))
                    }
                    startLoad() {
                        this.resumeBuffering()
                    }
                    stopLoad() {
                        this.pauseBuffering()
                    }
                    resumeBuffering() {
                        var t;
                        null == (t = this.getBufferingPlayer()) || t.resumeBuffering()
                    }
                    pauseBuffering() {
                        var t;
                        null == (t = this.getBufferingPlayer()) || t.pauseBuffering()
                    }
                    destroy() {
                        this.unregisterListeners(), this.stopLoad(), this.assetListLoader && this.assetListLoader.destroy(), this.emptyPlayerQueue(), this.clearScheduleState(), this.schedule && this.schedule.destroy(), this.media = this.detachedData = this.mediaSelection = this.requiredTracks = this.altSelection = this.manager = null, this.hls = this.HlsPlayerClass = this.schedule = this.log = null, this.assetListLoader = null, this.onPlay = this.onPause = this.onSeeking = this.onTimeupdate = null, this.onScheduleUpdate = null
                    }
                    onDestroying() {
                        const t = this.primaryMedia || this.media;
                        t && this.removeMediaListeners(t)
                    }
                    removeMediaListeners(t) {
                        On(t, "play", this.onPlay), On(t, "pause", this.onPause), On(t, "seeking", this.onSeeking), On(t, "timeupdate", this.onTimeupdate)
                    }
                    onMediaAttaching(t, e) {
                        const i = this.media = e.media;
                        Pn(i, "seeking", this.onSeeking), Pn(i, "timeupdate", this.onTimeupdate), Pn(i, "play", this.onPlay), Pn(i, "pause", this.onPause)
                    }
                    onMediaAttached(t, e) {
                        const i = this.effectivePlayingItem,
                            s = this.detachedData;
                        if (this.detachedData = null, null === i) this.checkStart();
                        else if (!s) {
                            this.clearScheduleState();
                            const t = this.findItemIndex(i);
                            this.setSchedulePosition(t)
                        }
                    }
                    clearScheduleState() {
                        this.playingItem = this.bufferingItem = this.waitingItem = this.endedItem = this.playingAsset = this.endedAsset = this.bufferingAsset = null
                    }
                    onMediaDetaching(t, e) {
                        const i = !!e.transferMedia,
                            s = this.media;
                        if (this.media = null, !i && (s && this.removeMediaListeners(s), this.detachedData)) {
                            const t = this.getBufferingPlayer();
                            t && (this.playingAsset = this.endedAsset = this.bufferingAsset = this.bufferingItem = this.waitingItem = this.detachedData = null, t.detachMedia()), this.shouldPlay = !1
                        }
                    }
                    get interstitialsManager() {
                        if (!this.manager) {
                            if (!this.hls) return null;
                            const t = this,
                                e = () => t.bufferingItem || t.waitingItem,
                                i = e => e ? t.getAssetPlayer(e.identifier) : e,
                                s = (e, s, r, a, o) => {
                                    if (e) {
                                        let l = e[s].start;
                                        const c = e.event;
                                        if (c) {
                                            if ("playout" === s || c.timelineOccupancy !== wn.Point) {
                                                const t = i(r);
                                                (null == t ? void 0 : t.interstitial) === c && (l += t.assetItem.startOffset + t[o])
                                            }
                                        } else l += ("bufferedPos" === a ? n() : t[a]) - e.start;
                                        return l
                                    }
                                    return 0
                                },
                                r = (e, i) => {
                                    if (0 !== e && "primary" !== i && t.schedule.length) {
                                        var s;
                                        const r = t.schedule.findItemIndexAtTime(e),
                                            n = null == (s = t.schedule.items) ? void 0 : s[r];
                                        if (n) return e + (n[i].start - n.start)
                                    }
                                    return e
                                },
                                n = () => {
                                    const e = t.bufferedPos;
                                    return e === Number.MAX_VALUE ? a("primary") : Math.max(e, 0)
                                },
                                a = e => {
                                    var i;
                                    return null != (i = t.primaryDetails) && i.live ? t.primaryDetails.edge : t.schedule.durations[e]
                                },
                                o = (e, r) => {
                                    var n, a;
                                    const o = t.effectivePlayingItem;
                                    if (null != o && null != (n = o.event) && n.restrictions.skip) return;
                                    t.log(`seek to ${e} "${r}"`);
                                    const l = t.effectivePlayingItem,
                                        c = t.schedule.findItemIndexAtTime(e, r),
                                        u = null == (a = t.schedule.items) ? void 0 : a[c],
                                        d = t.getBufferingPlayer(),
                                        h = null == d ? void 0 : d.interstitial,
                                        f = null == h ? void 0 : h.appendInPlace,
                                        p = l && t.itemsMatch(l, u);
                                    if (l && (f || p)) {
                                        const n = i(t.playingAsset),
                                            a = (null == n ? void 0 : n.media) || t.primaryMedia;
                                        if (a) {
                                            const i = "primary" === r ? a.currentTime : s(l, r, t.playingAsset, "timelinePos", "currentTime"),
                                                o = e - i,
                                                c = (f ? i : a.currentTime) + o;
                                            if (c >= 0 && (!n || f || c <= n.duration)) return void(a.currentTime = c)
                                        }
                                    }
                                    if (u) {
                                        let i = e;
                                        if ("primary" !== r) {
                                            const t = e - u[r].start;
                                            i = u.start + t
                                        }
                                        const s = !t.isInterstitial(u);
                                        if (t.isInterstitial(l) && !l.event.appendInPlace || !s && !u.event.appendInPlace) {
                                            if (l) {
                                                const n = t.findItemIndex(l);
                                                if (c > n) {
                                                    const e = t.schedule.findJumpRestrictedIndex(n + 1, c);
                                                    if (e > n) return void t.setSchedulePosition(e)
                                                }
                                                let a = 0;
                                                if (s) t.timelinePos = i, t.checkBuffer();
                                                else {
                                                    var g;
                                                    const t = null == u || null == (g = u.event) ? void 0 : g.assetList;
                                                    if (t) {
                                                        const i = e - (u[r] || u).start;
                                                        for (let e = t.length; e--;) {
                                                            const s = t[e];
                                                            if (s.duration && i >= s.startOffset && i < s.startOffset + s.duration) {
                                                                a = e;
                                                                break
                                                            }
                                                        }
                                                    }
                                                }
                                                t.setSchedulePosition(c, a)
                                            }
                                        } else {
                                            const e = t.media || (f ? null == d ? void 0 : d.media : null);
                                            e && (e.currentTime = i)
                                        }
                                    }
                                },
                                l = () => {
                                    const i = t.effectivePlayingItem;
                                    if (t.isInterstitial(i)) return i;
                                    const s = e();
                                    return t.isInterstitial(s) ? s : null
                                },
                                c = {
                                    get currentTime() {
                                        const e = l(),
                                            i = t.effectivePlayingItem;
                                        return i && i === e ? s(i, "playout", t.effectivePlayingAsset, "timelinePos", "currentTime") - i.playout.start : 0
                                    },
                                    set currentTime(e) {
                                        const i = l(),
                                            s = t.effectivePlayingItem;
                                        s && s === i && o(e + s.playout.start, "playout")
                                    },
                                    get duration() {
                                        const t = l();
                                        return t ? t.playout.end - t.playout.start : 0
                                    },
                                    get assetPlayers() {
                                        var e;
                                        const i = null == (e = l()) ? void 0 : e.event.assetList;
                                        return i ? i.map((e => t.getAssetPlayer(e.identifier))) : []
                                    },
                                    get playingIndex() {
                                        var e;
                                        const i = null == (e = l()) ? void 0 : e.event;
                                        return i && t.effectivePlayingAsset ? i.findAssetIndex(t.effectivePlayingAsset) : -1
                                    },
                                    get scheduleItem() {
                                        return l()
                                    }
                                };
                            this.manager = {
                                get events() {
                                    var e, i;
                                    return (null == (e = t.schedule) || null == (i = e.events) ? void 0 : i.slice(0)) || []
                                },
                                get schedule() {
                                    var e, i;
                                    return (null == (e = t.schedule) || null == (i = e.items) ? void 0 : i.slice(0)) || []
                                },
                                get interstitialPlayer() {
                                    return l() ? c : null
                                },
                                get playerQueue() {
                                    return t.playerQueue.slice(0)
                                },
                                get bufferingAsset() {
                                    return t.bufferingAsset
                                },
                                get bufferingItem() {
                                    return e()
                                },
                                get bufferingIndex() {
                                    const i = e();
                                    return t.findItemIndex(i)
                                },
                                get playingAsset() {
                                    return t.effectivePlayingAsset
                                },
                                get playingItem() {
                                    return t.effectivePlayingItem
                                },
                                get playingIndex() {
                                    const e = t.effectivePlayingItem;
                                    return t.findItemIndex(e)
                                },
                                primary: {
                                    get bufferedEnd() {
                                        return n()
                                    },
                                    get currentTime() {
                                        const e = t.timelinePos;
                                        return e > 0 ? e : 0
                                    },
                                    set currentTime(t) {
                                        o(t, "primary")
                                    },
                                    get duration() {
                                        return a("primary")
                                    },
                                    get seekableStart() {
                                        var e;
                                        return (null == (e = t.primaryDetails) ? void 0 : e.fragmentStart) || 0
                                    }
                                },
                                integrated: {
                                    get bufferedEnd() {
                                        return s(e(), "integrated", t.bufferingAsset, "bufferedPos", "bufferedEnd")
                                    },
                                    get currentTime() {
                                        return s(t.effectivePlayingItem, "integrated", t.effectivePlayingAsset, "timelinePos", "currentTime")
                                    },
                                    set currentTime(t) {
                                        o(t, "integrated")
                                    },
                                    get duration() {
                                        return a("integrated")
                                    },
                                    get seekableStart() {
                                        var e;
                                        return r((null == (e = t.primaryDetails) ? void 0 : e.fragmentStart) || 0, "integrated")
                                    }
                                },
                                skip: () => {
                                    const e = t.effectivePlayingItem,
                                        i = null == e ? void 0 : e.event;
                                    if (i && !i.restrictions.skip) {
                                        const s = t.findItemIndex(e);
                                        if (i.appendInPlace) {
                                            const t = e.playout.start + e.event.duration;
                                            o(t + .001, "playout")
                                        } else t.advanceAfterAssetEnded(i, s, 1 / 0)
                                    }
                                }
                            }
                        }
                        return this.manager
                    }
                    get effectivePlayingItem() {
                        return this.waitingItem || this.playingItem || this.endedItem
                    }
                    get effectivePlayingAsset() {
                        return this.playingAsset || this.endedAsset
                    }
                    get playingLastItem() {
                        var t;
                        const e = this.playingItem,
                            i = null == (t = this.schedule) ? void 0 : t.items;
                        return !!(this.playbackStarted && e && i) && this.findItemIndex(e) === i.length - 1
                    }
                    get playbackStarted() {
                        return null !== this.effectivePlayingItem
                    }
                    get currentTime() {
                        var t, e, i;
                        if (null === this.mediaSelection) return;
                        const r = this.waitingItem || this.playingItem;
                        if (this.isInterstitial(r) && !r.event.appendInPlace) return;
                        let n = this.media;
                        !n && null != (t = this.bufferingItem) && null != (e = t.event) && e.appendInPlace && (n = this.primaryMedia);
                        const a = null == (i = n) ? void 0 : i.currentTime;
                        return void 0 !== a && s(a) ? a : void 0
                    }
                    get primaryMedia() {
                        var t;
                        return this.media || (null == (t = this.detachedData) ? void 0 : t.media) || null
                    }
                    isInterstitial(t) {
                        return !(null == t || !t.event)
                    }
                    retreiveMediaSource(t, e) {
                        const i = this.getAssetPlayer(t);
                        i && this.transferMediaFromPlayer(i, e)
                    }
                    transferMediaFromPlayer(t, e) {
                        const i = t.interstitial.appendInPlace,
                            s = t.media;
                        if (i && s === this.primaryMedia) {
                            if (this.bufferingAsset = null, (!e || this.isInterstitial(e) && !e.event.appendInPlace) && e && s) return void(this.detachedData = {
                                media: s
                            });
                            const i = t.transferMedia();
                            this.log(`transfer MediaSource from ${t} ${Yt(i)}`), this.detachedData = i
                        } else e && s && (this.shouldPlay || (this.shouldPlay = !s.paused))
                    }
                    transferMediaTo(t, e) {
                        var i, s;
                        if (t.media === e) return;
                        let r = null;
                        const n = this.hls,
                            a = t !== n,
                            o = a && t.interstitial.appendInPlace,
                            l = null == (i = this.detachedData) ? void 0 : i.mediaSource;
                        let c;
                        if (n.media) o && (r = n.transferMedia(), this.detachedData = r), c = "Primary";
                        else if (l) {
                            const t = this.getBufferingPlayer();
                            t ? (r = t.transferMedia(), c = `${t}`) : c = "detached MediaSource"
                        } else c = "detached media";
                        if (!r)
                            if (l) r = this.detachedData, this.log(`using detachedData: MediaSource ${Yt(r)}`);
                            else if (!this.detachedData || n.media === e) {
                            const t = this.playerQueue;
                            t.length > 1 && t.forEach((t => {
                                if (a && t.interstitial.appendInPlace !== o) {
                                    const e = t.interstitial;
                                    this.clearInterstitial(t.interstitial, null), e.appendInPlace = !1, e.appendInPlace && this.warn(`Could not change append strategy for queued assets ${e}`)
                                }
                            })), this.hls.detachMedia(), this.detachedData = {
                                media: e
                            }
                        }
                        const u = r && "mediaSource" in r && "closed" !== (null == (s = r.mediaSource) ? void 0 : s.readyState),
                            d = u && r ? r : e;
                        if (this.log(`${u?"transfering MediaSource":"attaching media"} to ${a?t:"Primary"} from ${c}`), d === r) {
                            const e = a && t.assetId === this.schedule.assetIdAtEnd;
                            d.overrides = {
                                duration: this.schedule.duration,
                                endOfStream: !a || e,
                                cueRemoval: !a
                            }
                        }
                        t.attachMedia(d)
                    }
                    onInterstitialCueEnter() {
                        this.onTimeupdate()
                    }
                    checkStart() {
                        const t = this.schedule,
                            e = t.events;
                        if (!e || this.playbackDisabled || !this.media) return; - 1 === this.bufferedPos && (this.bufferedPos = 0);
                        const i = this.timelinePos,
                            s = this.effectivePlayingItem;
                        if (-1 === i) {
                            const i = this.hls.startPosition;
                            if (this.timelinePos = i, e.length && e[0].cue.pre) {
                                const i = t.findEventIndex(e[0].identifier);
                                this.setSchedulePosition(i)
                            } else if (i >= 0 || !this.primaryLive) {
                                const e = this.timelinePos = i > 0 ? i : 0,
                                    s = t.findItemIndexAtTime(e);
                                this.setSchedulePosition(s)
                            }
                        } else if (s && !this.playingItem) {
                            const e = t.findItemIndex(s);
                            this.setSchedulePosition(e)
                        }
                    }
                    advanceAfterAssetEnded(t, e, i) {
                        const s = i + 1;
                        if (t.isAssetPastPlayoutLimit(s) || t.assetList[s].error) {
                            const i = this.schedule.items;
                            if (i) {
                                const s = e + 1;
                                if (s >= i.length) return void this.setSchedulePosition(-1);
                                const r = t.resumeTime;
                                this.timelinePos < r && (this.timelinePos = r, this.checkBuffer()), this.setSchedulePosition(s)
                            }
                        } else this.setSchedulePosition(e, s)
                    }
                    setScheduleToAssetAtTime(t, e) {
                        const i = this.schedule,
                            s = e.parentIdentifier,
                            r = i.getEvent(s);
                        if (r) {
                            const e = i.findEventIndex(s),
                                n = i.findAssetIndex(r, t);
                            this.setSchedulePosition(e, n)
                        }
                    }
                    setSchedulePosition(t, e) {
                        const i = this.schedule.items;
                        if (!i || this.playbackDisabled) return;
                        this.log(`setSchedulePosition ${t}, ${e}`);
                        const s = t >= 0 ? i[t] : null,
                            r = this.playingItem,
                            n = this.playingLastItem;
                        if (this.isInterstitial(r)) {
                            var a;
                            const c = r.event,
                                u = this.playingAsset,
                                d = null == u ? void 0 : u.identifier,
                                h = d ? this.getAssetPlayer(d) : null;
                            if (h && d && (!this.eventItemsMatch(r, s) || void 0 !== e && d !== (null == (a = c.assetList) ? void 0 : a[e].identifier))) {
                                var o;
                                const e = c.findAssetIndex(u);
                                this.log(`INTERSTITIAL_ASSET_ENDED ${e+1}/${c.assetList.length} ${Rn(u)}`), this.endedAsset = u, this.playingAsset = null, this.hls.trigger(l.INTERSTITIAL_ASSET_ENDED, {
                                    asset: u,
                                    assetListIndex: e,
                                    event: c,
                                    schedule: i.slice(0),
                                    scheduleIndex: t,
                                    player: h
                                }), this.retreiveMediaSource(d, s), !h.media || null != (o = this.detachedData) && o.mediaSource || h.detachMedia()
                            }
                            if (!this.eventItemsMatch(r, s) && (this.endedItem = r, this.playingItem = null, this.log(`INTERSTITIAL_ENDED ${c} ${Dn(r)}`), c.hasPlayed = !0, this.hls.trigger(l.INTERSTITIAL_ENDED, {
                                    event: c,
                                    schedule: i.slice(0),
                                    scheduleIndex: t
                                }), c.cue.once)) {
                                this.updateSchedule();
                                const t = this.schedule.items;
                                if (s && t) {
                                    const i = this.schedule.findItemIndex(s);
                                    this.advanceSchedule(i, t, e, r, n)
                                }
                                return
                            }
                        }
                        this.advanceSchedule(t, i, e, r, n)
                    }
                    advanceSchedule(t, e, i, s, r) {
                        const n = t >= 0 ? e[t] : null,
                            a = this.primaryMedia,
                            o = this.playerQueue;
                        if (o.length && o.forEach((e => {
                                const i = e.interstitial,
                                    s = this.schedule.findEventIndex(i.identifier);
                                (s < t || s > t + 1) && this.clearInterstitial(i, n)
                            })), this.isInterstitial(n)) {
                            this.timelinePos = Math.min(Math.max(this.timelinePos, n.start), n.end);
                            const r = n.event;
                            void 0 === i && (i = this.schedule.findAssetIndex(r, this.timelinePos));
                            const o = this.waitingItem;
                            this.assetsBuffered(n, a) || this.setBufferingItem(n);
                            let c = this.preloadAssets(r, i);
                            if (this.eventItemsMatch(n, o || s) || (this.waitingItem = n, this.log(`INTERSTITIAL_STARTED ${Dn(n)} ${r.appendInPlace?"append in place":""}`), this.hls.trigger(l.INTERSTITIAL_STARTED, {
                                    event: r,
                                    schedule: e.slice(0),
                                    scheduleIndex: t
                                })), !r.assetListLoaded) return void this.log(`Waiting for ASSET-LIST to complete loading ${r}`);
                            if (r.assetListLoader && (r.assetListLoader.destroy(), r.assetListLoader = void 0), !a) return void this.log(`Waiting for attachMedia to start Interstitial ${r}`);
                            this.waitingItem = this.endedItem = null, this.playingItem = n;
                            const u = r.assetList[i];
                            if (!u) {
                                const s = e[t + 1],
                                    n = this.media;
                                return s && n && !this.isInterstitial(s) && n.currentTime < s.start && (n.currentTime = this.timelinePos = s.start), void this.advanceAfterAssetEnded(r, t, i || 0)
                            }
                            if (c || (c = this.getAssetPlayer(u.identifier)), null === c || c.destroyed) {
                                const t = r.assetList.length;
                                this.warn(`asset ${i+1}/${t} player destroyed ${r}`), c = this.createAssetPlayer(r, u, i)
                            }
                            if (!this.eventItemsMatch(n, this.bufferingItem) && r.appendInPlace && this.isAssetBuffered(u)) return;
                            this.startAssetPlayer(c, i, e, t, a), this.shouldPlay && Mn(c.media)
                        } else null !== n ? (this.resumePrimary(n, t, s), this.shouldPlay && Mn(this.hls.media)) : r && this.isInterstitial(s) && (this.endedItem = null, this.playingItem = s, s.event.appendInPlace || this.attachPrimary(this.schedule.durations.primary, null))
                    }
                    get playbackDisabled() {
                        return !1 === this.hls.config.enableInterstitialPlayback
                    }
                    get primaryDetails() {
                        var t, e;
                        return null == (t = this.mediaSelection) || null == (e = t.main) ? void 0 : e.details
                    }
                    get primaryLive() {
                        var t;
                        return !(null == (t = this.primaryDetails) || !t.live)
                    }
                    resumePrimary(t, e, i) {
                        var s;
                        if (this.playingItem = t, this.playingAsset = this.endedAsset = null, this.waitingItem = this.endedItem = null, this.bufferedToItem(t), this.log(`resuming ${Dn(t)}`), null == (s = this.detachedData) || !s.mediaSource) {
                            let i = this.timelinePos;
                            (i < t.start || i >= t.end) && (i = this.getPrimaryResumption(t, e), this.timelinePos = i), this.attachPrimary(i, t)
                        }
                        if (!i) return;
                        const r = this.schedule.items;
                        r && (this.log(`resumed ${Dn(t)}`), this.hls.trigger(l.INTERSTITIALS_PRIMARY_RESUMED, {
                            schedule: r.slice(0),
                            scheduleIndex: e
                        }), this.checkBuffer())
                    }
                    getPrimaryResumption(t, e) {
                        const i = t.start;
                        if (this.primaryLive) {
                            const t = this.primaryDetails;
                            if (0 === e) return this.hls.startPosition;
                            if (t && (i < t.fragmentStart || i > t.edge)) return this.hls.liveSyncPosition || -1
                        }
                        return i
                    }
                    isAssetBuffered(t) {
                        const e = this.getAssetPlayer(t.identifier);
                        return null != e && e.hls ? e.hls.bufferedToEnd : Oe.bufferInfo(this.primaryMedia, this.timelinePos, 0).end + 1 >= t.timelineStart + (t.duration || 0)
                    }
                    attachPrimary(t, e, i) {
                        e ? this.setBufferingItem(e) : this.bufferingItem = this.playingItem, this.bufferingAsset = null;
                        const s = this.primaryMedia;
                        if (!s) return;
                        const r = this.hls;
                        r.media ? this.checkBuffer() : (this.transferMediaTo(r, s), i && this.startLoadingPrimaryAt(t, i)), i || (this.timelinePos = t, this.startLoadingPrimaryAt(t, i))
                    }
                    startLoadingPrimaryAt(t, e) {
                        var i;
                        const s = this.hls;
                        !s.loadingEnabled || !s.media || Math.abs(((null == (i = s.mainForwardBufferInfo) ? void 0 : i.start) || s.media.currentTime) - t) > .5 ? s.startLoad(t, e) : s.bufferingEnabled || s.resumeBuffering()
                    }
                    onManifestLoading() {
                        this.stopLoad(), this.schedule.reset(), this.emptyPlayerQueue(), this.clearScheduleState(), this.shouldPlay = !1, this.bufferedPos = this.timelinePos = -1, this.mediaSelection = this.altSelection = this.manager = this.requiredTracks = null, this.hls.off(l.BUFFER_CODECS, this.onBufferCodecs, this), this.hls.on(l.BUFFER_CODECS, this.onBufferCodecs, this)
                    }
                    onLevelUpdated(t, e) {
                        if (-1 === e.level) return;
                        const i = this.hls.levels[e.level],
                            s = E(E({}, this.mediaSelection || this.altSelection), {}, {
                                main: i
                            });
                        this.mediaSelection = s, this.schedule.parseInterstitialDateRanges(s, this.hls.config.interstitialAppendInPlace), !this.effectivePlayingItem && this.schedule.items && this.checkStart()
                    }
                    onAudioTrackUpdated(t, e) {
                        const i = this.hls.audioTracks[e.id],
                            s = this.mediaSelection;
                        if (!s) return void(this.altSelection = E(E({}, this.altSelection), {}, {
                            audio: i
                        }));
                        const r = E(E({}, s), {}, {
                            audio: i
                        });
                        this.mediaSelection = r
                    }
                    onSubtitleTrackUpdated(t, e) {
                        const i = this.hls.subtitleTracks[e.id],
                            s = this.mediaSelection;
                        if (!s) return void(this.altSelection = E(E({}, this.altSelection), {}, {
                            subtitles: i
                        }));
                        const r = E(E({}, s), {}, {
                            subtitles: i
                        });
                        this.mediaSelection = r
                    }
                    onAudioTrackSwitching(t, e) {
                        const i = Jt(e);
                        this.playerQueue.forEach((t => t.hls.setAudioOption(e) || t.hls.setAudioOption(i)))
                    }
                    onSubtitleTrackSwitch(t, e) {
                        const i = Jt(e);
                        this.playerQueue.forEach((t => t.hls.setSubtitleOption(e) || -1 !== e.id && t.hls.setSubtitleOption(i)))
                    }
                    onBufferCodecs(t, e) {
                        const i = e.tracks;
                        i && (this.requiredTracks = i)
                    }
                    onBufferAppended(t, e) {
                        this.checkBuffer()
                    }
                    onBufferFlushed(t, e) {
                        const i = this.playingItem;
                        if (i && !this.itemsMatch(i, this.bufferingItem) && !this.isInterstitial(i)) {
                            const t = this.timelinePos;
                            this.bufferedPos = t, this.checkBuffer()
                        }
                    }
                    onBufferedToEnd(t) {
                        const e = this.schedule.events;
                        if (this.bufferedPos < Number.MAX_VALUE && e) {
                            for (let t = 0; t < e.length; t++) {
                                const s = e[t];
                                if (s.cue.post) {
                                    var i;
                                    const t = this.schedule.findEventIndex(s.identifier),
                                        e = null == (i = this.schedule.items) ? void 0 : i[t];
                                    this.isInterstitial(e) && this.eventItemsMatch(e, this.bufferingItem) && this.bufferedToItem(e, 0);
                                    break
                                }
                            }
                            this.bufferedPos = Number.MAX_VALUE
                        }
                    }
                    onMediaEnded(t) {
                        const e = this.playingItem;
                        if (!this.playingLastItem && e) {
                            const t = this.findItemIndex(e);
                            this.setSchedulePosition(t + 1)
                        } else this.shouldPlay = !1
                    }
                    updateItem(t, e) {
                        const i = this.schedule.items;
                        return t && i && i[this.findItemIndex(t, e)] || null
                    }
                    itemsMatch(t, e) {
                        return !!e && (t === e || t.event && e.event && this.eventItemsMatch(t, e) || !t.event && !e.event && this.findItemIndex(t) === this.findItemIndex(e))
                    }
                    eventItemsMatch(t, e) {
                        var i;
                        return !!e && (t === e || t.event.identifier === (null == (i = e.event) ? void 0 : i.identifier))
                    }
                    findItemIndex(t, e) {
                        return t ? this.schedule.findItemIndex(t, e) : -1
                    }
                    updateSchedule() {
                        const t = this.mediaSelection;
                        t && this.schedule.updateSchedule(t, [])
                    }
                    checkBuffer(t) {
                        const e = this.schedule.items;
                        if (!e) return;
                        const i = Oe.bufferInfo(this.primaryMedia, this.timelinePos, 0);
                        t && (this.bufferedPos = this.timelinePos), t || (t = i.len < 1), this.updateBufferedPos(i.end, e, t)
                    }
                    updateBufferedPos(t, e, i) {
                        const s = this.schedule,
                            r = this.bufferingItem;
                        if (this.bufferedPos > t) return;
                        if (1 === e.length && this.itemsMatch(e[0], r)) return void(this.bufferedPos = t);
                        const n = this.playingItem,
                            a = this.findItemIndex(n);
                        let o = s.findItemIndexAtTime(t);
                        if (this.bufferedPos < t) {
                            var l, c;
                            const i = this.findItemIndex(r),
                                s = Math.min(i + 1, e.length - 1),
                                n = e[s];
                            if ((-1 === o && r && t >= r.end || null != (l = n.event) && l.appendInPlace && t + .01 >= n.start) && (o = s), s - a > 1 && !1 === (null == r || null == (c = r.event) ? void 0 : c.appendInPlace)) return;
                            if (this.bufferedPos = t, o > i && o > a) this.bufferedToItem(n);
                            else {
                                const e = this.primaryDetails;
                                this.primaryLive && e && t > e.edge - e.targetduration && n.start < e.edge + this.hls.config.interstitialLiveLookAhead && this.isInterstitial(n) && this.preloadAssets(n.event, 0)
                            }
                        } else i && n && !this.itemsMatch(n, r) && (o === a ? this.bufferedToItem(n) : o === a + 1 && this.bufferedToItem(e[o]))
                    }
                    assetsBuffered(t, e) {
                        return 0 !== t.event.assetList.length && !t.event.assetList.some((t => {
                            const i = this.getAssetPlayer(t.identifier);
                            return !(null != i && i.bufferedInPlaceToEnd(e))
                        }))
                    }
                    setBufferingItem(t) {
                        const e = this.bufferingItem,
                            i = this.schedule;
                        if (this.itemsMatch(t, e)) this.bufferingItem !== t && (this.bufferingItem = t);
                        else {
                            const {
                                items: s,
                                events: r
                            } = i;
                            if (!s || !r) return e;
                            const n = this.isInterstitial(t),
                                a = this.getBufferingPlayer();
                            if (this.bufferingItem = t, this.bufferedPos = Math.max(t.start, Math.min(t.end, this.timelinePos)), !this.playbackDisabled) {
                                const i = a ? a.remaining : e ? e.end - this.timelinePos : 0;
                                this.log(`buffered to boundary ${Dn(t)}` + (e ? ` (${i.toFixed(2)} remaining)` : "")), n ? t.event.assetList.forEach((t => {
                                    const e = this.getAssetPlayer(t.identifier);
                                    e && e.resumeBuffering()
                                })) : (this.hls.resumeBuffering(), this.playerQueue.forEach((t => t.pauseBuffering())))
                            }
                            this.hls.trigger(l.INTERSTITIALS_BUFFERED_TO_BOUNDARY, {
                                events: r.slice(0),
                                schedule: s.slice(0),
                                bufferingIndex: this.findItemIndex(t),
                                playingIndex: this.findItemIndex(this.playingItem)
                            })
                        }
                        return e
                    }
                    bufferedToItem(t, e = 0) {
                        const i = this.setBufferingItem(t);
                        if (!this.playbackDisabled)
                            if (this.isInterstitial(t)) this.bufferedToEvent(t, e);
                            else if (null !== i) {
                            this.bufferingAsset = null;
                            const e = this.detachedData;
                            if (e)
                                if (e.mediaSource) {
                                    const e = !0;
                                    this.attachPrimary(t.start, t, e)
                                } else this.preloadPrimary(t);
                            else this.preloadPrimary(t)
                        }
                    }
                    preloadPrimary(t) {
                        const e = this.findItemIndex(t),
                            i = this.getPrimaryResumption(t, e);
                        this.startLoadingPrimaryAt(i)
                    }
                    bufferedToEvent(t, e) {
                        const i = t.event,
                            s = 0 === i.assetList.length && !i.assetListLoader,
                            r = i.cue.once;
                        if (s || !r) {
                            const t = this.preloadAssets(i, e);
                            if (null != t && t.interstitial.appendInPlace) {
                                const s = i.assetList[e],
                                    r = this.primaryMedia;
                                s && r && this.bufferAssetPlayer(t, r)
                            }
                        }
                    }
                    preloadAssets(t, e) {
                        const i = t.assetUrl,
                            s = t.assetList.length,
                            r = 0 === s && !t.assetListLoader,
                            n = t.cue.once;
                        if (r) {
                            const r = t.timelineStart;
                            if (t.appendInPlace) {
                                var a;
                                const e = this.playingItem;
                                this.isInterstitial(e) || (null == e || null == (a = e.nextEvent) ? void 0 : a.identifier) !== t.identifier || this.flushFrontBuffer(r + .25)
                            }
                            let n, o = 0;
                            if (!this.playingItem && this.primaryLive && (o = this.hls.startPosition, -1 === o && (o = this.hls.liveSyncPosition || 0)), o && !t.cue.pre && !t.cue.post) {
                                const t = o - r;
                                t > 0 && (n = Math.round(1e3 * t) / 1e3)
                            }
                            if (this.log(`Load interstitial asset ${e+1}/${i?1:s} ${t}${n?` live-start: ${o} start-offset: ${n}`:""}`), i) return this.createAsset(t, 0, 0, r, t.duration, i);
                            const l = this.assetListLoader.loadAssetList(t, n);
                            l && (t.assetListLoader = l)
                        } else if (!n && s) {
                            for (let i = e; i < s; i++) {
                                const e = t.assetList[i],
                                    s = this.getAssetPlayerQueueIndex(e.identifier); - 1 !== s && !this.playerQueue[s].destroyed || e.error || this.createAssetPlayer(t, e, i)
                            }
                            return this.getAssetPlayer(t.assetList[e].identifier)
                        }
                        return null
                    }
                    flushFrontBuffer(t) {
                        const e = this.requiredTracks;
                        e && (this.log(`Removing front buffer starting at ${t}`), Object.keys(e).forEach((e => {
                            this.hls.trigger(l.BUFFER_FLUSHING, {
                                startOffset: t,
                                endOffset: 1 / 0,
                                type: e
                            })
                        })))
                    }
                    getAssetPlayerQueueIndex(t) {
                        const e = this.playerQueue;
                        for (let i = 0; i < e.length; i++)
                            if (t === e[i].assetId) return i;
                        return -1
                    }
                    getAssetPlayer(t) {
                        const e = this.getAssetPlayerQueueIndex(t);
                        return this.playerQueue[e] || null
                    }
                    getBufferingPlayer() {
                        const {
                            playerQueue: t,
                            primaryMedia: e
                        } = this;
                        if (e)
                            for (let i = 0; i < t.length; i++)
                                if (t[i].media === e) return t[i];
                        return null
                    }
                    createAsset(t, e, i, s, r, n) {
                        const a = {
                            parentIdentifier: t.identifier,
                            identifier: kn(t, n, e),
                            duration: r,
                            startOffset: i,
                            timelineStart: s,
                            uri: n
                        };
                        return this.createAssetPlayer(t, a, e)
                    }
                    createAssetPlayer(t, e, i) {
                        this.log(`create HLSAssetPlayer for ${Rn(e)}`);
                        const s = this.hls,
                            r = s.userConfig;
                        let n = r.videoPreference;
                        const c = s.loadLevelObj || s.levels[s.currentLevel];
                        (n || c) && (n = b({}, n), c.videoCodec && (n.videoCodec = c.videoCodec), c.videoRange && (n.allowedVideoRanges = [c.videoRange]));
                        const u = s.audioTracks[s.audioTrack],
                            d = s.subtitleTracks[s.subtitleTrack];
                        let h = 0;
                        if (this.primaryLive || t.appendInPlace) {
                            const t = this.timelinePos - e.timelineStart;
                            if (t > 1) {
                                const i = e.duration;
                                i && t < i && (h = t)
                            }
                        }
                        const f = e.identifier,
                            p = E(E({}, r), {}, {
                                autoStartLoad: !0,
                                startFragPrefetch: !0,
                                primarySessionId: s.sessionId,
                                assetPlayerId: f,
                                abrEwmaDefaultEstimate: s.bandwidthEstimate,
                                interstitialsController: void 0,
                                startPosition: h,
                                liveDurationInfinity: !1,
                                testBandwidth: !1,
                                videoPreference: n,
                                audioPreference: u || r.audioPreference,
                                subtitlePreference: d || r.subtitlePreference
                            });
                        t.appendInPlace && (t.appendInPlaceStarted = !0, e.timelineStart && (p.timelineOffset = e.timelineStart));
                        const g = p.cmcd;
                        null != g && g.sessionId && g.contentId && (p.cmcd = b({}, g, {
                            contentId: En(e.uri)
                        })), this.getAssetPlayer(f) && this.warn(`Duplicate date range identifier ${t} and asset ${f}`);
                        const m = new In(this.HlsPlayerClass, p, t, e);
                        this.playerQueue.push(m), t.assetList[i] = e;
                        const y = s => {
                            if (s.live) {
                                const e = new Error(`Interstitials MUST be VOD assets ${t}`),
                                    s = {
                                        fatal: !0,
                                        type: a.OTHER_ERROR,
                                        details: o.INTERSTITIAL_ASSET_ITEM_ERROR,
                                        error: e
                                    };
                                return void this.handleAssetItemError(s, t, this.schedule.findEventIndex(t.identifier), i, e.message)
                            }
                            const r = s.edge - s.fragmentStart,
                                n = e.duration;
                            (null === n || r > n) && (this.log(`Interstitial asset "${f}" duration change ${n} > ${r}`), e.duration = r, this.updateSchedule())
                        };
                        m.on(l.LEVEL_UPDATED, ((t, {
                            details: e
                        }) => y(e))), m.on(l.LEVEL_PTS_UPDATED, ((t, {
                            details: e
                        }) => y(e)));
                        const v = (t, e) => {
                            const i = this.getAssetPlayer(f);
                            if (i && e.tracks) {
                                i.off(l.BUFFER_CODECS, v), i.tracks = e.tracks;
                                const t = this.primaryMedia;
                                this.bufferingAsset === i.assetItem && t && !i.media && this.bufferAssetPlayer(i, t)
                            }
                        };
                        m.on(l.BUFFER_CODECS, v);
                        const T = () => {
                            var i;
                            const s = this.getAssetPlayer(f);
                            if (this.log(`buffered to end of asset ${s}`), !s) return;
                            const r = this.schedule.findEventIndex(t.identifier),
                                n = t.findAssetIndex(e),
                                a = n + 1,
                                o = null == (i = this.schedule.items) ? void 0 : i[r];
                            if (this.isInterstitial(o))
                                if (-1 === n || t.isAssetPastPlayoutLimit(a) || t.assetList[a].error) {
                                    var l;
                                    const t = null == (l = this.schedule.items) ? void 0 : l[r + 1];
                                    t && this.bufferedToItem(t)
                                } else this.bufferedToItem(o, a)
                        };
                        m.on(l.BUFFERED_TO_END, T);
                        const S = e => () => {
                            if (!this.getAssetPlayer(f)) return;
                            this.shouldPlay = !0;
                            const i = this.schedule.findEventIndex(t.identifier);
                            this.advanceAfterAssetEnded(t, i, e)
                        };
                        return m.once(l.MEDIA_ENDED, S(i)), m.once(l.PLAYOUT_LIMIT_REACHED, S(1 / 0)), m.on(l.ERROR, ((e, s) => {
                            const r = this.getAssetPlayer(f);
                            if (s.details !== o.BUFFER_STALLED_ERROR) this.handleAssetItemError(s, t, this.schedule.findEventIndex(t.identifier), i, `Asset player error ${s.error} ${t}`);
                            else if (null != r && r.media) {
                                const e = r.currentTime,
                                    i = r.duration - e;
                                e && t.appendInPlace && i / r.media.playbackRate < .5 ? (this.log(`Advancing buffer past end of asset ${f} ${t} at ${r.media.currentTime}`), T()) : (this.warn(`Stalled at ${e} of ${e+i} in asset ${f} ${t}`), this.onTimeupdate(), this.checkBuffer(!0))
                            }
                        })), m.on(l.DESTROYING, (() => {
                            if (!this.getAssetPlayer(f)) return;
                            const e = new Error(`Asset player destroyed unexpectedly ${f}`),
                                s = {
                                    fatal: !0,
                                    type: a.OTHER_ERROR,
                                    details: o.INTERSTITIAL_ASSET_ITEM_ERROR,
                                    error: e
                                };
                            this.handleAssetItemError(s, t, this.schedule.findEventIndex(t.identifier), i, e.message)
                        })), this.hls.trigger(l.INTERSTITIAL_ASSET_PLAYER_CREATED, {
                            asset: e,
                            assetListIndex: i,
                            event: t,
                            player: m
                        }), m
                    }
                    clearInterstitial(t, e) {
                        t.assetList.forEach((t => {
                            this.clearAssetPlayer(t.identifier, e)
                        })), t.reset()
                    }
                    clearAssetPlayer(t, e) {
                        const i = this.getAssetPlayerQueueIndex(t);
                        if (-1 !== i) {
                            this.log(`clearAssetPlayer "${t}" toSegment: ${e?Dn(e):e}`);
                            const s = this.playerQueue[i];
                            this.transferMediaFromPlayer(s, e), this.playerQueue.splice(i, 1), s.destroy()
                        }
                    }
                    emptyPlayerQueue() {
                        let t;
                        for (; t = this.playerQueue.pop();) t.destroy();
                        this.playerQueue = []
                    }
                    startAssetPlayer(t, e, i, s, r) {
                        const {
                            interstitial: n,
                            assetItem: a,
                            assetId: o
                        } = t, c = n.assetList.length, u = this.playingAsset;
                        this.endedAsset = null, this.playingAsset = a, u && u.identifier === o || (u && (this.clearAssetPlayer(u.identifier, i[s]), delete u.error), this.log(`INTERSTITIAL_ASSET_STARTED ${e+1}/${c} ${t}`), this.hls.trigger(l.INTERSTITIAL_ASSET_STARTED, {
                            asset: a,
                            assetListIndex: e,
                            event: n,
                            schedule: i.slice(0),
                            scheduleIndex: s,
                            player: t
                        })), this.bufferAssetPlayer(t, r)
                    }
                    bufferAssetPlayer(t, e) {
                        var i, s;
                        const {
                            interstitial: r,
                            assetItem: n,
                            assetId: l
                        } = t, c = this.schedule.findEventIndex(r.identifier), u = null == (i = this.schedule.items) ? void 0 : i[c];
                        if (!u) return;
                        this.setBufferingItem(u), this.bufferingAsset = n;
                        const d = this.getBufferingPlayer();
                        if (d === t) return;
                        const h = r.appendInPlace;
                        if (h && !1 === (null == d ? void 0 : d.interstitial.appendInPlace)) return;
                        const f = (null == d ? void 0 : d.tracks) || (null == (s = this.detachedData) ? void 0 : s.tracks) || this.requiredTracks;
                        if (h && n !== this.playingAsset) {
                            if (!t.tracks) return;
                            if (f && !C(f, t.tracks)) {
                                const e = new Error(`Asset "${l}" SourceBuffer tracks ('${Object.keys(t.tracks)}') are not compatible with primary content tracks ('${Object.keys(f)}')`),
                                    i = {
                                        fatal: !0,
                                        type: a.OTHER_ERROR,
                                        details: o.INTERSTITIAL_ASSET_ITEM_ERROR,
                                        error: e
                                    },
                                    s = r.findAssetIndex(n);
                                return void this.handleAssetItemError(i, r, c, s, e.message)
                            }
                        }
                        this.transferMediaTo(t, e)
                    }
                    handleAssetItemError(t, e, i, s, r) {
                        if (t.details === o.BUFFER_STALLED_ERROR) return;
                        const n = e.assetList[s] || null;
                        let a = null;
                        if (n) {
                            const t = this.getAssetPlayerQueueIndex(n.identifier);
                            a = this.playerQueue[t] || null
                        }
                        const c = this.schedule.items,
                            u = b({}, t, {
                                fatal: !1,
                                errorAction: pe(!0),
                                asset: n,
                                assetListIndex: s,
                                event: e,
                                schedule: c,
                                scheduleIndex: i,
                                player: a
                            });
                        if (this.warn(`Asset item error: ${t.error}`), this.hls.trigger(l.INTERSTITIAL_ASSET_ERROR, u), !t.fatal) return;
                        const d = new Error(r);
                        n && (this.playingAsset !== n && this.clearAssetPlayer(n.identifier, null), n.error = d), e.assetList.some((t => !t.error)) ? e.appendInPlace && (e.error = d) : e.error = d, this.primaryFallback(e)
                    }
                    primaryFallback(t) {
                        const e = t.timelineStart,
                            i = this.effectivePlayingItem;
                        if (this.updateSchedule(), i) {
                            this.log(`Fallback to primary from event "${t.identifier}" start: ${e} pos: ${this.timelinePos} playing: ${i?Dn(i):"<none>"} error: ${t.error}`), t.appendInPlace && (this.attachPrimary(e, null), this.flushFrontBuffer(e));
                            let s = this.timelinePos; - 1 === s && (s = this.hls.startPosition);
                            const r = this.updateItem(i, s);
                            if (this.itemsMatch(i, r)) this.clearInterstitial(t, null);
                            else {
                                const t = this.schedule.findItemIndexAtTime(s);
                                this.setSchedulePosition(t)
                            }
                        } else this.checkStart()
                    }
                    onAssetListLoaded(t, e) {
                        var i;
                        const s = e.event,
                            r = s.identifier,
                            n = e.assetListResponse.ASSETS;
                        if (!this.schedule.hasEvent(r)) return;
                        const a = s.timelineStart,
                            o = s.duration;
                        let l = 0;
                        n.forEach(((t, e) => {
                            const i = parseFloat(t.DURATION);
                            this.createAsset(s, e, l, a + l, i, t.URI), l += i
                        })), s.duration = l, this.log(`Loaded asset-list with duration: ${l} (was: ${o}) ${s}`);
                        const c = this.waitingItem,
                            u = (null == c ? void 0 : c.event.identifier) === r;
                        this.updateSchedule();
                        const d = null == (i = this.bufferingItem) ? void 0 : i.event;
                        if (u) {
                            var h;
                            const t = this.schedule.findEventIndex(r),
                                e = null == (h = this.schedule.items) ? void 0 : h[t];
                            if (e) {
                                if (!this.playingItem && this.timelinePos > e.end && this.schedule.findItemIndexAtTime(this.timelinePos) !== t) return s.error = new Error(`Interstitial no longer within playback range ${this.timelinePos} ${s}`), void this.primaryFallback(s);
                                this.setBufferingItem(e)
                            }
                            this.setSchedulePosition(t)
                        } else if ((null == d ? void 0 : d.identifier) === r && d.appendInPlace) {
                            const t = s.assetList[0],
                                e = this.getAssetPlayer(t.identifier),
                                i = this.primaryMedia;
                            t && e && i && this.bufferAssetPlayer(e, i)
                        }
                    }
                    onError(t, e) {
                        switch (e.details) {
                            case o.ASSET_LIST_PARSING_ERROR:
                            case o.ASSET_LIST_LOAD_ERROR:
                            case o.ASSET_LIST_LOAD_TIMEOUT:
                                {
                                    const t = e.interstitial;t && this.primaryFallback(t);
                                    break
                                }
                            case o.BUFFER_STALLED_ERROR:
                                this.onTimeupdate(), this.checkBuffer(!0)
                        }
                    }
                }
            });

            function $a(t) {
                return t && "object" == typeof t ? Array.isArray(t) ? t.map($a) : Object.keys(t).reduce(((e, i) => (e[i] = $a(t[i]), e)), {}) : t
            }
            class Ua extends De {
                constructor(t, e) {
                    super("gap-controller", t.logger), this.hls = null, this.fragmentTracker = null, this.media = null, this.mediaSource = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.buffered = {}, this.lastCurrentTime = 0, this.ended = 0, this.waiting = 0, this.onMediaPlaying = () => {
                        this.ended = 0, this.waiting = 0
                    }, this.onMediaWaiting = () => {
                        var t;
                        null != (t = this.media) && t.seeking || (this.waiting = self.performance.now(), this.tick())
                    }, this.onMediaEnded = () => {
                        var t;
                        this.hls && (this.ended = (null == (t = this.media) ? void 0 : t.currentTime) || 1, this.hls.trigger(l.MEDIA_ENDED, {
                            stalled: !1
                        }))
                    }, this.hls = t, this.fragmentTracker = e, this.registerListeners()
                }
                registerListeners() {
                    const {
                        hls: t
                    } = this;
                    t && (t.on(l.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(l.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(l.BUFFER_APPENDED, this.onBufferAppended, this))
                }
                unregisterListeners() {
                    const {
                        hls: t
                    } = this;
                    t && (t.off(l.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(l.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(l.BUFFER_APPENDED, this.onBufferAppended, this))
                }
                destroy() {
                    super.destroy(), this.unregisterListeners(), this.media = this.hls = this.fragmentTracker = null, this.mediaSource = void 0
                }
                onMediaAttached(t, e) {
                    this.setInterval(100), this.mediaSource = e.mediaSource;
                    const i = this.media = e.media;
                    Pn(i, "playing", this.onMediaPlaying), Pn(i, "waiting", this.onMediaWaiting), Pn(i, "ended", this.onMediaEnded)
                }
                onMediaDetaching(t, e) {
                    this.clearInterval();
                    const {
                        media: i
                    } = this;
                    i && (On(i, "playing", this.onMediaPlaying), On(i, "waiting", this.onMediaWaiting), On(i, "ended", this.onMediaEnded), this.media = null), this.mediaSource = void 0
                }
                onBufferAppended(t, e) {
                    this.buffered = e.timeRanges
                }
                get hasBuffered() {
                    return Object.keys(this.buffered).length > 0
                }
                tick() {
                    var t;
                    if (null == (t = this.media) || !t.readyState || !this.hasBuffered) return;
                    const e = this.media.currentTime;
                    this.poll(e, this.lastCurrentTime), this.lastCurrentTime = e
                }
                poll(t, e) {
                    var i, s;
                    const r = null == (i = this.hls) ? void 0 : i.config;
                    if (!r) return;
                    const {
                        media: n,
                        stalled: a
                    } = this;
                    if (!n) return;
                    const {
                        seeking: o
                    } = n, c = this.seeking && !o, u = !this.seeking && o, d = n.paused && !o || n.ended || 0 === n.playbackRate;
                    if (this.seeking = o, t !== e) return e && (this.ended = 0), this.moved = !0, o || (this.nudgeRetry = 0, r.nudgeOnVideoHole && !d && t > e && this.nudgeOnVideoHole(t, e)), void(0 === this.waiting && this.stallResolved(t));
                    if (u || c) return void(c && this.stallResolved(t));
                    if (d) return this.nudgeRetry = 0, this.stallResolved(t), void(!this.ended && n.ended && this.hls && (this.ended = t || 1, this.hls.trigger(l.MEDIA_ENDED, {
                        stalled: !1
                    })));
                    if (!Oe.getBuffered(n).length) return void(this.nudgeRetry = 0);
                    const h = Oe.bufferInfo(n, t, 0),
                        f = h.nextStart || 0,
                        p = this.fragmentTracker;
                    if (o && p && this.hls) {
                        const e = Ba(this.hls.inFlightFragments, t),
                            i = h.len > 2,
                            s = !f || e || f - t > 2 && !p.getPartialFragment(t);
                        if (i || s) return;
                        this.moved = !1
                    }
                    const g = null == (s = this.hls) ? void 0 : s.latestLevelDetails;
                    if (!this.moved && null !== this.stalled && p) {
                        if (!(h.len > 0 || f)) return;
                        const e = Math.max(f, h.start || 0) - t,
                            i = null != g && g.live ? 2 * g.targetduration : 2,
                            s = p.getPartialFragment(t);
                        if (e > 0 && (e <= i || s)) return void(n.paused || this._trySkipBufferHole(s))
                    }
                    const m = r.detectStallWithCurrentTimeMs,
                        y = self.performance.now(),
                        v = this.waiting;
                    if (null === a) return void(this.stalled = v > 0 && y - v < m ? v : y);
                    const b = y - a;
                    if (!o && (b >= m || v) && this.hls) {
                        var T;
                        if ("ended" === (null == (T = this.mediaSource) ? void 0 : T.readyState) && (null == g || !g.live) && Math.abs(t - ((null == g ? void 0 : g.edge) || 0)) < 1) {
                            if (this.ended) return;
                            return this.ended = t || 1, void this.hls.trigger(l.MEDIA_ENDED, {
                                stalled: !0
                            })
                        }
                        if (this._reportStall(h), !this.media || !this.hls) return
                    }
                    const E = Oe.bufferInfo(n, t, r.maxBufferHole);
                    this._tryFixBufferStall(E, b)
                }
                stallResolved(t) {
                    const e = this.stalled;
                    if (e && this.hls && (this.stalled = null, this.stallReported)) {
                        const i = self.performance.now() - e;
                        this.log(`playback not stuck anymore @${t}, after ${Math.round(i)}ms`), this.stallReported = !1, this.waiting = 0, this.hls.trigger(l.STALL_RESOLVED, {})
                    }
                }
                nudgeOnVideoHole(t, e) {
                    var i;
                    const s = this.buffered.video;
                    if (this.hls && this.media && this.fragmentTracker && null != (i = this.buffered.audio) && i.length && s && s.length > 1 && t > s.end(0)) {
                        const i = Oe.bufferedInfo(Oe.timeRangesToArray(this.buffered.audio), t, 0);
                        if (i.len > 1 && e >= i.start) {
                            const i = Oe.timeRangesToArray(s),
                                r = Oe.bufferedInfo(i, e, 0).bufferedIndex;
                            if (r > -1 && r < i.length - 1) {
                                const e = Oe.bufferedInfo(i, t, 0).bufferedIndex,
                                    s = i[r].end,
                                    n = i[r + 1].start;
                                if ((-1 === e || e > r) && n - s < 1 && t - s < 2) {
                                    const i = new Error(`nudging playhead to flush pipeline after video hole. currentTime: ${t} hole: ${s} -> ${n} buffered index: ${e}`);
                                    this.warn(i.message), this.media.currentTime += 1e-6;
                                    const r = this.fragmentTracker.getPartialFragment(t) || void 0,
                                        c = Oe.bufferInfo(this.media, t, 0);
                                    this.hls.trigger(l.ERROR, {
                                        type: a.MEDIA_ERROR,
                                        details: o.BUFFER_SEEK_OVER_HOLE,
                                        fatal: !1,
                                        error: i,
                                        reason: i.message,
                                        frag: r,
                                        buffer: c.len,
                                        bufferInfo: c
                                    })
                                }
                            }
                        }
                    }
                }
                _tryFixBufferStall(t, e) {
                    var i, s;
                    const {
                        fragmentTracker: r,
                        media: n
                    } = this, a = null == (i = this.hls) ? void 0 : i.config;
                    if (!n || !r || !a) return;
                    const o = n.currentTime,
                        l = null == (s = this.hls) ? void 0 : s.latestLevelDetails,
                        c = r.getPartialFragment(o);
                    if ((c || null != l && l.live && o < l.fragmentStart) && (this._trySkipBufferHole(c) || !this.media)) return;
                    const u = t.buffered;
                    (u && u.length > 1 && t.len > a.maxBufferHole || t.nextStart && t.nextStart - o < a.maxBufferHole) && (e > 1e3 * a.highBufferWatchdogPeriod || this.waiting) && (this.warn("Trying to nudge playhead over buffer-hole"), this._tryNudgeBuffer(t))
                }
                _reportStall(t) {
                    const {
                        hls: e,
                        media: i,
                        stallReported: s,
                        stalled: r
                    } = this;
                    if (!s && null !== r && i && e) {
                        this.stallReported = !0;
                        const s = new Error(`Playback stalling at @${i.currentTime} due to low buffer (${Yt(t)})`);
                        this.warn(s.message), e.trigger(l.ERROR, {
                            type: a.MEDIA_ERROR,
                            details: o.BUFFER_STALLED_ERROR,
                            fatal: !1,
                            error: s,
                            buffer: t.len,
                            bufferInfo: t,
                            stalled: {
                                start: r
                            }
                        })
                    }
                }
                _trySkipBufferHole(t) {
                    var e;
                    const {
                        fragmentTracker: i,
                        media: s
                    } = this, r = null == (e = this.hls) ? void 0 : e.config;
                    if (!s || !i || !r) return 0;
                    const n = s.currentTime,
                        c = Oe.bufferInfo(s, n, 0),
                        u = n < c.start ? c.start : c.nextStart;
                    if (u && this.hls) {
                        const e = c.len <= r.maxBufferHole,
                            h = c.len > 0 && c.len < 1 && s.readyState < 3,
                            p = u - n;
                        if (p > 0 && (e || h)) {
                            if (p > r.maxBufferHole) {
                                let e = !1;
                                if (0 === n) {
                                    const t = i.getAppendedFrag(0, f);
                                    t && u < t.end && (e = !0)
                                }
                                if (!e) {
                                    const e = t || i.getAppendedFrag(n, f);
                                    if (e) {
                                        var d;
                                        if (null == (d = this.hls.loadLevelObj) || !d.details) return 0;
                                        if (Ba(this.hls.inFlightFragments, u)) return 0;
                                        let t = !1,
                                            s = e.end;
                                        for (; s < u;) {
                                            const e = i.getPartialFragment(s);
                                            if (!e) {
                                                t = !0;
                                                break
                                            }
                                            s += e.duration
                                        }
                                        if (t) return 0
                                    }
                                }
                            }
                            const e = Math.max(u + .05, n + .1);
                            if (this.warn(`skipping hole, adjusting currentTime from ${n} to ${e}`), this.moved = !0, s.currentTime = e, null == t || !t.gap) {
                                const i = new Error(`fragment loaded with buffer holes, seeking from ${n} to ${e}`);
                                this.hls.trigger(l.ERROR, {
                                    type: a.MEDIA_ERROR,
                                    details: o.BUFFER_SEEK_OVER_HOLE,
                                    fatal: !1,
                                    error: i,
                                    reason: i.message,
                                    frag: t || void 0,
                                    buffer: c.len,
                                    bufferInfo: c
                                })
                            }
                            return e
                        }
                    }
                    return 0
                }
                _tryNudgeBuffer(t) {
                    const {
                        hls: e,
                        media: i,
                        nudgeRetry: s
                    } = this, r = null == e ? void 0 : e.config;
                    if (!i || !r) return 0;
                    const n = i.currentTime;
                    if (this.nudgeRetry++, s < r.nudgeMaxRetry) {
                        const c = n + (s + 1) * r.nudgeOffset,
                            u = new Error(`Nudging 'currentTime' from ${n} to ${c}`);
                        this.warn(u.message), i.currentTime = c, e.trigger(l.ERROR, {
                            type: a.MEDIA_ERROR,
                            details: o.BUFFER_NUDGE_ON_STALL,
                            error: u,
                            fatal: !1,
                            buffer: t.len,
                            bufferInfo: t
                        })
                    } else {
                        const i = new Error(`Playhead still not moving while enough data buffered @${n} after ${r.nudgeMaxRetry} nudges`);
                        this.error(i.message), e.trigger(l.ERROR, {
                            type: a.MEDIA_ERROR,
                            details: o.BUFFER_STALLED_ERROR,
                            error: i,
                            fatal: !0,
                            buffer: t.len,
                            bufferInfo: t
                        })
                    }
                }
            }

            function Ba(t, e) {
                const i = ja(t.main);
                if (i && i.start <= e) return i;
                const s = ja(t.audio);
                return s && s.start <= e ? s : null
            }

            function ja(t) {
                if (!t) return null;
                switch (t.state) {
                    case Gi.IDLE:
                    case Gi.STOPPED:
                    case Gi.ENDED:
                    case Gi.ERROR:
                        return null
                }
                return t.frag
            }

            function Ga() {
                if ("undefined" != typeof self) return self.VTTCue || self.TextTrackCue
            }

            function Va(t, e, i, s, r) {
                let n = new t(e, i, "");
                try {
                    n.value = s, r && (n.type = r)
                } catch (a) {
                    n = new t(e, i, Yt(r ? E({
                        type: r
                    }, s) : s))
                }
                return n
            }
            const Ha = (() => {
                const t = Ga();
                try {
                    t && new t(0, Number.POSITIVE_INFINITY, "")
                } catch (t) {
                    return Number.MAX_VALUE
                }
                return Number.POSITIVE_INFINITY
            })();
            class Ka {
                constructor(t) {
                    this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.removeCues = !0, this.onEventCueEnter = () => {
                        this.hls && this.hls.trigger(l.EVENT_CUE_ENTER, {})
                    }, this.hls = t, this._registerListeners()
                }
                destroy() {
                    this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = this.onEventCueEnter = null
                }
                _registerListeners() {
                    const {
                        hls: t
                    } = this;
                    t.on(l.MEDIA_ATTACHING, this.onMediaAttaching, this), t.on(l.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(l.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(l.MANIFEST_LOADING, this.onManifestLoading, this), t.on(l.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), t.on(l.BUFFER_FLUSHING, this.onBufferFlushing, this), t.on(l.LEVEL_UPDATED, this.onLevelUpdated, this), t.on(l.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this)
                }
                _unregisterListeners() {
                    const {
                        hls: t
                    } = this;
                    t.off(l.MEDIA_ATTACHING, this.onMediaAttaching, this), t.off(l.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(l.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(l.MANIFEST_LOADING, this.onManifestLoading, this), t.off(l.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), t.off(l.BUFFER_FLUSHING, this.onBufferFlushing, this), t.off(l.LEVEL_UPDATED, this.onLevelUpdated, this), t.off(l.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this)
                }
                onMediaAttaching(t, e) {
                    var i;
                    this.media = e.media, !1 === (null == (i = e.overrides) ? void 0 : i.cueRemoval) && (this.removeCues = !1)
                }
                onMediaAttached() {
                    const t = this.hls.latestLevelDetails;
                    t && this.updateDateRangeCues(t)
                }
                onMediaDetaching(t, e) {
                    this.media = null, e.transferMedia || (this.id3Track && (this.removeCues && vn(this.id3Track, this.onEventCueEnter), this.id3Track = null), this.dateRangeCuesAppended = {})
                }
                onManifestLoading() {
                    this.dateRangeCuesAppended = {}
                }
                createTrack(t) {
                    const e = this.getID3Track(t.textTracks);
                    return e.mode = "hidden", e
                }
                getID3Track(t) {
                    if (this.media) {
                        for (let e = 0; e < t.length; e++) {
                            const i = t[e];
                            if ("metadata" === i.kind && "id3" === i.label) return mn(i, this.media), i
                        }
                        return this.media.addTextTrack("metadata", "id3")
                    }
                }
                onFragParsingMetadata(t, e) {
                    if (!this.media) return;
                    const {
                        hls: {
                            config: {
                                enableEmsgMetadataCues: i,
                                enableID3MetadataCues: s
                            }
                        }
                    } = this;
                    if (!i && !s) return;
                    const {
                        samples: r
                    } = e;
                    this.id3Track || (this.id3Track = this.createTrack(this.media));
                    const n = Ga();
                    if (n)
                        for (let t = 0; t < r.length; t++) {
                            const e = r[t].type;
                            if (e === Es.emsg && !i || !s) continue;
                            const a = ys(r[t].data);
                            if (a) {
                                const i = r[t].pts;
                                let s = i + r[t].duration;
                                s > Ha && (s = Ha), s - i <= 0 && (s = i + .25);
                                for (let t = 0; t < a.length; t++) {
                                    const r = a[t];
                                    if (!vs(r)) {
                                        this.updateId3CueEnds(i, e);
                                        const t = Va(n, i, s, r, e);
                                        t && this.id3Track.addCue(t)
                                    }
                                }
                            }
                        }
                }
                updateId3CueEnds(t, e) {
                    var i;
                    const s = null == (i = this.id3Track) ? void 0 : i.cues;
                    if (s)
                        for (let i = s.length; i--;) {
                            const r = s[i];
                            r.type === e && r.startTime < t && r.endTime === Ha && (r.endTime = t)
                        }
                }
                onBufferFlushing(t, {
                    startOffset: e,
                    endOffset: i,
                    type: s
                }) {
                    const {
                        id3Track: r,
                        hls: n
                    } = this;
                    if (!n) return;
                    const {
                        config: {
                            enableEmsgMetadataCues: a,
                            enableID3MetadataCues: o
                        }
                    } = n;
                    if (r && (a || o)) {
                        let t;
                        t = "audio" === s ? t => t.type === Es.audioId3 && o : "video" === s ? t => t.type === Es.emsg && a : t => t.type === Es.audioId3 && o || t.type === Es.emsg && a, bn(r, e, i, t)
                    }
                }
                onLevelUpdated(t, {
                    details: e
                }) {
                    this.updateDateRangeCues(e, !0)
                }
                onLevelPtsUpdated(t, e) {
                    Math.abs(e.drift) > .01 && this.updateDateRangeCues(e.details)
                }
                updateDateRangeCues(t, e) {
                    if (!this.media || !t.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) return;
                    const {
                        id3Track: i
                    } = this, {
                        dateRanges: r
                    } = t, n = Object.keys(r);
                    let a = this.dateRangeCuesAppended;
                    var o;
                    if (i && e)
                        if (null != (o = i.cues) && o.length) {
                            const t = Object.keys(a).filter((t => !n.includes(t)));
                            for (let e = t.length; e--;) {
                                const s = t[e],
                                    r = a[s].cues;
                                delete a[s], Object.keys(r).forEach((t => {
                                    try {
                                        const e = r[t];
                                        e.removeEventListener("enter", this.onEventCueEnter), i.removeCue(e)
                                    } catch (t) {}
                                }))
                            }
                        } else a = this.dateRangeCuesAppended = {};
                    const l = t.fragments[t.fragments.length - 1];
                    if (0 === n.length || !s(null == l ? void 0 : l.programDateTime)) return;
                    this.id3Track || (this.id3Track = this.createTrack(this.media));
                    const c = Ga();
                    for (let t = 0; t < n.length; t++) {
                        const e = n[t],
                            i = r[e],
                            s = i.startTime,
                            o = a[e],
                            l = (null == o ? void 0 : o.cues) || {};
                        let h = (null == o ? void 0 : o.durationKnown) || !1,
                            f = Ha;
                        const {
                            duration: p,
                            endDate: g
                        } = i;
                        if (g && null !== p) f = s + p, h = !0;
                        else if (i.endOnNext && !h) {
                            const t = n.reduce(((t, e) => {
                                if (e !== i.id) {
                                    const s = r[e];
                                    if (s.class === i.class && s.startDate > i.startDate && (!t || i.startDate < t.startDate)) return s
                                }
                                return t
                            }), null);
                            t && (f = t.startTime, h = !0)
                        }
                        const m = Object.keys(i.attr);
                        for (let t = 0; t < m.length; t++) {
                            const r = m[t];
                            if ("ID" === (d = r) || "CLASS" === d || "CUE" === d || "START-DATE" === d || "DURATION" === d || "END-DATE" === d || "END-ON-NEXT" === d) continue;
                            const n = l[r];
                            if (n) h && !o.durationKnown ? n.endTime = f : Math.abs(n.startTime - s) > .01 && (n.startTime = s, n.endTime = f);
                            else if (c) {
                                let t = i.attr[r];
                                Ve(r) && (u = t, t = Uint8Array.from(u.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer);
                                const n = Va(c, s, f, {
                                    key: r,
                                    data: t
                                }, Es.dateRange);
                                n && (n.id = e, this.id3Track.addCue(n), l[r] = n, this.hls.config.interstitialsController && ("X-ASSET-LIST" !== r && "X-ASSET-URL" !== r || n.addEventListener("enter", this.onEventCueEnter)))
                            }
                        }
                        a[e] = {
                            cues: l,
                            dateRange: i,
                            durationKnown: h
                        }
                    }
                    var u, d
                }
            }
            class za {
                constructor(t) {
                    this.hls = void 0, this.config = void 0, this.media = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this._targetLatencyUpdated = !1, this.onTimeupdate = () => {
                        const {
                            media: t
                        } = this, e = this.levelDetails;
                        if (!t || !e) return;
                        this.currentTime = t.currentTime;
                        const i = this.computeLatency();
                        if (null === i) return;
                        this._latency = i;
                        const {
                            lowLatencyMode: s,
                            maxLiveSyncPlaybackRate: r
                        } = this.config;
                        if (!s || 1 === r || !e.live) return;
                        const n = this.targetLatency;
                        if (null === n) return;
                        const a = i - n;
                        if (a < Math.min(this.maxLatency, n + e.targetduration) && a > .05 && this.forwardBufferLength > 1) {
                            const e = Math.min(2, Math.max(1, r)),
                                i = Math.round(2 / (1 + Math.exp(-.75 * a - this.edgeStalled)) * 20) / 20,
                                s = Math.min(e, Math.max(1, i));
                            this.changeMediaPlaybackRate(t, s)
                        } else 1 !== t.playbackRate && 0 !== t.playbackRate && this.changeMediaPlaybackRate(t, 1)
                    }, this.hls = t, this.config = t.config, this.registerListeners()
                }
                get levelDetails() {
                    var t;
                    return (null == (t = this.hls) ? void 0 : t.latestLevelDetails) || null
                }
                get latency() {
                    return this._latency || 0
                }
                get maxLatency() {
                    const {
                        config: t
                    } = this;
                    if (void 0 !== t.liveMaxLatencyDuration) return t.liveMaxLatencyDuration;
                    const e = this.levelDetails;
                    return e ? t.liveMaxLatencyDurationCount * e.targetduration : 0
                }
                get targetLatency() {
                    const t = this.levelDetails;
                    if (null === t || null === this.hls) return null;
                    const {
                        holdBack: e,
                        partHoldBack: i,
                        targetduration: s
                    } = t, {
                        liveSyncDuration: r,
                        liveSyncDurationCount: n,
                        lowLatencyMode: a
                    } = this.config, o = this.hls.userConfig;
                    let l = a && i || e;
                    (this._targetLatencyUpdated || o.liveSyncDuration || o.liveSyncDurationCount || 0 === l) && (l = void 0 !== r ? r : n * s);
                    const c = s;
                    return l + Math.min(this.stallCount * this.config.liveSyncOnStallIncrease, c)
                }
                set targetLatency(t) {
                    this.stallCount = 0, this.config.liveSyncDuration = t, this._targetLatencyUpdated = !0
                }
                get liveSyncPosition() {
                    const t = this.estimateLiveEdge(),
                        e = this.targetLatency;
                    if (null === t || null === e) return null;
                    const i = this.levelDetails;
                    if (null === i) return null;
                    const s = i.edge,
                        r = t - e - this.edgeStalled,
                        n = s - i.totalduration,
                        a = s - (this.config.lowLatencyMode && i.partTarget || i.targetduration);
                    return Math.min(Math.max(n, r), a)
                }
                get drift() {
                    const t = this.levelDetails;
                    return null === t ? 1 : t.drift
                }
                get edgeStalled() {
                    const t = this.levelDetails;
                    if (null === t) return 0;
                    const e = 3 * (this.config.lowLatencyMode && t.partTarget || t.targetduration);
                    return Math.max(t.age - e, 0)
                }
                get forwardBufferLength() {
                    const {
                        media: t
                    } = this, e = this.levelDetails;
                    if (!t || !e) return 0;
                    const i = t.buffered.length;
                    return (i ? t.buffered.end(i - 1) : e.edge) - this.currentTime
                }
                destroy() {
                    this.unregisterListeners(), this.onMediaDetaching(), this.hls = null
                }
                registerListeners() {
                    const {
                        hls: t
                    } = this;
                    t && (t.on(l.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(l.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(l.MANIFEST_LOADING, this.onManifestLoading, this), t.on(l.LEVEL_UPDATED, this.onLevelUpdated, this), t.on(l.ERROR, this.onError, this))
                }
                unregisterListeners() {
                    const {
                        hls: t
                    } = this;
                    t && (t.off(l.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(l.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(l.MANIFEST_LOADING, this.onManifestLoading, this), t.off(l.LEVEL_UPDATED, this.onLevelUpdated, this), t.off(l.ERROR, this.onError, this))
                }
                onMediaAttached(t, e) {
                    this.media = e.media, this.media.addEventListener("timeupdate", this.onTimeupdate)
                }
                onMediaDetaching() {
                    this.media && (this.media.removeEventListener("timeupdate", this.onTimeupdate), this.media = null)
                }
                onManifestLoading() {
                    this._latency = null, this.stallCount = 0
                }
                onLevelUpdated(t, {
                    details: e
                }) {
                    e.advanced && this.onTimeupdate(), !e.live && this.media && this.media.removeEventListener("timeupdate", this.onTimeupdate)
                }
                onError(t, e) {
                    var i;
                    e.details === o.BUFFER_STALLED_ERROR && (this.stallCount++, this.hls && null != (i = this.levelDetails) && i.live && this.hls.logger.warn("[latency-controller]: Stall detected, adjusting target latency"))
                }
                changeMediaPlaybackRate(t, e) {
                    var i, s;
                    t.playbackRate !== e && (null == (i = this.hls) || i.logger.debug(`[latency-controller]: latency=${this.latency.toFixed(3)}, targetLatency=${null==(s=this.targetLatency)?void 0:s.toFixed(3)}, forwardBufferLength=${this.forwardBufferLength.toFixed(3)}: adjusting playback rate from ${t.playbackRate} to ${e}`), t.playbackRate = e)
                }
                estimateLiveEdge() {
                    const t = this.levelDetails;
                    return null === t ? null : t.edge + t.age
                }
                computeLatency() {
                    const t = this.estimateLiveEdge();
                    return null === t ? null : t - this.currentTime
                }
            }
            class qa extends Tr {
                constructor(t, e) {
                    super(t, "level-controller"), this._levels = [], this._firstLevel = -1, this._maxAutoLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = e, this._registerListeners()
                }
                _registerListeners() {
                    const {
                        hls: t
                    } = this;
                    t.on(l.MANIFEST_LOADING, this.onManifestLoading, this), t.on(l.MANIFEST_LOADED, this.onManifestLoaded, this), t.on(l.LEVEL_LOADED, this.onLevelLoaded, this), t.on(l.LEVELS_UPDATED, this.onLevelsUpdated, this), t.on(l.FRAG_BUFFERED, this.onFragBuffered, this), t.on(l.ERROR, this.onError, this)
                }
                _unregisterListeners() {
                    const {
                        hls: t
                    } = this;
                    t.off(l.MANIFEST_LOADING, this.onManifestLoading, this), t.off(l.MANIFEST_LOADED, this.onManifestLoaded, this), t.off(l.LEVEL_LOADED, this.onLevelLoaded, this), t.off(l.LEVELS_UPDATED, this.onLevelsUpdated, this), t.off(l.FRAG_BUFFERED, this.onFragBuffered, this), t.off(l.ERROR, this.onError, this)
                }
                destroy() {
                    this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy()
                }
                stopLoad() {
                    this._levels.forEach((t => {
                        t.loadError = 0, t.fragmentError = 0
                    })), super.stopLoad()
                }
                resetLevels() {
                    this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = [], this._maxAutoLevel = -1
                }
                onManifestLoading(t, e) {
                    this.resetLevels()
                }
                onManifestLoaded(t, e) {
                    const i = this.hls.config.preferManagedMediaSource,
                        s = [],
                        r = {},
                        n = {};
                    let a = !1,
                        o = !1,
                        l = !1;
                    e.levels.forEach((t => {
                        var e;
                        const c = t.attrs;
                        let {
                            audioCodec: u,
                            videoCodec: d
                        } = t;
                        u && (t.audioCodec = u = Pt(u, i) || void 0), 0 === (null == (e = d) ? void 0 : e.indexOf("avc1")) && (d = t.videoCodec = function(t) {
                            const e = t.split(",");
                            for (let t = 0; t < e.length; t++) {
                                const i = e[t].split(".");
                                if (i.length > 2) {
                                    let s = i.shift() + ".";
                                    s += parseInt(i.shift()).toString(16), s += ("000" + parseInt(i.shift()).toString(16)).slice(-4), e[t] = s
                                }
                            }
                            return e.join(",")
                        }(d));
                        const {
                            width: h,
                            height: f,
                            unknownCodecs: p
                        } = t;
                        let g = p ? p.length : 0;
                        if (p)
                            for (let e = g; e--;) {
                                const i = p[e];
                                this.isAudioSupported(i) ? (t.audioCodec = u = u ? `${u},${i}` : i, g--, kt.audio[u.substring(0, 4)] = 2) : this.isVideoSupported(i) && (t.videoCodec = d = d ? `${d},${i}` : i, g--, kt.video[d.substring(0, 4)] = 2)
                            }
                        if (a || (a = !(!h || !f)), o || (o = !!d), l || (l = !!u), g || u && !this.isAudioSupported(u) || d && !this.isVideoSupported(d)) return void this.log(`Some or all CODECS not supported "${c.CODECS}"`);
                        const {
                            CODECS: m,
                            "FRAME-RATE": y,
                            "HDCP-LEVEL": v,
                            "PATHWAY-ID": b,
                            RESOLUTION: T,
                            "VIDEO-RANGE": E
                        } = c, S = `${b||"."}-${t.bitrate}-${T}-${y}-${m}-${E}-${v}`;
                        if (r[S])
                            if (r[S].uri === t.url || t.attrs["PATHWAY-ID"]) r[S].addGroupId("audio", c.AUDIO), r[S].addGroupId("text", c.SUBTITLES);
                            else {
                                const e = n[S] += 1;
                                t.attrs["PATHWAY-ID"] = new Array(e + 1).join(".");
                                const i = this.createLevel(t);
                                r[S] = i, s.push(i)
                            }
                        else {
                            const e = this.createLevel(t);
                            r[S] = e, n[S] = 1, s.push(e)
                        }
                    })), this.filterAndSortMediaOptions(s, e, a, o, l)
                }
                createLevel(t) {
                    const e = new qt(t),
                        i = t.supplemental;
                    if (null != i && i.videoCodec && !this.isVideoSupported(i.videoCodec)) {
                        const t = new Error(`SUPPLEMENTAL-CODECS not supported "${i.videoCodec}"`);
                        this.log(t.message), e.supportedResult = Ut(t, [])
                    }
                    return e
                }
                isAudioSupported(t) {
                    return _t(t, "audio", this.hls.config.preferManagedMediaSource)
                }
                isVideoSupported(t) {
                    return _t(t, "video", this.hls.config.preferManagedMediaSource)
                }
                filterAndSortMediaOptions(t, e, i, s, r) {
                    let n = [],
                        c = [],
                        u = t;
                    if ((i || s) && r && (u = u.filter((({
                            videoCodec: t,
                            videoRange: e,
                            width: i,
                            height: s
                        }) => {
                            return (!!t || !(!i || !s)) && !!(r = e) && Ht.indexOf(r) > -1;
                            var r
                        }))), 0 === u.length) return void Promise.resolve().then((() => {
                        if (this.hls) {
                            let t = "no level with compatible codecs found in manifest",
                                i = t;
                            e.levels.length && (i = `one or more CODECS in variant not supported: ${Yt(e.levels.map((t=>t.attrs.CODECS)).filter(((t,e,i)=>i.indexOf(t)===e)))}`, this.warn(i), t += ` (${i})`);
                            const s = new Error(t);
                            this.hls.trigger(l.ERROR, {
                                type: a.MEDIA_ERROR,
                                details: o.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                                fatal: !0,
                                url: e.url,
                                error: s,
                                reason: i
                            })
                        }
                    }));
                    e.audioTracks && (n = e.audioTracks.filter((t => !t.audioCodec || this.isAudioSupported(t.audioCodec))), Wa(n)), e.subtitles && (c = e.subtitles, Wa(c));
                    const d = u.slice(0);
                    u.sort(((t, e) => {
                        if (t.attrs["HDCP-LEVEL"] !== e.attrs["HDCP-LEVEL"]) return (t.attrs["HDCP-LEVEL"] || "") > (e.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
                        if (i && t.height !== e.height) return t.height - e.height;
                        if (t.frameRate !== e.frameRate) return t.frameRate - e.frameRate;
                        if (t.videoRange !== e.videoRange) return Ht.indexOf(t.videoRange) - Ht.indexOf(e.videoRange);
                        if (t.videoCodec !== e.videoCodec) {
                            const i = It(t.videoCodec),
                                s = It(e.videoCodec);
                            if (i !== s) return s - i
                        }
                        if (t.uri === e.uri && t.codecSet !== e.codecSet) {
                            const i = Ct(t.codecSet),
                                s = Ct(e.codecSet);
                            if (i !== s) return s - i
                        }
                        return t.averageBitrate !== e.averageBitrate ? t.averageBitrate - e.averageBitrate : 0
                    }));
                    let h = d[0];
                    if (this.steering && (u = this.steering.filterParsedLevels(u), u.length !== d.length))
                        for (let t = 0; t < d.length; t++)
                            if (d[t].pathwayId === u[0].pathwayId) {
                                h = d[t];
                                break
                            }
                    this._levels = u;
                    for (let t = 0; t < u.length; t++)
                        if (u[t] === h) {
                            var f;
                            this._firstLevel = t;
                            const e = h.bitrate,
                                i = this.hls.bandwidthEstimate;
                            if (this.log(`manifest loaded, ${u.length} level(s) found, first bitrate: ${e}`), void 0 === (null == (f = this.hls.userConfig) ? void 0 : f.abrEwmaDefaultEstimate)) {
                                const t = Math.min(e, this.hls.config.abrEwmaDefaultEstimateMax);
                                t > i && i === this.hls.abrEwmaDefaultEstimate && (this.hls.bandwidthEstimate = t)
                            }
                            break
                        }
                    const p = r && !s,
                        g = this.hls.config,
                        m = !(!g.audioStreamController || !g.audioTrackController),
                        y = {
                            levels: u,
                            audioTracks: n,
                            subtitleTracks: c,
                            sessionData: e.sessionData,
                            sessionKeys: e.sessionKeys,
                            firstLevel: this._firstLevel,
                            stats: e.stats,
                            audio: r,
                            video: s,
                            altAudio: m && !p && n.some((t => !!t.url))
                        };
                    this.hls.trigger(l.MANIFEST_PARSED, y)
                }
                get levels() {
                    return 0 === this._levels.length ? null : this._levels
                }
                get loadLevelObj() {
                    return this.currentLevel
                }
                get level() {
                    return this.currentLevelIndex
                }
                set level(t) {
                    const e = this._levels;
                    if (0 === e.length) return;
                    if (t < 0 || t >= e.length) {
                        const i = new Error("invalid level idx"),
                            s = t < 0;
                        if (this.hls.trigger(l.ERROR, {
                                type: a.OTHER_ERROR,
                                details: o.LEVEL_SWITCH_ERROR,
                                level: t,
                                fatal: s,
                                error: i,
                                reason: i.message
                            }), s) return;
                        t = Math.min(t, e.length - 1)
                    }
                    const i = this.currentLevelIndex,
                        s = this.currentLevel,
                        r = s ? s.attrs["PATHWAY-ID"] : void 0,
                        n = e[t],
                        c = n.attrs["PATHWAY-ID"];
                    if (this.currentLevelIndex = t, this.currentLevel = n, i === t && s && r === c) return;
                    this.log(`Switching to level ${t} (${n.height?n.height+"p ":""}${n.videoRange?n.videoRange+" ":""}${n.codecSet?n.codecSet+" ":""}@${n.bitrate})${c?" with Pathway "+c:""} from level ${i}${r?" with Pathway "+r:""}`);
                    const u = {
                        level: t,
                        attrs: n.attrs,
                        details: n.details,
                        bitrate: n.bitrate,
                        averageBitrate: n.averageBitrate,
                        maxBitrate: n.maxBitrate,
                        realBitrate: n.realBitrate,
                        width: n.width,
                        height: n.height,
                        codecSet: n.codecSet,
                        audioCodec: n.audioCodec,
                        videoCodec: n.videoCodec,
                        audioGroups: n.audioGroups,
                        subtitleGroups: n.subtitleGroups,
                        loaded: n.loaded,
                        loadError: n.loadError,
                        fragmentError: n.fragmentError,
                        name: n.name,
                        id: n.id,
                        uri: n.uri,
                        url: n.url,
                        urlId: 0,
                        audioGroupIds: n.audioGroupIds,
                        textGroupIds: n.textGroupIds
                    };
                    this.hls.trigger(l.LEVEL_SWITCHING, u);
                    const d = n.details;
                    if (!d || d.live) {
                        const t = this.switchParams(n.uri, null == s ? void 0 : s.details, d);
                        this.loadPlaylist(t)
                    }
                }
                get manualLevel() {
                    return this.manualLevelIndex
                }
                set manualLevel(t) {
                    this.manualLevelIndex = t, void 0 === this._startLevel && (this._startLevel = t), -1 !== t && (this.level = t)
                }
                get firstLevel() {
                    return this._firstLevel
                }
                set firstLevel(t) {
                    this._firstLevel = t
                }
                get startLevel() {
                    if (void 0 === this._startLevel) {
                        const t = this.hls.config.startLevel;
                        return void 0 !== t ? t : this.hls.firstAutoLevel
                    }
                    return this._startLevel
                }
                set startLevel(t) {
                    this._startLevel = t
                }
                get pathways() {
                    return this.steering ? this.steering.pathways() : []
                }
                get pathwayPriority() {
                    return this.steering ? this.steering.pathwayPriority : null
                }
                set pathwayPriority(t) {
                    if (this.steering) {
                        const e = this.steering.pathways(),
                            i = t.filter((t => -1 !== e.indexOf(t)));
                        if (t.length < 1) return void this.warn(`pathwayPriority ${t} should contain at least one pathway from list: ${e}`);
                        this.steering.pathwayPriority = i
                    }
                }
                onError(t, e) {
                    !e.fatal && e.context && e.context.type === u && e.context.level === this.level && this.checkRetry(e)
                }
                onFragBuffered(t, {
                    frag: e
                }) {
                    if (void 0 !== e && e.type === f) {
                        const t = e.elementaryStreams;
                        if (!Object.keys(t).some((e => !!t[e]))) return;
                        const i = this._levels[e.level];
                        null != i && i.loadError && (this.log(`Resetting level error count of ${i.loadError} on frag buffered`), i.loadError = 0)
                    }
                }
                onLevelLoaded(t, e) {
                    var i;
                    const {
                        level: s,
                        details: r
                    } = e, n = e.levelInfo;
                    var a;
                    if (!n) return this.warn(`Invalid level index ${s}`), void(null != (a = e.deliveryDirectives) && a.skip && (r.deltaUpdateFailed = !0));
                    if (n === this.currentLevel || e.withoutMultiVariant) {
                        0 === n.fragmentError && (n.loadError = 0);
                        let t = n.details;
                        t === e.details && t.advanced && (t = void 0), this.playlistLoaded(s, e, t)
                    } else null != (i = e.deliveryDirectives) && i.skip && (r.deltaUpdateFailed = !0)
                }
                loadPlaylist(t) {
                    super.loadPlaylist(), this.shouldLoadPlaylist(this.currentLevel) && this.scheduleLoading(this.currentLevel, t)
                }
                loadingPlaylist(t, e) {
                    super.loadingPlaylist(t, e);
                    const i = this.getUrlWithDirectives(t.uri, e),
                        s = this.currentLevelIndex,
                        r = t.attrs["PATHWAY-ID"],
                        n = t.details,
                        a = null == n ? void 0 : n.age;
                    this.log(`Loading level index ${s}${void 0!==(null==e?void 0:e.msn)?" at sn "+e.msn+" part "+e.part:""}${r?" Pathway "+r:""}${a&&n.live?" age "+a.toFixed(1)+(n.type?" "+n.type||0:""):""} ${i}`), this.hls.trigger(l.LEVEL_LOADING, {
                        url: i,
                        level: s,
                        levelInfo: t,
                        pathwayId: t.attrs["PATHWAY-ID"],
                        id: 0,
                        deliveryDirectives: e || null
                    })
                }
                get nextLoadLevel() {
                    return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel
                }
                set nextLoadLevel(t) {
                    this.level = t, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = t)
                }
                removeLevel(t) {
                    var e;
                    if (1 === this._levels.length) return;
                    const i = this._levels.filter(((e, i) => i !== t || (this.steering && this.steering.removeLevel(e), e === this.currentLevel && (this.currentLevel = null, this.currentLevelIndex = -1, e.details && e.details.fragments.forEach((t => t.level = -1))), !1)));
                    Ni(i), this._levels = i, this.currentLevelIndex > -1 && null != (e = this.currentLevel) && e.details && (this.currentLevelIndex = this.currentLevel.details.fragments[0].level), this.manualLevelIndex > -1 && (this.manualLevelIndex = this.currentLevelIndex);
                    const s = i.length - 1;
                    this._firstLevel = Math.min(this._firstLevel, s), this._startLevel && (this._startLevel = Math.min(this._startLevel, s)), this.hls.trigger(l.LEVELS_UPDATED, {
                        levels: i
                    })
                }
                onLevelsUpdated(t, {
                    levels: e
                }) {
                    this._levels = e
                }
                checkMaxAutoUpdated() {
                    const {
                        autoLevelCapping: t,
                        maxAutoLevel: e,
                        maxHdcpLevel: i
                    } = this.hls;
                    this._maxAutoLevel !== e && (this._maxAutoLevel = e, this.hls.trigger(l.MAX_AUTO_LEVEL_UPDATED, {
                        autoLevelCapping: t,
                        levels: this.levels,
                        maxAutoLevel: e,
                        minAutoLevel: this.hls.minAutoLevel,
                        maxHdcpLevel: i
                    }))
                }
            }

            function Wa(t) {
                const e = {};
                t.forEach((t => {
                    const i = t.groupId || "";
                    t.id = e[i] = e[i] || 0, e[i]++
                }))
            }

            function Ya() {
                return self.SourceBuffer || self.WebKitSourceBuffer
            }

            function Xa() {
                if (!I()) return !1;
                const t = Ya();
                return !t || t.prototype && "function" == typeof t.prototype.appendBuffer && "function" == typeof t.prototype.remove
            }
            class Qa extends Vi {
                constructor(t, e, i) {
                    super(t, e, i, "stream-controller", f), this.audioCodecSwap = !1, this.level = -1, this._forceStartLoad = !1, this._hasEnoughToStart = !1, this.altAudio = 0, this.audioOnly = !1, this.fragPlaying = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this.onMediaPlaying = () => {
                        this.tick()
                    }, this.onMediaSeeked = () => {
                        const t = this.media,
                            e = t ? t.currentTime : null;
                        if (null === e || !s(e)) return;
                        if (this.log(`Media seeked to ${e.toFixed(3)}`), !this.getBufferedFrag(e)) return;
                        const i = this.getFwdBufferInfoAtPos(t, e, f, 0);
                        null !== i && 0 !== i.len ? this.tick() : this.warn(`Main forward buffer length at ${e} on "seeked" event ${i?i.len:"empty"})`)
                    }, this.registerListeners()
                }
                registerListeners() {
                    super.registerListeners();
                    const {
                        hls: t
                    } = this;
                    t.on(l.MANIFEST_PARSED, this.onManifestParsed, this), t.on(l.LEVEL_LOADING, this.onLevelLoading, this), t.on(l.LEVEL_LOADED, this.onLevelLoaded, this), t.on(l.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), t.on(l.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.on(l.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.on(l.BUFFER_CREATED, this.onBufferCreated, this), t.on(l.BUFFER_FLUSHED, this.onBufferFlushed, this), t.on(l.LEVELS_UPDATED, this.onLevelsUpdated, this), t.on(l.FRAG_BUFFERED, this.onFragBuffered, this)
                }
                unregisterListeners() {
                    super.unregisterListeners();
                    const {
                        hls: t
                    } = this;
                    t.off(l.MANIFEST_PARSED, this.onManifestParsed, this), t.off(l.LEVEL_LOADED, this.onLevelLoaded, this), t.off(l.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), t.off(l.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.off(l.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.off(l.BUFFER_CREATED, this.onBufferCreated, this), t.off(l.BUFFER_FLUSHED, this.onBufferFlushed, this), t.off(l.LEVELS_UPDATED, this.onLevelsUpdated, this), t.off(l.FRAG_BUFFERED, this.onFragBuffered, this)
                }
                onHandlerDestroying() {
                    this.onMediaPlaying = this.onMediaSeeked = null, this.unregisterListeners(), super.onHandlerDestroying()
                }
                startLoad(t, e) {
                    if (this.levels) {
                        const {
                            lastCurrentTime: i,
                            hls: s
                        } = this;
                        if (this.stopLoad(), this.setInterval(100), this.level = -1, !this.startFragRequested) {
                            let t = s.startLevel; - 1 === t && (s.config.testBandwidth && this.levels.length > 1 ? (t = 0, this.bitrateTest = !0) : t = s.firstAutoLevel), s.nextLoadLevel = t, this.level = s.loadLevel, this._hasEnoughToStart = !!e
                        }
                        i > 0 && -1 === t && !e && (this.log(`Override startPosition with lastCurrentTime @${i.toFixed(3)}`), t = i), this.state = Gi.IDLE, this.nextLoadPosition = this.lastCurrentTime = t + this.timelineOffset, this.startPosition = e ? -1 : t, this.tick()
                    } else this._forceStartLoad = !0, this.state = Gi.STOPPED
                }
                stopLoad() {
                    this._forceStartLoad = !1, super.stopLoad()
                }
                doTick() {
                    switch (this.state) {
                        case Gi.WAITING_LEVEL:
                            {
                                const {
                                    levels: t,
                                    level: e
                                } = this,
                                i = null == t ? void 0 : t[e],
                                s = null == i ? void 0 : i.details;
                                if (s && (!s.live || this.levelLastLoaded === i && !this.waitForLive(i))) {
                                    if (this.waitForCdnTuneIn(s)) break;
                                    this.state = Gi.IDLE;
                                    break
                                }
                                if (this.hls.nextLoadLevel !== this.level) {
                                    this.state = Gi.IDLE;
                                    break
                                }
                                break
                            }
                        case Gi.FRAG_LOADING_WAITING_RETRY:
                            {
                                var t;
                                const e = self.performance.now(),
                                    i = this.retryDate;
                                if (!i || e >= i || null != (t = this.media) && t.seeking) {
                                    const {
                                        levels: t,
                                        level: e
                                    } = this, i = null == t ? void 0 : t[e];
                                    this.resetStartWhenNotLoaded(i || null), this.state = Gi.IDLE
                                }
                            }
                    }
                    this.state === Gi.IDLE && this.doTickIdle(), this.onTickEnd()
                }
                onTickEnd() {
                    var t;
                    super.onTickEnd(), null != (t = this.media) && t.readyState && !1 === this.media.seeking && (this.lastCurrentTime = this.media.currentTime), this.checkFragmentChanged()
                }
                doTickIdle() {
                    const {
                        hls: t,
                        levelLastLoaded: e,
                        levels: i,
                        media: s
                    } = this;
                    if (null === e || !s && !this.primaryPrefetch && (this.startFragRequested || !t.config.startFragPrefetch)) return;
                    if (this.altAudio && this.audioOnly) return;
                    const r = this.buffering ? t.nextLoadLevel : t.loadLevel;
                    if (null == i || !i[r]) return;
                    const n = i[r],
                        a = this.getMainFwdBufferInfo();
                    if (null === a) return;
                    const o = this.getLevelDetails();
                    if (o && this._streamEnded(a, o)) {
                        const t = {};
                        return 2 === this.altAudio && (t.type = "video"), this.hls.trigger(l.BUFFER_EOS, t), void(this.state = Gi.ENDED)
                    }
                    if (!this.buffering) return;
                    t.loadLevel !== r && -1 === t.manualLevel && this.log(`Adapting to level ${r} from level ${this.level}`), this.level = t.nextLoadLevel = r;
                    const c = n.details;
                    if (!c || this.state === Gi.WAITING_LEVEL || this.waitForLive(n)) return this.level = r, this.state = Gi.WAITING_LEVEL, void(this.startFragRequested = !1);
                    const u = a.len,
                        d = this.getMaxBufferLength(n.maxBitrate);
                    if (u >= d) return;
                    this.backtrackFragment && this.backtrackFragment.start > a.end && (this.backtrackFragment = null);
                    const h = this.backtrackFragment ? this.backtrackFragment.start : a.end;
                    let p = this.getNextFragment(h, c);
                    if (this.couldBacktrack && !this.fragPrevious && p && q(p) && this.fragmentTracker.getState(p) !== ve) {
                        var g;
                        const t = (null != (g = this.backtrackFragment) ? g : p).sn - c.startSN,
                            e = c.fragments[t - 1];
                        e && p.cc === e.cc && (p = e, this.fragmentTracker.removeFragment(e))
                    } else this.backtrackFragment && a.len && (this.backtrackFragment = null);
                    if (p && this.isLoopLoading(p, h)) {
                        if (!p.gap) {
                            const t = this.audioOnly && !this.altAudio ? V : H,
                                e = (t === H ? this.videoBuffer : this.mediaBuffer) || this.media;
                            e && this.afterBufferFlushed(e, t, f)
                        }
                        p = this.getNextFragmentLoopLoading(p, c, a, f, d)
                    }
                    p && (!p.initSegment || p.initSegment.data || this.bitrateTest || (p = p.initSegment), this.loadFragment(p, n, h))
                }
                loadFragment(t, e, i) {
                    const s = this.fragmentTracker.getState(t);
                    s === ge || s === ye ? q(t) ? this.bitrateTest ? (this.log(`Fragment ${t.sn} of level ${t.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(t, e)) : super.loadFragment(t, e, i) : this._loadInitSegment(t, e) : this.clearTrackerIfNeeded(t)
                }
                getBufferedFrag(t) {
                    return this.fragmentTracker.getBufferedFrag(t, f)
                }
                followingBufferedFrag(t) {
                    return t ? this.getBufferedFrag(t.end + .5) : null
                }
                immediateLevelSwitch() {
                    this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
                }
                nextLevelSwitch() {
                    const {
                        levels: t,
                        media: e
                    } = this;
                    if (null != e && e.readyState) {
                        let i;
                        const s = this.getAppendedFrag(e.currentTime);
                        s && s.start > 1 && this.flushMainBuffer(0, s.start - 1);
                        const r = this.getLevelDetails();
                        if (null != r && r.live) {
                            const t = this.getMainFwdBufferInfo();
                            if (!t || t.len < 2 * r.targetduration) return
                        }
                        if (!e.paused && t) {
                            const e = t[this.hls.nextLoadLevel],
                                s = this.fragLastKbps;
                            i = s && this.fragCurrent ? this.fragCurrent.duration * e.maxBitrate / (1e3 * s) + 1 : 0
                        } else i = 0;
                        const n = this.getBufferedFrag(e.currentTime + i);
                        if (n) {
                            const t = this.followingBufferedFrag(n);
                            if (t) {
                                this.abortCurrentFrag();
                                const e = t.maxStartPTS ? t.maxStartPTS : t.start,
                                    i = t.duration,
                                    s = Math.max(n.end, e + Math.min(Math.max(i - this.config.maxFragLookUpTolerance, i * (this.couldBacktrack ? .5 : .125)), i * (this.couldBacktrack ? .75 : .25)));
                                this.flushMainBuffer(s, Number.POSITIVE_INFINITY)
                            }
                        }
                    }
                }
                abortCurrentFrag() {
                    const t = this.fragCurrent;
                    switch (this.fragCurrent = null, this.backtrackFragment = null, t && (t.abortRequests(), this.fragmentTracker.removeFragment(t)), this.state) {
                        case Gi.KEY_LOADING:
                        case Gi.FRAG_LOADING:
                        case Gi.FRAG_LOADING_WAITING_RETRY:
                        case Gi.PARSING:
                        case Gi.PARSED:
                            this.state = Gi.IDLE
                    }
                    this.nextLoadPosition = this.getLoadPosition()
                }
                flushMainBuffer(t, e) {
                    super.flushMainBuffer(t, e, 2 === this.altAudio ? "video" : null)
                }
                onMediaAttached(t, e) {
                    super.onMediaAttached(t, e);
                    const i = e.media;
                    Pn(i, "playing", this.onMediaPlaying), Pn(i, "seeked", this.onMediaSeeked)
                }
                onMediaDetaching(t, e) {
                    const {
                        media: i
                    } = this;
                    i && (On(i, "playing", this.onMediaPlaying), On(i, "seeked", this.onMediaSeeked)), this.videoBuffer = null, this.fragPlaying = null, super.onMediaDetaching(t, e), e.transferMedia || (this._hasEnoughToStart = !1)
                }
                onManifestLoading() {
                    super.onManifestLoading(), this.log("Trigger BUFFER_RESET"), this.hls.trigger(l.BUFFER_RESET, void 0), this.couldBacktrack = !1, this.fragLastKbps = 0, this.fragPlaying = this.backtrackFragment = null, this.altAudio = 0, this.audioOnly = !1
                }
                onManifestParsed(t, e) {
                    let i = !1,
                        s = !1;
                    e.levels.forEach((t => {
                        const e = t.audioCodec;
                        e && (i = i || -1 !== e.indexOf("mp4a.40.2"), s = s || -1 !== e.indexOf("mp4a.40.5"))
                    })), this.audioCodecSwitch = i && s && ! function() {
                        var t;
                        const e = Ya();
                        return "function" == typeof(null == e || null == (t = e.prototype) ? void 0 : t.changeType)
                    }(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = e.levels, this.startFragRequested = !1
                }
                onLevelLoading(t, e) {
                    const {
                        levels: i
                    } = this;
                    if (!i || this.state !== Gi.IDLE) return;
                    const s = e.levelInfo;
                    (!s.details || s.details.live && (this.levelLastLoaded !== s || s.details.expired) || this.waitForCdnTuneIn(s.details)) && (this.state = Gi.WAITING_LEVEL)
                }
                onLevelLoaded(t, e) {
                    var i;
                    const {
                        levels: s,
                        startFragRequested: r
                    } = this, n = e.level, a = e.details, o = a.totalduration;
                    if (!s) return void this.warn(`Levels were reset while loading level ${n}`);
                    this.log(`Level ${n} loaded [${a.startSN},${a.endSN}]${a.lastPartSn?`[part-${a.lastPartSn}-${a.lastPartIndex}]`:""}, cc [${a.startCC}, ${a.endCC}] duration:${o}`);
                    const c = e.levelInfo,
                        u = this.fragCurrent;
                    !u || this.state !== Gi.FRAG_LOADING && this.state !== Gi.FRAG_LOADING_WAITING_RETRY || u.level !== e.level && u.loader && this.abortCurrentFrag();
                    let d = 0;
                    if (a.live || null != (i = c.details) && i.live) {
                        var h;
                        if (this.checkLiveUpdate(a), a.deltaUpdateFailed) return;
                        d = this.alignPlaylists(a, c.details, null == (h = this.levelLastLoaded) ? void 0 : h.details)
                    }
                    if (c.details = a, this.levelLastLoaded = c, r || this.setStartPosition(a, d), this.hls.trigger(l.LEVEL_UPDATED, {
                            details: a,
                            level: n
                        }), this.state === Gi.WAITING_LEVEL) {
                        if (this.waitForCdnTuneIn(a)) return;
                        this.state = Gi.IDLE
                    }
                    r && a.live && this.synchronizeToLiveEdge(a), this.tick()
                }
                synchronizeToLiveEdge(t) {
                    const {
                        config: e,
                        media: i
                    } = this;
                    if (!i) return;
                    const s = this.hls.liveSyncPosition,
                        r = this.getLoadPosition(),
                        n = t.fragmentStart,
                        a = t.edge,
                        o = r >= n - e.maxFragLookUpTolerance && r <= a;
                    if (null !== s && i.duration > s && (r < s || !o)) {
                        const n = void 0 !== e.liveMaxLatencyDuration ? e.liveMaxLatencyDuration : e.liveMaxLatencyDurationCount * t.targetduration;
                        (!o && i.readyState < 4 || r < a - n) && (this._hasEnoughToStart || (this.nextLoadPosition = s), i.readyState && (this.warn(`Playback: ${r.toFixed(3)} is located too far from the end of live sliding playlist: ${a}, reset currentTime to : ${s.toFixed(3)}`), i.currentTime = s))
                    }
                }
                _handleFragmentLoadProgress(t) {
                    var e;
                    const i = t.frag,
                        {
                            part: s,
                            payload: r
                        } = t,
                        {
                            levels: n
                        } = this;
                    if (!n) return void this.warn(`Levels were reset while fragment load was in progress. Fragment ${i.sn} of level ${i.level} will not be buffered`);
                    const a = n[i.level];
                    if (!a) return void this.warn(`Level ${i.level} not found on progress`);
                    const o = a.details;
                    if (!o) return this.warn(`Dropping fragment ${i.sn} of level ${i.level} after level details were reset`), void this.fragmentTracker.removeFragment(i);
                    const l = a.videoCodec,
                        c = o.PTSKnown || !o.live,
                        u = null == (e = i.initSegment) ? void 0 : e.data,
                        d = this._getAudioCodec(a),
                        h = this.transmuxer = this.transmuxer || new br(this.hls, f, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)),
                        p = s ? s.index : -1,
                        g = -1 !== p,
                        m = new xe(i.level, i.sn, i.stats.chunkCount, r.byteLength, p, g),
                        y = this.initPTS[i.cc];
                    h.push(r, u, d, l, i, s, o.totalduration, c, m, y)
                }
                onAudioTrackSwitching(t, e) {
                    const i = this.hls,
                        s = 2 === this.altAudio;
                    if (se(e.url, i)) this.altAudio = 1;
                    else {
                        if (this.mediaBuffer !== this.media) {
                            this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
                            const t = this.fragCurrent;
                            t && (this.log("Switching to main audio track, cancel main fragment load"), t.abortRequests(), this.fragmentTracker.removeFragment(t)), this.resetTransmuxer(), this.resetLoadingState()
                        } else this.audioOnly && this.resetTransmuxer();
                        if (s) return this.fragmentTracker.removeAllFragments(), i.once(l.BUFFER_FLUSHED, (() => {
                            var t;
                            null == (t = this.hls) || t.trigger(l.AUDIO_TRACK_SWITCHED, e)
                        })), void i.trigger(l.BUFFER_FLUSHING, {
                            startOffset: 0,
                            endOffset: Number.POSITIVE_INFINITY,
                            type: null
                        });
                        i.trigger(l.AUDIO_TRACK_SWITCHED, e)
                    }
                }
                onAudioTrackSwitched(t, e) {
                    const i = se(e.url, this.hls);
                    if (i) {
                        const t = this.videoBuffer;
                        t && this.mediaBuffer !== t && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = t)
                    }
                    this.altAudio = i ? 2 : 0, this.tick()
                }
                onBufferCreated(t, e) {
                    const i = e.tracks;
                    let s, r, n = !1;
                    for (const t in i) {
                        const e = i[t];
                        if ("main" === e.id) {
                            if (r = t, s = e, "video" === t) {
                                const e = i[t];
                                e && (this.videoBuffer = e.buffer)
                            }
                        } else n = !0
                    }
                    n && s ? (this.log(`Alternate track found, use ${r}.buffered to schedule main fragment loading`), this.mediaBuffer = s.buffer) : this.mediaBuffer = this.media
                }
                onFragBuffered(t, e) {
                    const {
                        frag: i,
                        part: s
                    } = e, r = i.type === f;
                    if (r) {
                        if (this.fragContextChanged(i)) return this.warn(`Fragment ${i.sn}${s?" p: "+s.index:""} of level ${i.level} finished buffering, but was aborted. state: ${this.state}`), void(this.state === Gi.PARSED && (this.state = Gi.IDLE));
                        const t = s ? s.stats : i.stats;
                        this.fragLastKbps = Math.round(8 * t.total / (t.buffering.end - t.loading.first)), q(i) && (this.fragPrevious = i), this.fragBufferedComplete(i, s)
                    }
                    const n = this.media;
                    n && (!this._hasEnoughToStart && Oe.getBuffered(n).length && (this._hasEnoughToStart = !0, this.seekToStartPos()), r && this.tick())
                }
                get hasEnoughToStart() {
                    return this._hasEnoughToStart
                }
                onError(t, e) {
                    var i;
                    if (e.fatal) this.state = Gi.ERROR;
                    else switch (e.details) {
                        case o.FRAG_GAP:
                        case o.FRAG_PARSING_ERROR:
                        case o.FRAG_DECRYPT_ERROR:
                        case o.FRAG_LOAD_ERROR:
                        case o.FRAG_LOAD_TIMEOUT:
                        case o.KEY_LOAD_ERROR:
                        case o.KEY_LOAD_TIMEOUT:
                            this.onFragmentOrKeyLoadError(f, e);
                            break;
                        case o.LEVEL_LOAD_ERROR:
                        case o.LEVEL_LOAD_TIMEOUT:
                        case o.LEVEL_PARSING_ERROR:
                            e.levelRetry || this.state !== Gi.WAITING_LEVEL || (null == (i = e.context) ? void 0 : i.type) !== u || (this.state = Gi.IDLE);
                            break;
                        case o.BUFFER_ADD_CODEC_ERROR:
                        case o.BUFFER_APPEND_ERROR:
                            if ("main" !== e.parent) return;
                            this.resetLoadingState();
                            break;
                        case o.BUFFER_FULL_ERROR:
                            if ("main" !== e.parent) return;
                            this.reduceLengthAndFlushBuffer(e) && this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
                            break;
                        case o.INTERNAL_EXCEPTION:
                            this.recoverWorkerError(e)
                    }
                }
                onFragLoadEmergencyAborted() {
                    this.state = Gi.IDLE, this._hasEnoughToStart || (this.startFragRequested = !1, this.nextLoadPosition = this.lastCurrentTime), this.tickImmediate()
                }
                onBufferFlushed(t, {
                    type: e
                }) {
                    if (e !== V || !this.altAudio) {
                        const t = (e === H ? this.videoBuffer : this.mediaBuffer) || this.media;
                        t && (this.afterBufferFlushed(t, e, f), this.tick())
                    }
                }
                onLevelsUpdated(t, e) {
                    this.level > -1 && this.fragCurrent && (this.level = this.fragCurrent.level, -1 === this.level && this.resetWhenMissingContext(this.fragCurrent)), this.levels = e.levels
                }
                swapAudioCodec() {
                    this.audioCodecSwap = !this.audioCodecSwap
                }
                seekToStartPos() {
                    const {
                        media: t
                    } = this;
                    if (!t) return;
                    const e = t.currentTime;
                    let i = this.startPosition;
                    if (i >= 0 && e < i) {
                        if (t.seeking) return void this.log(`could not seek to ${i}, already seeking at ${e}`);
                        const s = this.timelineOffset;
                        s && i && (i += s);
                        const r = this.getLevelDetails(),
                            n = Oe.getBuffered(t),
                            a = n.length ? n.start(0) : 0,
                            o = a - i,
                            l = Math.max(this.config.maxBufferHole, this.config.maxFragLookUpTolerance);
                        o > 0 && (o < l || this.loadingParts && o < 2 * ((null == r ? void 0 : r.partTarget) || 0)) && (this.log(`adjusting start position by ${o} to match buffer start`), i += o, this.startPosition = i), e < i && (this.log(`seek to target start position ${i} from current time ${e} buffer start ${a}`), t.currentTime = i)
                    }
                }
                _getAudioCodec(t) {
                    let e = this.config.defaultAudioCodec || t.audioCodec;
                    return this.audioCodecSwap && e && (this.log("Swapping audio codec"), e = -1 !== e.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), e
                }
                _loadBitrateTestFrag(t, e) {
                    t.bitrateTest = !0, this._doFragLoad(t, e).then((t => {
                        const {
                            hls: i
                        } = this, s = null == t ? void 0 : t.frag;
                        if (!s || this.fragContextChanged(s)) return;
                        e.fragmentError = 0, this.state = Gi.IDLE, this.startFragRequested = !1, this.bitrateTest = !1;
                        const r = s.stats;
                        r.parsing.start = r.parsing.end = r.buffering.start = r.buffering.end = self.performance.now(), i.trigger(l.FRAG_LOADED, t), s.bitrateTest = !1
                    }))
                }
                _handleTransmuxComplete(t) {
                    var e;
                    const i = this.playlistType,
                        {
                            hls: r
                        } = this,
                        {
                            remuxResult: n,
                            chunkMeta: a
                        } = t,
                        o = this.getCurrentContext(a);
                    if (!o) return void this.resetWhenMissingContext(a);
                    const {
                        frag: c,
                        part: u,
                        level: d
                    } = o, {
                        video: h,
                        text: f,
                        id3: p,
                        initSegment: g
                    } = n, {
                        details: m
                    } = d, y = this.altAudio ? void 0 : n.audio;
                    if (this.fragContextChanged(c)) this.fragmentTracker.removeFragment(c);
                    else {
                        if (this.state = Gi.PARSING, g) {
                            if (null != g && g.tracks) {
                                const t = c.initSegment || c;
                                this._bufferInitSegment(d, g.tracks, t, a), r.trigger(l.FRAG_PARSING_INIT_SEGMENT, {
                                    frag: t,
                                    id: i,
                                    tracks: g.tracks
                                })
                            }
                            const t = g.initPTS,
                                e = g.timescale;
                            s(t) && (this.initPTS[c.cc] = {
                                baseTime: t,
                                timescale: e
                            }, r.trigger(l.INIT_PTS_FOUND, {
                                frag: c,
                                id: i,
                                initPTS: t,
                                timescale: e
                            }))
                        }
                        if (h && m) {
                            y || "audiovideo" !== h.type || this.logMuxedErr(c);
                            const t = m.fragments[c.sn - 1 - m.startSN],
                                e = c.sn === m.startSN,
                                i = !t || c.cc > t.cc;
                            if (!1 !== n.independent) {
                                const {
                                    startPTS: t,
                                    endPTS: s,
                                    startDTS: r,
                                    endDTS: n
                                } = h;
                                if (u) u.elementaryStreams[h.type] = {
                                    startPTS: t,
                                    endPTS: s,
                                    startDTS: r,
                                    endDTS: n
                                };
                                else if (h.firstKeyFrame && h.independent && 1 === a.id && !i && (this.couldBacktrack = !0), h.dropped && h.independent) {
                                    const r = this.getMainFwdBufferInfo(),
                                        a = (r ? r.end : this.getLoadPosition()) + this.config.maxBufferHole,
                                        o = h.firstKeyFramePTS ? h.firstKeyFramePTS : t;
                                    if (!e && a < o - this.config.maxBufferHole && !i) return void this.backtrack(c);
                                    i && (c.gap = !0), c.setElementaryStreamInfo(h.type, c.start, s, c.start, n, !0)
                                } else e && t - (m.appliedTimelineOffset || 0) > 2 && (c.gap = !0);
                                c.setElementaryStreamInfo(h.type, t, s, r, n), this.backtrackFragment && (this.backtrackFragment = c), this.bufferFragmentData(h, c, u, a, e || i)
                            } else {
                                if (!e && !i) return void this.backtrack(c);
                                c.gap = !0
                            }
                        }
                        if (y) {
                            const {
                                startPTS: t,
                                endPTS: e,
                                startDTS: i,
                                endDTS: s
                            } = y;
                            u && (u.elementaryStreams[V] = {
                                startPTS: t,
                                endPTS: e,
                                startDTS: i,
                                endDTS: s
                            }), c.setElementaryStreamInfo(V, t, e, i, s), this.bufferFragmentData(y, c, u, a)
                        }
                        if (m && null != p && null != (e = p.samples) && e.length) {
                            const t = {
                                id: i,
                                frag: c,
                                details: m,
                                samples: p.samples
                            };
                            r.trigger(l.FRAG_PARSING_METADATA, t)
                        }
                        if (m && f) {
                            const t = {
                                id: i,
                                frag: c,
                                details: m,
                                samples: f.samples
                            };
                            r.trigger(l.FRAG_PARSING_USERDATA, t)
                        }
                    }
                }
                logMuxedErr(t) {
                    this.warn(`${q(t)?"Media":"Init"} segment with muxed audiovideo where only video expected: ${t.url}`)
                }
                _bufferInitSegment(t, e, i, s) {
                    if (this.state !== Gi.PARSING) return;
                    this.audioOnly = !!e.audio && !e.video, this.altAudio && !this.audioOnly && (delete e.audio, e.audiovideo && this.logMuxedErr(i));
                    const {
                        audio: r,
                        video: n,
                        audiovideo: a
                    } = e;
                    if (r) {
                        let i = Ot(r.codec, t.audioCodec);
                        "mp4a" === i && (i = "mp4a.40.5");
                        const s = navigator.userAgent.toLowerCase();
                        if (this.audioCodecSwitch) {
                            i && (i = -1 !== i.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5");
                            const t = r.metadata;
                            t && "channelCount" in t && 1 !== (t.channelCount || 1) && -1 === s.indexOf("firefox") && (i = "mp4a.40.5")
                        }
                        i && -1 !== i.indexOf("mp4a.40.5") && -1 !== s.indexOf("android") && "audio/mpeg" !== r.container && (i = "mp4a.40.2", this.log(`Android: force audio codec to ${i}`)), t.audioCodec && t.audioCodec !== i && this.log(`Swapping manifest audio codec "${t.audioCodec}" for "${i}"`), r.levelCodec = i, r.id = f, this.log(`Init audio buffer, container:${r.container}, codecs[selected/level/parsed]=[${i||""}/${t.audioCodec||""}/${r.codec}]`), delete e.audiovideo
                    }
                    if (n) {
                        n.levelCodec = t.videoCodec, n.id = f;
                        const i = n.codec;
                        if (4 === (null == i ? void 0 : i.length)) switch (i) {
                            case "hvc1":
                            case "hev1":
                                n.codec = "hvc1.1.6.L120.90";
                                break;
                            case "av01":
                                n.codec = "av01.0.04M.08";
                                break;
                            case "avc1":
                                n.codec = "avc1.42e01e"
                        }
                        this.log(`Init video buffer, container:${n.container}, codecs[level/parsed]=[${t.videoCodec||""}/${i}]${n.codec!==i?" parsed-corrected="+n.codec:""}${n.supplemental?" supplemental="+n.supplemental:""}`), delete e.audiovideo
                    }
                    a && (this.log(`Init audiovideo buffer, container:${a.container}, codecs[level/parsed]=[${t.codecs}/${a.codec}]`), delete e.video, delete e.audio);
                    const o = Object.keys(e);
                    if (o.length) {
                        if (this.hls.trigger(l.BUFFER_CODECS, e), !this.hls) return;
                        o.forEach((t => {
                            const r = e[t].initSegment;
                            null != r && r.byteLength && this.hls.trigger(l.BUFFER_APPENDING, {
                                type: t,
                                data: r,
                                frag: i,
                                part: null,
                                chunkMeta: s,
                                parent: i.type
                            })
                        }))
                    }
                    this.tickImmediate()
                }
                getMainFwdBufferInfo() {
                    const t = this.mediaBuffer && 2 === this.altAudio ? this.mediaBuffer : this.media;
                    return this.getFwdBufferInfo(t, f)
                }
                get maxBufferLength() {
                    const {
                        levels: t,
                        level: e
                    } = this, i = null == t ? void 0 : t[e];
                    return i ? this.getMaxBufferLength(i.maxBitrate) : this.config.maxBufferLength
                }
                backtrack(t) {
                    this.couldBacktrack = !0, this.backtrackFragment = t, this.resetTransmuxer(), this.flushBufferGap(t), this.fragmentTracker.removeFragment(t), this.fragPrevious = null, this.nextLoadPosition = t.start, this.state = Gi.IDLE
                }
                checkFragmentChanged() {
                    const t = this.media;
                    let e = null;
                    if (t && t.readyState > 1 && !1 === t.seeking) {
                        const i = t.currentTime;
                        if (Oe.isBuffered(t, i) ? e = this.getAppendedFrag(i) : Oe.isBuffered(t, i + .1) && (e = this.getAppendedFrag(i + .1)), e) {
                            this.backtrackFragment = null;
                            const t = this.fragPlaying,
                                i = e.level;
                            t && e.sn === t.sn && t.level === i || (this.fragPlaying = e, this.hls.trigger(l.FRAG_CHANGED, {
                                frag: e
                            }), t && t.level === i || this.hls.trigger(l.LEVEL_SWITCHED, {
                                level: i
                            }))
                        }
                    }
                }
                get nextLevel() {
                    const t = this.nextBufferedFrag;
                    return t ? t.level : -1
                }
                get currentFrag() {
                    var t;
                    if (this.fragPlaying) return this.fragPlaying;
                    const e = (null == (t = this.media) ? void 0 : t.currentTime) || this.lastCurrentTime;
                    return s(e) ? this.getAppendedFrag(e) : null
                }
                get currentProgramDateTime() {
                    var t;
                    const e = (null == (t = this.media) ? void 0 : t.currentTime) || this.lastCurrentTime;
                    if (s(e)) {
                        const t = this.getLevelDetails(),
                            i = this.currentFrag || (t ? ne(null, t.fragments, e) : null);
                        if (i) {
                            const t = i.programDateTime;
                            if (null !== t) {
                                const s = t + 1e3 * (e - i.start);
                                return new Date(s)
                            }
                        }
                    }
                    return null
                }
                get currentLevel() {
                    const t = this.currentFrag;
                    return t ? t.level : -1
                }
                get nextBufferedFrag() {
                    const t = this.currentFrag;
                    return t ? this.followingBufferedFrag(t) : null
                }
                get forceStartLoad() {
                    return this._forceStartLoad
                }
            }
            class Ja {
                constructor(t) {
                    this.config = void 0, this.keyUriToKeyInfo = {}, this.emeController = null, this.config = t
                }
                abort(t) {
                    for (const i in this.keyUriToKeyInfo) {
                        const s = this.keyUriToKeyInfo[i].loader;
                        if (s) {
                            var e;
                            if (t && t !== (null == (e = s.context) ? void 0 : e.frag.type)) return;
                            s.abort()
                        }
                    }
                }
                detach() {
                    for (const t in this.keyUriToKeyInfo) {
                        const e = this.keyUriToKeyInfo[t];
                        (e.mediaKeySessionContext || e.decryptdata.isCommonEncryption) && delete this.keyUriToKeyInfo[t]
                    }
                }
                destroy() {
                    this.detach();
                    for (const t in this.keyUriToKeyInfo) {
                        const e = this.keyUriToKeyInfo[t].loader;
                        e && e.destroy()
                    }
                    this.keyUriToKeyInfo = {}
                }
                createKeyLoadError(t, e = o.KEY_LOAD_ERROR, i, s, r) {
                    return new Ce({
                        type: a.NETWORK_ERROR,
                        details: e,
                        fatal: !1,
                        frag: t,
                        response: r,
                        error: i,
                        networkDetails: s
                    })
                }
                loadClear(t, e) {
                    if (this.emeController && this.config.emeEnabled) {
                        const {
                            sn: i,
                            cc: s
                        } = t;
                        for (let t = 0; t < e.length; t++) {
                            const r = e[t];
                            if (s <= r.cc && ("initSegment" === i || "initSegment" === r.sn || i < r.sn)) {
                                this.emeController.selectKeySystemFormat(r).then((t => {
                                    r.setKeyFormat(t)
                                }));
                                break
                            }
                        }
                    }
                }
                load(t) {
                    return !t.decryptdata && t.encrypted && this.emeController && this.config.emeEnabled ? this.emeController.selectKeySystemFormat(t).then((e => this.loadInternal(t, e))) : this.loadInternal(t)
                }
                loadInternal(t, e) {
                    var i, s;
                    e && t.setKeyFormat(e);
                    const r = t.decryptdata;
                    if (!r) {
                        const i = new Error(e ? `Expected frag.decryptdata to be defined after setting format ${e}` : "Missing decryption data on fragment in onKeyLoading");
                        return Promise.reject(this.createKeyLoadError(t, o.KEY_LOAD_ERROR, i))
                    }
                    const n = r.uri;
                    if (!n) return Promise.reject(this.createKeyLoadError(t, o.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${n}"`)));
                    let a = this.keyUriToKeyInfo[n];
                    if (null != (i = a) && i.decryptdata.key) return r.key = a.decryptdata.key, Promise.resolve({
                        frag: t,
                        keyInfo: a
                    });
                    var l;
                    if (null != (s = a) && s.keyLoadPromise) switch (null == (l = a.mediaKeySessionContext) ? void 0 : l.keyStatus) {
                        case void 0:
                        case "status-pending":
                        case "usable":
                        case "usable-in-future":
                            return a.keyLoadPromise.then((e => (r.key = e.keyInfo.decryptdata.key, {
                                frag: t,
                                keyInfo: a
                            })))
                    }
                    switch (a = this.keyUriToKeyInfo[n] = {
                        decryptdata: r,
                        keyLoadPromise: null,
                        loader: null,
                        mediaKeySessionContext: null
                    }, r.method) {
                        case "ISO-23001-7":
                        case "SAMPLE-AES":
                        case "SAMPLE-AES-CENC":
                        case "SAMPLE-AES-CTR":
                            return "identity" === r.keyFormat ? this.loadKeyHTTP(a, t) : this.loadKeyEME(a, t);
                        case "AES-128":
                        case "AES-256":
                        case "AES-256-CTR":
                            return this.loadKeyHTTP(a, t);
                        default:
                            return Promise.reject(this.createKeyLoadError(t, o.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${r.method}"`)))
                    }
                }
                loadKeyEME(t, e) {
                    const i = {
                        frag: e,
                        keyInfo: t
                    };
                    if (this.emeController && this.config.emeEnabled) {
                        const e = this.emeController.loadKey(i);
                        if (e) return (t.keyLoadPromise = e.then((e => (t.mediaKeySessionContext = e, i)))).catch((e => {
                            throw t.keyLoadPromise = null, e
                        }))
                    }
                    return Promise.resolve(i)
                }
                loadKeyHTTP(t, e) {
                    const i = this.config,
                        s = new(0, i.loader)(i);
                    return e.keyLoader = t.loader = s, t.keyLoadPromise = new Promise(((r, n) => {
                        const a = {
                                keyInfo: t,
                                frag: e,
                                responseType: "arraybuffer",
                                url: t.decryptdata.uri
                            },
                            l = i.keyLoadPolicy.default,
                            c = {
                                loadPolicy: l,
                                timeout: l.maxLoadTimeMs,
                                maxRetry: 0,
                                retryDelay: 0,
                                maxRetryDelay: 0
                            },
                            u = {
                                onSuccess: (t, e, i, s) => {
                                    const {
                                        frag: a,
                                        keyInfo: l,
                                        url: c
                                    } = i;
                                    if (!a.decryptdata || l !== this.keyUriToKeyInfo[c]) return n(this.createKeyLoadError(a, o.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), s));
                                    l.decryptdata.key = a.decryptdata.key = new Uint8Array(t.data), a.keyLoader = null, l.loader = null, r({
                                        frag: a,
                                        keyInfo: l
                                    })
                                },
                                onError: (t, i, s, r) => {
                                    this.resetLoader(i), n(this.createKeyLoadError(e, o.KEY_LOAD_ERROR, new Error(`HTTP Error ${t.code} loading key ${t.text}`), s, E({
                                        url: a.url,
                                        data: void 0
                                    }, t)))
                                },
                                onTimeout: (t, i, s) => {
                                    this.resetLoader(i), n(this.createKeyLoadError(e, o.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), s))
                                },
                                onAbort: (t, i, s) => {
                                    this.resetLoader(i), n(this.createKeyLoadError(e, o.INTERNAL_ABORTED, new Error("key loading aborted"), s))
                                }
                            };
                        s.load(a, c, u)
                    }))
                }
                resetLoader(t) {
                    const {
                        frag: e,
                        keyInfo: i,
                        url: s
                    } = t, r = i.loader;
                    e.keyLoader === r && (e.keyLoader = null, i.loader = null), delete this.keyUriToKeyInfo[s], r && r.destroy()
                }
            }

            function Za(t) {
                const {
                    type: e
                } = t;
                switch (e) {
                    case d:
                        return p;
                    case h:
                        return g;
                    default:
                        return f
                }
            }

            function to(t, e) {
                let i = t.url;
                return void 0 !== i && 0 !== i.indexOf("data:") || (i = e.url), i
            }
            class eo {
                constructor(t) {
                    this.hls = void 0, this.loaders = Object.create(null), this.variableList = null, this.onManifestLoaded = this.checkAutostartLoad, this.hls = t, this.registerListeners()
                }
                startLoad(t) {}
                stopLoad() {
                    this.destroyInternalLoaders()
                }
                registerListeners() {
                    const {
                        hls: t
                    } = this;
                    t.on(l.MANIFEST_LOADING, this.onManifestLoading, this), t.on(l.LEVEL_LOADING, this.onLevelLoading, this), t.on(l.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), t.on(l.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this), t.on(l.LEVELS_UPDATED, this.onLevelsUpdated, this)
                }
                unregisterListeners() {
                    const {
                        hls: t
                    } = this;
                    t.off(l.MANIFEST_LOADING, this.onManifestLoading, this), t.off(l.LEVEL_LOADING, this.onLevelLoading, this), t.off(l.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), t.off(l.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this), t.off(l.LEVELS_UPDATED, this.onLevelsUpdated, this)
                }
                createInternalLoader(t) {
                    const e = this.hls.config,
                        i = e.pLoader,
                        s = e.loader,
                        r = new(i || s)(e);
                    return this.loaders[t.type] = r, r
                }
                getInternalLoader(t) {
                    return this.loaders[t.type]
                }
                resetInternalLoader(t) {
                    this.loaders[t] && delete this.loaders[t]
                }
                destroyInternalLoaders() {
                    for (const t in this.loaders) {
                        const e = this.loaders[t];
                        e && e.destroy(), this.resetInternalLoader(t)
                    }
                }
                destroy() {
                    this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders()
                }
                onManifestLoading(t, e) {
                    const {
                        url: i
                    } = e;
                    this.variableList = null, this.load({
                        id: null,
                        level: 0,
                        responseType: "text",
                        type: c,
                        url: i,
                        deliveryDirectives: null,
                        levelOrTrack: null
                    })
                }
                onLevelLoading(t, e) {
                    const {
                        id: i,
                        level: s,
                        pathwayId: r,
                        url: n,
                        deliveryDirectives: a,
                        levelInfo: o
                    } = e;
                    this.load({
                        id: i,
                        level: s,
                        pathwayId: r,
                        responseType: "text",
                        type: u,
                        url: n,
                        deliveryDirectives: a,
                        levelOrTrack: o
                    })
                }
                onAudioTrackLoading(t, e) {
                    const {
                        id: i,
                        groupId: s,
                        url: r,
                        deliveryDirectives: n,
                        track: a
                    } = e;
                    this.load({
                        id: i,
                        groupId: s,
                        level: null,
                        responseType: "text",
                        type: d,
                        url: r,
                        deliveryDirectives: n,
                        levelOrTrack: a
                    })
                }
                onSubtitleTrackLoading(t, e) {
                    const {
                        id: i,
                        groupId: s,
                        url: r,
                        deliveryDirectives: n,
                        track: a
                    } = e;
                    this.load({
                        id: i,
                        groupId: s,
                        level: null,
                        responseType: "text",
                        type: h,
                        url: r,
                        deliveryDirectives: n,
                        levelOrTrack: a
                    })
                }
                onLevelsUpdated(t, e) {
                    const i = this.loaders[u];
                    if (i) {
                        const t = i.context;
                        t && !e.levels.some((e => e === t.levelOrTrack)) && (i.abort(), delete this.loaders[u])
                    }
                }
                load(t) {
                    var e;
                    const i = this.hls.config;
                    let r, n = this.getInternalLoader(t);
                    if (n) {
                        const e = this.hls.logger,
                            i = n.context;
                        if (i && i.levelOrTrack === t.levelOrTrack && (i.url === t.url || i.deliveryDirectives && !t.deliveryDirectives)) return void(i.url === t.url ? e.log(`[playlist-loader]: ignore ${t.url} ongoing request`) : e.log(`[playlist-loader]: ignore ${t.url} in favor of ${i.url}`));
                        e.log(`[playlist-loader]: aborting previous loader for type: ${t.type}`), n.abort()
                    }
                    if (r = t.type === c ? i.manifestLoadPolicy.default : b({}, i.playlistLoadPolicy.default, {
                            timeoutRetry: null,
                            errorRetry: null
                        }), n = this.createInternalLoader(t), s(null == (e = t.deliveryDirectives) ? void 0 : e.part)) {
                        let e;
                        if (t.type === u && null !== t.level ? e = this.hls.levels[t.level].details : t.type === d && null !== t.id ? e = this.hls.audioTracks[t.id].details : t.type === h && null !== t.id && (e = this.hls.subtitleTracks[t.id].details), e) {
                            const t = e.partTarget,
                                i = e.targetduration;
                            if (t && i) {
                                const e = 1e3 * Math.max(3 * t, .8 * i);
                                r = b({}, r, {
                                    maxTimeToFirstByteMs: Math.min(e, r.maxTimeToFirstByteMs),
                                    maxLoadTimeMs: Math.min(e, r.maxTimeToFirstByteMs)
                                })
                            }
                        }
                    }
                    const a = r.errorRetry || r.timeoutRetry || {},
                        o = {
                            loadPolicy: r,
                            timeout: r.maxLoadTimeMs,
                            maxRetry: a.maxNumRetry || 0,
                            retryDelay: a.retryDelayMs || 0,
                            maxRetryDelay: a.maxRetryDelayMs || 0
                        },
                        l = {
                            onSuccess: (t, e, i, s) => {
                                const r = this.getInternalLoader(i);
                                this.resetInternalLoader(i.type);
                                const n = t.data;
                                0 === n.indexOf("#EXTM3U") ? (e.parsing.start = performance.now(), mi.isMediaPlaylist(n) || i.type !== c ? this.handleTrackOrLevelPlaylist(t, e, i, s || null, r) : this.handleMasterPlaylist(t, e, i, s)) : this.handleManifestParsingError(t, i, new Error("no EXTM3U delimiter"), s || null, e)
                            },
                            onError: (t, e, i, s) => {
                                this.handleNetworkError(e, i, !1, t, s)
                            },
                            onTimeout: (t, e, i) => {
                                this.handleNetworkError(e, i, !0, void 0, t)
                            }
                        };
                    n.load(t, o, l)
                }
                checkAutostartLoad() {
                    if (!this.hls) return;
                    const {
                        config: {
                            autoStartLoad: t,
                            startPosition: e
                        },
                        forceStartLoad: i
                    } = this.hls;
                    (t || i) && (this.hls.logger.log(`${t?"auto":"force"} startLoad with configured startPosition ${e}`), this.hls.startLoad(e))
                }
                handleMasterPlaylist(t, e, i, s) {
                    const r = this.hls,
                        n = t.data,
                        a = to(t, i),
                        o = mi.parseMasterPlaylist(n, a);
                    if (o.playlistParsingError) return void this.handleManifestParsingError(t, i, o.playlistParsingError, s, e);
                    const {
                        contentSteering: c,
                        levels: u,
                        sessionData: d,
                        sessionKeys: h,
                        startTimeOffset: f,
                        variableList: p
                    } = o;
                    this.variableList = p;
                    const {
                        AUDIO: g = [],
                        SUBTITLES: m,
                        "CLOSED-CAPTIONS": y
                    } = mi.parseMasterPlaylistMedia(n, a, o);
                    g.length && (g.some((t => !t.url)) || !u[0].audioCodec || u[0].attrs.AUDIO || (this.hls.logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), g.unshift({
                        type: "main",
                        name: "main",
                        groupId: "main",
                        default: !1,
                        autoselect: !1,
                        forced: !1,
                        id: -1,
                        attrs: new Ge({}),
                        bitrate: 0,
                        url: ""
                    }))), r.trigger(l.MANIFEST_LOADED, {
                        levels: u,
                        audioTracks: g,
                        subtitles: m,
                        captions: y,
                        contentSteering: c,
                        url: a,
                        stats: e,
                        networkDetails: s,
                        sessionData: d,
                        sessionKeys: h,
                        startTimeOffset: f,
                        variableList: p
                    })
                }
                handleTrackOrLevelPlaylist(t, e, i, r, n) {
                    const a = this.hls,
                        {
                            id: o,
                            level: u,
                            type: d
                        } = i,
                        h = to(t, i),
                        f = s(u) ? u : s(o) ? o : 0,
                        p = Za(i),
                        g = mi.parseLevelPlaylist(t.data, h, f, p, 0, this.variableList);
                    if (d === c) {
                        const t = {
                            attrs: new Ge({}),
                            bitrate: 0,
                            details: g,
                            name: "",
                            url: h
                        };
                        g.requestScheduled = e.loading.start + Pi(g, 0), a.trigger(l.MANIFEST_LOADED, {
                            levels: [t],
                            audioTracks: [],
                            url: h,
                            stats: e,
                            networkDetails: r,
                            sessionData: null,
                            sessionKeys: null,
                            contentSteering: null,
                            startTimeOffset: null,
                            variableList: null
                        })
                    }
                    e.parsing.end = performance.now(), i.levelDetails = g, this.handlePlaylistLoaded(g, t, e, i, r, n)
                }
                handleManifestParsingError(t, e, i, s, r) {
                    this.hls.trigger(l.ERROR, {
                        type: a.NETWORK_ERROR,
                        details: o.MANIFEST_PARSING_ERROR,
                        fatal: e.type === c,
                        url: t.url,
                        err: i,
                        error: i,
                        reason: i.message,
                        response: t,
                        context: e,
                        networkDetails: s,
                        stats: r
                    })
                }
                handleNetworkError(t, e, i = !1, s, r) {
                    let n = `A network ${i?"timeout":"error"+(s?" (status "+s.code+")":"")} occurred while loading ${t.type}`;
                    t.type === u ? n += `: ${t.level} id: ${t.id}` : t.type !== d && t.type !== h || (n += ` id: ${t.id} group-id: "${t.groupId}"`);
                    const f = new Error(n);
                    this.hls.logger.warn(`[playlist-loader]: ${n}`);
                    let p = o.UNKNOWN,
                        g = !1;
                    const m = this.getInternalLoader(t);
                    switch (t.type) {
                        case c:
                            p = i ? o.MANIFEST_LOAD_TIMEOUT : o.MANIFEST_LOAD_ERROR, g = !0;
                            break;
                        case u:
                            p = i ? o.LEVEL_LOAD_TIMEOUT : o.LEVEL_LOAD_ERROR, g = !1;
                            break;
                        case d:
                            p = i ? o.AUDIO_TRACK_LOAD_TIMEOUT : o.AUDIO_TRACK_LOAD_ERROR, g = !1;
                            break;
                        case h:
                            p = i ? o.SUBTITLE_TRACK_LOAD_TIMEOUT : o.SUBTITLE_LOAD_ERROR, g = !1
                    }
                    m && this.resetInternalLoader(t.type);
                    const y = {
                        type: a.NETWORK_ERROR,
                        details: p,
                        fatal: g,
                        url: t.url,
                        loader: m,
                        context: t,
                        error: f,
                        networkDetails: e,
                        stats: r
                    };
                    if (s) {
                        const i = (null == e ? void 0 : e.url) || t.url;
                        y.response = E({
                            url: i,
                            data: void 0
                        }, s)
                    }
                    this.hls.trigger(l.ERROR, y)
                }
                handlePlaylistLoaded(t, e, i, s, r, n) {
                    const p = this.hls,
                        {
                            type: g,
                            level: m,
                            id: y,
                            groupId: v,
                            deliveryDirectives: b
                        } = s,
                        T = to(e, s),
                        E = Za(s),
                        S = "number" == typeof s.level && E === f ? m : void 0;
                    if (!t.fragments.length) {
                        const n = t.playlistParsingError = new Error("No Segments found in Playlist");
                        return void p.trigger(l.ERROR, {
                            type: a.NETWORK_ERROR,
                            details: o.LEVEL_EMPTY_ERROR,
                            fatal: !1,
                            url: T,
                            error: n,
                            reason: n.message,
                            response: e,
                            context: s,
                            level: S,
                            parent: E,
                            networkDetails: r,
                            stats: i
                        })
                    }
                    t.targetduration || (t.playlistParsingError = new Error("Missing Target Duration"));
                    const w = t.playlistParsingError;
                    if (w) {
                        if (this.hls.logger.warn(w), !p.config.ignorePlaylistParsingErrors) return void p.trigger(l.ERROR, {
                            type: a.NETWORK_ERROR,
                            details: o.LEVEL_PARSING_ERROR,
                            fatal: !1,
                            url: T,
                            error: w,
                            reason: w.message,
                            response: e,
                            context: s,
                            level: S,
                            parent: E,
                            networkDetails: r,
                            stats: i
                        });
                        t.playlistParsingError = null
                    }
                    switch (t.live && n && (n.getCacheAge && (t.ageHeader = n.getCacheAge() || 0), n.getCacheAge && !isNaN(t.ageHeader) || (t.ageHeader = 0)), g) {
                        case c:
                        case u:
                            p.trigger(l.LEVEL_LOADED, {
                                details: t,
                                levelInfo: s.levelOrTrack || p.levels[0],
                                level: S || 0,
                                id: y || 0,
                                stats: i,
                                networkDetails: r,
                                deliveryDirectives: b,
                                withoutMultiVariant: g === c
                            });
                            break;
                        case d:
                            p.trigger(l.AUDIO_TRACK_LOADED, {
                                details: t,
                                track: s.levelOrTrack,
                                id: y || 0,
                                groupId: v || "",
                                stats: i,
                                networkDetails: r,
                                deliveryDirectives: b
                            });
                            break;
                        case h:
                            p.trigger(l.SUBTITLE_TRACK_LOADED, {
                                details: t,
                                track: s.levelOrTrack,
                                id: y || 0,
                                groupId: v || "",
                                stats: i,
                                networkDetails: r,
                                deliveryDirectives: b
                            })
                    }
                }
            }
            class io {
                static get version() {
                    return Xi
                }
                static isMSESupported() {
                    return Xa()
                }
                static isSupported() {
                    return function() {
                        if (!Xa()) return !1;
                        const t = I();
                        return "function" == typeof(null == t ? void 0 : t.isTypeSupported) && (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some((e => t.isTypeSupported(Rt(e, "video")))) || ["mp4a.40.2", "fLaC"].some((e => t.isTypeSupported(Rt(e, "audio")))))
                    }()
                }
                static getMediaSource() {
                    return I()
                }
                static get Events() {
                    return l
                }
                static get MetadataSchema() {
                    return Es
                }
                static get ErrorTypes() {
                    return a
                }
                static get ErrorDetails() {
                    return o
                }
                static get DefaultConfig() {
                    return io.defaultConfig ? io.defaultConfig : Fa
                }
                static set DefaultConfig(t) {
                    io.defaultConfig = t
                }
                constructor(t = {}) {
                    this.config = void 0, this.userConfig = void 0, this.logger = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new Yi, this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioStreamController = void 0, this.subtititleStreamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.interstitialsController = void 0, this.gapController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this._url = null, this._sessionId = void 0, this.triggeringException = void 0, this.started = !1;
                    const e = this.logger = function(t, e, i) {
                            const s = A();
                            if ("object" == typeof console && !0 === t || "object" == typeof t) {
                                const e = ["debug", "log", "info", "warn", "error"];
                                e.forEach((e => {
                                    s[e] = _(e, t, i)
                                }));
                                try {
                                    s.log('Debug logs enabled for "Hls instance" in hls.js version 1.6.1')
                                } catch (t) {
                                    return A()
                                }
                                e.forEach((e => {
                                    L[e] = _(e, t)
                                }))
                            } else b(L, s);
                            return s
                        }(t.debug || !1, 0, t.assetPlayerId),
                        i = this.config = function(t, e, i) {
                            if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
                            if (void 0 !== e.liveMaxLatencyDurationCount && (void 0 === e.liveSyncDurationCount || e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount)) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
                            if (void 0 !== e.liveMaxLatencyDuration && (void 0 === e.liveSyncDuration || e.liveMaxLatencyDuration <= e.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
                            const s = $a(t),
                                r = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
                            return ["manifest", "level", "frag"].forEach((t => {
                                const n = `${"level"===t?"playlist":t}LoadPolicy`,
                                    a = void 0 === e[n],
                                    o = [];
                                r.forEach((i => {
                                    const r = `${t}Loading${i}`,
                                        l = e[r];
                                    if (void 0 !== l && a) {
                                        o.push(r);
                                        const t = s[n].default;
                                        switch (e[n] = {
                                            default: t
                                        }, i) {
                                            case "TimeOut":
                                                t.maxLoadTimeMs = l, t.maxTimeToFirstByteMs = l;
                                                break;
                                            case "MaxRetry":
                                                t.errorRetry.maxNumRetry = l, t.timeoutRetry.maxNumRetry = l;
                                                break;
                                            case "RetryDelay":
                                                t.errorRetry.retryDelayMs = l, t.timeoutRetry.retryDelayMs = l;
                                                break;
                                            case "MaxRetryTimeout":
                                                t.errorRetry.maxRetryDelayMs = l, t.timeoutRetry.maxRetryDelayMs = l
                                        }
                                    }
                                })), o.length && i.warn(`hls.js config: "${o.join('", "')}" setting(s) are deprecated, use "${n}": ${Yt(e[n])}`)
                            })), E(E({}, s), e)
                        }(io.DefaultConfig, t, e);
                    this.userConfig = t, i.progressive && function(t, e) {
                        const i = t.loader;
                        i !== xa && i !== Na ? (e.log("[config]: Custom loader detected, cannot enable progressive streaming"), t.progressive = !1) : function() {
                            if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try {
                                return new self.ReadableStream({}), !0
                            } catch (t) {}
                            return !1
                        }() && (t.loader = xa, t.progressive = !0, t.enableSoftwareAES = !0, e.log("[config]: Progressive streaming enabled, using FetchLoader"))
                    }(i, e);
                    const {
                        abrController: s,
                        bufferController: r,
                        capLevelController: n,
                        errorController: a,
                        fpsController: o
                    } = i, c = new a(this), u = this.abrController = new s(this), d = new be(this), h = i.interstitialsController, f = h ? this.interstitialsController = new h(this, io) : null, p = this.bufferController = new r(this, d), g = this.capLevelController = new n(this), m = new o(this), y = new eo(this), v = i.contentSteeringController, T = v ? new v(this) : null, S = this.levelController = new qa(this, T), w = new Ka(this), k = new Ja(this.config), R = this.streamController = new Qa(this, d, k), I = this.gapController = new Ua(this, d);
                    g.setStreamController(R), m.setStreamController(R);
                    const C = [y, S, R];
                    f && C.splice(1, 0, f), T && C.splice(1, 0, T), this.networkControllers = C;
                    const D = [u, p, I, g, m, w, d];
                    this.audioTrackController = this.createController(i.audioTrackController, C);
                    const x = i.audioStreamController;
                    x && C.push(this.audioStreamController = new x(this, d, k)), this.subtitleTrackController = this.createController(i.subtitleTrackController, C);
                    const P = i.subtitleStreamController;
                    P && C.push(this.subtititleStreamController = new P(this, d, k)), this.createController(i.timelineController, D), k.emeController = this.emeController = this.createController(i.emeController, D), this.cmcdController = this.createController(i.cmcdController, D), this.latencyController = this.createController(za, D), this.coreComponents = D, C.push(c);
                    const O = c.onErrorOut;
                    "function" == typeof O && this.on(l.ERROR, O, c), this.on(l.MANIFEST_LOADED, y.onManifestLoaded, y)
                }
                createController(t, e) {
                    if (t) {
                        const i = new t(this);
                        return e && e.push(i), i
                    }
                    return null
                }
                on(t, e, i = this) {
                    this._emitter.on(t, e, i)
                }
                once(t, e, i = this) {
                    this._emitter.once(t, e, i)
                }
                removeAllListeners(t) {
                    this._emitter.removeAllListeners(t)
                }
                off(t, e, i = this, s) {
                    this._emitter.off(t, e, i, s)
                }
                listeners(t) {
                    return this._emitter.listeners(t)
                }
                emit(t, e, i) {
                    return this._emitter.emit(t, e, i)
                }
                trigger(t, e) {
                    if (this.config.debug) return this.emit(t, t, e);
                    try {
                        return this.emit(t, t, e)
                    } catch (e) {
                        if (this.logger.error("An internal error happened while handling event " + t + '. Error message: "' + e.message + '". Here is a stacktrace:', e), !this.triggeringException) {
                            this.triggeringException = !0;
                            const i = t === l.ERROR;
                            this.trigger(l.ERROR, {
                                type: a.OTHER_ERROR,
                                details: o.INTERNAL_EXCEPTION,
                                fatal: i,
                                event: t,
                                error: e
                            }), this.triggeringException = !1
                        }
                    }
                    return !1
                }
                listenerCount(t) {
                    return this._emitter.listenerCount(t)
                }
                destroy() {
                    this.logger.log("destroy"), this.trigger(l.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this._url = null, this.networkControllers.forEach((t => t.destroy())), this.networkControllers.length = 0, this.coreComponents.forEach((t => t.destroy())), this.coreComponents.length = 0;
                    const t = this.config;
                    t.xhrSetup = t.fetchSetup = void 0, this.userConfig = null
                }
                attachMedia(t) {
                    if (!t || "media" in t && !t.media) {
                        const e = new Error(`attachMedia failed: invalid argument (${t})`);
                        return void this.trigger(l.ERROR, {
                            type: a.OTHER_ERROR,
                            details: o.ATTACH_MEDIA_ERROR,
                            fatal: !0,
                            error: e
                        })
                    }
                    this.logger.log("attachMedia"), this._media && (this.logger.warn("media must be detached before attaching"), this.detachMedia());
                    const e = "media" in t,
                        i = e ? t.media : t,
                        s = e ? t : {
                            media: i
                        };
                    this._media = i, this.trigger(l.MEDIA_ATTACHING, s)
                }
                detachMedia() {
                    this.logger.log("detachMedia"), this.trigger(l.MEDIA_DETACHING, {}), this._media = null
                }
                transferMedia() {
                    this._media = null;
                    const t = this.bufferController.transferMedia();
                    return this.trigger(l.MEDIA_DETACHING, {
                        transferMedia: t
                    }), t
                }
                loadSource(t) {
                    this.stopLoad();
                    const e = this.media,
                        i = this._url,
                        s = this._url = j.buildAbsoluteURL(self.location.href, t, {
                            alwaysNormalize: !0
                        });
                    this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.logger.log(`loadSource:${s}`), e && i && (i !== s || this.bufferController.hasSourceTypes()) && (this.detachMedia(), this.attachMedia(e)), this.trigger(l.MANIFEST_LOADING, {
                        url: t
                    })
                }
                get url() {
                    return this._url
                }
                get hasEnoughToStart() {
                    return this.streamController.hasEnoughToStart
                }
                get startPosition() {
                    return this.streamController.startPositionValue
                }
                startLoad(t = -1, e) {
                    this.logger.log(`startLoad(${t+(e?", <skip seek to start>":"")})`), this.started = !0, this.resumeBuffering();
                    for (let i = 0; i < this.networkControllers.length && (this.networkControllers[i].startLoad(t, e), this.started && this.networkControllers); i++);
                }
                stopLoad() {
                    this.logger.log("stopLoad"), this.started = !1;
                    for (let t = 0; t < this.networkControllers.length && (this.networkControllers[t].stopLoad(), !this.started && this.networkControllers); t++);
                }
                get loadingEnabled() {
                    return this.started
                }
                get bufferingEnabled() {
                    return this.streamController.bufferingEnabled
                }
                resumeBuffering() {
                    this.bufferingEnabled || (this.logger.log("resume buffering"), this.networkControllers.forEach((t => {
                        t.resumeBuffering && t.resumeBuffering()
                    })))
                }
                pauseBuffering() {
                    this.bufferingEnabled && (this.logger.log("pause buffering"), this.networkControllers.forEach((t => {
                        t.pauseBuffering && t.pauseBuffering()
                    })))
                }
                get inFlightFragments() {
                    const t = {
                        [f]: this.streamController.inFlightFrag
                    };
                    return this.audioStreamController && (t[p] = this.audioStreamController.inFlightFrag), this.subtititleStreamController && (t[g] = this.subtititleStreamController.inFlightFrag), t
                }
                swapAudioCodec() {
                    this.logger.log("swapAudioCodec"), this.streamController.swapAudioCodec()
                }
                recoverMediaError() {
                    this.logger.log("recoverMediaError");
                    const t = this._media,
                        e = null == t ? void 0 : t.currentTime;
                    this.detachMedia(), t && (this.attachMedia(t), e && this.startLoad(e))
                }
                removeLevel(t) {
                    this.levelController.removeLevel(t)
                }
                get sessionId() {
                    let t = this._sessionId;
                    return t || (t = this._sessionId = function() {
                        try {
                            return crypto.randomUUID()
                        } catch (t) {
                            try {
                                const t = URL.createObjectURL(new Blob),
                                    e = t.toString();
                                return URL.revokeObjectURL(t), e.slice(e.lastIndexOf("/") + 1)
                            } catch (t) {
                                let e = (new Date).getTime();
                                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t => {
                                    const i = (e + 16 * Math.random()) % 16 | 0;
                                    return e = Math.floor(e / 16), ("x" == t ? i : 3 & i | 8).toString(16)
                                }))
                            }
                        }
                    }()), t
                }
                get levels() {
                    return this.levelController.levels || []
                }
                get latestLevelDetails() {
                    return this.streamController.getLevelDetails() || null
                }
                get loadLevelObj() {
                    return this.levelController.loadLevelObj
                }
                get currentLevel() {
                    return this.streamController.currentLevel
                }
                set currentLevel(t) {
                    this.logger.log(`set currentLevel:${t}`), this.levelController.manualLevel = t, this.streamController.immediateLevelSwitch()
                }
                get nextLevel() {
                    return this.streamController.nextLevel
                }
                set nextLevel(t) {
                    this.logger.log(`set nextLevel:${t}`), this.levelController.manualLevel = t, this.streamController.nextLevelSwitch()
                }
                get loadLevel() {
                    return this.levelController.level
                }
                set loadLevel(t) {
                    this.logger.log(`set loadLevel:${t}`), this.levelController.manualLevel = t
                }
                get nextLoadLevel() {
                    return this.levelController.nextLoadLevel
                }
                set nextLoadLevel(t) {
                    this.levelController.nextLoadLevel = t
                }
                get firstLevel() {
                    return Math.max(this.levelController.firstLevel, this.minAutoLevel)
                }
                set firstLevel(t) {
                    this.logger.log(`set firstLevel:${t}`), this.levelController.firstLevel = t
                }
                get startLevel() {
                    const t = this.levelController.startLevel;
                    return -1 === t && this.abrController.forcedAutoLevel > -1 ? this.abrController.forcedAutoLevel : t
                }
                set startLevel(t) {
                    this.logger.log(`set startLevel:${t}`), -1 !== t && (t = Math.max(t, this.minAutoLevel)), this.levelController.startLevel = t
                }
                get capLevelToPlayerSize() {
                    return this.config.capLevelToPlayerSize
                }
                set capLevelToPlayerSize(t) {
                    const e = !!t;
                    e !== this.config.capLevelToPlayerSize && (e ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = e)
                }
                get autoLevelCapping() {
                    return this._autoLevelCapping
                }
                get bandwidthEstimate() {
                    const {
                        bwEstimator: t
                    } = this.abrController;
                    return t ? t.getEstimate() : NaN
                }
                set bandwidthEstimate(t) {
                    this.abrController.resetEstimator(t)
                }
                get abrEwmaDefaultEstimate() {
                    const {
                        bwEstimator: t
                    } = this.abrController;
                    return t ? t.defaultEstimate : NaN
                }
                get ttfbEstimate() {
                    const {
                        bwEstimator: t
                    } = this.abrController;
                    return t ? t.getEstimateTTFB() : NaN
                }
                set autoLevelCapping(t) {
                    this._autoLevelCapping !== t && (this.logger.log(`set autoLevelCapping:${t}`), this._autoLevelCapping = t, this.levelController.checkMaxAutoUpdated())
                }
                get maxHdcpLevel() {
                    return this._maxHdcpLevel
                }
                set maxHdcpLevel(t) {
                    (function(t) {
                        return Vt.indexOf(t) > -1
                    })(t) && this._maxHdcpLevel !== t && (this._maxHdcpLevel = t, this.levelController.checkMaxAutoUpdated())
                }
                get autoLevelEnabled() {
                    return -1 === this.levelController.manualLevel
                }
                get manualLevel() {
                    return this.levelController.manualLevel
                }
                get minAutoLevel() {
                    const {
                        levels: t,
                        config: {
                            minAutoBitrate: e
                        }
                    } = this;
                    if (!t) return 0;
                    const i = t.length;
                    for (let s = 0; s < i; s++)
                        if (t[s].maxBitrate >= e) return s;
                    return 0
                }
                get maxAutoLevel() {
                    const {
                        levels: t,
                        autoLevelCapping: e,
                        maxHdcpLevel: i
                    } = this;
                    let s;
                    if (s = -1 === e && null != t && t.length ? t.length - 1 : e, i)
                        for (let e = s; e--;) {
                            const s = t[e].attrs["HDCP-LEVEL"];
                            if (s && s <= i) return e
                        }
                    return s
                }
                get firstAutoLevel() {
                    return this.abrController.firstAutoLevel
                }
                get nextAutoLevel() {
                    return this.abrController.nextAutoLevel
                }
                set nextAutoLevel(t) {
                    this.abrController.nextAutoLevel = t
                }
                get playingDate() {
                    return this.streamController.currentProgramDateTime
                }
                get mainForwardBufferInfo() {
                    return this.streamController.getMainFwdBufferInfo()
                }
                get maxBufferLength() {
                    return this.streamController.maxBufferLength
                }
                setAudioOption(t) {
                    var e;
                    return (null == (e = this.audioTrackController) ? void 0 : e.setAudioOption(t)) || null
                }
                setSubtitleOption(t) {
                    var e;
                    return (null == (e = this.subtitleTrackController) ? void 0 : e.setSubtitleOption(t)) || null
                }
                get allAudioTracks() {
                    const t = this.audioTrackController;
                    return t ? t.allAudioTracks : []
                }
                get audioTracks() {
                    const t = this.audioTrackController;
                    return t ? t.audioTracks : []
                }
                get audioTrack() {
                    const t = this.audioTrackController;
                    return t ? t.audioTrack : -1
                }
                set audioTrack(t) {
                    const e = this.audioTrackController;
                    e && (e.audioTrack = t)
                }
                get allSubtitleTracks() {
                    const t = this.subtitleTrackController;
                    return t ? t.allSubtitleTracks : []
                }
                get subtitleTracks() {
                    const t = this.subtitleTrackController;
                    return t ? t.subtitleTracks : []
                }
                get subtitleTrack() {
                    const t = this.subtitleTrackController;
                    return t ? t.subtitleTrack : -1
                }
                get media() {
                    return this._media
                }
                set subtitleTrack(t) {
                    const e = this.subtitleTrackController;
                    e && (e.subtitleTrack = t)
                }
                get subtitleDisplay() {
                    const t = this.subtitleTrackController;
                    return !!t && t.subtitleDisplay
                }
                set subtitleDisplay(t) {
                    const e = this.subtitleTrackController;
                    e && (e.subtitleDisplay = t)
                }
                get lowLatencyMode() {
                    return this.config.lowLatencyMode
                }
                set lowLatencyMode(t) {
                    this.config.lowLatencyMode = t
                }
                get liveSyncPosition() {
                    return this.latencyController.liveSyncPosition
                }
                get latency() {
                    return this.latencyController.latency
                }
                get maxLatency() {
                    return this.latencyController.maxLatency
                }
                get targetLatency() {
                    return this.latencyController.targetLatency
                }
                set targetLatency(t) {
                    this.latencyController.targetLatency = t
                }
                get drift() {
                    return this.latencyController.drift
                }
                get forceStartLoad() {
                    return this.streamController.forceStartLoad
                }
                get pathways() {
                    return this.levelController.pathways
                }
                get pathwayPriority() {
                    return this.levelController.pathwayPriority
                }
                set pathwayPriority(t) {
                    this.levelController.pathwayPriority = t
                }
                get bufferedToEnd() {
                    var t;
                    return !(null == (t = this.bufferController) || !t.bufferedToEnd)
                }
                get interstitialsManager() {
                    var t;
                    return (null == (t = this.interstitialsController) ? void 0 : t.interstitialsManager) || null
                }
                getMediaDecodingInfo(t, e = this.allAudioTracks) {
                    return Gt(t, Qt(e), navigator.mediaCapabilities)
                }
            }
            io.defaultConfig = void 0
        },
        5132: (t, e, i) => {
            "use strict";
            i.d(e, {
                ZP: () => wt
            });
            var s = {};
            i.r(s), i.d(s, {
                Decoder: () => gt,
                Encoder: () => ft,
                PacketType: () => ht,
                protocol: () => dt
            });
            const r = Object.create(null);
            r.open = "0", r.close = "1", r.ping = "2", r.pong = "3", r.message = "4", r.upgrade = "5", r.noop = "6";
            const n = Object.create(null);
            Object.keys(r).forEach((t => {
                n[r[t]] = t
            }));
            const a = {
                    type: "error",
                    data: "parser error"
                },
                o = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === Object.prototype.toString.call(Blob),
                l = "function" == typeof ArrayBuffer,
                c = t => "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(t) : t && t.buffer instanceof ArrayBuffer,
                u = ({
                    type: t,
                    data: e
                }, i, s) => o && e instanceof Blob ? i ? s(e) : d(e, s) : l && (e instanceof ArrayBuffer || c(e)) ? i ? s(e) : d(new Blob([e]), s) : s(r[t] + (e || "")),
                d = (t, e) => {
                    const i = new FileReader;
                    return i.onload = function() {
                        const t = i.result.split(",")[1];
                        e("b" + (t || ""))
                    }, i.readAsDataURL(t)
                };

            function h(t) {
                return t instanceof Uint8Array ? t : t instanceof ArrayBuffer ? new Uint8Array(t) : new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
            }
            let f;
            const p = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256);
            for (let t = 0; t < 64; t++) p["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charCodeAt(t)] = t;
            const g = "function" == typeof ArrayBuffer,
                m = (t, e) => {
                    if ("string" != typeof t) return {
                        type: "message",
                        data: v(t, e)
                    };
                    const i = t.charAt(0);
                    return "b" === i ? {
                        type: "message",
                        data: y(t.substring(1), e)
                    } : n[i] ? t.length > 1 ? {
                        type: n[i],
                        data: t.substring(1)
                    } : {
                        type: n[i]
                    } : a
                },
                y = (t, e) => {
                    if (g) {
                        const i = (t => {
                            let e, i, s, r, n, a = .75 * t.length,
                                o = t.length,
                                l = 0;
                            "=" === t[t.length - 1] && (a--, "=" === t[t.length - 2] && a--);
                            const c = new ArrayBuffer(a),
                                u = new Uint8Array(c);
                            for (e = 0; e < o; e += 4) i = p[t.charCodeAt(e)], s = p[t.charCodeAt(e + 1)], r = p[t.charCodeAt(e + 2)], n = p[t.charCodeAt(e + 3)], u[l++] = i << 2 | s >> 4, u[l++] = (15 & s) << 4 | r >> 2, u[l++] = (3 & r) << 6 | 63 & n;
                            return c
                        })(t);
                        return v(i, e)
                    }
                    return {
                        base64: !0,
                        data: t
                    }
                },
                v = (t, e) => "blob" === e ? t instanceof Blob ? t : new Blob([t]) : t instanceof ArrayBuffer ? t : t.buffer,
                b = String.fromCharCode(30);
            let T;

            function E(t) {
                return t.reduce(((t, e) => t + e.length), 0)
            }

            function S(t, e) {
                if (t[0].length === e) return t.shift();
                const i = new Uint8Array(e);
                let s = 0;
                for (let r = 0; r < e; r++) i[r] = t[0][s++], s === t[0].length && (t.shift(), s = 0);
                return t.length && s < t[0].length && (t[0] = t[0].slice(s)), i
            }

            function w(t) {
                if (t) return function(t) {
                    for (var e in w.prototype) t[e] = w.prototype[e];
                    return t
                }(t)
            }
            w.prototype.on = w.prototype.addEventListener = function(t, e) {
                return this._callbacks = this._callbacks || {}, (this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e), this
            }, w.prototype.once = function(t, e) {
                function i() {
                    this.off(t, i), e.apply(this, arguments)
                }
                return i.fn = e, this.on(t, i), this
            }, w.prototype.off = w.prototype.removeListener = w.prototype.removeAllListeners = w.prototype.removeEventListener = function(t, e) {
                if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
                var i, s = this._callbacks["$" + t];
                if (!s) return this;
                if (1 == arguments.length) return delete this._callbacks["$" + t], this;
                for (var r = 0; r < s.length; r++)
                    if ((i = s[r]) === e || i.fn === e) {
                        s.splice(r, 1);
                        break
                    }
                return 0 === s.length && delete this._callbacks["$" + t], this
            }, w.prototype.emit = function(t) {
                this._callbacks = this._callbacks || {};
                for (var e = new Array(arguments.length - 1), i = this._callbacks["$" + t], s = 1; s < arguments.length; s++) e[s - 1] = arguments[s];
                if (i) {
                    s = 0;
                    for (var r = (i = i.slice(0)).length; s < r; ++s) i[s].apply(this, e)
                }
                return this
            }, w.prototype.emitReserved = w.prototype.emit, w.prototype.listeners = function(t) {
                return this._callbacks = this._callbacks || {}, this._callbacks["$" + t] || []
            }, w.prototype.hasListeners = function(t) {
                return !!this.listeners(t).length
            };
            const k = "undefined" != typeof self ? self : "undefined" != typeof window ? window : Function("return this")();

            function A(t, ...e) {
                return e.reduce(((e, i) => (t.hasOwnProperty(i) && (e[i] = t[i]), e)), {})
            }
            const _ = k.setTimeout,
                L = k.clearTimeout;

            function R(t, e) {
                e.useNativeTimers ? (t.setTimeoutFn = _.bind(k), t.clearTimeoutFn = L.bind(k)) : (t.setTimeoutFn = k.setTimeout.bind(k), t.clearTimeoutFn = k.clearTimeout.bind(k))
            }
            var I = i(3859);
            class C extends Error {
                constructor(t, e, i) {
                    super(t), this.description = e, this.context = i, this.type = "TransportError"
                }
            }
            class D extends w {
                constructor(t) {
                    super(), this.writable = !1, R(this, t), this.opts = t, this.query = t.query, this.socket = t.socket
                }
                onError(t, e, i) {
                    return super.emitReserved("error", new C(t, e, i)), this
                }
                open() {
                    return this.readyState = "opening", this.doOpen(), this
                }
                close() {
                    return "opening" !== this.readyState && "open" !== this.readyState || (this.doClose(), this.onClose()), this
                }
                send(t) {
                    "open" === this.readyState && this.write(t)
                }
                onOpen() {
                    this.readyState = "open", this.writable = !0, super.emitReserved("open")
                }
                onData(t) {
                    const e = m(t, this.socket.binaryType);
                    this.onPacket(e)
                }
                onPacket(t) {
                    super.emitReserved("packet", t)
                }
                onClose(t) {
                    this.readyState = "closed", super.emitReserved("close", t)
                }
                pause(t) {}
                createUri(t, e = {}) {
                    return t + "://" + this._hostname() + this._port() + this.opts.path + this._query(e)
                }
                _hostname() {
                    const t = this.opts.hostname;
                    return -1 === t.indexOf(":") ? t : "[" + t + "]"
                }
                _port() {
                    return this.opts.port && (this.opts.secure && Number(443 !== this.opts.port) || !this.opts.secure && 80 !== Number(this.opts.port)) ? ":" + this.opts.port : ""
                }
                _query(t) {
                    const e = (0, I.c)(t);
                    return e.length ? "?" + e : ""
                }
            }
            const x = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),
                P = 64,
                O = {};
            let M, N = 0,
                F = 0;

            function $(t) {
                let e = "";
                do {
                    e = x[t % P] + e, t = Math.floor(t / P)
                } while (t > 0);
                return e
            }

            function U() {
                const t = $(+new Date);
                return t !== M ? (N = 0, M = t) : t + "." + $(N++)
            }
            for (; F < P; F++) O[x[F]] = F;
            let B = !1;
            try {
                B = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest
            } catch (t) {}
            const j = B;

            function G(t) {
                const e = t.xdomain;
                try {
                    if ("undefined" != typeof XMLHttpRequest && (!e || j)) return new XMLHttpRequest
                } catch (t) {}
                if (!e) try {
                    return new(k[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")
                } catch (t) {}
            }

            function V() {}
            const H = null != new G({
                xdomain: !1
            }).responseType;
            class K extends w {
                constructor(t, e) {
                    super(), R(this, e), this.opts = e, this.method = e.method || "GET", this.uri = t, this.data = void 0 !== e.data ? e.data : null, this.create()
                }
                create() {
                    var t;
                    const e = A(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
                    e.xdomain = !!this.opts.xd;
                    const i = this.xhr = new G(e);
                    try {
                        i.open(this.method, this.uri, !0);
                        try {
                            if (this.opts.extraHeaders) {
                                i.setDisableHeaderCheck && i.setDisableHeaderCheck(!0);
                                for (let t in this.opts.extraHeaders) this.opts.extraHeaders.hasOwnProperty(t) && i.setRequestHeader(t, this.opts.extraHeaders[t])
                            }
                        } catch (t) {}
                        if ("POST" === this.method) try {
                            i.setRequestHeader("Content-type", "text/plain;charset=UTF-8")
                        } catch (t) {}
                        try {
                            i.setRequestHeader("Accept", "*/*")
                        } catch (t) {}
                        null === (t = this.opts.cookieJar) || void 0 === t || t.addCookies(i), "withCredentials" in i && (i.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (i.timeout = this.opts.requestTimeout), i.onreadystatechange = () => {
                            var t;
                            3 === i.readyState && (null === (t = this.opts.cookieJar) || void 0 === t || t.parseCookies(i)), 4 === i.readyState && (200 === i.status || 1223 === i.status ? this.onLoad() : this.setTimeoutFn((() => {
                                this.onError("number" == typeof i.status ? i.status : 0)
                            }), 0))
                        }, i.send(this.data)
                    } catch (t) {
                        return void this.setTimeoutFn((() => {
                            this.onError(t)
                        }), 0)
                    }
                    "undefined" != typeof document && (this.index = K.requestsCount++, K.requests[this.index] = this)
                }
                onError(t) {
                    this.emitReserved("error", t, this.xhr), this.cleanup(!0)
                }
                cleanup(t) {
                    if (void 0 !== this.xhr && null !== this.xhr) {
                        if (this.xhr.onreadystatechange = V, t) try {
                            this.xhr.abort()
                        } catch (t) {}
                        "undefined" != typeof document && delete K.requests[this.index], this.xhr = null
                    }
                }
                onLoad() {
                    const t = this.xhr.responseText;
                    null !== t && (this.emitReserved("data", t), this.emitReserved("success"), this.cleanup())
                }
                abort() {
                    this.cleanup()
                }
            }

            function z() {
                for (let t in K.requests) K.requests.hasOwnProperty(t) && K.requests[t].abort()
            }
            K.requestsCount = 0, K.requests = {}, "undefined" != typeof document && ("function" == typeof attachEvent ? attachEvent("onunload", z) : "function" == typeof addEventListener && addEventListener("onpagehide" in k ? "pagehide" : "unload", z, !1));
            const q = "function" == typeof Promise && "function" == typeof Promise.resolve ? t => Promise.resolve().then(t) : (t, e) => e(t, 0),
                W = k.WebSocket || k.MozWebSocket,
                Y = "undefined" != typeof navigator && "string" == typeof navigator.product && "reactnative" === navigator.product.toLowerCase(),
                X = {
                    websocket: class extends D {
                        constructor(t) {
                            super(t), this.supportsBinary = !t.forceBase64
                        }
                        get name() {
                            return "websocket"
                        }
                        doOpen() {
                            if (!this.check()) return;
                            const t = this.uri(),
                                e = this.opts.protocols,
                                i = Y ? {} : A(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
                            this.opts.extraHeaders && (i.headers = this.opts.extraHeaders);
                            try {
                                this.ws = Y ? new W(t, e, i) : e ? new W(t, e) : new W(t)
                            } catch (t) {
                                return this.emitReserved("error", t)
                            }
                            this.ws.binaryType = this.socket.binaryType, this.addEventListeners()
                        }
                        addEventListeners() {
                            this.ws.onopen = () => {
                                this.opts.autoUnref && this.ws._socket.unref(), this.onOpen()
                            }, this.ws.onclose = t => this.onClose({
                                description: "websocket connection closed",
                                context: t
                            }), this.ws.onmessage = t => this.onData(t.data), this.ws.onerror = t => this.onError("websocket error", t)
                        }
                        write(t) {
                            this.writable = !1;
                            for (let e = 0; e < t.length; e++) {
                                const i = t[e],
                                    s = e === t.length - 1;
                                u(i, this.supportsBinary, (t => {
                                    try {
                                        this.ws.send(t)
                                    } catch (t) {}
                                    s && q((() => {
                                        this.writable = !0, this.emitReserved("drain")
                                    }), this.setTimeoutFn)
                                }))
                            }
                        }
                        doClose() {
                            void 0 !== this.ws && (this.ws.close(), this.ws = null)
                        }
                        uri() {
                            const t = this.opts.secure ? "wss" : "ws",
                                e = this.query || {};
                            return this.opts.timestampRequests && (e[this.opts.timestampParam] = U()), this.supportsBinary || (e.b64 = 1), this.createUri(t, e)
                        }
                        check() {
                            return !!W
                        }
                    },
                    webtransport: class extends D {
                        get name() {
                            return "webtransport"
                        }
                        doOpen() {
                            "function" == typeof WebTransport && (this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]), this.transport.closed.then((() => {
                                this.onClose()
                            })).catch((t => {
                                this.onError("webtransport error", t)
                            })), this.transport.ready.then((() => {
                                this.transport.createBidirectionalStream().then((t => {
                                    const e = function(t, e) {
                                            T || (T = new TextDecoder);
                                            const i = [];
                                            let s = 0,
                                                r = -1,
                                                n = !1;
                                            return new TransformStream({
                                                transform(o, l) {
                                                    for (i.push(o);;) {
                                                        if (0 === s) {
                                                            if (E(i) < 1) break;
                                                            const t = S(i, 1);
                                                            n = 128 == (128 & t[0]), r = 127 & t[0], s = r < 126 ? 3 : 126 === r ? 1 : 2
                                                        } else if (1 === s) {
                                                            if (E(i) < 2) break;
                                                            const t = S(i, 2);
                                                            r = new DataView(t.buffer, t.byteOffset, t.length).getUint16(0), s = 3
                                                        } else if (2 === s) {
                                                            if (E(i) < 8) break;
                                                            const t = S(i, 8),
                                                                e = new DataView(t.buffer, t.byteOffset, t.length),
                                                                n = e.getUint32(0);
                                                            if (n > Math.pow(2, 21) - 1) {
                                                                l.enqueue(a);
                                                                break
                                                            }
                                                            r = n * Math.pow(2, 32) + e.getUint32(4), s = 3
                                                        } else {
                                                            if (E(i) < r) break;
                                                            const t = S(i, r);
                                                            l.enqueue(m(n ? t : T.decode(t), e)), s = 0
                                                        }
                                                        if (0 === r || r > t) {
                                                            l.enqueue(a);
                                                            break
                                                        }
                                                    }
                                                }
                                            })
                                        }(Number.MAX_SAFE_INTEGER, this.socket.binaryType),
                                        i = t.readable.pipeThrough(e).getReader(),
                                        s = new TransformStream({
                                            transform(t, e) {
                                                ! function(t, e) {
                                                    o && t.data instanceof Blob ? t.data.arrayBuffer().then(h).then(e) : l && (t.data instanceof ArrayBuffer || c(t.data)) ? e(h(t.data)) : u(t, !1, (t => {
                                                        f || (f = new TextEncoder), e(f.encode(t))
                                                    }))
                                                }(t, (i => {
                                                    const s = i.length;
                                                    let r;
                                                    if (s < 126) r = new Uint8Array(1), new DataView(r.buffer).setUint8(0, s);
                                                    else if (s < 65536) {
                                                        r = new Uint8Array(3);
                                                        const t = new DataView(r.buffer);
                                                        t.setUint8(0, 126), t.setUint16(1, s)
                                                    } else {
                                                        r = new Uint8Array(9);
                                                        const t = new DataView(r.buffer);
                                                        t.setUint8(0, 127), t.setBigUint64(1, BigInt(s))
                                                    }
                                                    t.data && "string" != typeof t.data && (r[0] |= 128), e.enqueue(r), e.enqueue(i)
                                                }))
                                            }
                                        });
                                    s.readable.pipeTo(t.writable), this.writer = s.writable.getWriter();
                                    const r = () => {
                                        i.read().then((({
                                            done: t,
                                            value: e
                                        }) => {
                                            t || (this.onPacket(e), r())
                                        })).catch((t => {}))
                                    };
                                    r();
                                    const n = {
                                        type: "open"
                                    };
                                    this.query.sid && (n.data = `{"sid":"${this.query.sid}"}`), this.writer.write(n).then((() => this.onOpen()))
                                }))
                            })))
                        }
                        write(t) {
                            this.writable = !1;
                            for (let e = 0; e < t.length; e++) {
                                const i = t[e],
                                    s = e === t.length - 1;
                                this.writer.write(i).then((() => {
                                    s && q((() => {
                                        this.writable = !0, this.emitReserved("drain")
                                    }), this.setTimeoutFn)
                                }))
                            }
                        }
                        doClose() {
                            var t;
                            null === (t = this.transport) || void 0 === t || t.close()
                        }
                    },
                    polling: class extends D {
                        constructor(t) {
                            if (super(t), this.polling = !1, "undefined" != typeof location) {
                                const e = "https:" === location.protocol;
                                let i = location.port;
                                i || (i = e ? "443" : "80"), this.xd = "undefined" != typeof location && t.hostname !== location.hostname || i !== t.port
                            }
                            const e = t && t.forceBase64;
                            this.supportsBinary = H && !e, this.opts.withCredentials && (this.cookieJar = void 0)
                        }
                        get name() {
                            return "polling"
                        }
                        doOpen() {
                            this.poll()
                        }
                        pause(t) {
                            this.readyState = "pausing";
                            const e = () => {
                                this.readyState = "paused", t()
                            };
                            if (this.polling || !this.writable) {
                                let t = 0;
                                this.polling && (t++, this.once("pollComplete", (function() {
                                    --t || e()
                                }))), this.writable || (t++, this.once("drain", (function() {
                                    --t || e()
                                })))
                            } else e()
                        }
                        poll() {
                            this.polling = !0, this.doPoll(), this.emitReserved("poll")
                        }
                        onData(t) {
                            ((t, e) => {
                                const i = t.split(b),
                                    s = [];
                                for (let t = 0; t < i.length; t++) {
                                    const r = m(i[t], e);
                                    if (s.push(r), "error" === r.type) break
                                }
                                return s
                            })(t, this.socket.binaryType).forEach((t => {
                                if ("opening" === this.readyState && "open" === t.type && this.onOpen(), "close" === t.type) return this.onClose({
                                    description: "transport closed by the server"
                                }), !1;
                                this.onPacket(t)
                            })), "closed" !== this.readyState && (this.polling = !1, this.emitReserved("pollComplete"), "open" === this.readyState && this.poll())
                        }
                        doClose() {
                            const t = () => {
                                this.write([{
                                    type: "close"
                                }])
                            };
                            "open" === this.readyState ? t() : this.once("open", t)
                        }
                        write(t) {
                            this.writable = !1, ((t, e) => {
                                const i = t.length,
                                    s = new Array(i);
                                let r = 0;
                                t.forEach(((t, n) => {
                                    u(t, !1, (t => {
                                        s[n] = t, ++r === i && e(s.join(b))
                                    }))
                                }))
                            })(t, (t => {
                                this.doWrite(t, (() => {
                                    this.writable = !0, this.emitReserved("drain")
                                }))
                            }))
                        }
                        uri() {
                            const t = this.opts.secure ? "https" : "http",
                                e = this.query || {};
                            return !1 !== this.opts.timestampRequests && (e[this.opts.timestampParam] = U()), this.supportsBinary || e.sid || (e.b64 = 1), this.createUri(t, e)
                        }
                        request(t = {}) {
                            return Object.assign(t, {
                                xd: this.xd,
                                cookieJar: this.cookieJar
                            }, this.opts), new K(this.uri(), t)
                        }
                        doWrite(t, e) {
                            const i = this.request({
                                method: "POST",
                                data: t
                            });
                            i.on("success", e), i.on("error", ((t, e) => {
                                this.onError("xhr post error", t, e)
                            }))
                        }
                        doPoll() {
                            const t = this.request();
                            t.on("data", this.onData.bind(this)), t.on("error", ((t, e) => {
                                this.onError("xhr poll error", t, e)
                            })), this.pollXhr = t
                        }
                    }
                };
            var Q = i(1928);
            class J extends w {
                constructor(t, e = {}) {
                    super(), this.binaryType = "arraybuffer", this.writeBuffer = [], t && "object" == typeof t && (e = t, t = null), t ? (t = (0, Q.Q)(t), e.hostname = t.host, e.secure = "https" === t.protocol || "wss" === t.protocol, e.port = t.port, t.query && (e.query = t.query)) : e.host && (e.hostname = (0, Q.Q)(e.host).host), R(this, e), this.secure = null != e.secure ? e.secure : "undefined" != typeof location && "https:" === location.protocol, e.hostname && !e.port && (e.port = this.secure ? "443" : "80"), this.hostname = e.hostname || ("undefined" != typeof location ? location.hostname : "localhost"), this.port = e.port || ("undefined" != typeof location && location.port ? location.port : this.secure ? "443" : "80"), this.transports = e.transports || ["polling", "websocket", "webtransport"], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
                        path: "/engine.io",
                        agent: !1,
                        withCredentials: !1,
                        upgrade: !0,
                        timestampParam: "t",
                        rememberUpgrade: !1,
                        addTrailingSlash: !0,
                        rejectUnauthorized: !0,
                        perMessageDeflate: {
                            threshold: 1024
                        },
                        transportOptions: {},
                        closeOnBeforeunload: !1
                    }, e), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), "string" == typeof this.opts.query && (this.opts.query = (0, I.J)(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, "function" == typeof addEventListener && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {
                        this.transport && (this.transport.removeAllListeners(), this.transport.close())
                    }, addEventListener("beforeunload", this.beforeunloadEventListener, !1)), "localhost" !== this.hostname && (this.offlineEventListener = () => {
                        this.onClose("transport close", {
                            description: "network connection lost"
                        })
                    }, addEventListener("offline", this.offlineEventListener, !1))), this.open()
                }
                createTransport(t) {
                    const e = Object.assign({}, this.opts.query);
                    e.EIO = 4, e.transport = t, this.id && (e.sid = this.id);
                    const i = Object.assign({}, this.opts, {
                        query: e,
                        socket: this,
                        hostname: this.hostname,
                        secure: this.secure,
                        port: this.port
                    }, this.opts.transportOptions[t]);
                    return new X[t](i)
                }
                open() {
                    let t;
                    if (this.opts.rememberUpgrade && J.priorWebsocketSuccess && -1 !== this.transports.indexOf("websocket")) t = "websocket";
                    else {
                        if (0 === this.transports.length) return void this.setTimeoutFn((() => {
                            this.emitReserved("error", "No transports available")
                        }), 0);
                        t = this.transports[0]
                    }
                    this.readyState = "opening";
                    try {
                        t = this.createTransport(t)
                    } catch (t) {
                        return this.transports.shift(), void this.open()
                    }
                    t.open(), this.setTransport(t)
                }
                setTransport(t) {
                    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (t => this.onClose("transport close", t)))
                }
                probe(t) {
                    let e = this.createTransport(t),
                        i = !1;
                    J.priorWebsocketSuccess = !1;
                    const s = () => {
                        i || (e.send([{
                            type: "ping",
                            data: "probe"
                        }]), e.once("packet", (t => {
                            if (!i)
                                if ("pong" === t.type && "probe" === t.data) {
                                    if (this.upgrading = !0, this.emitReserved("upgrading", e), !e) return;
                                    J.priorWebsocketSuccess = "websocket" === e.name, this.transport.pause((() => {
                                        i || "closed" !== this.readyState && (c(), this.setTransport(e), e.send([{
                                            type: "upgrade"
                                        }]), this.emitReserved("upgrade", e), e = null, this.upgrading = !1, this.flush())
                                    }))
                                } else {
                                    const t = new Error("probe error");
                                    t.transport = e.name, this.emitReserved("upgradeError", t)
                                }
                        })))
                    };

                    function r() {
                        i || (i = !0, c(), e.close(), e = null)
                    }
                    const n = t => {
                        const i = new Error("probe error: " + t);
                        i.transport = e.name, r(), this.emitReserved("upgradeError", i)
                    };

                    function a() {
                        n("transport closed")
                    }

                    function o() {
                        n("socket closed")
                    }

                    function l(t) {
                        e && t.name !== e.name && r()
                    }
                    const c = () => {
                        e.removeListener("open", s), e.removeListener("error", n), e.removeListener("close", a), this.off("close", o), this.off("upgrading", l)
                    };
                    e.once("open", s), e.once("error", n), e.once("close", a), this.once("close", o), this.once("upgrading", l), -1 !== this.upgrades.indexOf("webtransport") && "webtransport" !== t ? this.setTimeoutFn((() => {
                        i || e.open()
                    }), 200) : e.open()
                }
                onOpen() {
                    if (this.readyState = "open", J.priorWebsocketSuccess = "websocket" === this.transport.name, this.emitReserved("open"), this.flush(), "open" === this.readyState && this.opts.upgrade) {
                        let t = 0;
                        const e = this.upgrades.length;
                        for (; t < e; t++) this.probe(this.upgrades[t])
                    }
                }
                onPacket(t) {
                    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) switch (this.emitReserved("packet", t), this.emitReserved("heartbeat"), this.resetPingTimeout(), t.type) {
                        case "open":
                            this.onHandshake(JSON.parse(t.data));
                            break;
                        case "ping":
                            this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
                            break;
                        case "error":
                            const e = new Error("server error");
                            e.code = t.data, this.onError(e);
                            break;
                        case "message":
                            this.emitReserved("data", t.data), this.emitReserved("message", t.data)
                    }
                }
                onHandshake(t) {
                    this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), "closed" !== this.readyState && this.resetPingTimeout()
                }
                resetPingTimeout() {
                    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn((() => {
                        this.onClose("ping timeout")
                    }), this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref()
                }
                onDrain() {
                    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emitReserved("drain") : this.flush()
                }
                flush() {
                    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
                        const t = this.getWritablePackets();
                        this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved("flush")
                    }
                }
                getWritablePackets() {
                    if (!(this.maxPayload && "polling" === this.transport.name && this.writeBuffer.length > 1)) return this.writeBuffer;
                    let t = 1;
                    for (let i = 0; i < this.writeBuffer.length; i++) {
                        const s = this.writeBuffer[i].data;
                        if (s && (t += "string" == typeof(e = s) ? function(t) {
                                let e = 0,
                                    i = 0;
                                for (let s = 0, r = t.length; s < r; s++) e = t.charCodeAt(s), e < 128 ? i += 1 : e < 2048 ? i += 2 : e < 55296 || e >= 57344 ? i += 3 : (s++, i += 4);
                                return i
                            }(e) : Math.ceil(1.33 * (e.byteLength || e.size))), i > 0 && t > this.maxPayload) return this.writeBuffer.slice(0, i);
                        t += 2
                    }
                    var e;
                    return this.writeBuffer
                }
                write(t, e, i) {
                    return this.sendPacket("message", t, e, i), this
                }
                send(t, e, i) {
                    return this.sendPacket("message", t, e, i), this
                }
                sendPacket(t, e, i, s) {
                    if ("function" == typeof e && (s = e, e = void 0), "function" == typeof i && (s = i, i = null), "closing" === this.readyState || "closed" === this.readyState) return;
                    (i = i || {}).compress = !1 !== i.compress;
                    const r = {
                        type: t,
                        data: e,
                        options: i
                    };
                    this.emitReserved("packetCreate", r), this.writeBuffer.push(r), s && this.once("flush", s), this.flush()
                }
                close() {
                    const t = () => {
                            this.onClose("forced close"), this.transport.close()
                        },
                        e = () => {
                            this.off("upgrade", e), this.off("upgradeError", e), t()
                        },
                        i = () => {
                            this.once("upgrade", e), this.once("upgradeError", e)
                        };
                    return "opening" !== this.readyState && "open" !== this.readyState || (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", (() => {
                        this.upgrading ? i() : t()
                    })) : this.upgrading ? i() : t()), this
                }
                onError(t) {
                    J.priorWebsocketSuccess = !1, this.emitReserved("error", t), this.onClose("transport error", t)
                }
                onClose(t, e) {
                    "opening" !== this.readyState && "open" !== this.readyState && "closing" !== this.readyState || (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), "function" == typeof removeEventListener && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1), removeEventListener("offline", this.offlineEventListener, !1)), this.readyState = "closed", this.id = null, this.emitReserved("close", t, e), this.writeBuffer = [], this.prevBufferLen = 0)
                }
                filterUpgrades(t) {
                    const e = [];
                    let i = 0;
                    const s = t.length;
                    for (; i < s; i++) ~this.transports.indexOf(t[i]) && e.push(t[i]);
                    return e
                }
            }
            J.protocol = 4, J.protocol;
            const Z = "function" == typeof ArrayBuffer,
                tt = t => "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(t) : t.buffer instanceof ArrayBuffer,
                et = Object.prototype.toString,
                it = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === et.call(Blob),
                st = "function" == typeof File || "undefined" != typeof File && "[object FileConstructor]" === et.call(File);

            function rt(t) {
                return Z && (t instanceof ArrayBuffer || tt(t)) || it && t instanceof Blob || st && t instanceof File
            }

            function nt(t, e) {
                if (!t || "object" != typeof t) return !1;
                if (Array.isArray(t)) {
                    for (let e = 0, i = t.length; e < i; e++)
                        if (nt(t[e])) return !0;
                    return !1
                }
                if (rt(t)) return !0;
                if (t.toJSON && "function" == typeof t.toJSON && 1 === arguments.length) return nt(t.toJSON(), !0);
                for (const e in t)
                    if (Object.prototype.hasOwnProperty.call(t, e) && nt(t[e])) return !0;
                return !1
            }

            function at(t) {
                const e = [],
                    i = t.data,
                    s = t;
                return s.data = ot(i, e), s.attachments = e.length, {
                    packet: s,
                    buffers: e
                }
            }

            function ot(t, e) {
                if (!t) return t;
                if (rt(t)) {
                    const i = {
                        _placeholder: !0,
                        num: e.length
                    };
                    return e.push(t), i
                }
                if (Array.isArray(t)) {
                    const i = new Array(t.length);
                    for (let s = 0; s < t.length; s++) i[s] = ot(t[s], e);
                    return i
                }
                if ("object" == typeof t && !(t instanceof Date)) {
                    const i = {};
                    for (const s in t) Object.prototype.hasOwnProperty.call(t, s) && (i[s] = ot(t[s], e));
                    return i
                }
                return t
            }

            function lt(t, e) {
                return t.data = ct(t.data, e), delete t.attachments, t
            }

            function ct(t, e) {
                if (!t) return t;
                if (t && !0 === t._placeholder) {
                    if ("number" == typeof t.num && t.num >= 0 && t.num < e.length) return e[t.num];
                    throw new Error("illegal attachments")
                }
                if (Array.isArray(t))
                    for (let i = 0; i < t.length; i++) t[i] = ct(t[i], e);
                else if ("object" == typeof t)
                    for (const i in t) Object.prototype.hasOwnProperty.call(t, i) && (t[i] = ct(t[i], e));
                return t
            }
            const ut = ["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener"],
                dt = 5;
            var ht;
            ! function(t) {
                t[t.CONNECT = 0] = "CONNECT", t[t.DISCONNECT = 1] = "DISCONNECT", t[t.EVENT = 2] = "EVENT", t[t.ACK = 3] = "ACK", t[t.CONNECT_ERROR = 4] = "CONNECT_ERROR", t[t.BINARY_EVENT = 5] = "BINARY_EVENT", t[t.BINARY_ACK = 6] = "BINARY_ACK"
            }(ht || (ht = {}));
            class ft {
                constructor(t) {
                    this.replacer = t
                }
                encode(t) {
                    return t.type !== ht.EVENT && t.type !== ht.ACK || !nt(t) ? [this.encodeAsString(t)] : this.encodeAsBinary({
                        type: t.type === ht.EVENT ? ht.BINARY_EVENT : ht.BINARY_ACK,
                        nsp: t.nsp,
                        data: t.data,
                        id: t.id
                    })
                }
                encodeAsString(t) {
                    let e = "" + t.type;
                    return t.type !== ht.BINARY_EVENT && t.type !== ht.BINARY_ACK || (e += t.attachments + "-"), t.nsp && "/" !== t.nsp && (e += t.nsp + ","), null != t.id && (e += t.id), null != t.data && (e += JSON.stringify(t.data, this.replacer)), e
                }
                encodeAsBinary(t) {
                    const e = at(t),
                        i = this.encodeAsString(e.packet),
                        s = e.buffers;
                    return s.unshift(i), s
                }
            }

            function pt(t) {
                return "[object Object]" === Object.prototype.toString.call(t)
            }
            class gt extends w {
                constructor(t) {
                    super(), this.reviver = t
                }
                add(t) {
                    let e;
                    if ("string" == typeof t) {
                        if (this.reconstructor) throw new Error("got plaintext data when reconstructing a packet");
                        e = this.decodeString(t);
                        const i = e.type === ht.BINARY_EVENT;
                        i || e.type === ht.BINARY_ACK ? (e.type = i ? ht.EVENT : ht.ACK, this.reconstructor = new mt(e), 0 === e.attachments && super.emitReserved("decoded", e)) : super.emitReserved("decoded", e)
                    } else {
                        if (!rt(t) && !t.base64) throw new Error("Unknown type: " + t);
                        if (!this.reconstructor) throw new Error("got binary data when not reconstructing a packet");
                        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved("decoded", e))
                    }
                }
                decodeString(t) {
                    let e = 0;
                    const i = {
                        type: Number(t.charAt(0))
                    };
                    if (void 0 === ht[i.type]) throw new Error("unknown packet type " + i.type);
                    if (i.type === ht.BINARY_EVENT || i.type === ht.BINARY_ACK) {
                        const s = e + 1;
                        for (;
                            "-" !== t.charAt(++e) && e != t.length;);
                        const r = t.substring(s, e);
                        if (r != Number(r) || "-" !== t.charAt(e)) throw new Error("Illegal attachments");
                        i.attachments = Number(r)
                    }
                    if ("/" === t.charAt(e + 1)) {
                        const s = e + 1;
                        for (; ++e && "," !== t.charAt(e) && e !== t.length;);
                        i.nsp = t.substring(s, e)
                    } else i.nsp = "/";
                    const s = t.charAt(e + 1);
                    if ("" !== s && Number(s) == s) {
                        const s = e + 1;
                        for (; ++e;) {
                            const i = t.charAt(e);
                            if (null == i || Number(i) != i) {
                                --e;
                                break
                            }
                            if (e === t.length) break
                        }
                        i.id = Number(t.substring(s, e + 1))
                    }
                    if (t.charAt(++e)) {
                        const s = this.tryParse(t.substr(e));
                        if (!gt.isPayloadValid(i.type, s)) throw new Error("invalid payload");
                        i.data = s
                    }
                    return i
                }
                tryParse(t) {
                    try {
                        return JSON.parse(t, this.reviver)
                    } catch (t) {
                        return !1
                    }
                }
                static isPayloadValid(t, e) {
                    switch (t) {
                        case ht.CONNECT:
                            return pt(e);
                        case ht.DISCONNECT:
                            return void 0 === e;
                        case ht.CONNECT_ERROR:
                            return "string" == typeof e || pt(e);
                        case ht.EVENT:
                        case ht.BINARY_EVENT:
                            return Array.isArray(e) && ("number" == typeof e[0] || "string" == typeof e[0] && -1 === ut.indexOf(e[0]));
                        case ht.ACK:
                        case ht.BINARY_ACK:
                            return Array.isArray(e)
                    }
                }
                destroy() {
                    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null)
                }
            }
            class mt {
                constructor(t) {
                    this.packet = t, this.buffers = [], this.reconPack = t
                }
                takeBinaryData(t) {
                    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {
                        const t = lt(this.reconPack, this.buffers);
                        return this.finishedReconstruction(), t
                    }
                    return null
                }
                finishedReconstruction() {
                    this.reconPack = null, this.buffers = []
                }
            }
            var yt = i(5901);
            const vt = Object.freeze({
                connect: 1,
                connect_error: 1,
                disconnect: 1,
                disconnecting: 1,
                newListener: 1,
                removeListener: 1
            });
            class bt extends w {
                constructor(t, e, i) {
                    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, i && i.auth && (this.auth = i.auth), this._opts = Object.assign({}, i), this.io._autoConnect && this.open()
                }
                get disconnected() {
                    return !this.connected
                }
                subEvents() {
                    if (this.subs) return;
                    const t = this.io;
                    this.subs = [(0, yt.on)(t, "open", this.onopen.bind(this)), (0, yt.on)(t, "packet", this.onpacket.bind(this)), (0, yt.on)(t, "error", this.onerror.bind(this)), (0, yt.on)(t, "close", this.onclose.bind(this))]
                }
                get active() {
                    return !!this.subs
                }
                connect() {
                    return this.connected || (this.subEvents(), this.io._reconnecting || this.io.open(), "open" === this.io._readyState && this.onopen()), this
                }
                open() {
                    return this.connect()
                }
                send(...t) {
                    return t.unshift("message"), this.emit.apply(this, t), this
                }
                emit(t, ...e) {
                    if (vt.hasOwnProperty(t)) throw new Error('"' + t.toString() + '" is a reserved event name');
                    if (e.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) return this._addToQueue(e), this;
                    const i = {
                        type: ht.EVENT,
                        data: e,
                        options: {}
                    };
                    if (i.options.compress = !1 !== this.flags.compress, "function" == typeof e[e.length - 1]) {
                        const t = this.ids++,
                            s = e.pop();
                        this._registerAckCallback(t, s), i.id = t
                    }
                    const s = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
                    return this.flags.volatile && (!s || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(i), this.packet(i)) : this.sendBuffer.push(i)), this.flags = {}, this
                }
                _registerAckCallback(t, e) {
                    var i;
                    const s = null !== (i = this.flags.timeout) && void 0 !== i ? i : this._opts.ackTimeout;
                    if (void 0 === s) return void(this.acks[t] = e);
                    const r = this.io.setTimeoutFn((() => {
                        delete this.acks[t];
                        for (let e = 0; e < this.sendBuffer.length; e++) this.sendBuffer[e].id === t && this.sendBuffer.splice(e, 1);
                        e.call(this, new Error("operation has timed out"))
                    }), s);
                    this.acks[t] = (...t) => {
                        this.io.clearTimeoutFn(r), e.apply(this, [null, ...t])
                    }
                }
                emitWithAck(t, ...e) {
                    const i = void 0 !== this.flags.timeout || void 0 !== this._opts.ackTimeout;
                    return new Promise(((s, r) => {
                        e.push(((t, e) => i ? t ? r(t) : s(e) : s(t))), this.emit(t, ...e)
                    }))
                }
                _addToQueue(t) {
                    let e;
                    "function" == typeof t[t.length - 1] && (e = t.pop());
                    const i = {
                        id: this._queueSeq++,
                        tryCount: 0,
                        pending: !1,
                        args: t,
                        flags: Object.assign({
                            fromQueue: !0
                        }, this.flags)
                    };
                    t.push(((t, ...s) => {
                        if (i === this._queue[0]) return null !== t ? i.tryCount > this._opts.retries && (this._queue.shift(), e && e(t)) : (this._queue.shift(), e && e(null, ...s)), i.pending = !1, this._drainQueue()
                    })), this._queue.push(i), this._drainQueue()
                }
                _drainQueue(t = !1) {
                    if (!this.connected || 0 === this._queue.length) return;
                    const e = this._queue[0];
                    e.pending && !t || (e.pending = !0, e.tryCount++, this.flags = e.flags, this.emit.apply(this, e.args))
                }
                packet(t) {
                    t.nsp = this.nsp, this.io._packet(t)
                }
                onopen() {
                    "function" == typeof this.auth ? this.auth((t => {
                        this._sendConnectPacket(t)
                    })) : this._sendConnectPacket(this.auth)
                }
                _sendConnectPacket(t) {
                    this.packet({
                        type: ht.CONNECT,
                        data: this._pid ? Object.assign({
                            pid: this._pid,
                            offset: this._lastOffset
                        }, t) : t
                    })
                }
                onerror(t) {
                    this.connected || this.emitReserved("connect_error", t)
                }
                onclose(t, e) {
                    this.connected = !1, delete this.id, this.emitReserved("disconnect", t, e)
                }
                onpacket(t) {
                    if (t.nsp === this.nsp) switch (t.type) {
                        case ht.CONNECT:
                            t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                            break;
                        case ht.EVENT:
                        case ht.BINARY_EVENT:
                            this.onevent(t);
                            break;
                        case ht.ACK:
                        case ht.BINARY_ACK:
                            this.onack(t);
                            break;
                        case ht.DISCONNECT:
                            this.ondisconnect();
                            break;
                        case ht.CONNECT_ERROR:
                            this.destroy();
                            const e = new Error(t.data.message);
                            e.data = t.data.data, this.emitReserved("connect_error", e)
                    }
                }
                onevent(t) {
                    const e = t.data || [];
                    null != t.id && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e))
                }
                emitEvent(t) {
                    if (this._anyListeners && this._anyListeners.length) {
                        const e = this._anyListeners.slice();
                        for (const i of e) i.apply(this, t)
                    }
                    super.emit.apply(this, t), this._pid && t.length && "string" == typeof t[t.length - 1] && (this._lastOffset = t[t.length - 1])
                }
                ack(t) {
                    const e = this;
                    let i = !1;
                    return function(...s) {
                        i || (i = !0, e.packet({
                            type: ht.ACK,
                            id: t,
                            data: s
                        }))
                    }
                }
                onack(t) {
                    const e = this.acks[t.id];
                    "function" == typeof e && (e.apply(this, t.data), delete this.acks[t.id])
                }
                onconnect(t, e) {
                    this.id = t, this.recovered = e && this._pid === e, this._pid = e, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0)
                }
                emitBuffered() {
                    this.receiveBuffer.forEach((t => this.emitEvent(t))), this.receiveBuffer = [], this.sendBuffer.forEach((t => {
                        this.notifyOutgoingListeners(t), this.packet(t)
                    })), this.sendBuffer = []
                }
                ondisconnect() {
                    this.destroy(), this.onclose("io server disconnect")
                }
                destroy() {
                    this.subs && (this.subs.forEach((t => t())), this.subs = void 0), this.io._destroy(this)
                }
                disconnect() {
                    return this.connected && this.packet({
                        type: ht.DISCONNECT
                    }), this.destroy(), this.connected && this.onclose("io client disconnect"), this
                }
                close() {
                    return this.disconnect()
                }
                compress(t) {
                    return this.flags.compress = t, this
                }
                get volatile() {
                    return this.flags.volatile = !0, this
                }
                timeout(t) {
                    return this.flags.timeout = t, this
                }
                onAny(t) {
                    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this
                }
                prependAny(t) {
                    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this
                }
                offAny(t) {
                    if (!this._anyListeners) return this;
                    if (t) {
                        const e = this._anyListeners;
                        for (let i = 0; i < e.length; i++)
                            if (t === e[i]) return e.splice(i, 1), this
                    } else this._anyListeners = [];
                    return this
                }
                listenersAny() {
                    return this._anyListeners || []
                }
                onAnyOutgoing(t) {
                    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this
                }
                prependAnyOutgoing(t) {
                    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this
                }
                offAnyOutgoing(t) {
                    if (!this._anyOutgoingListeners) return this;
                    if (t) {
                        const e = this._anyOutgoingListeners;
                        for (let i = 0; i < e.length; i++)
                            if (t === e[i]) return e.splice(i, 1), this
                    } else this._anyOutgoingListeners = [];
                    return this
                }
                listenersAnyOutgoing() {
                    return this._anyOutgoingListeners || []
                }
                notifyOutgoingListeners(t) {
                    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
                        const e = this._anyOutgoingListeners.slice();
                        for (const i of e) i.apply(this, t.data)
                    }
                }
            }

            function Tt(t) {
                t = t || {}, this.ms = t.min || 100, this.max = t.max || 1e4, this.factor = t.factor || 2, this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0, this.attempts = 0
            }
            Tt.prototype.duration = function() {
                var t = this.ms * Math.pow(this.factor, this.attempts++);
                if (this.jitter) {
                    var e = Math.random(),
                        i = Math.floor(e * this.jitter * t);
                    t = 0 == (1 & Math.floor(10 * e)) ? t - i : t + i
                }
                return 0 | Math.min(t, this.max)
            }, Tt.prototype.reset = function() {
                this.attempts = 0
            }, Tt.prototype.setMin = function(t) {
                this.ms = t
            }, Tt.prototype.setMax = function(t) {
                this.max = t
            }, Tt.prototype.setJitter = function(t) {
                this.jitter = t
            };
            class Et extends w {
                constructor(t, e) {
                    var i;
                    super(), this.nsps = {}, this.subs = [], t && "object" == typeof t && (e = t, t = void 0), (e = e || {}).path = e.path || "/socket.io", this.opts = e, R(this, e), this.reconnection(!1 !== e.reconnection), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor(null !== (i = e.randomizationFactor) && void 0 !== i ? i : .5), this.backoff = new Tt({
                        min: this.reconnectionDelay(),
                        max: this.reconnectionDelayMax(),
                        jitter: this.randomizationFactor()
                    }), this.timeout(null == e.timeout ? 2e4 : e.timeout), this._readyState = "closed", this.uri = t;
                    const r = e.parser || s;
                    this.encoder = new r.Encoder, this.decoder = new r.Decoder, this._autoConnect = !1 !== e.autoConnect, this._autoConnect && this.open()
                }
                reconnection(t) {
                    return arguments.length ? (this._reconnection = !!t, this) : this._reconnection
                }
                reconnectionAttempts(t) {
                    return void 0 === t ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this)
                }
                reconnectionDelay(t) {
                    var e;
                    return void 0 === t ? this._reconnectionDelay : (this._reconnectionDelay = t, null === (e = this.backoff) || void 0 === e || e.setMin(t), this)
                }
                randomizationFactor(t) {
                    var e;
                    return void 0 === t ? this._randomizationFactor : (this._randomizationFactor = t, null === (e = this.backoff) || void 0 === e || e.setJitter(t), this)
                }
                reconnectionDelayMax(t) {
                    var e;
                    return void 0 === t ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, null === (e = this.backoff) || void 0 === e || e.setMax(t), this)
                }
                timeout(t) {
                    return arguments.length ? (this._timeout = t, this) : this._timeout
                }
                maybeReconnectOnOpen() {
                    !this._reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect()
                }
                open(t) {
                    if (~this._readyState.indexOf("open")) return this;
                    this.engine = new J(this.uri, this.opts);
                    const e = this.engine,
                        i = this;
                    this._readyState = "opening", this.skipReconnect = !1;
                    const s = (0, yt.on)(e, "open", (function() {
                            i.onopen(), t && t()
                        })),
                        r = e => {
                            this.cleanup(), this._readyState = "closed", this.emitReserved("error", e), t ? t(e) : this.maybeReconnectOnOpen()
                        },
                        n = (0, yt.on)(e, "error", r);
                    if (!1 !== this._timeout) {
                        const t = this._timeout,
                            i = this.setTimeoutFn((() => {
                                s(), r(new Error("timeout")), e.close()
                            }), t);
                        this.opts.autoUnref && i.unref(), this.subs.push((() => {
                            this.clearTimeoutFn(i)
                        }))
                    }
                    return this.subs.push(s), this.subs.push(n), this
                }
                connect(t) {
                    return this.open(t)
                }
                onopen() {
                    this.cleanup(), this._readyState = "open", this.emitReserved("open");
                    const t = this.engine;
                    this.subs.push((0, yt.on)(t, "ping", this.onping.bind(this)), (0, yt.on)(t, "data", this.ondata.bind(this)), (0, yt.on)(t, "error", this.onerror.bind(this)), (0, yt.on)(t, "close", this.onclose.bind(this)), (0, yt.on)(this.decoder, "decoded", this.ondecoded.bind(this)))
                }
                onping() {
                    this.emitReserved("ping")
                }
                ondata(t) {
                    try {
                        this.decoder.add(t)
                    } catch (t) {
                        this.onclose("parse error", t)
                    }
                }
                ondecoded(t) {
                    q((() => {
                        this.emitReserved("packet", t)
                    }), this.setTimeoutFn)
                }
                onerror(t) {
                    this.emitReserved("error", t)
                }
                socket(t, e) {
                    let i = this.nsps[t];
                    return i ? this._autoConnect && !i.active && i.connect() : (i = new bt(this, t, e), this.nsps[t] = i), i
                }
                _destroy(t) {
                    const e = Object.keys(this.nsps);
                    for (const t of e)
                        if (this.nsps[t].active) return;
                    this._close()
                }
                _packet(t) {
                    const e = this.encoder.encode(t);
                    for (let i = 0; i < e.length; i++) this.engine.write(e[i], t.options)
                }
                cleanup() {
                    this.subs.forEach((t => t())), this.subs.length = 0, this.decoder.destroy()
                }
                _close() {
                    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close()
                }
                disconnect() {
                    return this._close()
                }
                onclose(t, e) {
                    this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, e), this._reconnection && !this.skipReconnect && this.reconnect()
                }
                reconnect() {
                    if (this._reconnecting || this.skipReconnect) return this;
                    const t = this;
                    if (this.backoff.attempts >= this._reconnectionAttempts) this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
                    else {
                        const e = this.backoff.duration();
                        this._reconnecting = !0;
                        const i = this.setTimeoutFn((() => {
                            t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts), t.skipReconnect || t.open((e => {
                                e ? (t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", e)) : t.onreconnect()
                            })))
                        }), e);
                        this.opts.autoUnref && i.unref(), this.subs.push((() => {
                            this.clearTimeoutFn(i)
                        }))
                    }
                }
                onreconnect() {
                    const t = this.backoff.attempts;
                    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t)
                }
            }
            const St = {};

            function wt(t, e) {
                "object" == typeof t && (e = t, t = void 0);
                const i = function(t, e = "", i) {
                        let s = t;
                        i = i || "undefined" != typeof location && location, null == t && (t = i.protocol + "//" + i.host), "string" == typeof t && ("/" === t.charAt(0) && (t = "/" === t.charAt(1) ? i.protocol + t : i.host + t), /^(https?|wss?):\/\//.test(t) || (t = void 0 !== i ? i.protocol + "//" + t : "https://" + t), s = (0, Q.Q)(t)), s.port || (/^(http|ws)$/.test(s.protocol) ? s.port = "80" : /^(http|ws)s$/.test(s.protocol) && (s.port = "443")), s.path = s.path || "/";
                        const r = -1 !== s.host.indexOf(":") ? "[" + s.host + "]" : s.host;
                        return s.id = s.protocol + "://" + r + ":" + s.port + e, s.href = s.protocol + "://" + r + (i && i.port === s.port ? "" : ":" + s.port), s
                    }(t, (e = e || {}).path || "/socket.io"),
                    s = i.source,
                    r = i.id,
                    n = i.path,
                    a = St[r] && n in St[r].nsps;
                let o;
                return e.forceNew || e["force new connection"] || !1 === e.multiplex || a ? o = new Et(s, e) : (St[r] || (St[r] = new Et(s, e)), o = St[r]), i.query && !e.query && (e.query = i.queryKey), o.socket(i.path, e)
            }
            Object.assign(wt, {
                Manager: Et,
                Socket: bt,
                io: wt,
                connect: wt
            })
        },
        5901: (t, e, i) => {
            "use strict";

            function s(t, e, i) {
                return t.on(e, i),
                    function() {
                        t.off(e, i)
                    }
            }
            i.d(e, {
                on: () => s
            })
        }
    }
]);